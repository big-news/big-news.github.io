{"pages":[{"title":"友链","text":"神仙Langlangago’s BlogShu_Yan’s blog Christopher’s BlogRefined_hearthzwer OJCodeforcesUVa Online JudgeLuoguVijosLibre Online JudgeHDU OJPKU OJOpenJudgeVirtual Judge","link":"/friends.html"},{"title":"关于","text":"关于Blog创建于2019-1-30的深夜。（实际已经到了1-31日00:20，Orz）2019.2~2019.6 托管于GitHub。目前部署于疼训云。 关于bn一只现役蒟蒻，技不如人，肝败吓疯。 联系蒟蒻Luogu: @big_newsCodeforces: @ce_amticGitHub: @ce-amticE-mail: fyh516@126.comQQ：2981191397 关于LaTeX您可以通过右键单击公式框来打开MathJax命令栏，然后通过下面的方式获取LaTeX源代码。 关于搜索您可以搜索本站的文章，分类，标签，甚至是页面(xxx.html)。您也可以通过文章内容搜索文章，匹配度高的文章会被优先列出。 关于评论系统评论系统采用了Valine，基于LeanCloud提供的云计算服务。因服务限制，23点至7点这一时间段服务器自动休眠，无法进行评论，这是正常的。当您的评论有回复时，您会收到邮件提醒，前提是您留下了正确的邮箱。您如果想让我看到您的评论，您必须留下正确的邮箱，或者是回复我的评论。当然，您也可以直接发邮件。","link":"/about/index.html"},{"title":"Lisence","text":"本站采用知识署名Creative Commons协议。站内所有文章均适用CC BY-NC-SA 4.0协议。 该协议可以被这样理解： 您可以自由地共享或演绎本站的所有原创文章，只需给出署名。 您不可利用适用上述协议的文章进行商业行为。 在共享适用上述协议的文章时，您必须遵从CC BY-SA或CC BY-NC-SA协议。 以上仅是协议的简述，协议原文请见。 © 2019-2020 big-news. Some rights reserved.","link":"/about/license.html"},{"title":"Log","text":"2019-1-30 Built 2019-2-1 Basic Framework Completed 2019-2-17 1W Words 2019-2-26 2W Words 2019-3-8 3W Words 2019-3-17 4W Words 2019-3-22 Theme Changed 2019-4-14 Theme Changed 2019-4-16 ICO Redesigned 2019-5-4 50 Posts 2019-6-30 Domain Parked 2019-7-24 Record Put 2019.10.7 100 Posts, 14W Words 2020.8.9 Icarus 3 Updated","link":"/about/maintenance-log.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"Blocks","text":"html blocks used in Blog. 1 Last Updates123456&lt;article class=\"message message-immersive is-warning\"&gt;&lt;div class=\"message-body\"&gt;&lt;i class=\"fas fa-clock mr-2\"&gt;&lt;/i&gt;最近更新：y.m.d upds&lt;/div&gt;&lt;/article&gt; 最近更新：2020.8.9 upds 2 Related Posts123456&lt;article class=\"message message-immersive is-primary\"&gt;&lt;div class=\"message-body\"&gt;&lt;i class=\"fas fa-globe-asia mr-2\"&gt;&lt;/i&gt;此页面存在相关页面。关于，请参见&lt;a href=\"/path\"&gt;「」&lt;/a&gt;。&lt;/div&gt;&lt;/article&gt; 此页面存在相关页面。关于asdf，请参见「asdf」。 3 Ideas123456&lt;article class=\"message message-immersive is-primary\"&gt;&lt;div class=\"message-body\"&gt;&lt;i class=\"fas fa-lightbulb mr-2\"&gt;&lt;/i&gt;条件反射：看到xx，就应该想到xx。&lt;/div&gt;&lt;/article&gt; 条件反射：看到xx，就应该想到xx。 4 Exmple1234{% raw %}&lt;article class=\"message is-primary\" style=\"font-size:inherit\"&gt;&lt;div class=\"message-body\"&gt;{% endraw %}examples[url](markdown){% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} examplesurl 5 Info123456&lt;article class=\"message message-immersive is-primary\"&gt;&lt;div class=\"message-body\"&gt;&lt;i class=\"fas fa-info-circle mr-2\"&gt;&lt;/i&gt;Info.&lt;/div&gt;&lt;/article&gt; Info. 6 Issue123456&lt;article class=\"message message-immersive is-warning\"&gt;&lt;div class=\"message-body\"&gt;&lt;i class=\"fas fa-question-circle mr-2\"&gt;&lt;/i&gt;Issue.&lt;/div&gt;&lt;/article&gt; Issue. 7 Warning123456&lt;article class=\"message message-immersive is-danger\"&gt;&lt;div class=\"message-body\"&gt;&lt;i class=\"fas fa-exclamation-triangle mr-2\"&gt;&lt;/i&gt;Warnings.&lt;/div&gt;&lt;/article&gt; Warnings. 8 ICOs123456&lt;i class=\"fas fa-lightbulb mr-2\"&gt;&lt;/i&gt;&lt;i class=\"fas fa-globe-asia mr-2\"&gt;&lt;/i&gt;&lt;i class=\"fas fa-clock mr-2\"&gt;&lt;/i&gt;&lt;i class=\"fas fa-info-circle mr-2\"&gt;&lt;/i&gt;&lt;i class=\"fas fa-question-circle mr-2\"&gt;&lt;/i&gt;&lt;i class=\"fas fa-exclamation-triangle mr-2\"&gt;&lt;/i&gt;","link":"/port/blocks.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"Port","text":"This page is just for blogger. A dock or a port?","link":"/port/index.html"},{"title":"Control Panel","text":"Leancloud Apps Comments Manege DNS Manage Server Control Panel Site Analytics Site Push","link":"/port/control_panel.html"},{"title":"Templates","text":"1 Article1234567891011121314151617181920212223242526272829303132---title: 样板date: y-m-d h:mcategories: 分类priority: 0tags: - 标签- 标签toc: truetoc_auto_num: falsemathjax: truedonates:share:widgets: - type: recent_posts position: right - type: toc position: right---引文......&lt;!-- more --&gt;&lt;article class=\"message message-immersive is-warning\"&gt;&lt;div class=\"message-body\"&gt;&lt;i class=\"fas fa-clock mr-2\"&gt;&lt;/i&gt;最近更新：y.m.d upds&lt;/div&gt;&lt;/article&gt; 2 Sulotion12345678910111213141516171819202122232425---title: 「题解」样板date: y-m-d h:mcategories: 题解priority: 0tags: - 标签- 标签toc: truetoc_auto_num: falsemathjax: truedonates:share:widgets: - type: recent_posts position: right - type: toc position: right---引文......&lt;!-- more --&gt;","link":"/port/templates.html"}],"posts":[{"title":"2-SAT问题","text":"众所周知，2-SAT即二元适配性问题，用于解决一类布尔方程的求值问题…… 有 $n$ 个布尔变量 $x_1, x_2, …,x_n$，给定 $m$ 对冲突关系，形如 $x_i\\And x_j=0$，问一组可行解。$n\\le 10^5, m\\le 10^6$ 拆点建图，对每个变量 $x_i$ 拆成两个点 $i$ 和 $i’$，前者表示“$x_i$ 为真”，后者表示“$x_i$ 为假”。则可以将冲突关系 $(x_i,x_j)$ 转化为偏序关系 $(i,j’)$ 和 $(j,i’)$，依此得到一张有向图，然后就可以按照处理偏序关系的思路去做了。 容易发现，对于一个偏序环上的点，如果取一个值为真，那么剩下的点取值也必然为真；于是可以得到解的存在性定理：该布尔方程有解当且仅当 $\\forall i$，$i$ 和 $i’$ 不在同一个偏序环上。 如何求出一组可行解呢？贪心地想，对于 $i$ 和 $i’$，我们应该选择在新图中拓扑序大的那个将其设为真，因为这样可以最小化影响。注意到 tarjan 求出的 SCC 的编号即为新图拓扑序的反序，因此直接判断即可。 一道栗题 有 $n$ 个布尔变量 $x_1\\sim x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 true / false 或 $x_j$ 为 true / false」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。试给每个变量赋值使得所有条件得到满足，无解输出 IMPOSSIBLE。$n, m\\le 10^6$ 容易发现一共有三种本质不同的条件形式： $x_i=0|x_j=1$，等价于 $x_i\\And \\neg x_j=0$，连边 $(i,j),(j’,i’)$； $x_i=0|x_j=0$，等价于 $x_i\\And x_j=0$，连边 $(i,j’),(j,i’)$； $x_i=1|x_j=1$，等价于 $\\neg x_i\\And \\neg x_j=0$，连边 $(i’,j),(j’,i)$。 然后套用上面的做法就好了，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int CN = 4e6 + 6;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]),hd[x] = ecnt;}int n, m, du[CN];int dfn[CN], low[CN], idx = 0, stk[CN], top = 0, bel[CN], bcnt = 0; bool ins[CN];void dfs(int u){ dfn[u] = low[u] = ++idx, stk[++top] = u, ins[u] = true; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(!dfn[v]) dfs(v), low[u] = min(low[u], low[v]); else if(ins[v]) low[u] = min(low[u], low[v]); } if(low[u] == dfn[u]){ bcnt++; int pos = 0; while(pos ^ u) pos = stk[top--], ins[pos] = false, bel[pos] = bcnt; }}int main(){ freopen(\"_in.in\", \"r\", stdin); n = read(), m = read(); while(m--){ int i = read(), a = read(), j = read(), b = read(); if(a ^ b){ if(a &gt; b) swap(i, j), swap(a, b); add(i, j), add(j + n, i + n); } else{ if(!a) add(i, j + n), add(j, i + n); else add(i + n, j), add(j + n, i); } } for(int i = 1; i &lt;= (n &lt;&lt; 1); i++) if(!dfn[i]) dfs(i); bool flag = true; for(int i = 1; i &lt;= n &amp;&amp; flag; i++) flag &amp;= (bel[i] != bel[i + n]); if(!flag) puts(\"IMPOSSIBLE\"); else{ puts(\"POSSIBLE\"); for(int i = 1; i &lt;= n; i++) if(bel[i] &lt; bel[i + n]) printf(\"1 \"); else printf(\"0 \"); }}","link":"/2020/09/03/2-SAT%E9%97%AE%E9%A2%98/"},{"title":"Splay","text":"没有摘要可以提供，因为摘要还在rotate…… 此页面存在相关页面。关于使用vector替代平衡树，请参见「利用vector重现set」。 Splay - OI Wiki.pdfLGp3316 普通平衡树 模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1e5+5;int read(){ int s = 0,ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}class Splay{ public: int ch[CN][2],fa[CN],val[CN],sz[CN],cnt[CN],tot,rt; Splay() {memset(ch, 0, sizeof(ch)); memset(fa, 0, sizeof(fa)); tot = rt = 0;} #define lc ch[u][0] #define rc ch[u][1] bool get(int u) {return u == ch[ fa[u] ][1];} void maintain(int u) {sz[u] = sz[lc] + sz[rc] + cnt[u];} void clear(int u) {lc = rc = sz[u] = val[u] = fa[u] = cnt[u] = 0;} void make(int f,int k) {int u = ++tot; sz[u] = cnt[u] = 1, val[u] = k, fa[u] = f; if(f) ch[f][val[f] &lt; k] = u;} void rotate(int u){ int f = fa[u], gf = fa[ fa[u] ], chk = get(u); ch[f][chk] = ch[u][chk ^ 1], fa[ ch[u][chk ^ 1] ] = f; ch[u][chk ^ 1] = f, fa[f] = u; fa[u] = gf; if(gf) ch[gf][f == ch[gf][1]] = u; maintain(f), maintain(u); } void splay(int u){ for(int f = fa[u]; f = fa[u]; rotate(u)) if(fa[f]) rotate(get(f) == get(u) ? f : u); rt = u; } void _ins(int u,int f,int k){ if(!u) {make(f, k); rt = tot; maintain(f); return;} if(val[u] == k) {cnt[rt = u]++,sz[u]++; maintain(f); return;} _ins(val[u] &gt; k ? lc : rc, u, k); } void ins(int k) {_ins(rt, 0, k); splay(rt);} // // int _rank(int u,int k) {return val[u] == k ? rt = u, sz[lc] + 1 : (val[u] &gt; k ? _rank(lc, k) : sz[lc] + cnt[u] + _rank(rc, k));} int rank(int k) {int r = _rank(rt, k); splay(rt); return r;} // // int _kth(int u,int k) {return sz[lc] &gt;= k ? _kth(lc, k) : (sz[lc] + cnt[u] &gt;= k ? val[rt = u] : _kth(rc, k - sz[lc] - cnt[u]));} int kth(int k) {int r = _kth(rt, k); splay(rt); return r;} // // int pre() {int u = ch[rt][0]; while(rc) u = rc; return u;} int nxt() {int u = ch[rt][1]; while(lc) u = lc; return u;} void del(int k){ rank(k); int u = rt; if(cnt[u] &gt; 1) {sz[u]--,cnt[u]--; return;} if(!lc &amp;&amp; !rc) {rt = 0, clear(u); return;} if(!lc) {rt = rc, fa[rc] = 0; clear(u); return;} if(!rc) {rt = lc, fa[lc] = 0; clear(u); return;} int x = pre(); splay(x); ch[x][1] = rc,fa[rc] = x; clear(u); maintain(x); }}t;int n;int main(){ n = read(); while(n--){ int tp = read(),x = read(); if(tp == 1) t.ins(x); if(tp == 2) t.del(x); if(tp == 3) printf(\"%d\", t.rank(x)); if(tp == 4) printf(\"%d\", t.kth(x)); if(tp == 5) t.ins(x), printf(\"%d\", t.val[ t.pre() ]), t.del(x); if(tp == 6) t.ins(x), printf(\"%d\", t.val[ t.nxt() ]), t.del(x); if(tp &gt; 2) puts(\"\"); }} 最近更新： 2020.6.26","link":"/2020/06/26/Splay/"},{"title":"CSP2019 退役记","text":"没有摘要可以提供，因为摘要自闭去了…… d014:00p.m.+ arrived.然后颓了约 1h+ ，出去买了一瓶钟水回来切题。考前想练练码力，于是去做NOIP2017d1t2 时间复杂度，结果交了五遍才过…… 然后因为想用vscode编译，去搞环境变量，终于没出错，于是很满足的去恰饭…… 7:40p.m.+ 去试机，发现电脑并没有什么问题。试了试gdb也活着，然后大约还剩20min左右吧，就去打树剖的板子。结果等到试机结束，只剩下读入没写完….于是放弃。 回宿舍，想起来钟水喝完了，于是又去买了一瓶（total : 2）。宿舍里凳子不够，只好上床上肝题，一直肝到宿管都走了才睡觉，大约11:10p.m. d16:20a.m. get up.然后又睡了15min 7:30a.m. 去考场，在门口等了将近30min才进去。 8:30a.m. 准时开题。看了看t1觉得做法显然，然后去看t2，发现链的分数居然这么多。。。遂在草纸上写下：t2 链 O(n^2) 30pts + O(n) 25pts；暴力 O(n^2) 20 pts。觉得如果都能拿到也很可观。 去看t3，发现又是一道树上问题。。看来出题人是真的互相不知情。。。发现 25pts 是链，25pts 是菊花图，然后暴力分只有 10pts 。。。按照去年的经验，这种题特殊情况应该比较好想，所以觉得这题期望60pts。 然后去开t1，发现貌似会爆精度。不过不要紧，我可以特判啊，于是写了个类似于高精读入然后再转低精的东西，20min码完20min调完，时间用的貌似有点多。 开t2，发现并不会线性的做法。。。只会O(n^2)大力递推，然后想可能能用数据结构优化到O(nlogn)级别，不过没有思路。发现链的做法和树没有什么本质的区别，于是感觉要有25pts拿不到了。 开t3，发现两个特殊情况一个也不显然（真香）。。没救了，觉得可能t2更可做一点，于是打完10pts暴力去肝t2。 然而只剩下50min-。再看t2依然没有更优秀的想法，于是果断放弃去检查t1。发现t1写的处处是锅。。。然后发现貌似并不会爆精度，于是直接开unsigned long long大力搞。结果一些小细节一直在出锅，一直搞到11:55a.m.。 期间去看t2和t3，觉得我的t3绝不可能写挂，于是重点看t2有没有被卡精度，并没有发现明显的锅。 然后就这样了，最后看了看文件也没有出锅，就到12:00了。期望：100+50+10=160，考满也才到大众分。。。不过突然很怂t1写锅。 下午又去买钟水（total: 3）。 5:04p.m. t1过民间数据，看来思路没锅。不过最后5min改代码还是怂。。恰完晚饭又开始怂t2写锅。。 6:33p.m. t2自测居然80pts。。一定是数据太水。 d26:50a.m. get up.然后并不想恰早饭，喝了两碗粥散伙。 7:40a.m. 就憨憨的去了考场，然后等了半个小时。。。 8:25a.m. 拿到题目。t1居然是emiya。。emiya你为何如此nb。。然后发现我并不能把这个题看透，越看越像背包，但是并没有显然的想法，写了30min发现写不出来，于是去看t2。 开t2，一眼不可做。看数据更觉得这题绝不可做，直接考虑暴力，复杂度大概 O(玄学) ？看不透到底是有12pts还是24pts，于是告辞去看t3。 开t3，又是树。。ccf你一年考三道树上问题可还行。。发现暴力有40pts，反手一个O(n^2)大力枚举，单走一个样例，过掉，然后去写t2。 10min码出t2暴力，走前两个样例居然都过了，第三个样例太大肯定过不去，于是自己造了一个n=50的数据，发现跑的还挺快？++24pts。 10:00a.m. 重开t1。我剩两个小时写t1你能秒我？我两个小时t1你能把我秒了？结果活活推了1h毫无想法。只好去写暴力，测到第三个样例就炸掉了，估计只有32pts。 还剩大约40min，去看t3发现链的情况可做，因为链上的重心显然可以O(1)算出来。然后20min调试好代码，造了几个数据对拍都过掉了，于是觉得大概不会有什么锅，心想++15pts。 最后15min把三个源程序都重新看了一遍，没看出什么锅来，然后就告辞了。 回去的路上又去买了一瓶钟水（total : 4）。可能是退役之前的最后一瓶钟水了。。。 后来发现我t3链的情况写锅了。。。(Pi,Pi+1)活活看成(i,i+1)，当时还觉得没问题。。。于是成功–15pts。 估分：32+24+40=96，两天100+80+10+32+24+40=286封顶，预测会被锅到250~260左右，成功AFO。 然后回来的时候听说全国划线。。。目测省四稳了。 然后就没然后了。。技不如人，肝败下风。 退役了，虽然好像还有很多事没去完成。 cf一直想上蓝，结果直到最后都在Specialist的底部徘徊。。洛谷红了快两年了吧，停课之后打了几场月赛，排名居然升到了rk264，不过马上也就要掉下去了。。顺带一说昨天恰好499AC，差一道就到500题了。本来想在退役之前把差的题目刷上去，可惜觉得找不到适合充当这最后一道题目的题。。那就不刷了吧，有时候不完美也是一种完美。 2017.9~2019.11 Away From OI，虽然打的很菜，但至少我来过。 Upd on 2019.11.20 几天没上洛谷居然又上分了，rk181，xswl。Upd on 2019.11.25 洛谷居然又上分了……rk168… Upd on 2019.12.17 迟到好久的最终更新 最后 t2 的大力DP终究还是没能活下来，然后成功地100+50+10+32+24+40=256，省rk110+，原地升天爆炸退役。 然后就这样吧。因为太菜，所以只能选择退役。 $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/11/16/CSP2019%20%E9%80%80%E5%BD%B9%E8%AE%B0/"},{"title":"「维护日志」2019-3-22 改版","text":"经过三个晚上的不懈努力与若干次调试，新的主题被打磨得终于能看得过去了。于是bn’s Blog得以以船新面貌面世，不过依然留下了一大堆不可优化的BUG…… 1 界面更新采用了GodBMW设计的主题Art Design。界面样式如封面图。 去除了动态背景。 独立了“友链”页面。 2 功能更新去除了字数统计。去除了阅读数统计。 添加了运行时间统计。 原Links内容移至底栏。保留了Valine评论系统。 3 文章格式主题采用了新的文章格式，模板如下： 12345678910111213141516171819202122---title: 样板date: y-m-d h:mcategories: 分类tags: - 标签cover: &quot;https://text.com/demo.png&quot;mathjax: truedonates:share:widgets: - type: recent_posts position: right - type: toc position: right--- # head引文...... &lt;!-- more --&gt; # begin$$ ---- \\mathcal{End} ---- $$ # end`最近更新： y-m-d upds。` # upd 支持引文和封面图。 支持文章分类。 4 访问速度问题与原先采用的NexT相比，在一定程度上提升了访问速度。 5 已知BUG站内搜索基于Google实现，目前无法正常使用（我看以后也悬）。解决办法请参见站内公告。 6 Updates2019.3.29用了三天的时间尝试移植原先NexT主题的静态搜索。结果资源文件配置好了，语法转义也完成了，就是不知道怎么加上一个调用链接（大雾）。然后发现完全不懂Javascript……虽然搞了三天有点理解语法了，但还是看不懂。于是发现不可改，放弃，日后再说。 把原先链接到搜索框的搜索键直接链接到了search.xml资源文件，方便使用页面查找实现（实现？？）站内搜索。 2019.3.30把valine换成了gitalk。 好了，这样新主题的打磨基本就完成了，以后只debug（真香警告）。 $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/22/%E3%80%8C%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97%E3%80%8D2019-3-22%20%E6%94%B9%E7%89%88/"},{"title":"「维护日志」2019-4-14 改版","text":"不得不说，好主题还是真香啊。刚打磨了三个多星期的主题又被抛弃了…… 1 主题采用了ICARUS。 2 功能功能被大部分保留。 运行时间统计被删除。 评论系统又换回Valine。因为Gitalk出了玄学错误… 3 文章格式更新的文章格式如下： 123456789101112131415161718192021222324---title: 样板date: y-m-d h:mcategories: 分类tags: - 标签thumbnail: &quot;https://text.com/demo.png&quot;toc: truetoc_auto_num: falsemathjax: truedonates:share:widgets: - type: recent_posts position: right - type: toc position: right---引文......&lt;!-- more --&gt;$$ ---- \\mathcal{End} ---- $$`最近更新： y-m-d upds。` 4 访问速度它已经够快了！ 5 已知BUG暂无。 $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/04/14/%E3%80%8C%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97%E3%80%8D2019-4-14%20%E6%94%B9%E7%89%88/"},{"title":"「解题报告」 Codeforces Round 599 (Div. 2)","text":"解题报告貌似鸽了好几天了，毕竟是晚上爆肝打的比赛，第二天早上起来还要 % 拟 ……其实之前还有场 Div. 3 ，不过打的太烂就不写解题报告了…… 先是掉分经过：开场 15min 切 A,B1 签到不多说，然后去看 B2 ，觉得它不显然；就去看 C 题，然后觉得这个东西貌似可以分解质因数然后搞一搞，结果后来代码一直锅掉，调了将近一个小时才过……期间去看 D 题，也没有什么本质的想法，然后就睡觉去了，大概在 0:20 a.m. 左右，目测掉分预定。第二天早上起来发现 C 题居然没锅，然后就神奇的 rating +19 ，不过依然是 $\\text{Specialist}$ 。 A. Maximum SquareSource 签到题。当时切了 C 题去 room 里砍人，居然发现这题有人写二分……无言以对。 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e3+3;int read(){/* omitted */}int q,n,a[CN];int main(){ q = read(); while(q--){ n = read(); for(int i=1;i&lt;=n;i++) a[i] = read(); for(int i=n;i;i--){ int cnt = 0; for(int j=1;j&lt;=n;j++) if(a[j] &gt;= i) cnt++; if(cnt &gt;= i) {printf(\"%d\\n\",i); break;} } } return 0;} B1. Character Swap (Easy Version)Source 依然签到。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e4+4;int read(){/* omitted */}int k,n; char s[CN],t[CN];int main(){ k = read(); while(k--){ n = read(); cin&gt;&gt;s&gt;&gt;t; int cnt = 0; for(int i=0;i&lt;n;i++) if(s[i] != t[i]) cnt++; if(cnt != 2) printf(\"No\\n\"); else{ int p[20],q = 0; for(int i=0;i&lt;n;i++) if(s[i] != t[i]) p[q++] = i; swap(s[ p[0] ], t[ p[1] ]); cnt = 0; for(int i=0;i&lt;n;i++) if(s[i] != t[i]) cnt++; if(!cnt) printf(\"Yes\\n\"); else printf(\"No\\n\"); } } return 0;} B2 不会，skip 。 C. Tile PaintingSource 考虑有哪些格子的颜色相同，不难发现这个东西跟它的质因子有关系。从一个点出发，我们应该筛掉从该点出发，以 n 的任一质因子为“距离”能到达的所有点，这些点的颜色相同；然后下一次我们应该再去找一个没有被筛过的点重复上述过程。问题的本质在于“没有被筛过的点”我们能找到几个。 不难发现如果一个数字只有一个质因子 p ，那么这样的点我们有 p 个，即 1~p ；若其存在两个或更多的质因子，那么看起来从第一个点开始就能筛掉所有点，于是答案是 1 . 代码： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;#define LL long longLL n,p[101];void div(LL x){ for(LL k=2;k*k&lt;=x;k++){ if(!(x % k)) p[ ++p[0] ] = k; while(!(x % k)) x /= k; } if(x &gt; 1) p[ ++p[0] ] = x;}int main(){ scanf(\"%I64d\",&amp;n); if(n == 1){ printf(\"1\"); return 0; } div(n); if(p[0] == 1) printf(\"%I64d\",p[1]); else printf(\"1\"); return 0;} D. 0-1 MSTSource 显然连 0 边更优，也就是说我们只在迫不得已的情况下去连 1 边。考虑在图上只保留 0 边，那么显然一个联通块里面我们是不需要连 1 边的。把每个联通块整体考虑，则需要连 1 边的数量为联通块数 -1 。 上述过程大力搜索实现显然是不行的，考虑用并查集维护联通性。我们怎么判定一个点属于一个联通块？假设某一联通块的大小为 sz ，那么一个点向它连的 1 边的数量（记作 ct ）是可以统计的，而该点和此联通块一共有 sz 条边相连；当 sz &gt; ct 时，即可推出该点与联通块之间有 0 边。 可是上述过程大力去做还是 O(n^2) 的，考虑到一个联通块只需要被合并一次，于是对于所有找到的联通块，只记录其中一个点进行合并就好了，也就是把该联通块在并查集中的根记下来。因为原图上 0 边很多，也就是说联通块个数很少，所以这个想法就会跑得很快。 最后的答案是并查集中根的个数 -1，其中根的个数即为联通块数。考虑到我们此前维护的根可能被合并，也就是说有些根 gg 掉了，所以最后还得再统计一下根的数量。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;const int CN = 1e5+5;class dsu{ public: int fa[CN],sz[CN]; vector&lt;int&gt; rt; dsu() {for(int i=1;i&lt;CN;i++) fa[i]=i,sz[i]=1;} int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);} bool exm(int x,int y) {return find(x) != find(y);} void merge(int x,int y) {x = find(x); y = find(y); sz[y] += sz[x]; fa[x] = y;}}co;class fs{ public: int to,nxt; void init(int t,int n) {to=t;nxt=n;}}E[CN * 21];int hd[CN],ecnt = 0;void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int n,m;int ve[CN];int ct(){ co.rt.push_back(1); for(int i=2;i&lt;=n;i++){ memset(ve, 0, sizeof(ve)); for(int k=hd[i];k;k=E[k].nxt){ int v = E[k].to; if(v &lt; i) ve[ co.find(v) ]++; } int cn = co.rt.size(); for(int j=0;j&lt;cn;j++){ int r = co.rt[j]; r = co.find(r); if(co.sz[r] &gt; ve[r] &amp;&amp; co.exm(i, r)) co.merge(i, r); } if(co.find(i) == i) co.rt.push_back(i); } int cnt = 0; for(int i=1;i&lt;=n;i++) if(co.find(i) == i) cnt++; return cnt;}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); while(m--){ int u,v; scanf(\"%d%d\",&amp;u,&amp;v); add(u, v); add(v, u); } printf(\"%d\",ct() - 1); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/11/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%20Codeforces%20Round%20599%20(Div.%202)/"},{"title":"「解题报告」Codeforces Round 594 (Div. 2)","text":"可怜的小cj被卡死在C题…… A. PolandBall and HypothesisSource 不难发现只有形如y=x+b1和y=-x+b2的函数会有交点。联立x+b1 = -x+b2,有x = (b2-b1)/2。这个东西为整数，当且仅当b2-b1为偶数。也就是说现在我们要统计∀i∈[1,n],j∈[1,m] , (bj-bi) ≡ 0 (mod 2)的数量。我们发现我们关注的只是bj-bi的奇偶性，而并不是这个式子具体的值。考虑什么情况下两数相减会出现偶数：偶-偶 或 奇-奇 。考虑用乘法解决这个问题，那我们设c1表示bi(i∈[1,n])$中奇数的数量，c2表示bj(j∈[1,m])中奇数的数量，那么答案显然就是c1×c2 + (n-c1)×(m-c2)。于是做完了。 代码： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define LL long longconst int CN = 1e5+5;LL read(){ LL s = 0,ne = 1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne = -1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}LL t,n,m;int main(){ //freopen(\"a.in\",\"r\",stdin); t = read(); while(t--){ LL cnt1 = 0,cnt2 = 0,ans; n = read(); for(int i=1;i&lt;=n;i++) {int pi = read(); if(pi % 2) cnt1++;} m = read(); for(int i=1;i&lt;=m;i++) {int qi = read(); if(qi % 2) cnt2++;} ans = cnt1 * cnt2 + (n-cnt1) * (m-cnt2); printf(\"%I64d\\n\",ans); } return 0;} B. Grow The TreeSource 不能有连续的两段就是让你把这些边分成大小分别为⌊n/2⌋，⌈n/2⌉的两组。一个并不显然但是是正确的的贪心思路：小的分一组，大的分一组。然后就做完了。 代码： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std; #define LL long long const int CN = 1e5+5; LL read(){ LL s = 0,ne = 1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne = -1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;} int n; LL a[CN],sum[CN]; LL Pow(LL u) {return u*u;} int main(){ //freopen(\"b.in\",\"r\",stdin); n = read(); for(int i=1;i&lt;=n;i++) a[i] = read(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) sum[i] = sum[i-1]+a[i]; LL ans = Pow(sum[_n]) + Pow(sum[n]-sum[_n]); int _n = n/2; if(_n * 2 != n) ans = max(ans, Pow(sum[_n+1])+Pow(sum[n]-sum[_n+1])); printf(\"%I64d\",ans); return 0;} C. Ivan the Fool and the Probability TheorySource 考虑第一行。固定第一个格子的颜色，那么方案数是一个fibonacci数列。推广到整个矩阵： 当第一行不存在相邻元素时，也就是说它长这样：10101… 这个时候仅需要相邻三行互不相同。把每一行理解成一个元素，实际上又回到了上面的那个问题，这个方案数又是一个fibonacci数列。因此此时答案是 1×f[m] 。 当第一行存在相邻元素时，那么下面的整个矩阵实际上已经确定了，因为下面的每一行都只能是上面一行把每位都取反的结果。此时答案为 (f[n]-1)×1 。 因此答案总数为 1×f[m] + (f[n]-1)×1 = f[n]+f[m]-1 。考虑第一个格子有两种情况，因此答案是 2×(f[n]+f[m]-1) 。 代码： 1234567891011121314#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int CN = 1e5+5;const int R = 1e9+7;int n,m,f[CN];int main(){ scanf(\"%d%d\",&amp;n,&amp;m); f[0] = 2,f[1] = 2; for(int i=2;i&lt;=max(n,m);i++) f[i] = (f[i-1]+f[i-2]) % R; printf(\"%d\", (f[n]+f[m]-2) % R); return 0;} D1. The World Is Just a Programming Task (Easy Version)Source 显然是枚举方案，剩下的问题是怎么找“循环匹配”个数。设’(‘代表 1 ，’)’代表 -1 ，于是我们得到一串数列。有一个结论是说“循环匹配”个数恰好等于这个数列的前缀和最小值的数量，感性理解一下，这个东西很有道理，然后就做完了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 550;int abs(int x) {return x &gt; 0 ? x : -x;}int n; char ch[CN];int ans = 0,ansi = 1,ansj = 1;int GetAns(){ int cnt = 0,sum = 0,mn = 0; for(int i=0;i&lt;n;i++){ if(ch[i] == '(') cnt++; else cnt--; mn = min(mn, cnt); } for(int i=0;i&lt;n;i++){ if(ch[i] == '(') cnt++; else cnt--; if(cnt == mn) sum++; } return sum;}bool checker(){ int a = 0,b = 0; for(int i=0;i&lt;n;i++) if(ch[i] == '(') a++; else b++; return a == b;}int main(){ scanf(\"%d\",&amp;n); cin&gt;&gt;ch; if(!checker()) printf(\"0\\n1 1\"); else{ for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++){ swap(ch[i],ch[j]); if(GetAns() &gt; ans) {ans = GetAns(); ansi = i+1; ansj = j+1;} swap(ch[j],ch[i]); } printf(\"%d\\n%d %d\",ans,ansi,ansj); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/10/22/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20594%20(Div.%202)/"},{"title":"「解题报告」Codeforces Round 596 (Div. 2)","text":"又被C题的一些小细节卡死…… A. Forgetting ThingsSource 不难发现只有 a+1 = b 或 a = b 时才有解。前一种直接输出 ‘a b’ ，后一种输出 ‘a0 b1’ 。然后还有一个坑点是 a = 9,b = 1 的情况，此时是有解的，应输出 ‘9 10’。 代码： 123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int a,b;int main(){ scanf(\"%d%d\",&amp;a,&amp;b); if(a == b) printf(\"%d0 %d1\",a,b); else if(a + 1 == b) printf(\"%d %d\",a,b); else if(a == 9 &amp;&amp; b == 1) printf(\"9 10\"); else printf(\"-1\"); return 0;} B. TV SubscriptionsSource (Easy Version)Source (Hard Version) 区间的长度是固定的，那么只需要开一个桶，维护一下在某段区间内有那些元素。考虑从一个区间滑动到另一个区间，那么这时候区间内元素个数是可以 O(1) 维护的，然后切了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1e6+6;const int INF = 0x3f3f3f3f;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int t,n,k,d,a[CN];int tot[CN];int main(){ t = read(); while(t--){ memset(tot,0,sizeof(tot)); n = read(); k = read(); d = read(); for(int i=1;i&lt;=n;i++) a[i] = read(); int ans = INF,cnt = 0; for(int i=1;i&lt;d;i++) {if(!tot[ a[i] ]) cnt++; tot[ a[i] ]++;} for(int i=d;i&lt;=n;i++){ if(!tot[ a[i] ]) cnt++; tot[ a[i] ]++; tot[ a[i-d] ]--; if(!tot[ a[i-d] ]) cnt--; ans = min(ans, cnt); } printf(\"%d\\n\",ans); } return 0;} C. p-binarySource 简化一下题意：给定 $p,s$ ，试求得一个最小的 $n$ ，使得存在一组 $\\begin{Bmatrix} k_1,k_2,…,k_n \\end{Bmatrix}$ ，满足 $\\sum\\limits_{i=1}^n 2^{k_i} + np = s$ 。 把 $np$ 移到右边去，变形成 $\\sum\\limits_{i=1}^n 2^{k_i} = s-np$ 。枚举 $n$ 之后， $s-np$ 就变成了一个定值，于是很自然的联想到可以把 $s-np$ 这个数表示成二进制下的和的形式，也就是 $s-np=\\sum\\limits_{(s-np) \\And 2^i} 2^i$ 。那么这实际上就是一种可行的拆分方案，我们只需要 check 一下 $(s-np) \\And 2^i$ 成立的数量是否恰好等于 $n$ 即可，也就是判断 $s-np$ 在二进制下 $1$ 的数量是否恰好等于 $n$ ，这是 $O(\\log)$ 的。 但是这并不能涵盖所有的方案。事实上，对于一个正整数 $k$，总有 $2^k=2\\times(2^{k-1})=2^{k-1} + 2^{k-1}$ ，也就是说有一些项我们依然可以继续拆分。考虑 $2^k$ 能拆出的项数的范围：最少只有它自己，也就是一项；最多呢？考虑把上面拆分的过程看作一棵二叉树，不难发先我们总可以拆出两项，三项，…，直到 $k$ 项。那么对于任意的 $2^k$ ，它总可以被拆分一项，两项，…， $k$ 项，也就是说它“能拆出的项数的范围”是 $[1,k]$ 。 考虑 $s-np=\\sum\\limits_{(s-np) \\And 2^i} 2^i$ 中，后面那些部分能变成多少项。显然，任意 $2^i$ 能拆出的项数的范围是 $[1,i]$ ，那么设 $s-np = 2^{i_1}+2^{i_2}+…+2^{i_k} $ ，其中后面那一部分共有 $k$ 项，即可推出 $s-np$ 能拆出的项数的范围就是 $[k,i_1+i_2+…+i_k]$ 。 于是我们要做的就变成了 check 一下 $n\\in [k,i_1+i_2+…+i_k]$ 是否成立，若成立则我们找到了一个可行解。这个判断还是 $O(\\log)$ 的，那么只需要在 $10^6$ 内枚举 $n$ 就好了。 然后还有一些小细节，比赛的时候把我卡死了。。。具体看代码。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int N = 1e6; // 枚举的边界，实际上还可以更小LL n,p,ans = -1;bool checker(LL u,int k){ if(!u) return false; // 特判 u 为 0 时一定无解 int lb = 0,rb = 1,i = 0; // rb 一定要初始化为 1, 因为至少有一项 while(u){ if(u &amp; 1) lb++,rb += i; u &gt;&gt;= 1,i++; } return lb &lt;= k &amp;&amp; k &lt;= rb;} int main(){ scanf(\"%I64d%I64d\",&amp;n,&amp;p); for(int k=1;k&lt;=N;k++){ LL c = n - 1ll * k * p; if(c &lt; 0) break; if(checker(c,k)){ ans = 1ll * k; break; } } printf(\"%I64d\",ans);} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/10/27/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20596%20(Div.%202)/"},{"title":"「解题报告」Codeforces Round 668 (Div. 2)","text":"两场 Div.2 爆肝上蓝系列…… 比赛链接 A. Permutation Forgery这题是精心构造样例给选手降智啊….卡了我半小时 /kk实际上反过来输出就好了啊… 1234const int CN = 110;int a[CN], n = read();for(int i = 1; i &lt;= n; i++) a[i] = read();for(int i = n; i &gt;= 1; i--) printf(\"%d \", a[i]); puts(\"\"); B. Array Cancellation容易发现答案就是后缀和的最大值…证明显然啊，就算了吧… 123456#define int long longconst int CN = 1e5 + 5;int n, a[CN];n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read();int ans = max(0ll, a[n]); for(int i = n - 1; i; i--) a[i] += a[i + 1], ans = max(ans, a[i]);printf(\"%lld\", ans), puts(\"\"); C. Balanced Bitstring容易发现模 $k$ 相同的位置， 字符应当是相同的，那么模拟即可。 123456789101112131415161718const int CN = 1e6 + 10;int T, n, k; char a[CN], s[CN];ios :: sync_with_stdio(false);cin &gt;&gt; n &gt;&gt; k &gt;&gt; a; for(int i = 0; i &lt; k; i++) s[i] = '?'; bool flag = true;for(int i = 0; i &lt; n &amp;&amp; flag; i++) if(a[i] != '?') { if(s[i % k] == '?') s[i % k] = a[i]; else if(s[i % k] != a[i]) flag = false; } int cnt0 = 0, cnt1 = 0;for(int i = 0; i &lt; k; i++) cnt1 += (s[i] == '1'), cnt0 += (s[i] == '0');if(cnt0 &gt; (k / 2) || cnt1 &gt; (k / 2)) flag = false;flag ? puts(\"YES\") : puts(\"NO\"); D. Tree Tag容易发现初始位置看似是无用的，那么把树的直径找出来判断即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int CN = 1e5 + 5;int T, n, a, b, da, db;class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}void hinit() {for(int i = 0; i &lt;= n; i++) hd[i] = 0;}int d[CN], dm;void dinit() {for(int i = 0; i &lt;= n; i++) d[i] = 0;}void dfs(int u, int p){ for(int k = hd[u]; k; k = E[k].nxt) {int v = E[k].to; if(v ^ p) d[v] = d[u] + 1, dfs(v, u);}}int fa[CN][21], dep[CN];void finit(){ for(int i = 0; i &lt;= 20; i++) for(int j = 0; j &lt;= n; j++) fa[j][i] = 0; for(int i = 0; i &lt;= n; i++) dep[i] = 0;}void pc(int u, int p){ fa[u][0] = p, dep[u] = dep[p] + 1; for(int k = hd[u]; k; k = E[k].nxt) {int v = E[k].to; if(v ^ p) pc(v, u);}}int lca(int u, int v){ if(dep[u] &lt; dep[v]) swap(u, v); for(int k = 20; k + 1; k--) if(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k]; if(u ^ v) {for(int k = 20; k + 1; k--) if(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][0];} return u;}int dis(int u, int v) {return dep[u] + dep[v] - 2 * dep[lca(u, v)];}int main() { T = read(); while(T--){ hinit(), ecnt = 0; n = read(), a = read(), b = read(), da = read(), db = read(); for(int i = 1; i &lt; n; i++) {int u = read(), v = read(); add(u, v), add(v, u);} finit(), pc(1, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; if(dis(a, b) &lt;= da) {puts(\"Alice\"); continue;} dinit(), dfs(1, 0); int mx = 0, p; for(int i = 1; i &lt;= n; i++) mx = mx &lt; d[i] ? p = i, mx = d[i] : mx; dinit(), dfs(p, 0), dm = 0; for(int i = 1; i &lt;= n; i++) dm = max(dm, d[i]); if(2 * da &gt;= dm) puts(\"Alice\"); else if(db &gt;= 2 * da + 1) puts(\"Bob\"); else puts(\"Alice\");}} E. Fixed Point Removal乍一看像是道二维数点，不过我的做法假掉了 /kk英文 tutorial 看不懂啊，咕一咕等个中文题解吧…","link":"/2020/09/07/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20668%20(Div.%202)/"},{"title":"「解题报告」NIKKEI Prog. Contest 2019-2","text":"又是签到走人的一天…… A. Sum of Two IntegersSource 签到题。 12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main(){ int n; scanf(\"%d\",&amp;n); if(n % 2) n += 1; n /= 2; printf(\"%d\",n - 1); return 0;} B. Counting of TreesSource 签到题。考虑每一层的方案数，直接乘法原理就好了。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define LL long longconst int CN = 1e5+5;const LL R = 998244353;int n,fir; LL s[CN];LL qpow(LL a,LL b){ LL rec = 1; while(b){ if(b &amp; 1) (rec *= a) %= R; (a *= a) %= R; b &gt;&gt;= 1; } return rec;}int main(){ scanf(\"%d%d\",&amp;n,&amp;fir); for(int i=2;i&lt;=n;i++){ int x; scanf(\"%d\",&amp;x); if(!x) {fir = 1; break;} s[x]++; } for(int i=1;i&lt;=n;i++) if(s[i]) s[0] = i; for(int i=1;i&lt;=s[0];i++) if(!s[i]) fir = 1; if(fir) printf(\"0\"); else{ LL ans = 1; for(int i=2;i&lt;=s[0];i++) (ans *= qpow(s[i-1], s[i])) %= R; printf(\"%lld\",ans); } return 0;} C 不会，skip 。 D. Shortest Path on a LineSource 这题把我卡了一个多小时还没想出来，当时一直在想建个线段树搞线段覆盖…… 实际上一段区间里面任意两点间有等距的有向边，这个东西等价于把这段区间连成一个简单环：节点顺序连边，然后仅有一条边有边权为 ci ，其余为 0 。那么如果我们逆着这个环的方向去求最短路，就能得到这个长度总是 ci ，因为没法直接到达，就总要经过那条边权为 ci 的边。 一张图解： 剩下的问题跑 DJ 就好了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int CN = 1e5+5;const LL INF = 0x3f3f3f3f3f3f3f2f;LL read(){ LL s = 0,ne = 1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int to,nxt; LL di; void init(int t,int n,LL d) {to=t;nxt=n;di=d;}}E[CN * 51];int hd[CN],ecnt = 0;void add(int x,int y,LL z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}int n,m;/* DJ */class DJ{ public: int id; LL v; bool operator &lt; (const DJ&amp; a)const {return v &gt; a.v;}};priority_queue&lt;DJ&gt; Q; LL d[CN]; bool vis[CN];LL SP(int st,int ed){ memset(vis, 0, sizeof(vis)); memset(d, 0x3f, sizeof(d)); Q.push((DJ){st, d[st] = 0}); while(!Q.empty()){ int u = Q.top().id; Q.pop(); if(vis[u]) continue; vis[u] = true; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(d[v] &gt; d[u] + E[k].di){ d[v] = d[u] + E[k].di; Q.push((DJ){v, d[v]}); } } } return d[ed] &lt; INF ? d[ed] : -1;}int main(){ n = read(); m = read(); while(m--){ int u = read(),v = read(); LL c = read(); add(u, v, c); } for(int i=1;i&lt;n;i++) add(i + 1, i, 0); printf(\"%lld\", SP(1, n)); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/11/10/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DNIKKEI%20Prog%20Contest%202019-2/"},{"title":"「解题报告」Codeforces Round 667 (Div. 3)","text":"最近 CF 的 Div2.3 有一点点水啊，虽然说蒟蒻还是上不了分…… 比赛链接 A Yet Another Two Integers Problem签到傻题。 123456int t, a, b;t = read(); while(t--){ a = read(), b = read(); int k = abs(a - b), b = k / 10; if(b * 10 == k) printf(\"%d\", b); else printf(\"%d\", b + 1); puts(\"\");} B Minimum Product设 $a$ 变成了 $a-c$，$b$ 变成了 $b-d$，则减少的部分是 $-cb-ad+cd$，代入 $c+d=n$ 可以推出这是一个关于 $c$ 的二次函数，且开口向下，那么容易知道 $c$ 只有两种取值 $\\max(0,y-b+n)$ 或 $a-x$，代入检验即可。 代码： 12345678910111213141516#define int long longconst int INF = 0x3f3f3f3f3f3f3f3f;int t, a, b, x, y, n;t = read(); while(t--){ a = read(), b = read(), x = read(), y = read(), n = read(); int ans = INF, c, d; if(a + b - x - y &lt;= n) ans = x * y; else{ c = min(n, a - x), d = min(b - y, n - c); ans = min(ans, (a - c) * (b - d)); c = min(n, max(0ll, y - b + n)), d = min(b - y, n - c); ans = min(ans, (a - c) * (b - d)); } printf(\"%I64d\", ans); puts(\"\");}} C Yet Another Array Restoration傻题，模拟即可。 123456789101112131415161718192021222324const int CN = 202;int t, n, x, y, d, a[CN], ans[CN];int mx(int a[]){ int mx = 0; for(int i = 1; i &lt;= n; i++) mx = max(mx, a[i]); return mx;}t = read(); while(t--){ n = read(), x = read(), y = read(); int mn = INT_MAX; for(d = 1; d &lt;= y; d++){ if((y - x) % d) continue; int l = (y - x) / d + 1, u = x; if(l &gt; n) continue; for(int i = 1; i &lt;= l; i++) a[i] = u, u += d; if(l &lt; n){ int sum = n - l; u = x - d; while(u &gt; 0 &amp;&amp; sum) sum--, a[++l] = u, u -= d; u = y + d; while(sum) sum--, a[++l] = u, u += d; } int cur = mx(a); if(cur &lt; y) continue; if(cur &lt; mn) mn = cur, memcpy(ans, a, sizeof(a)); } for(int i = 1; i &lt;= n; i++) printf(\"%d \", ans[i]); puts(\"\");} D Decrease the Sum of Digits容易发现代价是固定的，那么模拟即可。 123456789101112131415#define int long longint t, n, s, bit[101], p10[101], cur;p10[0] = 1; for(int i = 1; i &lt;= 70; i++) p10[i] = p10[i - 1] * 10;t = read(); while(t--){ cur = 0, n = read(), s = read(); int lg = 0; while(n) bit[++lg] = n % 10, n /= 10, cur += bit[lg]; int ans = 0; for(int i = 1; i &lt;= lg &amp;&amp; cur &gt; s; i++){ if(!bit[i]) continue; ans += (10 - bit[i]) * p10[i - 1]; bit[i + 1]++, cur -= bit[i] - 1; } printf(\"%I64d\", ans), puts(\"\");} E Two Platforms离散化坐标，考虑对于每个坐标 $i$ ，求出 $[1,i]$ 和 $(i,n]$ 的答案，加起来更新答案即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define int long longconst int CN = 6e5 + 5;int t, n, d, X[CN], val[CN], pre[CN], suf[CN], sum[CN];int id(int x) {return lower_bound(val + 1, val + val[0] + 1, x) - val;}signed main(){ freopen(\"_in.in\", \"r\", stdin); t = read(); while(t--){ n = read(), d = read(), val[0] = 0; for(int i = 1; i &lt;= n; i++) X[i] = read(), val[ ++val[0] ] = X[i], val[ ++val[0] ] = X[i] + d, val[ ++val[0] ] = X[i] - d; for(int i = 1; i &lt;= n; i++) read(); sort(val + 1, val + val[0] + 1); int cnt = 1; for(int i = 2; i &lt;= val[0]; i++) if(val[i] ^ val[i - 1]) val[++cnt] = val[i]; val[0] = cnt; for(int i = 0; i &lt;= val[0] + 100; i++) pre[i] = suf[i] = sum[i] = 0; for(int i = 1; i &lt;= n; i++) sum[ id(X[i]) ]++; for(int i = 1; i &lt;= val[0]; i++) sum[i] += sum[i - 1]; for(int i = 1; i &lt;= n; i++){ int p = id(X[i]), l = id(X[i] - d), r = id(X[i] + d); pre[p] = sum[p] - sum[l - 1], suf[p] = sum[r] - sum[p - 1]; } for(int i = 1; i &lt;= val[0]; i++) pre[i] = max(pre[i], pre[i - 1]); for(int i = val[0]; i; i--) suf[i] = max(suf[i], suf[i + 1]); int ans = 0; for(int i = 1; i &lt;= val[0]; i++) ans = max(ans, pre[i] + suf[i + 1]); printf(\"%lld\", ans), puts(\"\");}} F Subsequences of Length Two显然要 DP，设 $f[i,j,k]$ 表示考虑 $s[1:i]$ 中，$t[1]$ 出现了 $j$ 次，当前改动了 $k$ 次的方案数，就可以转移了。 具体来讲，考虑 $i\\to i+1$，我们有两种选择： 什么都不做，转移到 $f[i+1,c+0/1,k]$； 把这一位改成 $t_1$，转移到 $f[i+1,c+1,k+1]$ 把这一位改成 $t_2$，转移到 $f[i+1,c,k+1]+c$ 最后特殊考虑一下 $t[1]=t[2]$ 的情况即可，时间复杂度 $O(n^3)$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define int long longconst int CN = 210;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int n, d, f[CN][CN][CN], ans; char s[CN], c1, c2;void DP1(){ memset(f, -0x3f, sizeof(f)), f[0][0][0] = 0; int c = 0; for(int i = 1; i &lt;= n; i++){ f[i][c + (s[i] == c1)][0] = f[i - 1][c][0]; c += (s[i] == c1); if(s[i] == c2) f[i][c][0] += c; } for(int k = 0; k &lt;= d; k++) for(int c = 0; c &lt;= n; c++) for(int i = 0; i &lt;= n; i++){ if(s[i + 1] == c2) f[i + 1][c][k] = max(f[i + 1][c][k], f[i][c][k] + c); else if(s[i + 1] == c1) f[i + 1][c + 1][k] = max(f[i + 1][c + 1][k], f[i][c][k]); else f[i + 1][c][k] = max(f[i + 1][c][k], f[i][c][k]); if(s[i + 1] != c1) f[i + 1][c + 1][k + 1] = max(f[i + 1][c + 1][k + 1], f[i][c][k]); if(s[i + 1] != c2) f[i + 1][c][k + 1] = max(f[i + 1][c][k + 1], f[i][c][k] + c); }}void DP2(){ memset(f, -0x3f, sizeof(f)), f[0][0][0] = 0; int c = 0; for(int i = 1; i &lt;= n; i++){ f[i][c + (s[i] == c1)][0] = f[i - 1][c][0]; if(s[i] == c1) c++, f[i][c][0] += c - 1; } for(int k = 0; k &lt;= d; k++) for(int c = 0; c &lt;= n; c++) for(int i = 0; i &lt;= n; i++){ if(s[i + 1] == c1) f[i + 1][c + 1][k] = max(f[i + 1][c + 1][k], f[i][c][k] + c); else f[i + 1][c][k] = max(f[i + 1][c][k], f[i][c][k]); if(s[i + 1] != c1) f[i + 1][c + 1][k + 1] = max(f[i + 1][c + 1][k + 1], f[i][c][k] + c); }}signed main(){ freopen(\"_in.in\", \"r\", stdin); n = read(), d = read(), cin &gt;&gt; (s + 1) &gt;&gt; c1 &gt;&gt; c2; if(c1 != c2) DP1(); else DP2(); for(int x = 0; x &lt;= n; x++) for(int k = 0; k &lt;= d; k++) ans = max(ans, f[n][x][k]); printf(\"%lld\", ans);}","link":"/2020/09/05/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20667%20(Div.%203)/"},{"title":"「解题报告」Codeforces Round 597 (Div. 2)","text":"真香警告.jpg…… A. Good ol’ Numbers ColoringSource 看完样例就很显然了，切掉就好了。 代码： 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int read(){ int s = 0,ne = 1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c == '-') ne = -1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s = (s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s * ne;}int t,a,b;int gcd(int a,int b){return !b ? a : gcd(b, a % b);}int main(){ t = read(); while(t--){ a = read(); b = read(); if(gcd(a,b) == 1) printf(\"Finite\\n\"); else printf(\"Infinite\\n\"); } return 0;} B. Restricted RPSSource 每步贪心，能干就干。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e5+5;int read(){ int s = 0,ne = 1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c == '-') ne = -1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s = (s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s * ne;}int t,n,s0,s1,s2,opt[CN],ans[CN]; bool bt[CN];int main(){ t = read(); while(t--){ n = read(); s1 = read(); s0 = read(); s2 = read(); for(int i=1;i&lt;=n;i++){ char c; cin&gt;&gt;c; if(c == 'P') opt[i] = 0; if(c == 'R') opt[i] = 1; if(c == 'S') opt[i] = 2; } memset(bt,0,sizeof(bt)); int cnt = 0; for(int i=1;i&lt;=n;i++){ if(!opt[i] &amp;&amp; s2) bt[i] = true,s2--; if(opt[i] == 1 &amp;&amp; s0) bt[i] = true,s0--; if(opt[i] == 2 &amp;&amp; s1) bt[i] = true,s1--; } for(int i=1;i&lt;=n;i++){ if(bt[i]) ans[i] = (opt[i] + 2) % 3,cnt++; else{ if(s0) ans[i] = 0,s0--; else if(s1) ans[i] = 1,s1--; else if(s2) ans[i] = 2,s2--; } } int vs = n / 2; if(n % 2) vs += 1; if(cnt &gt;= vs){ printf(\"Yes\\n\"); for(int i=1;i&lt;=n;i++){ if(!ans[i]) cout&lt;&lt;'P'; if(ans[i] == 1) cout&lt;&lt;'R'; if(ans[i] == 2) cout&lt;&lt;'S'; } printf(\"\\n\"); } else printf(\"No\\n\"); } return 0;} C. Constanze’s MachineSource 这题看上去还是比较有感觉的，只不过式子错了，这就很dl了（真香）。 首先显然可以把每个连续字段的方案数算出来然后再乘法原理，剩下的问题是求一个“连续字段”的方案数。 关于“连续字段”的方案，这个问题可以抽象成给你一段序列类似于“uuuuuu”这个样子，让你在其中划若干条长度为 2 的线，两两线不能相交，求方案数。那么显然这个东西可以设个状态写写方程，于是设 f[i] 表示考虑长度为 i 的序列的方案数。考虑新加入的这个元素，我们可以把它和元素 i-1 划成一段，方案数 f[i-2] ；也可以不划到任何一段，方案数 f[i-1] 。于是 f[i]=f[i-1]+f[i-2] ，又是 fibonacci 数列…然后做完了。 比赛的时候方程推成了 f[i]=f[i-1]+i-2 ，因为实际上我只考虑了划两段的情况…然后pretest9一直WA，自闭了，看来还是不够熟练… 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; #define LL long long const int CN = 2e5+5;const LL R = 1e9+7; char ch[CN]; int n;LL f[CN],ans = 1; int main(){ cin&gt;&gt;ch; n = strlen(ch); f[1] = 1; f[2] = 2; for(LL i=3;i&lt;=n;i++) f[i] = (f[i-1] + f[i-2]) % R; bool flag = true; for(int i=0;i&lt;n;i++) if(ch[i] == 'm' || ch[i] == 'w') flag = false; if(!flag) printf(\"0\"); else{ for(int i=0;i&lt;n;i++){ if(ch[i] != 'n' &amp;&amp; ch[i] != 'u') continue; int p = i,l = 1; while(p &lt; n &amp;&amp; ch[p] == ch[p+1]) p++,l++; (ans *= f[l]) %= R; i = p; } printf(\"%I64d\",ans); } return 0;} D. Shichikuji and Power GridSource 第一眼没什么感觉，看了 tutorial 发现就是个 mst … 建一个虚点向每个点连边，表示建电站就好了，看来还是不够熟练… 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std; #define LL long long const int CN = 2010; class fs{ public: int fr,to; LL di; void init(int f,int t,LL d) {fr=f;to=t;di=d;} bool operator &lt; (const fs&amp; a)const {return di &lt; a.di;}}E[CN * CN];int ecnt = 0;void add(int x,int y,LL z) {E[++ecnt].init(x,y,z);}class ufs{ public: int fa[CN]; ufs() {for(int i=1;i&lt;CN;i++) fa[i] = i;} int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);} bool exm(int x,int y) {return find(x) != find(y);} void merge(int x,int y) {fa[find(x)] = find(y);} }ck; int n,px[CN],py[CN],pc[CN],pk[CN];int abs(int x) {return x&lt;0 ? -x : x;}int dist(int a,int b) {return abs(px[a] - px[b]) + abs(py[a] - py[b]);} bool sel[CN * CN]; LL si = 0;void MST(){ memset(sel,false,sizeof(sel)); sort(E+1,E+ecnt+1); int cnt = 0; for(int i=1;i&lt;=ecnt;i++){ if(!ck.exm(E[i].fr, E[i].to)) continue; ck.merge(E[i].fr, E[i].to); cnt++; si += E[i].di; sel[i] = true; if(cnt == n - 1) break; }} int main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;px[i],&amp;py[i]); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;pc[i]); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;pk[i]); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) add(i,j,1ll*(pk[i]+pk[j])*dist(i,j)); for(int i=1;i&lt;=n;i++) add(i,n+1,pc[i]); n += 1; MST(); printf(\"%I64d\\n\",si); int cnt = 0; for(int i=1;i&lt;=ecnt;i++) if(sel[i] &amp;&amp; E[i].to == n) cnt++; printf(\"%d\\n\",cnt); for(int i=1;i&lt;=ecnt;i++) if(sel[i] &amp;&amp; E[i].to == n) printf(\"%d \",E[i].fr); printf(\"\\n\"); cnt = n - 1 - cnt; printf(\"%d\\n\",cnt); for(int i=1;i&lt;=ecnt;i++) if(sel[i] &amp;&amp; E[i].to != n) printf(\"%d %d\\n\",E[i].fr,E[i].to); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/11/03/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20597%20(Div.%202)/"},{"title":"「解题报告」牛客小白月赛 27","text":"又是签到走人的一天…… 比赛链接 A 巨木之森签到题，对每个点维护一个到叶子的最长距离，随便怎么搞搞就行了。本人脑子笨，写了个线段树，复杂度 $O(n\\log n)$，实际上有严格 $O(n)$ 解法。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define int long longconst int CN = 1e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt,d; void init(int t,int n,int dd) {to = t, nxt = n, d = dd;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}class SGT { public: int d[CN &lt;&lt; 2], tag[CN &lt;&lt; 2]; #define lc k &lt;&lt; 1 #define rc k &lt;&lt; 1 | 1 void pd(int l, int r, int k){ d[lc] += tag[k], d[rc] += tag[k], tag[lc] += tag[k], tag[rc] += tag[k], tag[k] = 0; } void md(int l, int r, int k, int s, int t, int x){ if(s &lt;= l &amp;&amp; r &lt;= t) return (void)(tag[k] += x, d[k] += x); int m = (l + r) &gt;&gt; 1; if(tag[k]) pd(l, r, k); if(s &lt;= m) md(l, m, lc, s, t, x); if(m &lt; t) md(m + 1, r, rc, s, t, x); d[k] = max(d[lc], d[rc]); } void upd(int l, int r, int k){ if(l == r) return; int m = (l + r) &gt;&gt; 1; if(tag[k]) pd(l, r, k); upd(l, m, lc), upd(m + 1, r, rc); d[k] = max(d[lc], d[rc]); } int qu() {return d[1];}} D;int n, m, sum = 0, d[CN], id[CN], sz[CN], idx = 0, mxd[CN];void bd(int u, int p){ id[u] = ++idx, sz[u] = 1; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p) d[v] = d[u] + E[k].d, bd(v, u), sz[u] += sz[v]; }}void dfs(int u, int p){ mxd[u] = D.qu(); for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p){ D.md(1, n, 1, 1, n, E[k].d), D.md(1, n, 1, id[v], id[v] + sz[v] - 1, -2ll * E[k].d); dfs(v, u); D.md(1, n, 1, 1, n, -E[k].d), D.md(1, n, 1, id[v], id[v] + sz[v] - 1, 2ll * E[k].d); } }}signed main(){ n = read(), m = read(); for(int i = 1; i &lt; n; i++){ int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w), sum += w; } sum = 2ll * sum; bd(1, 0); for(int i = 1; i &lt;= n; i++) D.md(1, n, 1, id[i], id[i], d[i]); dfs(1, 0); for(int i = 1; i &lt;= n; i++) mxd[i] = sum - mxd[i]; sort(mxd + 1, mxd + n + 1); int ans = 0, sum = 0, p = 1; while(p &lt;= n &amp;&amp; sum + mxd[p] &lt;= m) sum += mxd[p++], ans++; printf(\"%lld\", ans);} B 乐团派对考察快速排序以及输入输出。代码： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int n, a[CN];bool cmp(int a, int b) {return a &gt; b;}int main(){ n = read(); for(int i = 1; i &lt;= n; i++) {a[i] = read(); if(a[i] &gt; n) return puts(\"-1\"), 0;} sort(a + 1, a + n + 1, cmp); int p = 1, ans = 0; while(p &lt;= n) {if(p + a[p] &lt;= n + 1) ans++, p += a[p]; else p++;} printf(\"%d\", ans);} D 巅峰对决线段树板子题。代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e5 + 5;const int INF = 0x3f3f3f3f;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int gcd(int a, int b) {return !b ? a : gcd(b, a % b);}class SGT { public: int d[CN &lt;&lt; 2], mx[CN &lt;&lt; 2], mn[CN &lt;&lt; 2]; #define lc k &lt;&lt; 1 #define rc k &lt;&lt; 1 | 1 void bd(int l, int r, int k, int *a){ if(l == r) return (void)(mx[k] = mn[k] = d[k] = a[l]); int m = (l + r) &gt;&gt; 1; bd(l, m, lc, a), bd(m + 1, r, rc, a); d[k] = gcd(d[lc], d[rc]), mx[k] = max(mx[lc], mx[rc]), mn[k] = min(mn[lc], mn[rc]); } void md(int l, int r, int k, int p, int x){ if(l == r) return (void)(mx[k] = mn[k] = d[k] = x); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) md(l, m, lc, p, x); else md(m + 1, r, rc, p, x); d[k] = gcd(d[lc], d[rc]), mx[k] = max(mx[lc], mx[rc]), mn[k] = min(mn[lc], mn[rc]); } int qu(int l, int r, int k, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t) return d[k]; int m = (l + r) &gt;&gt; 1, ans = 0; if(s &lt;= m) ans = gcd(qu(l, m, lc, s, t), ans); if(m &lt; t) ans = gcd(qu(m + 1, r, rc, s, t), ans); return ans; } int qum(int l, int r, int k, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t) return mx[k]; int m = (l + r) &gt;&gt; 1, ans = 0; if(s &lt;= m) ans = max(qum(l, m, lc, s, t), ans); if(m &lt; t) ans = max(qum(m + 1, r, rc, s, t), ans); return ans; } int qun(int l, int r, int k, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t) return mn[k]; int m = (l + r) &gt;&gt; 1, ans = INF; if(s &lt;= m) ans = min(qun(l, m, lc, s, t), ans); if(m &lt; t) ans = min(qun(m + 1, r, rc, s, t), ans); return ans; }} D;int n, q, a[CN];bool ck(int s, int t){ if(s == t) return true; int MX = D.qum(1, n, 1, s, t), MN = D.qun(1, n, 1, s, t); if((MX - MN) ^ (t - s)) return false; int G = D.qu(1, n, 1, s, t); return G ^ 1 ? 0 : 1;}int main(){ n = read(), q = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); D.bd(1, n, 1, a); while(q--){ int op = read(), x = read(), y = read(); if(op == 1) D.md(1, n, 1, x, y); else ck(x, y) ? puts(\"YES\") : puts(\"NO\"); }} F 核弹剑仙傻题。代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CN = 1e5 + 5;const int INF = 0x3f3f3f3f;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int n, m, f[CN]; bool vis[CN];void dfs(int u){ vis[u] = true; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(!vis[v]) dfs(v); }}int cnt(int u){ memset(vis, 0, sizeof(vis)); dfs(u); int ans = 0; for(int i = 1; i &lt;= n; i++) if(vis[i]) ans++; return ans - 1;}int main(){ n = read(), m = read(); for(int i = 1; i &lt;= m; i++){ int u = read(), v = read(); add(v, u); } for(int i = 1; i &lt;= n; i++) printf(\"%d\", cnt(i)), puts(\"\");}","link":"/2020/08/22/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B%2027/"},{"title":"「解题报告」Codeforces Round 669 (Div. 2)","text":"蒟蒻下分场…… 比赛链接 A. Ahahahahahahahaha注意到 01 串一定有 $\\ge n/2$ 个 0 或者 1，依此构造即可。 1234567891011121314151617181920212223242526int c = 0; memset(a, 0, sizeof(a));n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), c += (a[i] == 0);n /= 2;if(n &amp; 1){ if(c &gt;= n){ printf(\"%d\", n), puts(\"\"); for(int i = 1; i &lt;= n; i++) printf(\"0 \");puts(\"\"); } else if(!c){ printf(\"%d\", n &lt;&lt; 1), puts(\"\"); for(int i = 1; i &lt;= n * 2; i++) printf(\"1 \"); puts(\"\"); } else{ printf(\"%d\", n + 1), puts(\"\"); for(int i = 1; i &lt;= n + 1; i++) printf(\"1 \"); puts(\"\"); } continue;}if(c &gt;= n){ printf(\"%d\", n), puts(\"\"); for(int i = 1; i &lt;= n; i++) printf(\"0 \");}else{ printf(\"%d\", n), puts(\"\"); for(int i = 1; i &lt;= n; i++) printf(\"1 \");} B. Big Vova$O(n^2)$ 贪心即可。 1234567891011121314for(int i = 1; i &lt;= n; i++) usd[i] = 0;n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read();int lst = 0;for(int i = 1; i &lt;= n; i++) { int mx = 0; for(int j = 1; j &lt;= n; j++){ if(usd[j]) continue; if(mx == 0) mx = j; if(gcd(lst, a[mx]) &lt; gcd(lst, a[j])) mx = j; } usd[mx] = 1, b[i] = a[mx]; lst = gcd(lst, a[mx]);}for(int i = 1; i &lt;= n; i++) printf(\"%d \", b[i]); puts(\"\"); C. Chocolate Bunny连续询问 $x,y$ 和 $y, x$，得到 $a,b$，则有 $\\max(a,b)=\\min(p_x,p_y)$，依此模拟即可。 12345678910111213n = read(); int lst = 1;for(int i = 2; i &lt;= n; i++){ int x, y, z; printf(\"? %d %d\\n\", lst, i); fflush(stdout); x = read(); printf(\"? %d %d\\n\", i, lst); fflush(stdout); y = read(), z = max(x, y); if(x &lt; y) a[i] = z ; else a[lst] = z, lst = i;}for(int i = 1; i &lt;= n; i++) vis[ a[i] ]++;for(int i = 1; i &lt;= n; i++) if(!vis[i]) {a[lst] = i; break;}printf(\"! \"); for(int i = 1; i &lt;= n; i++) printf(\"%d \", a[i]); fflush(stdout); D. Discrete Centrifugal Jumps理性分析一下，边数看上去不是 $O(n^2)$ 的而是 $O(n)$ 的，那么可以线性地把图建出来，单调栈维护一下即可。但是这个题并不需要最短路算法，注意到这是一个 DAG，因此直接 DP 计算即可，时间复杂度 $O(n)$。 12345678910111213141516171819202122232425n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); memset(f, 0x3f, sizeof(f)), f[1] = 0;stk1[++top1] = 1, stk2[++top2] = 1;for(int i = 2; i &lt;= n; i++){ while(top1 &amp;&amp; a[ stk1[top1] ] &lt; a[i]){ f[i] = min(f[i], f[ stk1[top1] ]); while(top1 &amp;&amp; a[ stk1[top1] ] == a[ stk1[top1 - 1] ]) top1--; if(top1) top1--; } if(top1) f[i] = min(f[i], f[ stk1[top1] ]); stk1[++top1] = i; while(top2 &amp;&amp; a[ stk2[top2] ] &gt; a[i]){ f[i] = min(f[i], f[ stk2[top2] ]); while(top2 &amp;&amp; a[ stk2[top2] ] == a[ stk2[top2 - 1] ]) top2--; if(top2) top2--; } if(top2) f[i] = min(f[i], f[ stk2[top2] ]); stk2[++top2] = i; f[i]++;}printf(\"%lld\", f[n]); E. Egor in the Republic of Dagestan算是比较裸的一道 E 题了……设 $f[u,0/1]$ 表示在 $u$ 点，选 0 边还是选 1 边的答案，对于一条边 $u\\gets v$，应当有 $f[u,c]\\gets \\max(f[v,0],f[v,1])+1$，其中 $c$ 代表边 $u\\gets v$ 的颜色。注意到一个点不会被松弛超过一次，直接跑 Dijkstra 转移即可，时间复杂度 $O((n+m)\\log n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int CN = 1e6 + 6;const int INF = 0x3f3f3f3f;class fs {public: int to,nxt,tp; void init(int t,int n,int p) {to = t, nxt = n, tp = p;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}int n, m;class DJ {public: int v, id; bool operator &lt; (const DJ &amp;a) const {return v &gt; a.v;}} ;DJ mk(int a, int b) {DJ d; d.v = a, d.id = b; return d;}int d[CN][2]; bool vis[CN]; priority_queue&lt;DJ&gt; Q;void SP(int u){ memset(d, 0x3f, sizeof(d)), Q.push( mk(d[u][0] = d[u][1] = 0, u) ); while(!Q.empty()){ u = Q.top().id, Q.pop(); if(vis[u]) continue; vis[u] = true; int dis = max(d[u][0], d[u][1]); for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to, c = E[k].tp, cur; if(vis[v]) continue; if(d[v][c] &gt; dis + 1){ d[v][c] = dis + 1, cur = max(d[v][0], d[v][1]); if(cur &lt; INF) Q.push( mk(cur, v) ); } } }}int main(){ n = read(), m = read(); for(int i = 1; i &lt;= m; i++) {int u = read(), v = read(), t = read(); add(v, u, t);} SP(n); if(max(d[1][0], d[1][1]) &lt; INF) printf(\"%d\", max(d[1][0], d[1][1])), puts(\"\"); else puts(\"-1\"); for(int i = 1; i &lt;= n; i++) putchar(d[i][0] &gt; d[i][1] ? '0' : '1');}","link":"/2020/09/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20669%20(Div.%202)/"},{"title":"「题解」CME","text":"爆炸oj.png…… 一 题目 Source DescriptionsLet’s denote correct match equation (we will denote it as CME) an equation a+b=c there all integers a, b and c are greater than zero.For example, equations 2+2=4 (||+||=||||) and 1+2=3 (|+||=|||) are CME but equations 1+2=4 (|+||=||||), 2+2=3 (||+||=|||), and 0+1=1 (+|=|) are not. Now, you have n matches. You want to assemble a CME using all your matches. Unfortunately, it is possible that you can’t assemble the CME using all matches. But you can buy some extra matches and then assemble CME!For example, if n=2, you can buy two matches and assemble |+|=||, and if n=5 you can buy one match and assemble ||+|=|||. Calculate the minimum number of matches which you have to buy for assembling CME.Note, that you have to answer q independent queries. InputThe first line contains one integer q (1≤q≤100) — the number of queries.The only line of each query contains one integer n (2≤n≤109) — the number of matches. OutputFor each test case print one integer in single line — the minimum number of matches which you have to buy for assembling CME. 二 题解简化一下题面：给定 n ，设 a+b+c = n+r。求得最小的 r ，使得 a+b = c。用 c 代式一里面的 a+b ，则 2c = n+r。即 2c-r = n，n 是已知的，于是这个东西看起来很像exgcd。 实际上不需要exgcd，这个不定方程总有特解：c = 0, r = -n。根据一堆奇奇怪怪的东西我们得到：c在对(-1/gcd(2,-1))取模意义下定义，b在对(2/gcd(2,-1))取模意义下定义。即c ≡ 0 (mod 1), r ≡ -n (mod -2)。 然后再回想一下 c 和 r 实际上是有取值范围的，因为 a,b ⩾ 1，所以 c ⩾ 2，并且有 r ⩾ 0。 然后不动脑子你就可以写出这样一个 while ： 1234int c = 0,r = -n,cnt;while(c&lt;2 || r&lt;0){ c += 1; r += 2;} 然后输出 r 就好了，但是可惜它跑得不够快。 然后动一动脑子你就会发现上面那个 while 可以直接作除法来解决，就是这样： 1234567891011int c = 0,r = -n,cnt;if(!(n % 2)){ cnt = n/2; r = 0;}else{ cnt = (n/2) + 1; r = 1;}if(c+cnt &lt; 2){ int k = 2 - c - cnt; r += 2*k;} 然后就做完了。 代码: 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; int q,n; int main(){ scanf(\"%d\",&amp;q); while(q--){ scanf(\"%d\",&amp;n); int c = 0,r = -n,cnt; /* while(c&lt;2 || r&lt;0){ c += 1; r += 2; } */ if(!(n % 2)){ cnt = n/2; r = 0; } else{ cnt = (n/2) + 1; r = 1; } if(c+cnt &lt; 2){ int k = 2 - c - cnt; r += 2*k; } printf(\"%d\\n\",r); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/10/07/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DCME/"},{"title":"「题解」Complete Tripartite","text":"“完全”的三分图的存在性判定问题…… 一 题目 Source DescriptionsYou have a simple undirected graph consisting of n vertices and m edges. The graph doesn’t contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected. Let’s make a definition.Let v1 and v2 be two some nonempty subsets of vertices that do not intersect. Let f(v1,v2) be true if and only if all the conditions are satisfied:There are no edges with both endpoints in vertex set v1.There are no edges with both endpoints in vertex set v2.For every two vertices x and y such that x is in v1 and y is in v2, there is an edge between x and y. Create three vertex sets (v1, v2, v3) which satisfy the conditions below;All vertex sets should not be empty.Each vertex should be assigned to only one vertex set.f(v1,v2), f(v2,v3), f(v3,v1) are all true.Is it possible to create such three vertex sets? If it’s possible, print matching vertex set for each vertex. InputThe first line contains two integers n and m (3≤n≤105, 0≤m≤min(3⋅105,n(n−1)2)) — the number of vertices and edges in the graph.The i-th of the next m lines contains two integers ai and bi (1≤ai&lt;bi≤n) — it means there is an edge between ai and bi. The graph doesn’t contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected. OutputIf the answer exists, print n integers. i-th integer means the vertex set number (from 1 to 3) of i-th vertex. Otherwise, print −1.If there are multiple answers, print any. 二 题解就是给你一张图，让你判定能不能把这张图上找出三个互异点集，使它们的并是总点集，且有任意两点集中的点总有边相连。实际上可以看成一个”完全“（任意两点间都有边相连）的三分图。 显然，若图不连通，则必定无解。 然后在保证图联通的情况下，对于一个可行的极大的点集，其中的每个点能到达的 所有点 组成的点集总是一样的。换句话说，能到达的点集相同的点总属于同一个可行的极大的点集。那么只需要把这些点拎出来就好了，最后形成的点集个数如果为 3 就表明恰好有解，再给每个点集编号就好了。 也可以推广到完全 k 分图的判定 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 5e5+5;class edge{ public: int id; vector&lt;int&gt; to; // to : 每个点能到达的点集}E[CN];class ufs{ // 判联通 public: int fa[CN]; ufs() {for(int i=1;i&lt;=300001;i++) fa[i] = i;} int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);} bool exm(int x,int y) {return find(x) != find(y);} void merge(int x,int y) {fa[find(x)] = find(y);} }S;/* v define */int n,m;int bel[CN];/* */bool CheCon(){ // 判联通 for(int i=1;i&lt;=n;i++) S.find(i); int R = S.fa[1]; for(int i=2;i&lt;=n;i++) if(S.fa[i] != R) return false; return true;}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); while(m--){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); E[x].to.push_back(y); E[y].to.push_back(x); if(S.exm(x, y)) S.merge(x,y); } if(CheCon()){ for(int i=1;i&lt;=n;i++) sort(E[i].to.begin(), E[i].to.end()); // 排序，方便下面判等 for(int i=1;i&lt;=n;i++){ // 相当于一个离散化的过程 if(!bel[i]){ bel[i] = ++bel[0]; for(int j=1;j&lt;=n;j++) if(E[i].to == E[j].to) bel[j] = bel[0]; } } if(bel[0] == 3){ for(int i=1;i&lt;=n;i++) printf(\"%d \",bel[i]); } else printf(\"-1\"); } else printf(\"-1\"); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/10/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DComplete%20Tripartite/"},{"title":"「解题报告」牛客练习赛68","text":"牛客的题还是比较板啊，像我这样的菜鸡都能打到 rk30？？？/jk A 牛牛的mex主席树模板题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 4e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SGT { public: int d[CN * 50], rt[CN], ch[CN * 50][2], idx; SGT() {idx = 0;} #define lc ch[u][0] #define rc ch[u][1] int make() {return ++idx;} void ins(int &amp;u, int v, int l, int r, int p){ if(!u) u = make(); if(l == r) return (void)(d[u] = d[v] + 1); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) rc = ch[v][1], ins(lc, ch[v][0], l, m, p); else lc = ch[v][0], ins(rc, ch[v][1], m + 1, r, p); d[u] = d[lc] + d[rc]; } int qu(int u, int v, int l, int r){ if(l == r) return l; int m = (l + r) &gt;&gt; 1, s = d[lc] - d[ ch[v][0] ]; if(s &lt; m - l + 1) return qu(lc, ch[v][0], l, m); else return qu(rc, ch[v][1], m + 1, r); }} D;int n, q, ai;int main(){ freopen(\"_in.in\", \"r\", stdin); n = read(), q = read(); for(int i = 1; i &lt;= n; i++) ai = read(), D.ins(D.rt[i], D.rt[i - 1], 1, n, ai + 1); int x, y; while(q--) x = read(), y = read(), printf(\"%d\", y - x + 1 &lt; n ? D.qu(D.rt[y], D.rt[x - 1], 1, n) - 1 : n), puts(\"\");} B 牛牛的算术傻题，随便推一推柿子，特判下就好了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 5e5 + 5;const int P = 199999;int qp(int a,int b) {int r = 1; while(b) {if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P; b &gt;&gt;= 1;} return r;}#define i2 qp(2, P - 2)int t, f[CN], p[CN];char ch[CN];int cal(int x) { int squ = 1ll * x * x % P; squ = 1ll * squ * (x + 1) % P; return squ;}int main(){ freopen(\"_in.in\", \"r\", stdin); std::ios::sync_with_stdio(false); for(int i = 1; i &lt; P; i++) f[i] = (f[i - 1] + cal(i)) % P; p[0] = 1; for(int i = 1; i &lt; P; i++) p[i] = 1ll * p[i - 1] * i % P, p[i] = 1ll * p[i] * f[i] % P, p[i] = 1ll * p[i] * i2 % P; cin &gt;&gt; t; while(t--){ cin &gt;&gt; ch; int l = strlen(ch); if(l &gt;= 6) {puts(\"0\"); continue;} int n = 0; for(int i = 0; i &lt; l; i++) n = n * 10 + (ch[i] - '0'); if(n &gt;= P) puts(\"0\"); else printf(\"%d\", p[n]), puts(\"\"); }} C 牛牛的无向图容易想到把边和询问都按权值排序，然后依次加边，能加就加，然后对于每个连通块就可以 $O(1)$ 算答案了。维护一个并查集就解决了，时间复杂度 $O(m\\log m + (m + q)\\alpha(n))$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define LL long longconst int CN = 5e5 + 5;class DSU { public: int fa[CN]; DSU() {for(int i = 1; i &lt;= 100000; i++) fa[i] = i;} int fd(int x) {return fa[x] ^ x ? fa[x] = fd(fa[x]) : x;}} C;int n, m, q, LIM, X[CN], Y[CN], W[CN], id[CN], pos = 1, L[CN], sz[CN]; LL ans[CN];bool cmp(int i, int j) {return W[i] &lt; W[j];}LL cal(int x) {return 1ll * x * (x - 1) / 2ll;}unsigned int SA, SB, SC; unsigned int rng61(){ SA ^= SA &lt;&lt; 16; SA ^= SA &gt;&gt; 5; SA ^= SA &lt;&lt; 1; unsigned int t = SA; SA = SB; SB = SC; SC ^= t ^ SA; return SC;}void gen(){ scanf(\"%d%d%d%u%u%u%d\", &amp;n, &amp;m, &amp;q, &amp;SA, &amp;SB, &amp;SC, &amp;LIM); for(int i = 1; i &lt;= m; i++){ X[i] = rng61() % n + 1; Y[i] = rng61() % n + 1; W[i] = rng61() % LIM; id[i] = i; } for(int i = 1; i &lt;= q; i++){ L[i] = rng61() % LIM; }}int main(){ freopen(\"_in.in\", \"r\", stdin); gen(); sort(L + 1, L + q + 1), sort(id + 1, id + m + 1, cmp); for(int i = 1; i &lt;= n; i++) sz[i] = 1; for(int i = 1; i &lt;= q; i++){ LL cur = ans[i - 1]; while(W[ id[pos] ] &lt;= L[i] &amp;&amp; pos &lt;= m){ int u = X[ id[pos] ], v = Y[ id[pos] ], fu = C.fd(u), fv = C.fd(v); if(fu ^ fv) cur += 1ll * sz[fu] * sz[fv], C.fa[fv] = fu, sz[fu] += sz[fv]; pos++; } ans[i] = cur; } for(int i = 1; i &lt;= q; i++) ans[0] ^= ans[i]; printf(\"%lld\", ans[0]);} D 牛牛的粉丝显然是个矩乘优化 DP 转移，设 $f[k,i]$ 表示 $k$ 轮后点 $i$ 的答案这样，直接做复杂度 $O(n^3\\log k)$，好像不太行。然后就没有想法了…… upd：转移矩阵是循环的啊……既然是循环的就没必要 $O(n^3)$ 算了……存下第一行来矩乘就变卷积了……于是做到 $O(n^2\\log k)$……甚至还可以 $O(n\\log n\\log k)$ /jk…… E 牛牛的字符串回文不会处理啊……看上去我只会 $O(n^3)$ 的辣鸡 DP，也许可以通过一些字符串算法优化到 $O(n^2)$？不可做不可做。 upd：并没有什么神仙算法……所以说还是要观察性质……","link":"/2020/08/28/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B68/"},{"title":"「题解」Dividing a String","text":"AGC 037的A题，然后我连A题都不会做…… 一 题目 Source DescriptionsGiven is a string S consisting of lowercase English letters. Find the maximum positive integer K that satisfies the following condition:There exists a partition of S into K non-empty strings S=S1S2…SK such that Si≠Si+1 (1≤i≤K−1).Here S1S2…SK represents the concatenation of S1,S2,…,SK in this order. InputInput is given from Standard Input in the following format:S OutputPrint the maximum positive integer K that satisfies the condition. 二 题解一开始想着二分+暴力判断，结果T到飞起，记录。 然后正解说最优策略下每划分的一段要么长为1，要么为2……手模了几组数据貌似是对的，然后写了个爆搜再加上记忆化就AC了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e5+5;char ch[CN];int n;bool exm(int cl,int cr,int pl,int pr){ if((pr-pl+1) != (cr-cl+1)) return true; for(int i=0;i&lt;(pr-pl+1);i++) if(ch[cl+i] != ch[pl+i]) return true; return false;}int f[CN];int dfs(int st,int pl,int pr){ if(st &gt; n) return 0; if(f[st]) return f[st]; if(exm(st,st,pl,pr)) f[st] = max(f[st], dfs(st+1,st,st)+1); if(exm(st,st+1,pl,pr) &amp;&amp; st+1&lt;=n) f[st] = max(f[st], dfs(st+2,st,st+1)+1); return f[st];}int main(){ //freopen(\"agc037 A.in\",\"r\",stdin); cin&gt;&gt;ch; n = strlen(ch)-1; dfs(0,1,0); printf(\"%d\",f[0]); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/09/14/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DDividing%20a%20String/"},{"title":"「题解」Common Divisors","text":"数学题真是有趣，大胆猜想，无需证明…… 一 题目 Source DescriptionsYou are given an array a consisting of n integers. Your task is to say the number of such positive integers x such that x divides each number from the array. In other words, you have to find the number of common divisors of all elements in the array. For example, if the array a will be [2,4,6,2,10], then 1 and 2 divide each number from the array (so the answer for this test is 2). InputThe first line of the input contains one integer n (1≤n≤4⋅105) — the number of elements in a.The second line of the input contains n integers a1,a2,…,an (1≤ai≤1012), where ai is the i-th element of a. OutputPrint one integer — the number of such positive integers x such that x divides each number from the given array (in other words, the answer is the number of common divisors of all elements in the array). 二 题解实际上答案就是所有数的gcd的因子个数……写一发居然AC了，真是所谓大胆猜想，无需证明。 首先gcd肯定是“所有数的公因子”的大小的上界，即不会存在一个所有数的公因子比这些数的gcd大，否则和gcd的定义相悖。然后充分性体现在：既然一个数x是一列数a[]的gcd的因子，那么就这个x一定是这些a[]的公因子，因此得证。 代码，还是WA了好几遍…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;#define LL long longconst int CN = 4e5+5;LL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n;LL a[CN];LL gcd(LL a,LL b){return b?gcd(b,a%b):a;}LL calc(LL g){ if(g == 1) return 1; LL ans = 0,upb = sqrt(g); if(upb*upb == g){ ans = 1; for(LL k=1;k&lt;upb;k++) if(!(g%k)) ans += 2; } else{ for(LL k=1;k&lt;=upb;k++) if(!(g%k)) ans += 2; } return ans;}int main(){ n = read(); for(int i=1;i&lt;=n;i++) a[i] = read(),a[0] = gcd(a[0], a[i]); printf(\"%lld\",calc(a[0])); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/08/15/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DCommon%20Divisors/"},{"title":"「题解」AC自动机（简单版）","text":"虽然说这题是AC自动机吧…但是后缀数组也能解。在这里提供一个清新的后缀数组解法。 后缀数组后缀数组是个好东西啊，通过这个工具可以解决许多类型的字符串问题，这里简单介绍一下： 形式化地，对于一个长度为 $n$ 的字符串 $s$，它的形如 $s[i:n]$ 的子串被称作 $s$ 的后缀。 容易发现 $s$ 一共有 $n$ 个后缀，不妨记 $s[i:n]$ 为后缀 $i$，将所有的后缀排序后，顺序写下后缀的编号，就得到了后缀数组 (Suffix Array)。 举个例子，对 $s=ababa$，其后缀有 $a,ba,aba,baba,ababa$，排序后得到 $a,aba,ababa,ba,baba$，依次写下其编号，得到后缀数组为 $5,3,1,2,4$。 朴素求后缀数组是 $O(n^2 \\log n)$ 的，这显然是不太好的。通过倍增法去求，容易发现倍增的过程是某种双关键字排序，那么对其进行基数排序，可做到 $O(n \\log n)$。具体的实现超出了本篇题解的范畴，请移步 后缀排序。 回到本题容易发现，一个串 $s$ 若能与 $t$ 匹配，那么它必然是 $t$ 的 某个后缀的前缀。我们可以快速把所有后缀都排序，这样后缀就是有序的了，可以通过二分来找 $s$ 是否与 $t$ 匹配。 具体实现上，因为后缀的长度和是 $O(n^2)$ 级别的，所以不能把他们全部搞出来（会MLE）。实际上只需要写一个 cmp() 函数来比较字符串大小就好了，实现起来比较清新易懂。 复杂度因为每次要二分，所以整体多了一个 $\\log$，不过均摊下来跑的非常快，常数比AC自动机大了不到一半。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* fake-acam.cpp */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1e6 + 6;char t[CN], s[CN];string mem[CN];int sa[CN], rk[CN &lt;&lt; 1], prk[CN &lt;&lt; 1], id[CN], px[CN], cnt[CN];void SA(int n){ int m = max(n, 300); for(int i = 1;i &lt;= n;i++) rk[i] = t[i - 1]; for(int i = 1;i &lt;= n;i++) cnt[ rk[i] ] ++; for(int i = 1;i &lt;= m;i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ rk[i] ]-- ] = i; for(int w = 1; w &lt; n; w &lt;&lt;= 1){ memset(cnt, 0, sizeof(cnt)); for(int i = 1;i &lt;= n;i++) id[i] = sa[i]; for(int i = 1;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] + w ] ]++; for(int i = 1;i &lt;= m;i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i]; memset(cnt, 0, sizeof(cnt)); for(int i = 1;i &lt;= n;i++) id[i] = sa[i]; for(int i = 1;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] ] ]++; for(int i = 1;i &lt;= m;i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i]; memcpy(prk, rk, sizeof(rk)); m = 0; for(int i = 1;i &lt;= n;i++) if(prk[ sa[i] ] == prk[ sa[i - 1] ] &amp;&amp; prk[ sa[i] + w ] == prk[ sa[i - 1] + w ]) rk[ sa[i] ] = m; else rk[ sa[i] ] = ++m; if(m == n) break; }}int n, lt;// 判断 a[] &lt; b[]inline int le(char *a, char *b, int la,int lb){ int p = 0; while(a[p] == b[p] &amp;&amp; p &lt; min(la, lb)) p++; if(p == lb) return -1; if(p == la) return true; return a[p] &lt; b[p];}int main(){ // freopen(\"_in.in\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;n); for(int i = 1;i &lt;= n;i++) cin &gt;&gt; mem[i]; cin &gt;&gt; t; lt = strlen(t); SA(lt); int cnt = 0; for(int i = 1;i &lt;= n;i++){ int ls = mem[i].size(); s[ls] = '\\0'; for(int j = 0;j &lt; ls;j++) s[j] = mem[i][j]; int l = 1, r = lt, m; bool found = false; while(l &lt; r){ m = (l + r) &gt;&gt; 1; int leq = le(t + sa[m] - 1, s, lt - sa[m] + 1,ls); if(leq == -1) {found = true; break;} else if(leq) l = m + 1; else r = m; } cnt += found ? 1 : 0; } printf(\"%d\", cnt);}","link":"/2020/08/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DAC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/"},{"title":"「题解」Emiya家今天的饭","text":"众所周知，小葱同学擅长计算几何，但是并不擅长 DP。 $m = 2/3$ 设 $f[i,j,k]$ 表示考虑前 $i$ 行，第一列选了 $j$ 个，第二列选了 $k$ 个的方案数之和，有转移：$$f[i,j,k]\\gets f[i-1,j-1,k]·a[i,1]+f[i-1,j,k-1]·a[i,2]$$ $m = 3$ 的情况也同理，多开一维状态就好了，复杂度 $O(n^3)$ 或 $O(n^4)$，能拿到 64pts。 $m\\le 500$ 根据 lorem ipsum 原理，不合法方案中至多有一列的选择数超过 $\\lfloor k/2 \\rfloor$ ，则考虑补集转化，把不合法的方案 DP 出来。钦点第 $u$ 行不合法，设 $f[i,j,k]$ 表示考虑前 $i$ 行，其它行一共选 $j$ 个， $u$ 行选了 $k$ 个的方案数，有转移：$$ f[i,j,k]\\gets f[i-1,j,k]+f[i,j,k-1]·a[i,u]+\\sum\\limits_{v\\neq u} f[i,j-1,k]·a[i,v] $$ 预处理前缀和即可 $O(1)$ 转移，复杂度 $O(mn^3)$，能拿到 84pts。 代码： 123456789101112131415161718for(int i = 1; i &lt;= n; i++) ans = 1ll * ans * (a[i][0] + 1) % P; ans = (ans + P - 1) % P;for(int u = 1; u &lt;= m; u++){ memset(f, 0, sizeof(f)), f[0][0][0] = 1; for(int i = 1; i &lt;= n; i++){ for(int j = 0; j &lt;= n; j++){ for(int k = 0; k &lt;= n; k++){ f[i][j][k] = f[i - 1][j][k]; if(k) f[i][j][k] = (1ll * f[i - 1][j][k - 1] * a[i][u] % P + f[i][j][k]) % P; if(j) f[i][j][k] = (1ll * f[i - 1][j - 1][k] * (a[i][0] - a[i][u] + P) % P + f[i][j][k]) % P; } } } for(int j = 0; j &lt;= n; j++) for(int k = 0; k &lt;= n; k++){ int s = (j + k) &gt;&gt; 1; if(k &lt;= s) continue; ans = (ans - f[n][j][k] + P) % P; }} $n\\le 100, m \\le 2000$ 考虑削状态，设 $f[i,l]$ 表示考虑前 $i$ 行，$n+k-j=l$ 时的方案数，有转移：$$ f[i,l]\\gets f[i-1,l]+f[i-1,l+1]·a[i,u]+\\sum\\limits_{u\\neq v}f[i-1,l-1]·a[i,v] $$ 预处理前缀和即可 $O(1)$ 转移，复杂度 $O(mn^2)$。 代码： 1234567891011for(int i = 1; i &lt;= n; i++) ans = 1ll * ans * (a[i][0] + 1) % P; ans = (ans + P - 1) % P;for(int u = 1; u &lt;= m; u++){ memset(f, 0, sizeof(f)), f[0][n] = 1; for(int i = 1; i &lt;= n; i++) for(int l = 0; l &lt;= (n &lt;&lt; 1); l++){ f[i][l] = f[i - 1][l]; f[i][l] = (1ll * f[i - 1][l + 1] * a[i][u] + f[i][l]) % P; if(l) f[i][l] = (1ll * f[i - 1][l - 1] * (a[i][0] - a[i][u] + P) % P + f[i][l]) % P; } for(int l = 0; l &lt; n; l++) ans = (ans - f[n][l] + P) % P;}","link":"/2020/08/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DEmiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/"},{"title":"「题解」Grass Planting","text":"树链剖分对于树边权维护问题的解决…… 一 题目 Source DescriptionsFarmer John has N barren pastures (2 &lt;= N &lt;= 100,000) connected by N-1 bidirectional roads, such that there is exactly one path between any two pastures. Bessie, a cow who loves her grazing time, often complains about how there is no grass on the roads between pastures. Farmer John loves Bessie very much, and today he is finally going to plant grass on the roads. He will do so using a procedure consisting of M steps (1 &lt;= M &lt;= 100,000). At each step one of two things will happen: FJ will choose two pastures, and plant a patch of grass along each road in between the two pastures, or,Bessie will ask about how many patches of grass on a particular road, and Farmer John must answer her question. Farmer John is a very poor counter – help him answer Bessie’s questions! Input Line 1: Two space-separated integers N and M Lines 2..N: Two space-separated integers describing the endpoints of a road. Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either P or Q, which describes whether or not FJ is planting grass or simply querying. This is followed by two space-separated integers A_i and B_i (1 &lt;= A_i, B_i &lt;= N) which describe FJ’s action or query. Output Lines 1..???: Each line has the answer to a query, appearing in the same order as the queries appear in the input. 二 题解题目大意：给出一棵n个节点的树，有m个操作，操作为将一条路径上的边权加一或询问某条边的权值。 首先想到树链剖分。但是树链剖分只是解决树上的点权维护问题，而这题让我们维护边权。其实边权是可以转化为点权的，因为对于树上任意一个非根节点，这个节点到它的父节点的路径总是唯一的。也就是说，我们可以把一个节点连向它的父节点的边的权值，看作这个点的点权。 但是还是会出细节问题。若查找$x\\to y$路径上的所有边，则$x,y$的LCA对应的那条边实际上并不是我们查找的内容。但是如果不进行处理的话，我们并不会忽略这个LCA。也就是说，当$x,y$已经跳到了同一条重链上时，我们需要把深度浅的那个（也就是$x,y$的LCA）向它的重儿子移动一个单位，以避免处理到这个LCA。最后再特判一下此时$[x,y]$是不是一个合理的区间（即$x\\leqslant y$），若是进行修改即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 2e5+5;int read(){ int s=0,ne=1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c == '-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int to,nxt,va; void init(int t,int n,int vv){ to = t; nxt = n; va = vv; }}E[CN&lt;&lt;1];int hd[CN],ecnt = 0;void add(int x,int y,int z){ E[++ecnt].init(y,hd[x],z); hd[x] = ecnt;}//v defineint n,m;int c[CN];//SGT class SGT{ public: int d[CN&lt;&lt;2],tag[CN&lt;&lt;2]; void build(int l,int r,int k){ if(l == r) return (void)(d[k] = c[l]); int m = (l+r)&gt;&gt;1; build(l,m,k&lt;&lt;1); build(m+1,r,k&lt;&lt;1|1); d[k] = d[k&lt;&lt;1]+d[k&lt;&lt;1|1]; } void PushDown(int l,int r,int k,int m){ d[k&lt;&lt;1] += tag[k]*(m-l+1); tag[k&lt;&lt;1] += tag[k]; d[k&lt;&lt;1|1] += tag[k]*(r-m); tag[k&lt;&lt;1|1] += tag[k]; tag[k] = 0; } void modify(int l,int r,int k,int s,int t,int x){ if(s&lt;=l &amp;&amp; r&lt;=t){ tag[k] += x; d[k] += x*(r-l+1); return; } int m = (l+r)&gt;&gt;1; if(tag[k]) PushDown(l,r,k,m); if(s &lt;= m) modify(l,m,k&lt;&lt;1,s,t,x); if(m &lt; t) modify(m+1,r,k&lt;&lt;1|1,s,t,x); d[k] = d[k&lt;&lt;1]+d[k&lt;&lt;1|1]; } int query(int l,int r,int k,int s,int t){ if(s&lt;=l &amp;&amp; r&lt;=t) return d[k]; int m = (l+r)&gt;&gt;1,rec = 0; if(tag[k]) PushDown(l,r,k,m); if(s &lt;= m) rec += query(l,m,k&lt;&lt;1,s,t); if(m &lt; t) rec += query(m+1,r,k&lt;&lt;1|1,s,t); return rec; }}sgt;int tid[CN],pos[CN],dep[CN],imp[CN],top[CN],prv[CN],sz[CN];void init1(int u){ dep[u] = dep[prv[u]]+1; sz[u] = 1; int mx = 0; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(!dep[v]){ prv[v] = u; c[v] = E[k].va; //记录点权 init1(v); sz[u] += sz[v]; if(sz[v] &gt; mx) mx = sz[imp[u] = v]; } }}int idx = 0;void init2(int u,int t){ tid[++idx] = u; pos[u] = idx; top[u] = t; if(!imp[u]) return; init2(imp[u],t); for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v!=imp[u] &amp;&amp; v!=prv[u]) init2(v,v); }}void PathModify(int x,int y,int k){ while(top[x] != top[y]){ if(dep[top[x]] &gt; dep[top[y]]) swap(x,y); sgt.modify(1,n,1,pos[top[y]],pos[y],k); y = prv[top[y]]; } if(dep[x] &gt; dep[y]) swap(x,y); //让x为lca x = imp[x]; //下移一次 if(pos[x] &gt; pos[y]) return; //判断区间是否合理 sgt.modify(1,n,1,pos[x],pos[y],k); }int PathQuery(int x,int y){ int rec = 0; while(top[x] != top[y]){ if(dep[top[x]] &gt; dep[top[y]]) swap(x,y); rec += sgt.query(1,n,1,pos[top[y]],pos[y]); y = prv[top[y]]; } if(dep[x] &gt; dep[y]) swap(x,y); //同理 x = imp[x]; if(pos[x] &gt; pos[y]) return rec; return rec + sgt.query(1,n,1,pos[x],pos[y]);}int main(){ n = read(); m = read(); for(int i=1;i&lt;n;i++){ int x = read(),y = read(); add(x,y,0); add(y,x,0); } init1(1); init2(1,1); sgt.build(1,n,1); while(m--){ char c; int x,y; cin&gt;&gt;c; x = read(); y = read(); if(c == 'P') PathModify(x,y,1); if(c == 'Q') printf(\"%d\\n\",PathQuery(x,y)); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/20/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DGrass%20Planting/"},{"title":"「题解」Fancy Fence","text":"打了一场 CEOI2020 Day1 的线上镜像，发现这个 A 题好像有点水啊，于是切掉，来水个题解…… 原题链接 容易发现，一个长为 $N$ 宽为 $M$ 的矩形的合法子矩形的数量可以 $O(1)$ 算。具体来讲，设：$$A=\\dbinom{NM}{2}, B = M·\\dbinom{N}{2},C=N·\\dbinom{M}{2}$$ 有该矩形的子矩形数量为：$$(A-B-C)/2+B+C$$ 之所以要算的这么麻烦是为了去重…这个重复的问题考场上卡了我半小时/kk… 那么考虑对于每个 $h_i$ 拆开来算贡献。对于当前的高度 $h_i$ ，我们确定两个端点 $l_i$ 和 $r_i$，使得 $[l_i,r_i]$ 是极长的一段区间满足 $\\min\\limits_{l_i\\le k\\le r_i} h_k=h_i$，于是我们可以找到一个极大的矩形，然后就可以在这个矩形里面算答案了。 剩下的问题是考虑重复，即这个矩形下方存在一个 $h$ 更小的矩形（它应该是矮矮长长的这个样子），而它的贡献我们已经在前面算过了。我们强制令矩形的一个端点在这个矩形上方就好了。 于是就只剩下单调栈的复杂度了，总复杂度 $O(n)$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;#define int long long // 惨痛经历const int P = 1e9 + 7;const int CN = 2e5 + 5;const int i2 = 500000004;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int n, h[CN], w[CN], sum[CN], pr[CN], nt[CN], stk[CN], top = 0, ans = 0; map&lt;int, bool&gt; cal[CN];int C(int x) {return (1ll * x * (x - 1) / 2ll) % P;}int calc(int l, int a, int b){ int ab = ((a - b) % P + P) % P; int rec = C(1ll * l * ab % P), t1 = C(ab), t2 = C(l); t1 = 1ll * t1 * l % P, t2 = 1ll * t2 * ab % P; rec = ((rec - t1 - t2) % P + P) % P, rec = 1ll * rec * i2 % P; rec = (rec + t1 + t2) % P; int t = C(l + 1); t = 1ll * t * b % P, t = 1ll * t * ab % P, t = (t + P) % P; return (rec + t) % P;}signed main(){ freopen(\"_in.in\", \"r\", stdin); n = read(); for(int i = 1; i &lt;= n; i++) h[i] = read(); for(int i = 1; i &lt;= n; i++) w[i] = read(), sum[i] = (sum[i - 1] + w[i]) % P, ans = (1ll * w[i] * h[i] % P + ans) % P; stk[++top] = 1, pr[1] = 0; for(int i = 2; i &lt;= n; i++){ while(h[ stk[top] ] &gt;= h[i]) top--; pr[i] = stk[top], stk[++top] = i; } stk[top = 1] = n + 1; for(int i = n; i; i--){ while(h[ stk[top] ] &gt;= h[i]) top--; nt[i] = stk[top], stk[++top] = i; } for(int i = 1; i &lt;= n; i++){ if(cal[ pr[i] ][ h[i] ]) continue; cal[ pr[i] ][ h[i] ] = true; int l = (sum[ nt[i] - 1 ] - sum[ pr[i] ] + P) % P, a = h[i], b = max(h[ pr[i] ], h[ nt[i] ]); ans = (ans + calc(l, a, b)) % P; } printf(\"%lld\", ans);}","link":"/2020/08/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DFancy%20Fence/"},{"title":"「题解」Good Numbers","text":"可爱的数学题++…… 一 题目 Source DescriptionsThe only difference between easy and hard versions is the maximum value of n. You are given a positive integer number n. You really love good numbers so you want to find the smallest good number greater than or equal to n. The positive integer is called good if it can be represented as a sum of distinct powers of 3 (i.e. no duplicates of powers of 3 are allowed). For example:30 is a good number: 30=33+31,1 is a good number: 1=30,12 is a good number: 12=32+31,but 2 is not a good number: you can’t represent it as a sum of distinct powers of 3 (2=30+30),19 is not a good number: you can’t represent it as a sum of distinct powers of 3 (for example, the representations 19=32+32+30=32+31+31+31+30 are invalid),20 is also not a good number: you can’t represent it as a sum of distinct powers of 3 (for example, the representation 20=32+32+30+30 is invalid).Note, that there exist other representations of 19 and 20 as sums of powers of 3 but none of them consists of distinct powers of 3. For the given positive integer n find such smallest m (n≤m) that m is a good number. You have to answer q independent queries. InputThe first line of the input contains one integer q (1≤q≤500) — the number of queries. Then q queries follow.The only line of the query contains one integer n (1≤n≤1018). OutputFor each query, print such smallest integer m (where n≤m) that m is a good number. 二 题解考虑 n⩽10^4 的情况。我们现在要在数列 [3^0,3^1,3^2,…,3^k](3^k&gt;n) 中选出一些数，使得它们的和 ⩾n ，并使得这个和最小。考虑 k 的范围，此时 k⩽log3(10^4)≈14 ，所以只需要 2^k 枚举每个数字选不选就好了。总复杂度 O(q·2^k) ，解决了 easy version 。 考虑 n⩽10^18 的情况。实际上上述枚举过程可以通过枚举二进制状态来实现，即用一个数字二进制位上的 0/1 来表示数列某一项选不选。假设我们当前二进制枚举的状态码为 S ，那么实际上该状态码所对应的数值是单调的；换句话说，随着 S 变大，其表示的那个数字也变大。 简单的 proof ，请理性偷税。考虑把二进制数 0100 变成 0101 （前者表示 3^2 ，后者表示 3^2+3^0） ，一定变大，因为又多了新的一项。考虑把二进制数 0100 变成 1000 （前者表示 3^2 ，后者表示 3^3），也一定变大，因为次数+1。 那么也就是说现在枚举的数值具有单调性，那么为什么不二分呢？只需要二分查找出一个 ⩾n 的最小位置就好了。总复杂度 O(qk)，其中 k 为常数，它大概是 log2(2^40) = 40 ，这已经很小了，于是切掉。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longLL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne; }int q; LL n;LL Pow3(int a){ LL rec = 1,base = 3; while(a) {if(a &amp; 1) rec *= base; base *= base,a &gt;&gt;= 1;} return rec;}LL gen(LL u){ LL g = 0; for(int i=0;i&lt;40;i++) if(u &amp; (1ll &lt;&lt; i)) g += Pow3(i); return g;}int main(){ q = read(); while(q--){ n = read(); LL l = 0,r = (1ll &lt;&lt; 40); while(l &lt; r){ LL m = (l + r) &gt;&gt; 1; if(gen(m) &gt;= n) r = m; else l = m + 1; } printf(\"%lld\\n\",gen((l + r) &gt;&gt; 1)); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/10/28/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DGood%20Numbers/"},{"title":"「题解」Duck and Dove","text":"二维线段树（线段树套线段树）…… 注：此处题目应为“Luck and Love” 一 题目 原题链接 描述世界上上最远的距离不是相隔天涯海角而是我在你面前可你却不知道我爱你 ―― 张小娴 前段日子，枫冰叶子给Wiskey做了个征婚启事，聘礼达到500万哦，天哪，可是天文数字了啊，不知多少MM蜂拥而至，顿时万人空巷，连扫地的大妈都来凑热闹来了。―_―|||由于人数太多，Wiskey实在忙不过来，就把统计的事情全交给了枫冰叶子，自己跑回家休息去了。这可够枫冰叶子忙的了，他要处理的有两类事情，一是得接受MM的报名，二是要帮Wiskey查找符合要求的MM中缘分最高值。 输入本题有多个测试数据，第一个数字M，表示接下来有连续的M个操作，当M＝0时处理中止。接下来是一个操作符C。当操作符为‘I’时，表示有一个MM报名，后面接着一个整数，H表示身高，两个浮点数，A表示活泼度，L表示缘分值。 （100&lt;=H&lt;=200， 0.0&lt;=A，L&lt;=100.0）当操作符为‘Q’时，后面接着四个浮点数，H1，H2表示身高区间，A1，A2表示活泼度区间，输出符合身高和活泼度要求的MM中的缘分最高值。 （100&lt;=H1，H2&lt;=200， 0.0&lt;=A1，A2&lt;=100.0）所有输入的浮点数，均只有一位小数。 输出对于每一次询问操作，在一行里面输出缘分最高值，保留一位小数。对查找不到的询问，输出-1。 二 题解二维线段树模板。在一棵线段树的每个节点上，再维护一棵线段树。细节见代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define DB doubleconst int CN = 110;const DB EPS = 1e-7;int Q;/*h的范围是100~200，也就是说这段区间有101个整点*//*a的范围是0.0~100.0，先x10，就变成了1001个整点*/int H = 101,A = 1001; //线段树范围: [1,H] x [1,A]//(sugment tree)^2DB d[4*CN][4*CN*10]; //维护节点的值，要开四倍空间void build(){ for(int i=1;i&lt;=4*H;i++) for(int j=1;j&lt;=4*A;j++) d[i][j] = -1; //初始化}void sub_modify(int sl,int sr,int sk,int fk,int sa,DB sL){ //第二维修改 if(sl == sr) return (void)(d[fk][sk] = max(d[fk][sk], sL)); int sm = (sl+sr)&gt;&gt;1; if(sa &lt;= sm) sub_modify(sl,sm,sk&lt;&lt;1,fk,sa,sL); if(sm &lt; sa) sub_modify(sm+1,sr,sk&lt;&lt;1|1,fk,sa,sL); d[fk][sk] = max(d[fk][sk&lt;&lt;1], d[fk][sk&lt;&lt;1|1]);}void modify(int l,int r,int k,int h,int a,DB L){ //第一维修改 sub_modify(1,A,1,k,a,L); //注意走过的每个节点都要对第二维进行更新 //向下递归 if(l == r) return; int m = (l+r)&gt;&gt;1; if(h &lt;= m) modify(l,m,k&lt;&lt;1,h,a,L); if(m &lt; h) modify(m+1,r,k&lt;&lt;1|1,h,a,L);}DB sub_query(int sl,int sr,int sk,int fk,int sas,int sat){ //第二维查询 if(sas&lt;=sl &amp;&amp; sr&lt;=sat) return d[fk][sk]; int sm = (sl+sr)&gt;&gt;1; DB srec = -1; if(sas &lt;= sm) srec = max(srec, sub_query(sl,sm,sk&lt;&lt;1,fk,sas,sat)); if(sm &lt; sat) srec = max(srec, sub_query(sm+1,sr,sk&lt;&lt;1|1,fk,sas,sat)); return srec;} DB query(int l,int r,int k,int hs,int ht,int as,int at){ //第一维查询 if(hs&lt;=l &amp;&amp; r&lt;=ht) return sub_query(1,A,1,k,as,at); //确定了第一维中的区间，再去第二维查询 int m = (l+r)&gt;&gt;1; DB rec = -1; if(hs &lt;= m) rec = max(rec, query(l,m,k&lt;&lt;1,hs,ht,as,at)); if(m &lt; ht) rec = max(rec, query(m+1,r,k&lt;&lt;1|1,hs,ht,as,at)); return rec; }int main(){ scanf(\"%d\",&amp;Q); while(Q){ build(); while(Q--){ char c; cin&gt;&gt;c; if(c == 'I'){ int h; DB a,l; scanf(\"%d%lf%lf\",&amp;h,&amp;a,&amp;l); (a *= 10) += 1; h -= 99; //为了让区间端点变成整数 modify(1,H,1,h,(int)a,l); } else{ int h1,h2; DB a1,a2; scanf(\"%d%d%lf%lf\",&amp;h1,&amp;h2,&amp;a1,&amp;a2); if(h1 &gt; h2) swap(h1,h2); //坑点1 if(a1 &gt; a2) swap(a1,a2); h1 -= 99; h2 -= 99; (a1 *= 10) += 1; (a2 *= 10) += 1; DB ans = query(1,H,1,h1,h2,(int)a1,(int)a2); if(ans &lt; -EPS) printf(\"-1\\n\"); //坑点2 输出-1而不是-1.0 else printf(\"%.1lf\\n\",ans); } } scanf(\"%d\",&amp;Q); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/17/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DDuck%20and%20Dove/"},{"title":"「题解」Two Contests","text":"把一些线段分成两组，使得 每组线段的并的长度 之和最大…… 一 题目 Source Descriptions10^9 contestants, numbered 1 to 10^9, will compete in a competition. There will be two contests in this competition. The organizer prepared N problems, numbered 1 to N, to use in these contests. When Problem i is presented in a contest, it will be solved by all contestants from Contestant Li to Contestant Ri (inclusive), and will not be solved by any other contestants. The organizer will use these N problems in the two contests. Each problem must be used in exactly one of the contests, and each contest must have at least one problem. The joyfulness of each contest is the number of contestants who will solve all the problems in the contest. Find the maximum possible total joyfulness of the two contests. InputInput is given from Standard Input in the following format: 12345NL1 R1L2 R2⋮LN RN OutputPrint the maximum possible total joyfulness of the two contests. 二 题解首先肯定能想到对线段进行”某种排序“，然后前面分一组，后面分另一组。 然后发现并的长度受两个东西的限制： max(l[i]) 和 min(r[i]) 。我们先找出所有线段中，l[] 值最大的那一条（记为 p ）和 r[] 值最小的那一条（记为 q ），然后分类讨论。 考虑把 p,q 分到同一组线段里，那么显然，这组线段的并的长度一定是 max(0, r[q] - l[p]) 。于是想到留一条最长的线段另成第二组，然后其它的线段都分到第一组里，这样一定是坠吼的。 考虑不把 p,q 分到同一组里，那么考虑通过“某种排序”使得某一组里面的线段在数列里面连续。显然，与 p 分到同一组里面的线段的左端点受制于 p ，也就是说左端点固定，那么我们可以按照右端点进行升序排序，此时答案受制于最小的那个 r[] 值，也就是靠前面的 r[] 值；再考虑右端点相同的情况，我们可能会把前面一部分线段划给 q ，那么我们需要靠前的线段 l[] 值尽量小，于是按 l[] 升序排序，此时答案受制于最大的那个 l[] 值，也就是靠后面 l[] 值。 剩下的问题是枚举一个断点（前面化成一组，后面另一组），然后贪心就好了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e5+5;int n,l[CN],r[CN],id[CN],mnr,pr,mxl,pl;long long ans = 0;/* calc the length of a certain segment */long long d(int cl,int cr) {return 1ll * max(0, cr - cl + 1);}bool cmp(int x,int y){ return r[x] != r[y] ? r[x] &lt; r[y] : l[x] &lt; l[y];}int main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;l[i],&amp;r[i]); mnr = 0x7f7f7f7f; for(int i=1;i&lt;=n;i++) if(r[i] &lt; mnr) mnr = r[pr = i]; mxl = 0; for(int i=1;i&lt;=n;i++) if(l[i] &gt; mxl) mxl = l[pl = i]; /* in same */ for(int i=1;i&lt;=n;i++) if(i != pl &amp;&amp; i != pr) ans = max(ans, d(mxl, mnr) + d(l[i], r[i])); /* in diff */ for(int i=1;i&lt;=n;i++) id[i] = i; sort(id + 1, id + n + 1, cmp); int premxl = 0; for(int i=2;i&lt;=n;i++){ premxl = max(premxl, l[ id[i - 1] ]); ans = max(ans, d(mxl, r[ id[i] ]) + d(premxl, mnr)); } printf(\"%lld\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/11/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DTwo%20Contests/"},{"title":"「题解」MUL","text":"第一眼看暴力水题，第二眼看筛法水题，第三眼想DP，没想到正解是…最大流…… 一 题目 原题链接 描述有 N 个宝石，编号为 1, 2, .., N你可以进行任意次以下操作（可以一次也不做） 选择一个正整数 x，将所有编号为 x 的倍数的宝石打碎 最后，对于每个没有被打碎的宝石 i，你可以获得 a_i 元。要注意的是，有些 a_i 是负值，这意味着你要倒贴钱。 在最好的情况下，你能获得多少元呢？ 输入第一行一个整数 N，代表共有 N 个宝石第二行 N 个整数，分别代表 a_1, a_2, …, a_N 输出一行一个整数，表示你最多可以得到的钱 二 题解初步分析先不妨称砸掉宝石为筛去一个数值。设筛去的总权值为$v$，获得的利益为$w$，则有$w=\\sum\\limits_{i=1}^n a_i -v$。显然，$v$越小，$w$越大，得到的答案越优。 也就是说，要让删除的数之和最小。 问题的转化考虑我们删除一个数的条件。删掉第$k$个数，必须要将编号为$2\\times k,3\\times k,…,ik(ik\\leqslant n)$的数一起删掉。不妨从编号为$k$的数向编号为$k$的倍数的数$ik$连一条有向边，那么我们会得到一张图。现在再分析删除一个数的条件：即是将从该节点所能到达的所有节点删除。那么这时候就可以引入一个新的概念：闭合子图。 闭合子图：在一张图中选出一些节点，它们及从它们所能到达的所有节点组成原图的的一张闭合子图。 同时这张图上每个节点都是有权值的（即问题中宝石的价值），我们要让选出的闭合子图权值最小。那么问题转化成了在我们所建的图中，求出最小权闭合子图。 网络流模型先抛开最小权闭合子图。 我们知道最大权闭合子图的网络流模型：将图中所有正权节点与源点$s$相连，所连边的流量限制为节点权值；所有负权节点与汇点$t$相连，所连边的流量限制为节点权值的相反数（绝对值）；图上原有边的流量限制为$\\infty$。设$s\\to t$的最小割（最大流）的大小为$g$，则最大权闭合子图的权值和为$\\sum\\limits_{1\\leqslant i\\leqslant n}^{a_i&gt;0}a_i - g$。说得像人话一点，就是图上所有正权值之和减最小割。 以上结论我并不会证明，但是它是对的。好了，剩下的问题是用这个模型求出“最小权闭合子图”。 不妨将节点权值全部乘上$-1$，套用上面的模板，那么我们求出来的最大权闭合子图即是最小权闭合子图大小的相反数。设最小权闭合子图大小为$s$，则有$s = -(-\\sum\\limits_{1\\leqslant i\\leqslant n}^{a_i&lt;0}a_i - g)$，即图上所有负权值的绝对值之和减最小割。 设最优解为$f$，则有$f = \\sum\\limits_{i=1}^na_i - s = \\sum\\limits_{i=1}^na_i +(-\\sum\\limits_{1\\leqslant i\\leqslant n}^{a_i&lt;0}a_i - g)$。好了，问题解决了。 用Dinic求出这个$g$，注意，long long不要忘开，边数开多一点，然后千万别写当前弧优化！ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int CP=110;const int CE=CP*CP*20;const LL INF=0x3f3f3f3f3f3f3f3f;LL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int from,to,nxt; LL cap,flow; void init(int f,int t,int n,LL c,LL fl) {from=f;to=t;nxt=n;cap=c;flow=fl;}}E[CE];int hd[CP],ecnt=1;void add(int x,int y,LL z){ E[++ecnt].init(x,y,hd[x],z,0); hd[x] = ecnt; E[++ecnt].init(y,x,hd[y],0,0); hd[y] = ecnt;}//v defineint n;LL a[CP];void copy(int *a,int *b,int pos,int sz){ for(int i=pos;i&lt;pos+sz;i++) b[i] = a[i];}//dinicint dep[CP];bool build(int s,int t){ //构造分层图 memset(dep,0,sizeof(dep)); dep[s] = 1; queue&lt;int&gt; Q; Q.push(s); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int k=hd[u]; k; k=E[k].nxt){ int v = E[k].to; if(!dep[v] &amp;&amp; E[k].cap-E[k].flow&gt;0){ dep[v] = dep[u]+1; Q.push(v); } } } return dep[t];}LL augment(int u,int t,LL rst){ //多路增广 if(u == t) return rst; LL used = 0; for(int k=hd[u]; k; k=E[k].nxt){ fs &amp;e = E[k]; if(dep[e.to] == dep[u]+1){ LL a = augment(e.to,t, min(rst-used,e.cap-e.flow)); if(a){ used += a; E[k].flow += a; E[k^1].flow -= a; if(used == rst) return rst; } } } return used;}LL mf(int s,int t){ //最大流 LL _mf = 0; while(build(s,t)) _mf += augment(s,t,INF); return _mf;}int main(){ n = read(); for(int i=1;i&lt;=n;i++) a[i] = read(); for(int i=1;i&lt;=n;i++) for(int k=2;i*k&lt;=n;k++) add(i,i*k,INF); //原图内的边 int s = n+1,t = n+2; for(int i=1;i&lt;=n;i++) if(a[i] &gt; 0) add(i,t,a[i]); //反着连边，搞不懂自己推一推 else add(s,i,-a[i]); LL sum = 0,sigma = 0; for(int i=1;i&lt;=n;i++) //求负权的绝对值之和 if(a[i] &lt; 0) sigma -= a[i]; for(int i=1;i&lt;=n;i++) sum += a[i]; printf(\"%lld\",sum+(sigma-mf(s,t))); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/28/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DMUL/"},{"title":"「题解」Watching Fireworks is Fun","text":"单调队列优化DP转移…… 一 题目 Source DescriptionsA festival will be held in a town’s main street. There are n sections in the main street. The sections are numbered 1 through n from left to right. The distance between each adjacent sections is 1. In the festival m fireworks will be launched. The i-th (1 ≤ i ≤ m) launching is on time ti at section ai. If you are at section x (1 ≤ x ≤ n) at the time of i-th launching, you’ll gain happiness value bi - |ai - x| (note that the happiness value might be a negative value). You can move up to d length units in a unit time interval, but it’s prohibited to go out of the main street. Also you can be in an arbitrary section at initial time moment (time equals to 1), and want to maximize the sum of happiness that can be gained from watching fireworks. Find the maximum total happiness. Note that two or more fireworks can be launched at the same time. InputThe first line contains three integers n, m, d (1 ≤ n ≤ 150000; 1 ≤ m ≤ 300; 1 ≤ d ≤ n). Each of the next m lines contains integers ai, bi, ti (1 ≤ ai ≤ n; 1 ≤ bi ≤ 109; 1 ≤ ti ≤ 109). The i-th line contains description of the i-th launching. It is guaranteed that the condition ti ≤ ti + 1 (1 ≤ i &lt; m) will be satisfied. OutputPrint a single integer — the maximum sum of happiness that you can gain from watching all the fireworks. Please, do not write the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier. 二 题解单调队列优化DP。从O(n^2m)变成O(nm)。 因为转移方程里面有个固定长度区间的$\\max$或$\\min$，这个是可以滑动窗口的。emm细节懒得讲了。 贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 2e5+5;const int CM = 310;const LL INF = 1e18;LL read(){ LL s=0,ne=1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n,m,d;int a[CM],t[CM]; LL b[CM];LL f[2][CN]; int p = 0;LL abs(LL x){return x&gt;0 ? x:-x;} int main(){ //memset(f,-0x7f,sizeof(f)); n = read(); m = read(); d = read(); for(int i=1;i&lt;=m;i++) a[i] = read(),b[i] = read(),t[i] = read(); for(int i=1;i&lt;=n;i++) f[p][i] = b[1]-abs(a[1]-i); //初始化 for(int i=2;i&lt;=m;i++){ //枚举烟花 p ^= 1; LL MMD = (LL)(t[i]-t[i-1])*d; //MaxMoveDist //单调队列 int l = 1,r = 0,Q[CN]; for(int j=1;j&lt;=n;j++){ //正着扫一遍 j-k&lt;=MMD while(l&lt;=r &amp;&amp; j-Q[l]&gt;MMD) l++; //过时的出队 while(l&lt;=r &amp;&amp; f[p^1][j]&gt;f[p^1][Q[r]]) r--; //保持单减 Q[++r] = j; //入队 f[p][j] = f[p^1][Q[l]]+b[i]-abs(a[i]-j); //第一遍要强制更新状态 } l = 1; r = 0; for(int j=n;j;j--){ //倒着扫一遍 k-j&lt;=MMD while(l&lt;=r &amp;&amp; Q[l]-j&gt;MMD) l++; while(l&lt;=r &amp;&amp; f[p^1][j]&gt;f[p^1][Q[r]]) r--; Q[++r] = j; f[p][j] = max(f[p][j], f[p^1][Q[l]]+b[i]-abs(a[i]-j)); } } LL ans = -INF; for(int i=1;i&lt;=n;i++){ ans = max(ans, f[p][i]); //if(ans == 1) cout&lt;&lt;i&lt;&lt;endl; } printf(\"%lld\",ans); return 0;} 另一个例子LG-P2627 可以结合着一下理解MQ优化DP到底应该怎么写。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 1e5+5;int n,k;LL e,f[CN],sum[CN];int Q[CN],l = 0,r = 0; //存下标/*r = l = 0的原因是默认队列里面有一个初始元素 0 */LL d[CN]; //存值/*d[i] = f[i-1]-sum[i]源于方程 f[i] = max(f[j-1]+sum[i]-sum[j]) ,位置 j 不选变形 f[i] = max(f[j-1]-sum[j]) + sum[i] ,位置 j 不选max()里面的用MQ维护 当扫描到 i 时,在队列中添加 d[i] = f[i-1]-sum[i] ,位置 i 不选在队列中查询出位置 j 转移时,位置 j 不选*/void PushBack(int i){ d[i] = f[i-1]-sum[i]; while(l&lt;=r &amp;&amp; d[Q[r]]&lt;d[i]) r--; Q[++r] = i;}LL QueryMax(int i){ while(l&lt;r &amp;&amp; Q[l]&lt;i-k) l++; return d[Q[l]];}int main(){ scanf(\"%d%d\",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;e),sum[i] = sum[i-1]+e; for(int i=1;i&lt;=n;i++){ PushBack(i); f[i] = QueryMax(i)+sum[i]; } printf(\"%lld\",f[n]); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/08/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DWatching%20Fireworks%20is%20Fun/"},{"title":"「题解」Unusual Sequences","text":"题意：输入 $x,y$，求有多少个数列满足其gcd为 $x$，和为 $y$。这里提供一个不使用反演的清奇思路…… 设 $f(s,g)$ 表示和为 $s$ ,gcd为 $g$ 的数列的数量，容易发现以下性质： $$\\begin{aligned} f(s,g)&amp;=0, \\text{ }g\\nmid s \\newline f(s,g)&amp;=f(s/g,1), \\text{ } g|s \\end{aligned}$$ 我们知道和为 $s$ 的数列应当有 $2^{s - 1}$ 个，即把 $s$ 看成 $s$ 个1，然后插上 $s - 1$ 个隔板。那么有： $$\\begin{aligned} 2^{s - 1} &amp;= \\sum\\limits_{g=1}^s f(s,g)\\newline &amp;=\\sum\\limits_{g | s}f(s,g)\\newline &amp;=\\sum\\limits_{g | s}f(s/g,1)\\end{aligned}$$ 移一下项，得到：$$ f(s,1)=2^{s - 1}-\\sum\\limits_{g|s,g&gt;1}f(s / g,1) $$ 设 $f[s]$ 表示 $f(s, 1)$ ，得到递推方程：$$ f[s] = 2^{s - 1}-\\sum\\limits_{g|s,g&gt;1}f[s/g]$$ 直接做是 $O(n)$ 的，但是容易知道有些位置的值是用不到的。开一个 map 储存 $f[]$ 数组，大力递推计算，参考杜教筛的复杂度，大约是 $O(n^{\\frac{3}{4}})$，但是实际上跑得出奇的快。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;#define LL long longconst int P = 1e9+7;int x,y;int qp(int a,int b){ int r = 1; while(b){ if(b &amp; 1) r = (1ll * a * r) % P; a = (1ll * a * a) % P; b &gt;&gt;= 1; } return r;}map&lt;int, int&gt; f;int dfs(int s){ if(s == 1) return 1; if(f.count(s)) return f[s]; int r = qp(2, s - 1); for(int g = 2;g * g &lt;= s;g++){ if(s % g) continue; if(g * g == s) r = (r - dfs(g) + P) % P; else r = ((r - dfs(s / g) - dfs(g)) % P + P) % P; } return f[s] = (r - 1 + P) % P;}int main(){ // freopen(\"_in.in\", \"r\", stdin); scanf(\"%d%d\", &amp;x, &amp;y); if(y % x) puts(\"0\"); else printf(\"%d\", dfs(y / x));}","link":"/2020/07/08/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DUnusual%20Sequences/"},{"title":"「题解」Optimal Currency Exchange","text":"一道很有意思的数学题，第一眼没觉得有多难，结果瞎搞了一个多小时才AC，真是有趣…… 一 题目 Source DescriptionsAndrew was very excited to participate in Olympiad of Metropolises. Days flew by quickly, and Andrew is already at the airport, ready to go home. He has n rubles left, and would like to exchange them to euro and dollar bills. Andrew can mix dollar bills and euro bills in whatever way he wants. The price of one dollar is d rubles, and one euro costs e rubles. Recall that there exist the following dollar bills: 1, 2, 5, 10, 20, 50, 100, and the following euro bills — 5, 10, 20, 50, 100, 200 (note that, in this problem we do not consider the 500 euro bill, it is hard to find such bills in the currency exchange points). Andrew can buy any combination of bills, and his goal is to minimize the total number of rubles he will have after the exchange. Help him — write a program that given integers n, e and d, finds the minimum number of rubles Andrew can get after buying dollar and euro bills. InputThe first line of the input contains one integer n (1≤n≤108) — the initial sum in rubles Andrew has.The second line of the input contains one integer d (30≤d≤100) — the price of one dollar in rubles.The third line of the input contains integer e (30≤e≤100) — the price of one euro in rubles. OutputOutput one integer — the minimum number of rubles Andrew can have after buying dollar and euro bills optimally. 二 题解题目大意：你有一堆卢布，去换两种钱（美元和欧元），汇率分别是d对1和e对1。美元有1, 2, 5, 10, 20, 50, 100的面值，欧元有5, 10, 20, 50, 100, 200的面值，现在要求求出你能剩下的钱数的最小值。 首先想到的是背包，这个大概都能想出来就不多讲，写起来长这样： 123456for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=7;j++) if(i-D[j] &gt;= 0) f[i] = max(f[i], f[i-D[j]]+D[j]); for(int j=1;j&lt;=5;j++) if(i-E[j] &gt;= 0) f[i] = max(f[i], f[i-E[j]]+E[j]);} 然后1e8的数据范围妥妥的RE了。 然后回到题目。首先观察到一个结论：对于美元来讲，所有的面值都是一美元面值的倍数啊…也就是说换美元的话，不管你换到多少张不同面值的钞票，实际上都可以看成换了一堆面值为一美元的钞票。对于欧元也同理。那么也就是说，我们只需要考虑换成一美元和五欧元两种面值就好了。 于是把这两种钞票分别所需要的卢布的数量表示出来，不妨设x=d,y=5e。设美元换了a张，欧元换了b张，那么剩下的钱数就是n-(ax+by)。设c=n-(ax+by)，实际上就是要最小化c。 然后c=n-(ax+by)不觉得很眼熟么…移项后就是ax+by=n-c，其中x,y,n已知，可以看作关于a,b的不定方程。但是c呢？c可能有很多取值，但是不难发现，某一c值可行的条件是ax+by=n-c这个关于a,b的不定方程有a,b同为非负整数的解。 怎么判定？由裴蜀定理的推广我们知道不定方程有整解的条件是(a,b)|c，但是非负这个条件怎么保证呢？不定方程的整数通解是：针对于某一特解(x0,y0)，( x0+i(b/(a,b)), y0-i(a/(a,b)) )是方程的通解（注意：其中i∈Z，除号后面的(a,b)实际表示gcd(a,b)）。那么显然，若x0,y0同时⩾0，则一定有非负整数解；若x0,y0同时&lt;0，则一定没有非负整数解，因为即使让x0,y0中的一者变得⩾0，另一者也只会越来越小。那么对于x0,y0中有一者&lt;0，另一者⩾0的情况呢？不妨假定x0⩾0而y0&lt;0。我们希望让y0⩾0，于是不妨设y0+i(a/(a,b))⩾0。那么对于整数i，如果i最小时，也有x0-i(b/(a,b))&lt;0的话，那么我们就肯定不能通过调整特解来使得解均为非负数，反之则一定可以。x0&lt;0而y0⩾0的情况也同理。那么实际上就是几个判断的事： 12345678910111213141516bool check(){ ... int k = c/g,kx = b/g,ky = a/g; x = x0*k,y = y0*k; if(x&gt;=0 &amp;&amp; y&gt;=0) return true; if(x&lt;0 &amp;&amp; y&lt;0) return false; int i = 0; if(x &lt; 0){ while(x &lt; 0) x += kx,i++; //调整特解使得x非负 if(y-i*ky &lt; 0) return false; //此时另一解为负，则一定无非负整数解 return true; } while(y &lt; 0) y += ky,i++; //反之同理 if(x-i*kx &lt; 0) return false; return true;} 然后就好了，我们知道了如何判断一个c可行与否。不难发现有c⩽min(n mod a, n mod b)，后面那个东西不会大于100，于是枚举c就好了啊。 上面的内容用到了一点解不定方程的知识，顺手推推博：1,2。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; int n,a,b,r = 0;int gcd(int a,int b) {return b?gcd(b,a%b):a;}void exgcd(int a,int &amp;x,int b,int &amp;y){ //exgcd递归 if(!b){x = 1; y = 0; return;} exgcd(b,x,a%b,y); int t = x; x = y; y = t-(a/b)*y;}bool ExGcd(int a,int &amp;x,int b,int &amp;y, int c){ //解不定方程并判断有无非负整数解 int g = gcd(a,b); if(c % g) return false; //无整数解 int x0,y0; exgcd(a,x0,b,y0); //转化为求解ax+by=gcd(a,b) int k = c/g,kx = b/g,ky = a/g; x = x0*k,y = y0*k; //得到ax+by=c的特解(x,y) //判定部分 if(x&gt;=0 &amp;&amp; y&gt;=0) return true; if(x&lt;0 &amp;&amp; y&lt;0) return false; int i = 0; if(x &lt; 0){ while(x &lt; 0) x += kx,i++; //调整特解使得x非负 if(y-i*ky &lt; 0) return false; //此时另一解为负，则一定无非负整数解 return true; } while(y &lt; 0) y += ky,i++; //同理 if(x-i*kx &lt; 0) return false; return true;} int main(){ scanf(\"%d%d%d\",&amp;n,&amp;a,&amp;b); b *= 5; //乘上面值 int x,y; while(!ExGcd(a,x,b,y,n-r)) r++; //找到最小的r printf(\"%d\",r); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/09/14/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DOptimal%20Currency%20Exchange/"},{"title":"「题解」Typewriter","text":"一道很好的SAM+DP综合题，虽然说坑点也很多…… 原题链接 考虑DP。设 $f[i]$ 为考虑前 $i$ 个位置的答案，应当有转移 $f[i] = \\min f[i - 1] + p, f[l]+q$ ，其中 $l$ 满足 $s[l+1:r]\\subseteq s[1:l]$ 。$f[]$ 显然是不降的，那么我们应取最小的 $l$ 。 考虑 $r\\to r + 1$ ，容易发现 $l$ 是不降的；那么对 $s[1:l]$ 建立SAM，每次尝试扩展 $s[r+1]$，如果不行则令 $l\\to l + 1$，即可找到最小的 $l$。维护当前的 $s[l+1:r]$ 对应在SAM上的路径，则可 O(1) 做到删除该路径上的第一个字符 $s[l+1]$ ，然后再扩展出$s[r+1]$即可。 小细节：当SAM在extend()的时候，若该路径的终点 $d$ 被拆成了 $v,d’$ 两个节点，且$\\text{nxt}[d’]=v$，则应当将路径的终点变换为 $v$，否则维护的路径就被破坏了。HDU不给数据，然后上面那个坑点卡了我一晚上… 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e5 + 5;int n, prv[CN]; long long p, q, f[CN]; char s[CN];class SAM{ public: int nxt[CN &lt;&lt; 1], son[CN &lt;&lt; 1][26], len[CN &lt;&lt; 1], sz, lst, cur, l; void init(int n){ for(int i = 0;i &lt; (n &lt;&lt; 1);i++) for(int j = 0;j &lt; 26;j++) son[i][j] = 0; // 题目卡memset() sz = 1, lst = cur = l = len[0] = 0, nxt[0] = -1; } void et(int c){ int u = sz++, p = lst; lst = u, len[u] = len[p] + 1; while(p != -1 &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p]; if(p == -1) return (void)(nxt[u] = 0); int d = son[p][c]; if(len[d] == len[p] + 1) return (void)(nxt[u] = d); int v = sz++; if(d == cur) cur = v; // 坑点 len[v] = len[p] + 1, nxt[v] = nxt[d], nxt[d] = nxt[u] = v; for(int i = 0; i &lt; 26; i++) son[v][i] = son[d][i]; while(p != -1 &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p]; } void del() {if(nxt[cur] != -1 &amp;&amp; --l == len[ nxt[cur] ]) cur = nxt[cur];} // delete bool rd(int c) {return son[cur][c] ? cur = son[cur][c], l++, true : false;} // read}D;int main(){ freopen(\"_in.in\", \"r\", stdin); // freopen(\"wa.out\", \"w\", stdout); while(cin &gt;&gt; (s + 1)){ n = strlen(s + 1), scanf(\"%lld%lld\", &amp;p, &amp;q), D.init(n); int l = 1; D.et(s[1] - 'a'), prv[1] = 0; for(int i = 2; i &lt;= n; i++){ bool flag = true; while(!D.rd(s[i] - 'a')){ if(l + 1 == i) {flag = false; break;} D.del(), D.et(s[++l] - 'a'); } prv[i] = flag ? l : 0; if(!flag) D.et(s[++l] - 'a'); } f[1] = p; for(int i = 2;i &lt;= n;i++) if(prv[i]) f[i] = min(f[i - 1] + p, f[ prv[i] ] + q); else f[i] = f[i - 1] + p; printf(\"%lld\", f[n]), puts(\"\"); }}","link":"/2020/08/06/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DTypewriter/"},{"title":"【题解】“访问”美术馆","text":"经过数月的精心准备，Peer Brelstet，一个出了名的盗画者，准备开始他的下一个行动…… 一 题目 原题链接 描述经过数月的精心准备，Peer Brelstet，一个出了名的盗画者，准备开始他的下一个行动。艺术馆的结构，每条走廊要么分叉为两条走廊，要么通向一个展览室。Peer知道每个展室里藏画的数量，并且他精确测量了通过每条走廊的时间。由于经验老到，他拿下一幅画需要5秒的时间。你的任务是编一个程序，计算在警察赶来之前，他最多能偷到多少幅画。 输入第1行是警察赶到的时间，以s为单位。第2行描述了艺术馆的结构，是一串非负整数，成对地出现：每一对的第一个数是走过一条走廊的时间，第2个数是它末端的藏画数量；如果第2个数是0，那么说明这条走廊分叉为两条另外的走廊。数据按照深度优先的次序给出，请看样例。 一个展室最多有20幅画。通过每个走廊的时间不超过20s。艺术馆最多有100个展室。警察赶到的时间在10min以内。 输出输出偷到的画的数量。 二 题解题不难，但是坑不少。 设$f_{i,j}$为在节点$i$，花$j$的时间能偷到的画的数量，设$p_i$为$i$节点的藏画数量。对于叶节点，显然有$f_{i,j} =\\min j/5,p_i$。对于非叶节点，设$lt$为分配给该节点左儿子的时间，设左儿子为$l$，右儿子为$r$，设$d_{u,v}$为$u\\to v$的通行时间，则有$f_{i,j} = \\max f_{i,j}, f_{l,lt-d_{i,l}}+f_{r,j-lt-d_{i,r}}$。这个方程只需枚举$lt$即可，对于子节点不能到达的情况（通行时间不足）还需再特判。 接下来是坑点：通行时间要乘以二，因为要走来回。总时间要减一，因为警察来了就跑不掉了。要写记忆化。读入要写个深搜。然后就AC了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 606;const int INF = 0x3f3f3f3f;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int tot_time,paints[CN],pass_time[CN][CN];void scan_data(int u,int prv){ pass_time[prv][u] = read(); pass_time[prv][u] &lt;&lt;= 1; //*2 paints[u] = read(); if(!paints[u]){ scan_data(u&lt;&lt;1,u); scan_data(u&lt;&lt;1|1,u); }}//dpint f[CN][CN];int dp(int u,int prv,int rst_time){ if(paints[u]) //叶节点 return f[u][rst_time] = min(paints[u],rst_time/5); if(f[u][rst_time]) return f[u][rst_time]; int mx = -INF; for(int ls=0;ls&lt;=rst_time;ls++){ if(rst_time-ls &gt;= pass_time[u][u&lt;&lt;1|1]){ //右 f[u&lt;&lt;1|1][rst_time-ls-pass_time[u][u&lt;&lt;1|1]] = dp(u&lt;&lt;1|1,u,rst_time-ls-pass_time[u][u&lt;&lt;1|1]); mx = max(mx, f[u&lt;&lt;1|1][rst_time-ls-pass_time[u][u&lt;&lt;1|1]]); } if(ls &gt;= pass_time[u][u&lt;&lt;1]){ //左 f[u&lt;&lt;1][ls-pass_time[u][u&lt;&lt;1]] = dp(u&lt;&lt;1,u,ls-pass_time[u][u&lt;&lt;1]); mx = max(mx, f[u&lt;&lt;1][ls-pass_time[u][u&lt;&lt;1]]); } if(rst_time-ls&gt;=pass_time[u][u&lt;&lt;1|1] &amp;&amp; ls&gt;=pass_time[u][u&lt;&lt;1]) mx = max(mx, f[u&lt;&lt;1][ls-pass_time[u][u&lt;&lt;1]] + f[u&lt;&lt;1|1][rst_time-ls-pass_time[u][u&lt;&lt;1|1]]); } return f[u][rst_time] = mx;}int main(){ tot_time = read()-1; scan_data(1,0); printf(\"%d\",dp(1,0,tot_time-pass_time[0][1])); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/01/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E2%80%9C%E8%AE%BF%E9%97%AE%E2%80%9D%E7%BE%8E%E6%9C%AF%E9%A6%86/"},{"title":"「题解」井下矿工","text":"煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处…… 一 题目 原题链接 描述煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。 请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。 输入输入文件有若干组数据，每组数据的第一行是一个正整数 N（N&lt;=500），表示工地的隧道数，接下来的 N 行每行是用空格隔开的两个整数 S 和 T，表示挖 S 与挖煤点 T 由隧道直接连接。输入数据以 0 结尾。 输出输入文件中有多少组数据，输出文件 output.txt 中就有多少行。每行对应一组输入数据的 结果。其中第 i 行以 Case i: 开始（注意大小写，Case 与 i 之间有空格，i 与:之间无空格，: 之后有空格），其后是用空格隔开的两个正整数，第一个正整数表示对于第 i 组输入数据至少需 要设置几个救援出口，第二个正整数表示对于第 i 组输入数据不同最少救援出口的设置方案总 数。输入数据保证答案小于 2^64。输出格式参照以下输入输出样例。 二 题解简化题意：在一个无向图上选择尽量少的点涂黑，使得删除任意一个点后，每个连通分量里都至少有一个黑点。 分析一下就可以知道：当一个BCC（点双连通分量）只存在一个割顶时，才需要选择一个非割顶的点涂黑。因为若这个割顶被破坏，那么这个BCC就成了一个独立的联通块。若存在两个及以上的割顶，即使破坏了一个割顶，这个BCC里面的点也都通过其他的割顶与其他BCC连接，而这之中必定存在有一个割顶的BCC，所以有两个及以上割顶的BCC并不需要涂黑点。特殊情况：当一个BCC没有割顶时，需要任选两个点涂黑。 方案数对于只有一个割顶的BCC，设它的大小为$s$，则共有$s-1$种不同的涂黑方案，根据乘法原理将这些$s-1$相乘即可。对于没有割顶的BCC，方案数为$s*(s-1)/2$，与前面的相乘即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;#define LL long long LL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=((s&lt;&lt;1)+(s&lt;&lt;3))+c-'0'; return s*ne;}const int CP=1e5+123;const int CE=1e5+123;class fs{ public: int fr,to,nxt; void init(int f,int t,int n) {fr=f; to=t; nxt=n;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].init(x,y,hd[x]); hd[x] = ecnt;}void init(){ memset(hd,0,sizeof(hd)); ecnt = 0;}//v defineint n,m;//bccint idx=0,dfn[CP],low[CP];bool iscut[CP],ins[CP];int bcnt=0;vector&lt;int&gt; bcc[CP];int stk[CE],top=0;void tarjan(int u,int prv){ dfn[u] = low[u] = ++idx; int child = 0; for(int k=hd[u]; k; k=E[k].nxt){ int v = E[k].to; if(!dfn[v]){ child++; stk[++top] = k; tarjan(v,u); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u]){ int pos; bcnt++; bcc[bcnt].clear(); while(true){ pos = stk[top--]; if(!ins[E[pos].fr]){ ins[E[pos].fr] = true; bcc[bcnt].push_back(E[pos].fr); } if(!ins[E[pos].to]){ ins[E[pos].to] = true; bcc[bcnt].push_back(E[pos].to); } if(E[pos].fr==u &amp;&amp; E[pos].to==v) break; } iscut[u] = true; ins[u] = false; } } else if(prv != v) low[u] = min(low[u], dfn[v]); } if(!prv &amp;&amp; child==1) iscut[u] = false;}void BCC(){ memset(iscut,false,sizeof(iscut)); memset(ins,false,sizeof(ins)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); idx = top = bcnt = 0; for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i,0);}int main(){ int kase=0; m=read(); while(m){ init(); while(m--){ int x=read(),y=read(); n = max(n ,max(x,y)); add(x,y); add(y,x); } BCC(); LL ans1=0,ans2=1; for(int i=1;i&lt;=bcnt;i++){ int cut = 0; LL sz = bcc[i].size(); for(int j=0;j&lt;sz;j++) if(iscut[bcc[i][j]]) cut++; if(cut == 1){ //只有一个割顶 ans1++; ans2 *= (LL)(sz - cut); } if(cut == 0){ //没有割顶 ans1 += 2; ans2 *= (LL)(sz*(sz-1)) / 2; } } printf(\"Case %d: %lld %lld\\n\",++kase,ans1,ans2); m=read(); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/23/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E4%BA%95%E4%B8%8B%E7%9F%BF%E5%B7%A5/"},{"title":"「题解」Y型项链","text":"瞎搞AC第一题…… 一 题目 原题链接 描述欢乐岛上众多新奇的游乐项目让小可可他们玩的非常开心。现在他们正在玩比赛串项链的游戏，谁串的最快就能得到优厚的奖品。 这可不是普通的项链，而是一种Y型项链，项链的最中间有一颗大珍珠作为结合点，从大珍珠上连出来3条由各种宝石串起来的链子。 比赛的规则是这样的：每次可以从三条链子中某一条的一端取下来一个宝石，或者安上去一个宝石，称为一次操作，经过若干次操作，最终使得三条链子完全相同。想要赢得比赛，那么只能使用尽量少的操作次数。 假设每种宝石都有无数多个以供使用，且链子足够长。你能帮助小可可赢得比赛吗? 注：由于对Y型项链的宝石数没有特殊的要求，所以即使你把所有宝石都取下来，也是一个可以接受的方案(三根没有串宝石的绳子也是完全一样的)． 输入一共有3行，表示Y型项链的三条链子，每行开始有一个数字N，表示初始时这条链子上串有N个宝石(N&lt;=50)，随后是一个空格，然后是N个’A’和’Z’之间的字符，表示这个链子上的宝石，每个字母表示一种不同的宝石，这个字符串最左边的字符表示的是离大珍珠最近的那个宝石，而最右边的表示的是在链子末端的宝石。 输出只有一个整数，表示所需要的最少的操作次数． 二 题解n很小啊，瞎搞搞不就好了，不理解这题为什么在某谷是蓝题……可能是因为AHOI的缘故吧 首先有一个很zz的贪心思路就是说：如果不考虑把三串项链都摘下来，并且按照最优策略操作，那么最后得到的相同的三串项链一定是某一串项链的前缀。 然后暴力的去枚举这三串项链的所有前缀不就好了么……剩下的问题只是统计把三串项链都变成这个前缀串需要多少步，对于同一个串这个东西总是一定的啊。 最后再特判一下把三串项链都摘下来。然后就没什么了，一发交AC可还行。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 150;char s1[CN],s2[CN],s3[CN];int n,ans,l1,l2,l3;int main(){ scanf(\"%d\",&amp;l1); for(int i=1;i&lt;=l1;i++) cin&gt;&gt;s1[i]; scanf(\"%d\",&amp;l2); for(int i=1;i&lt;=l2;i++) cin&gt;&gt;s2[i]; scanf(\"%d\",&amp;l3); for(int i=1;i&lt;=l3;i++) cin&gt;&gt;s3[i]; ans = l1+l2+l3; //remove all for(int len=1;len&lt;=l1;len++){ //s1 int cost = l1-len; bool del = false; for(int j2=1;j2&lt;=min(len,l2);j2++){ if(del){ cost += 1; continue; } if(s1[j2] != s2[j2]){ cost += l2-j2+2; del = true; } } if(l2 != len){ if(l2&gt;len &amp;&amp; !del) cost += l2-len; if(len &gt; l2) cost += len-l2; } del = false; for(int j3=1;j3&lt;=min(len,l3);j3++){ if(del){ cost += 1; continue; } if(s1[j3] != s3[j3]){ cost += l3-j3+2; del = true; } } if(l3 != len){ if(l3&gt;len &amp;&amp; !del) cost += l3-len; if(len &gt; l3) cost += len-l3; } ans = min(ans, cost); } for(int len=1;len&lt;=l2;len++){ //s2 int cost = l2-len; bool del = false; for(int j1=1;j1&lt;=min(len,l1);j1++){ if(del){ cost += 1; continue; } if(s1[j1] != s2[j1]){ cost += l1-j1+2; del = true; } } if(l1 != len){ if(l1&gt;len &amp;&amp; !del) cost += l1-len; if(len &gt; l1) cost += len-l1; } del = false; for(int j3=1;j3&lt;=min(len,l3);j3++){ if(del){ cost += 1; continue; } if(s2[j3] != s3[j3]){ cost += l3-j3+2; del = true; } } if(l3 != len){ if(l3&gt;len &amp;&amp; !del) cost += l3-len; if(len &gt; l3) cost += len-l3; } ans = min(ans, cost); } for(int len=1;len&lt;=l3;len++){ //s3 int cost = l3-len; bool del = false; for(int j1=1;j1&lt;=min(len,l1);j1++){ if(del){ cost += 1; continue; } if(s1[j1] != s3[j1]){ cost += l1-j1+2; del = true; } } if(l1 != len){ if(l1&gt;len &amp;&amp; !del) cost += l1-len; if(len &gt; l1) cost += len-l1; } del = false; for(int j2=1;j2&lt;=min(len,l2);j2++){ if(del){ cost += 1; continue; } if(s2[j2] != s3[j2]){ cost += l2-j2+2; del = true; } } if(l2 != len){ if(l2&gt;len &amp;&amp; !del) cost += l2-len; if(len &gt; l2) cost += len-l2; } ans = min(ans, cost); } printf(\"%d\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/08/18/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DY%E5%9E%8B%E9%A1%B9%E9%93%BE/"},{"title":"「题解」关路灯","text":"终于把某谷的任务DP TG.lv1肝过了，只剩一道要高精的题了，实在是懒得写…… 一 题目 原题链接 描述某一村庄在一条路线上安装了n盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。 为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。 现在已知老张走的速度为1m/s，每个路灯的位置（是一个整数，即距路线起点的距离，单位：m）、功率（W），老张关灯所用的时间很短而可以忽略不计。 请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。 输入文件第一行是两个数字n(1&lt;=n&lt;=50，表示路灯的总数)和c(1&lt;＝c&lt;=n老张所处位置的路灯号)；接下来n行，每行两个数据，表示第1盏到第n盏路灯的位置和功率。数据保证路灯位置单调递增。 输出一个数据，即最少的功耗(单位：J，1J＝1W·s)。 二 题解先分析一下：若老李再路灯$s$处，要去关路灯$t$，那么一次性把$[s,t]$内所有路灯都关上肯定要更优。也就是说关闭的路灯区间一定是连续的，所以想到区间DP。 但是这题老张的位置对于状态的转移是有影响的。那么开两个数组，设$l_{i,j}$与$r_{i,j}$为关掉$[i,j]$内所有路灯，且完成后老张在路灯$i$($l_{i,j}$)或$j$($r_{i,j}$)处时，消耗的总能。 推方程。当老张在$i$处（对应状态$l_{i,j}$）时，可以由$l_{i+1,j}$或$l_{i,j-1}$或$r_{i+1,j}$或$r_{i,j-1}$四种状态转移。其中$l_{i,j-1}$和$r_{i,j-1}$肯定是不优的，因为要去关掉灯$j$在回来，走了很多重复的路。那么也就是在$l_{i+1,j}$和$r_{i+1,j}$中转移。此时未关闭的灯的总功率$P_t = \\sum\\limits_{k \\in [1,n]}P_k - \\sum\\limits_{k \\in (i,j]}P_k$，得到如下方程：$$ l_{i,j} = \\min l_{i+1,j} + P_t \\times\\text{dist}(i+1,i), r_{i+1,j} + P_t \\times\\text{dist}(j,i)$$其中$\\text{dist}$表示距离。因$W=P·t$，$t=\\dfrac{s}{v}=\\dfrac{s}{1m/s}=s$，故$W=P·s$，即$W=P·\\text{dist}$。 同理，对于$r_{i,j}$，有$P_t = \\sum\\limits_{k\\in[1,n]}P_k - \\sum\\limits_{k\\in[i,j)}P_k$，转移方程：$$ r_{i,j} = \\min l_{i,j-1}+P_t\\times \\text{dist}(j,i) , r_{i,j-1}+P_t\\times \\text{dist}(j,j-1)$$ 其中$P_t$用前缀和处理，然后按区间大小进行转移即可。注意当区间大小为$1$时，$l_{c,c}=r_{c,c}=0$，因为最初仅有老张所在的灯是被关上的，也是边界条件。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN=51;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n,s,p[CN],pos[CN];int sum[CN],l[CN][CN],r[CN][CN];int main(){ n=read(); s=read(); for(int i=1;i&lt;=n;i++) pos[i]=read(),p[i]=read(); for(int i=1;i&lt;=n;i++) //前缀和 sum[i] = sum[i-1]+p[i]; memset(l,0x3f,sizeof(l)); memset(r,0x3f,sizeof(r)); l[s][s] = r[s][s] = 0; //初始化 for(int len=2;len&lt;=n;len++) //外重循环枚举区间长度 for(int i=1;i+len-1&lt;=n;i++){ int j=i+len-1,sigma=0; sigma = sum[n]-(sum[j]-sum[i]); //总功率 l[i][j] = min(l[i+1][j]+sigma*(pos[i+1]-pos[i]), r[i+1][j]+sigma*(pos[j]-pos[i])); sigma = sum[n]-(sum[j-1]-sum[i-1]); //再求一次总功率 r[i][j] = min(l[i][j-1]+sigma*(pos[j]-pos[i]), r[i][j-1]+sigma*(pos[j]-pos[j-1])); } printf(\"%d\",min(l[1][n], r[1][n])); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/05/12/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%85%B3%E8%B7%AF%E7%81%AF/"},{"title":"「题解」农场的万圣节","text":"每年，在威斯康星州，奶牛们都会穿上衣服，收集农夫约翰在牛棚隔间中留下的糖果，以此来庆祝美国秋天的万圣节…… 一 题目 原题链接 描述每年，在威斯康星州，奶牛们都会穿上衣服，收集农夫约翰在N(1&lt;=N&lt;=100，000)个牛棚隔间中留下的糖果，以此来庆祝美国秋天的万圣节。 由于牛棚不太大，FJ通过指定奶牛必须遵循的穿越路线来确保奶牛的乐趣。为了实现这个让奶牛在牛棚里来回穿梭的方案，FJ在第i号隔间上张贴了一个“下一个隔间”Next_i(1&lt;=Next_i&lt;=N)，告诉奶牛要去的下一个隔间；这样，为了收集它们的糖果，奶牛就会在牛棚里来回穿梭了。 FJ命令奶牛i应该从i号隔间开始收集糖果。如果一只奶牛回到某一个她已经去过的隔间，她就会停止收集糖果。 在被迫停止收集糖果之前，计算一下每头奶牛要前往的隔间数（包含起点）。 输入第1行 整数n。第2行到n+1行 每行包含一个整数 next_i 。 输出n行，第i行包含一个整数，表示第i只奶牛要前往的隔间数。 二 题解简化题意：给定一张$n$点$n$边的有向有环图，不保证联通，求每个从点出发不重复经过点的最长路径。 每个点如果会重复经过其它点，那么就一定存在一条环，也就是一个SCC（强连通分量，详见）。因为每个点仅有一条出边，那么若视仅有一个点的SCC为自环SCC，则每一个非自环SCC都一定没有连向外部的边，因为要构成环就已经用去了所有的边。 也就是说每个非自环SCC必然是一条路径的终点。对于不经过非自环SCC的路径，可以证明它不存在。那么每只奶牛的旅行路线都肯定会以非自环SCC结束，因为它具备结束的条件，又不存在走出该SCC的路径。 也就是说每个奶牛必然在路径终点结束行走。 那么把每个非自环SCC视作一个点，原图就变成了多个DAG的并。每个点能最远到达的点即使该条路径的终点，递推一下就好了。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CP=1e5+5;const int CE=CP*10;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int to,nxt; void init(int t,int n) {to=t; nxt=n;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].init(y,hd[x]); hd[x]=ecnt;}void fs_init(){ ecnt=0; memset(hd,0,sizeof(hd));}//v defineint n,to[CP];//sccint dfn[CP],low[CP],idx=0;int bel[CP],sz[CP],scnt=0;int stk[CP],top=0; bool ins[CP];void tarjan(int u){ dfn[u] = low[u] = ++idx; stk[++top] = u; ins[u] = true; for(int k=hd[u]; k; k=E[k].nxt){ int v=E[k].to; if(!dfn[v]){ tarjan(v); low[u] = min(low[u], low[v]); } else if(ins[v]) low[u] = min(low[u], low[v]); } if(low[u] == dfn[u]){ int pos; scnt++; while(true){ pos = stk[top--]; ins[pos] = false; sz[scnt]++; bel[pos] = scnt; if(pos == u) break; } }}void scc(){ for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);}void rebuild(){ //缩点 fs_init(); for(int i=1;i&lt;=n;i++) if(bel[i] != bel[to[i]]) add(bel[i], bel[to[i]]);}//记忆化搜索bool calced[CP];int dp(int u){ if(calced[u]) return sz[u]; calced[u] = true; for(int k=hd[u]; k; k=E[k].nxt) sz[u] += dp(E[k].to); return sz[u];}int main(){ n=read(); for(int i=1;i&lt;=n;i++){ to[i] = read(); add(i, to[i]); } scc(); rebuild(); for(int i=1;i&lt;=scnt;i++) dp(i); for(int i=1;i&lt;=n;i++) printf(\"%d\\n\",sz[bel[i]]); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/04/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%86%9C%E5%9C%BA%E7%9A%84%E4%B8%87%E5%9C%A3%E8%8A%82/"},{"title":"「题解」加分二叉树","text":"设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di…… 一 题目 原题链接 描述设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第ii个节点的分数为di,tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数。 若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出； tree的最高加分 tree的前序遍历 输入第1行：1个整数n(n&lt;30)，为节点个数。第2行：n个用空格隔开的整数，为每个节点的分数（分数 &lt;100）。 输出第1行：1个整数，为最高加分（Ans≤4,000,000,000）。第2行：n个用空格隔开的整数，为该树的前序遍历。 二 题解二叉树的遍历方式 先序遍历（前序遍历）：先遍历根，然后递归遍历左子树，最后递归遍历右子树。即：根左右。 中序遍历：先递归遍历左子树，然后遍历根，最后递归遍历右子树。即：左根右。 后序遍历：先递归遍历左子树，然后递归遍历右子树，最后遍历根。即：左右根。 中序遍历的性质在中序遍历的数列上任取一节点$r$作为根，则$[1,r)$的所有节点总为$r$的左子树，$(r,n]$的所有节点总为$r$的右子树。 问题转化设$f_{i,j}$为$[i,j]$内的最大加分，设$c_i$为节点$i$的加分。则题意为：找一个$r$，使得$f_{i,r-1}\\times f_{r+1,j}+c_r$最大。 显然是个区间DP。在$(i,j)$内枚举断点$k$，则有$f_{i,j} = \\max f_{i,k-1}\\times f_{k+1,j}+c_k$。按照区间长度进行更新即可，然后再更新的时候维护一下选出的$k$（为了解决第二问）。 初始化：$f_{i,i}=c_i,f_{i,i+1}=c_i+c_{i+1}$。自己推一下就得出来了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 50;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n,c[CN];int f[CN][CN],rt[CN][CN];void find_path(int u,int l,int r){ if(l &gt; r) return; if(l == r) return (void)printf(\"%d \",u); printf(\"%d \",u); //输出中序遍历 find_path(rt[l][u-1],l,u-1); find_path(rt[u+1][r],u+1,r);}int main(){ n = read(); for(int i=1;i&lt;=n;i++) c[i] = read(); for(int i=1;i&lt;=n;i++) f[i][i] = c[i],rt[i][i] = i; //初始化 for(int i=1;i&lt;n;i++) f[i][i+1] = c[i]+c[i+1],rt[i][i+1] = i; //初始化 for(int l=3;l&lt;=n;l++) //枚举区间长度 for(int i=1;i+l-1&lt;=n;i++){ //确定区间 int j = i+l-1; //[i,j] for(int k=i+1;k&lt;j;k++){ //枚举断点 if(f[i][j] &lt; f[i][k-1]*f[k+1][j]+c[k]){ f[i][j] = f[i][k-1]*f[k+1][j]+c[k]; rt[i][j] = k; //维护 } } } printf(\"%d\\n\",f[1][n]); find_path(rt[1][n],1,n); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/05/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"「题解」垃圾陷阱","text":"卡门――农夫约翰极其珍视的一条Holsteins奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为D英尺…… 一 题目 原题链接 描述卡门――农夫约翰极其珍视的一条Holsteins奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为D(2≤D≤100)英尺。 卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。 假设卡门预先知道了每个垃圾扔下的时间t(0&lt;t≤1000)，以及每个垃圾堆放的高度h(1≤h≤25)和吃进该垃圾能维持生命的时间f(1≤f≤30)，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续10小时的能量，如果卡门10小时内没有进食，卡门就将饿死。 输入第一行为2个整数，D和G(1≤G≤100)，G为被投入井的垃圾的数量。第二到第G+1行每行包括3个整数：T(0&lt;T&lt;=1000)，表示垃圾被投进井中的时间；F(1≤F≤30)，表示该垃圾能维持卡门生命的时间；和H(1≤H≤25)，该垃圾能垫高的高度。 输出如果卡门可以爬出陷阱，输出一个整表示最早什么时候可以爬出；否则输出卡门最长可以存活多长时间。 二 题解把垃圾的高度看作体积，吃下去能维持生命的时间看作价值，那么就转化成了一个背包问题。设$f_{i,j}$为前$i$个垃圾堆$j$的高度所能得到的最大活命时间。下面的问题是怎么处理每个垃圾。把垃圾按投放时间排序，设当前处理垃圾$i$，投放时间为$t_i$，吃掉可以续命$s_i$，堆上增高$h_i$。因为时间在流逝，所以吃不吃生命都会降低$t_i-t_{i-1}$，那么得到转移方程：$$ f_{i,j}= \\max f_{i-1,j-h_i}-(t_i-t_{i-1}) , f_{i-1,j}+s_i-(t_i-t_{i-1}) $$第一种状态对应堆上这堆垃圾，第二种状态对应吃掉。注意这个方程的边界，无论是从哪一种状态$f$转移过来，都要满足$f \\geqslant t_i-t_{i-1}$，否则Carmen活不到垃圾$i$被丢下。 剩下的问题是得到的数据应该怎么用。显然任意一个$f_{i,d}$（$d$是坑的深度）我们都知道了，若$f_{i,d}\\geqslant 0$则用前$i$个垃圾可以爬出坑来。因为时间是升序的，所以只需要找到这样的最小的一个$i$值，记录$t_i$即为答案。如果找不到即为无解。那么只需要输出$\\max\\limits_{f_{i,0}\\geqslant 0} f_{i,0}$，因为吃掉全部垃圾显然活得更长。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN=110;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class litter{ public: int t,s,h; bool operator &lt; (const litter &amp;a)const {return t&lt;a.t;}}lt[CN];//v defineint d,g;int f[CN][CN];int main(){ memset(f,-0x3f,sizeof(f)); d=read(); g=read(); for(int i=1;i&lt;=g;i++) lt[i].t=read(),lt[i].s=read(),lt[i].h=read(); sort(lt+1,lt+g+1); //排序 f[0][0] = 10; //0个垃圾达到高度0，即为初始血量 lt[0].t = 0; for(int i=1;i&lt;=g;i++) for(int j=d; j&gt;=0; j--){ if(f[i-1][j] &gt;= lt[i].t-lt[i-1].t) f[i][j] = max(f[i][j], f[i-1][j]+lt[i].s-(lt[i].t-lt[i-1].t)); //吃 if(j-lt[i].h&gt;=0 &amp;&amp; f[i-1][j-lt[i].h]&gt;=lt[i].t-lt[i-1].t) f[i][j] = max(f[i][j], f[i-1][j-lt[i].h]-(lt[i].t-lt[i-1].t)); //填 } int ans=0; for(int i=1;i&lt;=g&amp;&amp;!ans;i++) if(f[i][d] &gt;= 0) ans = lt[i].t; if(!ans){ //无解 for(int i=1;i&lt;=g;i++) if(f[i][0] &gt;= 0) ans = max(ans, f[i][0]+lt[i].t); } printf(\"%d\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/05/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1/"},{"title":"「题解」伟大的奶牛聚集","text":"Bessie正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会…… 一 题目 原题链接 描述Bessie正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。 每个奶牛居住在 N(1&lt;=N&lt;=100,000) 个农场中的一个，这些农场由N-1条道路连接，并且从任意一个农场都能够到达另外一个农场。道路i连接农场A_i和B_i(1 &lt;= A_i &lt;=N; 1 &lt;= B_i &lt;= N),长度为L_i(1 &lt;= L_i &lt;= 1,000)。集会可以在N个农场中的任意一个举行。另外，每个牛棚中居住者C_i(0 &lt;= C_i &lt;= 1,000)只奶牛。 在选择集会的地点的时候，Bessie希望最大化方便的程度(也就是最小化不方便程度)。比如选择第X个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和，(比如，农场i到达农场X的距离是20，那么总路程就是C_i*20)。帮助Bessie找出最方便的地点来举行大集会。 输入第一行：一个整数 N 。第二到 N+1 行：第 i+1 行有一个整数 C_i第 N+2 行到 2*N 行：第 i+N+1 行为 3 个整数：A_i,B_i 和 L_i。 输出第一行：一个值，表示最小的不方便值。 二 题解简化题意：在一颗树上，选一个节点，使得其他节点到该节点的费用和最小（费用=点权 x 距离）。 先选节点$1$为根。 设$f_i$为选$i$作为集会地点，得到的不方便值。那么若$f_u$的值已知，可以$O(1)$地扩展到$u$的任意子孙$v$的$f$值，如下： 若地点从$u$转移到$v$，那么$v$的祖先会多走$dist(u,v)$的距离，$v$及它的子孙会少走$dist(u,v)$的距离。设$sum_i$为以节点$i$为根的子树中节点上奶牛的数量之和，那么有：$$ f_v = f_u -sum_v \\times dist(u,v) + (sum_1 - sum_v)\\times dist(u,v) | (u,v)\\in E $$整理一下得到：$$ f_v = f_u + (sum_1-2sum_v)\\times dist(u,v) | (u,v)\\in E $$ 答案是$\\min f_i (1\\leqslant i \\leqslant n)$。 好了，剩下的认为就是求出$f_1$和$sum[\\text{ }]$了。直接爆搜一遍，复杂度$O(n)$。总复杂度$O(2n)$。 要开long long！ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;#define LL long longint read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CP=1e5+5;const int CE=CP*2;const LL INF=0x3f3f3f3f3f3f3f3f;class fs{ public: int to,nxt,dist; void init(int t,int n,int d) {to=t; nxt=n; dist=d;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y,int z){ E[++ecnt].init(y,hd[x],z); hd[x]=ecnt; E[++ecnt].init(x,hd[y],z); hd[y]=ecnt;}//v defineint n,c[CP];//dpLL f[CP],sum[CP],data=0;void init(int u,int prv) //求出f[1](data)和sum[]{ sum[u] = c[u]; for(int k=hd[u]; k; k=E[k].nxt){ if(E[k].to != prv){ init(E[k].to, u); data += sum[E[k].to]*E[k].dist; sum[u] += sum[E[k].to]; } }}void updata(int u,int prv) //O(n)扩展{ for(int k=hd[u]; k; k=E[k].nxt) if(E[k].to != prv){ f[E[k].to] = f[u]+(sum[1]-2*sum[E[k].to])*E[k].dist; updata(E[k].to, u); }}int main(){ n=read(); for(int i=1;i&lt;=n;i++) c[i]=read(); for(int i=1;i&lt;n;i++){ int x=read(),y=read(),z=read(); add(x,y,z); } init(1,0); f[1] = data; updata(1,0); LL ans=INF; for(int i=1;i&lt;=n;i++) //比较一边 ans = min(ans, f[i]); printf(\"%lld\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/24/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E4%BC%9F%E5%A4%A7%E7%9A%84%E5%A5%B6%E7%89%9B%E8%81%9A%E9%9B%86/"},{"title":"「题解」小a和小uim之大逃离","text":"小a和uim来到雨林中探险。突然一阵北风吹来，一片乌云从北部天边急涌过来，还伴着一道道闪电，一阵阵雷声…… 一 题目 原题链接 描述小a和uim来到雨林中探险。突然一阵北风吹来，一片乌云从北部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个披头散发、青面獠牙的怪物，低沉着声音说：“呵呵，既然你们来到这，只能活下来一个！”。小a和他的小伙伴都惊呆了！ 瞬间，地面上出现了一个n*m的巨幅矩阵，矩阵的每个格子上有一坨0~k不等量的魔液。怪物各给了小a和uim一个魔瓶，说道，你们可以从矩阵的任一个格子开始，每次向右或向下走一步，从任一个格子结束。开始时小a用魔瓶吸收地面上的魔液，下一步由uim吸收，如此交替下去，并且要求最后一步必须由uim吸收。魔瓶只有k的容量，也就是说，如果装了k+1那么魔瓶会被清空成零，如果装了k+2就只剩下1，依次类推。怪物还说道，最后谁的魔瓶装的魔液多，谁就能活下来。小a和uim感情深厚，情同手足，怎能忍心让小伙伴离自己而去呢？沉默片刻，小a灵机一动，如果他俩的魔瓶中魔液一样多，不就都能活下来了吗？小a和他的小伙伴都笑呆了！ 现在他想知道他们都能活下来有多少种方法。 输入第一行，三个空格隔开的整数n，m，k接下来n行，m列，表示矩阵每一个的魔液量。同一行的数字用空格隔开。 输出一个整数，表示方法数。由于可能很大，输出对1 000 000 007取余后的结果。 123对于20%的数据，n,m&lt;=10,k&lt;=2对于50%的数据，n,m&lt;=100,k&lt;=5对于100%的数据，n,m&lt;=800,1&lt;=k&lt;=15 二 题解题外话：这是蒟蒻的第三百道题，同时是本站的第二十篇文章。 50分算法还是很好想出来的。设$f_{i,j,p,q,0/1}$表示当前以格子$(i,j)$为终点，小a收集了$p$体积的魔液，小uim收集了$q$体积的魔液，且上一步是小a（$0$）还是小uim（$1$）走 的时候，所得到的方案数。边界条件是枚举起点（小a走出第一步的点），且方案为$1$。 可惜内存会炸掉。 我们发现转移状态只需要用到$p,q$的差值，所以记录$p,q$的值是很不划算的。设$v=p-q$，可以得到一个更优秀的状态设计：设$f_{i,j,v,0/1}$表示当前以格子$(i,j)$为终点，小a与小uim收集的魔液的体积之差等于$v$，且上一步是小a（$0$）还是小uim（$1$）走 的时候，所得到的方案数。 但是差值有负数。因为差值的取值范围在$-k \\text{~} k$，所以有一个很朴素的想法是把每个差值加上$k$来避免负数。但是这么大的空间还是有炸掉的危险。 其实继续研究就可以发现，根本不需要这么麻烦。因为即使是这个差值也是要模上$k+1$的，所以余数最多有$k+1$种情况。对于差值为负的情况，我们把它加上一个模数（$k+1$）再模，让余数总为正数。此时可以形象的理解一下：小uim的魔液比小a多，小a不服气，又拿来一瓶刚好溢出的魔液，把小uim又比下去了。因为题目的特殊性质，总满足$k+1=0$，所以并不会出问题。 方程：$$ f_{i,j,v,0} = f_{i-1,j,v-s_{i,j},1} + f_{i,j-1,v-s_{i,j},1} \\newline f_{i,j,v,1} = f_{i-1,j,v+s_{i,j},0} + f_{i,j-1,v+s_{i,j},0} $$其中$s_{i,j}$是格子$(i,j)$的魔液体积。 还有一个小坑：虽然余数是long long型的，但是转移状态必须用int，统计状态再用long long，不然MLE。并且此时还不能让int自然溢出，还必须模上一个long long型的余数，不然有神仙错误…… 附上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN=8e2+1;const LL R=1000000007;int n,m,k;int sum[CN][CN];/*0 : xiao a 1 : xiao uimv=a-u*/ int f[CN][CN][16][2]; int main(){ scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) { scanf(\"%d\",&amp;sum[i][j]); sum[i][j] %= (k+1); //魔液先取一遍模 f[i][j][sum[i][j]][0]=1; //边界 } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int v=0;v&lt;=k;v++) //枚举差值 { (f[i][j][v][0] += f[i-1][j][(v-sum[i][j]+k+1)%(k+1)][1])%=R; //加上一个模数再取模 (f[i][j][v][0] += f[i][j-1][(v-sum[i][j]+k+1)%(k+1)][1])%=R; (f[i][j][v][1] += f[i-1][j][(v+sum[i][j])%(k+1)][0])%=R; (f[i][j][v][1] += f[i][j-1][(v+sum[i][j])%(k+1)][0])%=R; } LL ans=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) (ans+=f[i][j][0][1])%=R; printf(\"%lld\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/05/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%B0%8Fa%E5%92%8C%E5%B0%8Fuim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB/"},{"title":"「题解」天际线","text":"Latium省的Genoa是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官Caesar的委任，前往Genoa建立新的城市….. 一 题目 原题链接 描述Latium省的Genoa是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官Caesar的委任，前往Genoa建立新的城市。Caesar对这次任务的要求是在Genoa这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。 正在你大刀阔斧地进行城市建设的时候，Caesar突然写信给你，说他要检查Genoa的建设情况。Caesar希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。 怎样描述一个城市的轮廓呢？我们知道Genoa所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组（Li,Hi,Ri）其中Li和Ri分别是建筑的左坐标和右坐标，Hi就是建筑的高度。在下方所示的图表中左边建筑物描述如下(1,11,5),(2,6,7),(3,13,9),(12,7,16),(14,3,25),(19,18,22),(23,13,29),(24,4,28)，右边用轮廓线的顺序（1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0）表示： 输入在输入数据中，你将得到一系列表示建筑的三元组。在输入数据中所有建筑的坐标中的数值都是小于10000的正整数，且至少有1幢建筑，最多有5,000幢建筑。在输入输入中每幢建筑的三元组各占一行。三元组中的所有整数应由一个或多个空格分开。 输出在输出数据中，你被要求给出城市的轮廓线。你可以这样来描述：对于所有轮廓线上的折点，按顺序排好，第奇数个点输出x坐标，第偶数个点输出y坐标，两个数之间用空格分开。 二 题解扫描线+线段覆盖水题，不懂请参见「题解」Atlantis。 于是乎说一下我的AC过程吧。40min打完代码并调好样例，第一次提交拿了80pts，然后测试数据不给，只好自己去写对拍。然后我就可以顺理成章的贴出对拍的模板： run.bat123456789@echo off :loop g.exe&gt;data.in std.exe&lt;data.in&gt;std.out db.exe&lt;data.in&gt;my.out fc my.out std.out if not errorlevel 1 goto loop pause goto loop 顺便再贴一下上面这种样式的代码块的插入代码（对，这就是水博客）。 123{% codeblock [title] [lang:language] [url] [link text] %}code snippet{% endcodeblock %} 既然对拍的板子贴出来了，那么我水博客的目的达成了，然后发现应该一次性把在同一横坐标上的所有线段处理完，然后就AC了。 顺便一说，这代码反手就被我hack掉了。有什么办法么，我都AC了…… 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 4e6+6;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n;class locat{ public: int x,y; bool operator &lt; (const locat &amp;a)const{ if(x == a.x) return y &lt; a.y; return x &lt; a.x; }}ans[CN]; int acnt = 0;//Segment Cover class Segment{ public: int r,x,k; bool operator &lt; (const Segment &amp;a)const {return x &lt; a.x;}}seg[CN];int scnt = 0;int pos[CN],pcnt;class node{ public: int len,cnt;};class SGT{ public: node d[CN&lt;&lt;2]; int GetLen(int l,int r,int k){ if(d[k].cnt) return pos[r+1]-pos[l]; if(l == r) return 0; return d[k&lt;&lt;1].len + d[k&lt;&lt;1|1].len; } void modify(int l,int r,int k,int s,int t,int x){ if(s&lt;=l &amp;&amp; r&lt;=t){ d[k].cnt += x; d[k].len = GetLen(l,r,k); return; } int m = (l+r)&gt;&gt;1; if(s &lt;= m) modify(l,m,k&lt;&lt;1,s,t,x); if(m &lt; t) modify(m+1,r,k&lt;&lt;1|1,s,t,x); d[k].len = GetLen(l,r,k); }}sgt;void SegmentCover(int i){ int l = 1; int r = lower_bound(pos+1,pos+pcnt+1,seg[i].r)-pos-1; sgt.modify(1,pcnt,1,l,r,seg[i].k);}int main(){ //freopen(\"data.in\",\"r\",stdin); n = 0; int x,y,z; while(~scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)){ n++; seg[scnt+1].r = y; seg[scnt+1].x = x; seg[scnt+1].k = 1; seg[scnt+2].r = y; seg[scnt+2].x = z; seg[scnt+2].k = -1; scnt += 2; pos[n] = y; } pos[++n] = 0; //防止出锅 //离散化 sort(seg+1,seg+scnt+1); sort(pos+1,pos+n+1); pcnt =1; for(int i=2;i&lt;=n;i++) if(pos[i] != pos[i-1]) pos[++pcnt] = pos[i]; //solve int prvh = 0; for(int i=1;i&lt;=scnt;i++){ while(seg[i].x==seg[i+1].x &amp;&amp; i&lt;scnt) SegmentCover(i),i++; SegmentCover(i); if(sgt.d[1].len != prvh){ ans[++acnt].x = seg[i].x; ans[acnt].y = prvh; prvh = sgt.d[1].len; ans[++acnt].x = seg[i].x; ans[acnt].y = prvh; } } //print for(int i=1;i&lt;=acnt;i++) if(i &amp; 1) printf(\"%d \",ans[i].x); else printf(\"%d \",ans[i].y); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/19/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%A4%A9%E9%99%85%E7%BA%BF/"},{"title":"「题解」奶牛的电信","text":"农夫约翰的奶牛们喜欢通过电邮保持联系，于是她们建立了一个奶牛电脑网络，以便互相交流。这些机器用如下的方式发送电邮…… 一 题目 原题链接 1 描述农夫约翰的奶牛们喜欢通过电邮保持联系，于是她们建立了一个奶牛电脑网络，以便互相交流。这些机器用如下的方式发送电邮：如果存在一个由c台电脑组成的序列a1,a2,…,a(c)，且a1与a2相连，a2与a3相连，等等，那么电脑a1和a(c)就可以互发电邮。 很不幸，有时候奶牛会不小心踩到电脑上，农夫约翰的车也可能碾过电脑，这台倒霉的电脑就会坏掉。这意味着这台电脑不能再发送电邮了，于是与这台电脑相关的连接也就不可用了。 有两头奶牛就想：如果我们两个不能互发电邮，至少需要坏掉多少台电脑呢？请编写一个程序为她们计算这个最小值。 2 输入第一行 四个由空格分隔的整数：N,M,c1,c2.N是电脑总数(1&lt;=N&lt;=100)，电脑由1到N编号。M是电脑之间连接的总数(1&lt;=M&lt;=600)。最后的两个整数c1和c2是上述两头奶牛使用的电脑编号。连接没有重复且均为双向的(即如果c1与c2相连，那么c2与c1也相连)。两台电脑之间至多有一条连接。电脑c1和c2不会直接相连。 第2到M+1行 接下来的M行中，每行包含两台直接相连的电脑的编号。 3 输出一个整数表示使电脑c1和c2不能互相通信需要坏掉的电脑数目的最小值。 二 题解第一次做拆点建模…… 显然是求图上的最小割。根据最小割最大流定理，一开始的想法就是直接跑最大流，但是这是不对的，因为题目中让求最小割点集而不是最小割边集。直接跑跑出来的实际是最小割边集。 拆点的思想是：将节点$i$拆成$i$和$i+n$两个节点。其中节点$i$连接原图中进入$i$节点的边，节点$i+n$连接原图中连出$i$节点的边。再将$i$到$i+n$连接一条边，那么这条边就能代表原图中的节点$i$，也就把最小割点集转化成了最小割边集。将这类边的流量限制变成$1$（因为在割边集中这条边仅能出现一次），而其它边的流量限制变为$ \\infty $，跑最大流即可。 注意：这时原图中的源点应该是$s+n$，否则最小割会被限制在$s \\to s+n$这条边上。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CP=2*202;const int CE=4*1001;const int INF=0x7f7f7f3f;class fs{ public: int to,nxt,flow,cap; void init(int t,int n,int c,int f) {to=t; nxt=n; cap=c; flow=f;}}E[CE];int hd[CP],ecnt=1;void _add(int a,int b,int f){ E[++ecnt].init(b,hd[a],f,0); hd[a]=ecnt;}void add(int x,int y,int c){ _add(x,y,c); _add(y,x,0); //反向边}//v defineint n,m,s,t;//dinicint dep[CP],cur[CP];bool bfs() //分层{ memset(dep,0,sizeof(dep)); dep[s]=1; queue&lt;int&gt;Q; Q.push(s); while(!Q.empty()) { int u=Q.front(); Q.pop(); for(int k=hd[u]; k; k=E[k].nxt) { fs e=E[k]; if(!dep[e.to] &amp;&amp; e.cap-e.flow&gt;0) { dep[e.to]=dep[u]+1; Q.push(e.to); } } } return dep[t];}int Augment(int u,int rst){ if(u == t) return rst; int use=0; for(int k=cur[u]; k; k=E[k].nxt) { cur[u]=k; fs e=E[k]; if(dep[e.to]==dep[u]+1 &amp;&amp; e.cap-e.flow&gt;0) { int f=Augment(e.to, min(rst-use, e.cap-e.flow)); if(f){ E[k].flow+=f; E[k^1].flow-=f; use+=f; } if(use == rst) return use; } } return use;}int dinic(){ int max_flow=0; while(bfs()) { for(int i=1;i&lt;=n*2;i++) //当前弧优化 cur[i]=hd[i]; max_flow+=Augment(s,INF); //多路增广 } return max_flow;}int main(){ //freopen(\"testdata.in\",\"r\",stdin); scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;s,&amp;t); s+=n; while(m--){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x+n,y,INF); add(y+n,x,INF); } for(int i=1;i&lt;=n;i++) add(i,i+n,1); printf(\"%d\",dinic()); //最大流即为最小割 return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/10/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1/"},{"title":"「题解」封锁阳光大学","text":"曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街…… 一 题目 原题链接 描述曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。 阳光大学的校园是一张由N个点构成的无向图，N个点之间由M条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在与这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。 询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。 输入第一行：两个整数N，M 接下来M行：每行两个整数A，B，表示点A到点B之间有道路相连。任意两点之间最多有一条道路。 输出仅一行：如果河蟹无法封锁所有道路，则输出“Impossible”，否则输出一个整数，表示最少需要多少只河蟹。 二 题解既要“让每条边都被覆盖”，又要“相邻的节点的不能同时被选中”，那么就意味着，如果存在一种合法方案，相邻的节点之间肯定是“选 – 不选 – 选 – … ”这样的关系。 那么把选中的节点看作一个集合，不选的节点看作另一个集合。选中和不选的节点之间肯定有边相连，也就是说上述两个集合间一定有边相连。同理可知集合内一定没有边，这不就是二分图吗！ 当然，出现二分图的前提是有解。那么若有解，则原图一定是二分图，判断有无解就解决了。二分图的染色法判定请见。 剩下的问题是怎么找出这个“最小覆盖点数”。显然在二分图的左右两图$L,R$中，选出一个即可保证全部覆盖。那么就选点数最小的那个。**但是图不一定联通!**那么对于图上每个联通块（也就是每个二分图），我们都选出点数少的那个子图，并把点数累加就好了。 用当前染色操作的颜色$c$（$c\\geqslant 1$）来表示当前的联通块编号，分别统计该联通块左图的节点数$sl[]$和右图的节点数$sr[]$，累加就好了。对于同一联通块内，染色所用的两种颜色分别是$c,-c$，这样就可以用节点被染成的颜色判断节点在左图还是右图。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CP=1e4+4;const int CE=2e5+5;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int to,nxt; void init(int t,int n) {to=t; nxt=n;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].init(y,hd[x]); hd[x]=ecnt;}//v defineint n,m;//judgeint col[CP],sl[CP],sr[CP]; //col[i] : // =0 : 未访问 // &lt;0 : 颜色一 // &gt;0 : 颜色二bool dfs(int u,int c){ //染色 col[u] = c; for(int k=hd[u]; k; k=E[k].nxt) if(col[E[k].to]==c || (!col[E[k].to] &amp;&amp; !dfs(E[k].to,-c))) return false; return true;}int judge(){ int cc = 1; //当前的颜色 for(int i=1;i&lt;=n;i++) if(!col[i]){ if(!dfs(i,cc)) return 0; //染色失败 cc++; } for(int i=1;i&lt;=n;i++) //统计左右图的大小 if(col[i]){ if(col[i]&gt;0) sl[col[i]]++; else sr[-col[i]]++; } int sum=0; for(int i=1;i&lt;=cc;i++) sum += min(sl[i], sr[i]); //累加 return sum;}int main(){ n=read(); m=read(); while(m--){ int x=read(),y=read(); add(x,y); add(y,x); } int ans=judge(); if(ans) printf(\"%d\",ans); else printf(\"Impossible\"); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/04/26/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%B0%81%E9%94%81%E9%98%B3%E5%85%89%E5%A4%A7%E5%AD%A6/"},{"title":"「题解」引水入城","text":"在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个N行×M列的矩形…… 一 题目 原题链接 描述在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个N行×M列的矩形，如上图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。 为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。 因此，只有与湖泊毗邻的第 1 行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第 N 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。 输入每行两个数，之间用一个空格隔开。输入的第一行是两个正整数 N,M，表示矩形的规模。接下来 N 行，每行 M 个正整数，依次代表每座城市的海拔高度。 输出两行。如果能满足要求，输出的第一行是整数 1，第二行是一个整数，代表最少建造几个蓄水厂；如果不能满足要求，输出的第一行是整数 0，第二行是一个整数，代表有几座干旱区中的城市不可能建有水利设施 二 题解感觉要考好tg还是要学好大爆搜。还要搞好各种剪枝/优化。 第一问可以直接爆搜解决，时间复杂度大概是$O(nm)$，最后统计一下最后一行有没有点不能被搜到。 关键是第二问。不难发现从每个点出发，能到达最后一行的点总是一定的。而且如果有解，这些点总是一段连续的区间（如果不是区间，那么那个断点一定不能被覆盖，那么无解）。所以记录一下$l_{x,y}$表示从点$(x,y)$出发能到达的区间左端点，$r_{x,y}$为$(x,y)$能到达的区间右端点，在爆搜的时候可以直接调用这些值。 然后我们发现$l_{x,y}$和$r_{x,y}$的值可以递推得到：枚举与$(x,y)$相邻的格子$(vx,vy)$，若从$(x,y)$可以到达$(vx,vy)$，则有$$l_{x,y} = \\min l_{vx,vy} \\newline r_{x,y} = \\max r_{vx,vy}$$ 然后不难发现连爆搜都省了：若有解，则设当前覆盖的区间是$[1,curr)$，每次贪心取能接上当前区间的最大的区间就好了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CN=510;const int dx[4]={-1,0,1,0};const int dy[4]={0,1,0,-1};int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=((s&lt;&lt;1)+(s&lt;&lt;3))+c-'0'; return s*ne;}//v defineint n,m;int h[CN][CN],l[CN][CN],r[CN][CN]; //l[x][y] : 点(x,y)能到达的最左点 //r[x][y] : 点(x,y)能到达的最右点 bool vis[CN][CN];//dfsvoid dfs(int ux,int uy){ vis[ux][uy] = true; for(int k=0; k&lt;4; k++) { int vx=ux+dx[k],vy=uy+dy[k]; if(vx&lt;1 || vx&gt;n || vy&lt;1 || vy &gt; m) continue; if(h[ux][uy] &gt; h[vx][vy]) { if(!vis[vx][vy]) dfs(vx,vy); l[ux][uy] = min(l[ux][uy], l[vx][vy]); //递推 r[ux][uy] = max(r[ux][uy], r[vx][vy]); } }}int check() //爆搜整张图{ memset(l,CN+100,sizeof(l)); //设置初始值 for(int i=1;i&lt;=m;i++) l[n][i] = r[n][i] = i; //递推边界 for(int i=1;i&lt;=m;i++) { if(vis[1][i]) continue; dfs(1,i); } int cnt=0; for(int i=1;i&lt;=m;i++) if(!vis[n][i]) cnt++; return cnt;}int main(){ n=read(); m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) h[i][j]=read(); int cnt=check(); if(cnt) printf(\"0\\n%d\",cnt); //无解 else //有解 { int curr=1; //当前已经覆盖区间的右端点 (区间[1,curr)已经覆盖完成) while(curr &lt;= m) //贪心覆盖 { int maxr=curr; //最远的右端点 for(int i=1;i&lt;=m;i++) //遍历所有点 if(l[1][i] &lt;= curr) //能接上当前已经覆盖的区间 maxr = max(maxr, r[1][i]); //贪心取最大 cnt++; curr=maxr+1; //更新右端点 } printf(\"1\\n%d\",cnt); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/17/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E/"},{"title":"「题解」异构体","text":"一道比较简单的分类讨论题…… 一 题目Source : qbxt2019.10.3 T2Author : zhxSubmit : luogu T101285 描述你是能看到第二题的friends呢。 ——aoao众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。 Paradeus是一个新兴的宗教组织，该组织包含了N-1个Nyto，以及一个Mercurows总共NN个人组成。每个Nyto都是被其他某个人传教而进入的Paradeus，Mercurows是宗教的创立者，也就是说Mercurows并没有被任何人拉进组织。这张记录了每个人是由谁拉进传销组织的记录被视为Paradeus的教义，一直被广为传颂。 然而，随着岁月的流逝， 有不法分子开始对Paradeus的教义发动了攻击。不法分子在Paradeus的教义上添加了一条记录(a, b)，代表b是由a介绍入教的。 这条记录的加入导致Nyto们发现教义已经不合法了。 为了复兴教义，教徒们决定找到这条被不法分子加入的记录，并将其删除以恢复教义的荣光。更具体的说，现在给定N对记录(a_i, b_i)代表a_i是将b_i拉入教的。注意这NN条记录包含了被不法分子添加的那一条。现在我们希望你找到某一条记录，使得删掉这条记录之后剩下的N-1N−1条记录能够形成合法的教义。要注意的是， 教义并没有标注Mercurows，所以任何人都有可能是Mercurows。 输入第一行一个数代表人数；接下来N行每行两个数a_i,b_i代表一条记录。 输出一行一个数代表删掉第几条记录能够使得教义合法。 如果有多种方案， 输出 编号最大 的方案。 数据保证有解。 范围与约定对于40%的数据，n≤1000；对于另外20%的数据，可能成为Mercurows的人一定只有一个；对于100%的数据，1≤N≤10^5。 二 题解因为题目保证有解，那么正向地考虑构造，实际上就是在一棵树（有向，边从子节点指向父节点）上多连了一条边（也有向）。我们要拎出一条边，并使图恢复为一颗有根内向树。 先看这条边会改变什么。它一定会使得一个点的出度 +1。那么就意味着可能存在出度为 2 的节点，当然也可能没有（连在根上）。然后如果没有初度为二的节点，图就会是严格的基环内向树；否则有可能有环（不严格的基环外向树）或无环（DAG）。 实际上就 图一~三 这么几种情况： 对于图一，只需要在换上选最大边；图二，只能选择出度为 2 的节点指向基环内的边；图三，只需要在出度为 2 的节点的两条出边中选最大的那条。然后判环和把环拎出来只需要写个tarjan，然后就做完了。 考场tarjan写锅还能拿80pts可还行？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e5+5;class fs{ public: int to,nxt,id; void init(int t,int n,int i){to = t;nxt = n;id = i;}}E[CN];int hd[CN],ecnt = 0;void add(int x,int y,int z){ E[++ecnt].init(y,hd[x],z); hd[x] = ecnt;}int n;int de[CN];bool ChuDuWeiEr(){ for(int i=1;i&lt;=n;i++) if(de[i] == 2) return true; return false;}bool vis[CN];/* tarjan */int dfn[CN],low[CN],idx = 0,stk[CN],top = 0,bel[CN],bcnt = 0;bool ins[CN];int tot[CN];void dfstj(int u){ dfn[u] = low[u] = ++idx; ins[u] = true; stk[++top] = u; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(!dfn[v]){ dfstj(v); low[u] = min(low[u],low[v]); } else if(ins[v]) low[u] = min(low[u], low[v]); } if(dfn[u] == low[u]){ bcnt++; while(true){ int pos = stk[top--]; ins[pos] = false; bel[pos] = bcnt; tot[bcnt]++; if(pos == u) break; } }}void scc(){ memset(ins,0,sizeof(ins)); memset(tot,0,sizeof(tot)); for(int i=1;i&lt;=n;i++) if(!dfn[i]) dfstj(i);}/* pan huan */bool PanHuan(){ scc(); for(int i=1;i&lt;=bcnt;i++) if(tot[i] &gt; 1) return true; return false;}/* zhao huan */bool On[CN];void GetCir(int &amp;p,int &amp;q){ memset(On,0,sizeof(On)); for(int i=1;i&lt;=bcnt;i++) if(tot[i] &gt; 1) {p = i; break;} for(int i=1;i&lt;=n;i++) if(bel[i] == p) On[q = i] = true;}/* ji huan nei xiang shu */int MaxEdge = 0;void dfsst1(int u){ if(vis[u]) return; vis[u] = true; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(On[v]){ MaxEdge = max(MaxEdge, E[k].id); dfsst1(v); } }}int ST1(){ // 严格基环外向树 int p,q; scc(); GetCir(p,q); memset(vis,0,sizeof(vis)); dfsst1(q); return MaxEdge;}/* ST2 */int ST2(){ int Ans = 0; int st; for(int i=1;i&lt;=n;i++) if(de[i] == 2) {st = i; break;} if(!PanHuan()){ // DAG for(int k=hd[st];k;k=E[k].nxt) Ans = max(Ans, E[k].id); } else{ // 不严格基环内向树 int p,q; GetCir(p,q); for(int k=hd[st];k;k=E[k].nxt) if(On[E[k].to]) Ans = max(Ans, E[k].id); } return Ans;}int main(){ // scan scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++){ int a,b; scanf(\"%d%d\",&amp;a,&amp;b); add(b,a,i); de[b]++; } // calc int ans; if(ChuDuWeiEr()) ans = ST2(); else ans = ST1(); // ji huan nei xiang shu printf(\"%d\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/10/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%BC%82%E6%9E%84%E4%BD%93/"},{"title":"「题解」摆花","text":"矩阵快速幂优化二维DP…… 一 题目 原题链接 描述艺术馆门前将摆出许多花，一共有n个位置排成一排，每个位置可以摆花也可以不摆花。有些花如果摆在相邻的位置（隔着一个空的位置不算相邻），就不好看了。假定每种花数量无限，求摆花的方案数。 输入输入有1+m行，第一行有两个用空格隔开的正整数n、m，m表示花的种类数。接下来的m行，每行有m个字符1或0,若第i行第j列为1，则表示第i种花和第j种花不能排在相邻的位置，输入保证对称。（提示：同一种花可能不能排在相邻位置）。 输出输出只有一个整数，为方案数（这个数字可能很大，请输出方案数除以1000000007的余数）。 二 题解对于矩阵的初学者，建议您先看矩阵基础。 DP思路很容易想到一个$O(nm)$级别的DP：设$f_{i,j}$为考虑前$i$个位置，且第$i$个位置摆放第$j$种花时的方案数。由于任意位置都可以一盆花也不摆，故当$j = 0 $时表示该位置不摆花。 初始状态： $f_{0,0} = 1$转移方程：设$a(x,y) = 1$表示$x,y$两种花可以相邻。则转移方程为： $ f_{i,j} = \\sum\\limits_{k\\in [0,m]}^{a(i,k) = 1} f_{i-1,k}$答案： 答案为$\\sum\\limits_{i = 0}^m f_{n,i}$ 空间复杂度为$O(nm)$，朴素时间复杂度为$O(nm^2)$。核心代码大约长这样： 12345678const int R = 1e9+7;f[0][0]=1;for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=m;j++) for(int k=0;k&lt;=m;k++) if(a[j][k] || j==0 || k==0) f[i][j] = (f[i][j]+f[i-1][k])%R;for(int i=0;i&lt;=m;i++) ans = (ans+f[n][i])%R; 矩阵加速我们发现：上面的这个DP转移是由前一层状态转移到后一层状态，而我们最终需要第$n$层状态。 我们不妨设$F(i)$表示第$i$层的状态，即$F(i) = \\begin{bmatrix} f_{i,0}&amp;f_{i,1}&amp;f_{i,2}&amp;…&amp;f_{i,m} \\end{bmatrix}$，这是一个$1\\times (m+1)$阶的矩阵。 显然有$F(0) = \\begin{bmatrix}1&amp;\\overbrace{0 \\text{ }\\text{ }\\text{ }\\text{ }0\\text{ }\\text{ }\\text{ }\\text{ }…} \\end{bmatrix}$，后面的大括号里一共有$m$个$0$。 现在我们考虑怎么由$F(i-1)$推导$F(i)$。不妨把$a(x,y)$函数看成一个$(m+1)\\times (m+1)$阶的矩阵$A$，则有（注：乘号后面的$ A_{0\\text{}m,j}$表示$A$矩阵的第$j$列，即一个$1\\times (m+1)$阶的矩阵）：$$ \\begin{aligned}&amp; F(i-1) \\times A_{0\\text{}m,0} = f_{i,0} \\newline &amp; F(i-1) \\times A_{0\\text{}m,1} = f_{i,1} \\newline &amp;… \\newline &amp; F(i-1) \\times A_{0\\text{}m,m} = f_{i,m} \\end{aligned}$$故：$$ F(i-1) \\times A = F(i)$$ $$ F(i) \\times A^k = F(i+k)$$ 那么我们就可以用$F(0) \\times A^n = F(n)$推导出第$n$层状态，再求和就好了。 时间复杂度大约是$O(m^2\\log n )$。 一些细节$0$可以和任意一种花搭配，故$F,A$矩阵都是$k\\times {m+1}$阶级别的。因此在代码里我把$A$矩阵强行向右下平移了一格，即矩阵的有效区间是$(1\\text{}m+1) \\times (1 \\text{}m+1) $。在代码里看可能会更直白一些。 又因为$0$可以和任意一种花搭配，所以$A_{1,i} = A_{i,1} = 1 (i\\in[1,m+1])$（矩阵已经平移过了）。一定注意这一点！ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CM = 102;const LL R = 1e9+7;int n,m;class matrix{ //定义矩阵 public: LL a[CM][CM]; int n,m; void MakeOne(int k){ n = m = k; for(int i=1;i&lt;=n;i++) a[i][i] = 1; } matrix operator * (const matrix &amp;b)const{ matrix rec = (matrix){{{0}}, n, b.m}; //注意别忘了定义相乘得到的矩阵的大小 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int k=1;k&lt;=b.m;k++) (rec.a[i][k] += (a[i][j]*b.a[j][k])%R ) %= R; return rec; } void operator *= (const matrix &amp;b) {*this = (*this)*b;}}A;matrix MatrixQuickPow(matrix &amp;a,LL b){ //矩阵快速幂 matrix rec; rec.MakeOne(a.m); while(b){ if(b &amp; 1) rec *= a; a *= a; b &gt;&gt;= 1; } return a = rec;}int main(){ //freopen(\"in.in\",\"r\",stdin); scanf(\"%d%d\",&amp;n,&amp;m); A.n = A.m = m+1; //平移后矩阵的大小是 (m+1)^2 for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=m;j++){ char c; cin&gt;&gt;c; if(c == '0') A.a[i+1][j+1] = 1; //平移 } for(int i=1;i&lt;=m+1;i++) A.a[1][i] = A.a[i][1] = 1; //初始化，0可以和任意花搭配 matrix c = (matrix){{{0}}, 1, m+1}; //定义 F(0) c.a[1][1] = 1; //初始状态 c *= MatrixQuickPow(A, n); //递推到 F(n) LL ans = 0; for(int i=1;i&lt;=m+1;i++) (ans += c.a[1][i]) %= R; //累加答案 printf(\"%lld\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/08/01/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%91%86%E8%8A%B1/"},{"title":"「题解」抢掠计划","text":"Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心 出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆 祝他的胜利…… 一 题目 原题链接 描述Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定， 在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。 Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心 出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆 祝他的胜利。 使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希 望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可 以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机 里面就不会再有钱了。 输入第一行包含两个整数 N、M。N 表示路口的个数，M 表示道路条数。接下来 M 行，每行两个整数，这两个整数都在 1 到 N 之间，第 i+1 行的两个整数表示第 i 条道路的起点和终点的路口编号。接下来 N 行，每行一个整数，按顺序表示每 个路口处的 ATM 机中的钱数。接下来一行包含两个整数 S、P，S 表示市中心的 编号，也就是出发的路口。P 表示酒吧数目。接下来的一行中有 P 个整数，表示 P 个有酒吧的路口的编号。 输出输出一个整数，表示 Banditji 从市中心开始到某个酒吧结束所能抢劫的最多 的现金总数。 二 题解本以为会是缩点水题，缩点之后直接爆搜，本以为能AC，结果74分…然后发现一点细节失误，改好再交，一个点TLE，一个点WA。 TLE?TLE! 没救了，怒写记搜，结果7分。。看题解，发现要靠拓扑序转移状态，改了改，成了40分，还是没AC。 看到还有 缩点之后，用spfa求最长路 的解法。抱着试一试的态度写了一下，AC了？！ 这题还是告诉我们，DP并不是万能的，有时候还是要考虑考虑不那么玄学但是也不最优的解法。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CP=5e5+5;const int CE=CP+100;const int INF=0x7f7f7f7f;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}void E_init(){ memset(hd,0,sizeof(hd)); ecnt=0;}int _x[CP],_y[CP];//v define int n,m,p,s;int prz[CP],bar[CP];//sccint dfn[CP],low[CP],idx=0;int stack[CP],top=0;bool ins[CP];int bel[CP],sprz[CP],scnt=0;void tarjan(int cur){ dfn[cur] = low[cur] = ++idx; stack[++top]=cur; ins[cur]=true; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]) { tarjan(to); low[cur] = min(low[cur], low[to]); } else if(ins[to]) low[cur] = min(low[cur], low[to]); } if(dfn[cur] == low[cur]) { int pos; scnt++; while(true) { pos=stack[top--]; ins[pos] = false; bel[pos] = scnt; sprz[scnt] += prz[pos]; if(pos==cur) break; } }}void scc(){ for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);}//spfavoid re_build(){ E_init(); for(int i=1;i&lt;=m;i++) if(bel[_x[i]]!=bel[_y[i]]) add(bel[_x[i]], bel[_y[i]]);}int dis[CP];bool vis[CP];void spfa(int u){ memset(dis,0,sizeof(dis)); memset(vis,false,sizeof(vis)); queue&lt;int&gt;Q; Q.push(u); dis[u]=sprz[u]; while(!Q.empty()) { u=Q.front(); Q.pop(); vis[u]=false; for(int k=hd[u]; k; k=E[k].nxt) { int to=E[k].to; if(dis[to] &lt; dis[u]+sprz[to]) { dis[to] = dis[u]+sprz[to]; if(!vis[to]) { Q.push(to); vis[to]=true; } } } }}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ scanf(\"%d%d\",&amp;_x[i],&amp;_y[i]); add(_x[i],_y[i]); } for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;prz[i]); scanf(\"%d%d\",&amp;s,&amp;p); for(int i=1;i&lt;=p;i++) scanf(\"%d\",&amp;bar[i]); scc(); re_build(); spfa(bel[s]); int ans=-INF; for(int i=1;i&lt;=p;i++) ans=max(ans, dis[bel[bar[i]]]); printf(\"%d\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/11/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%8A%A2%E6%8E%A0%E8%AE%A1%E5%88%92/"},{"title":"「题解」弹飞绵羊","text":"正解貌似是LCT，不过分块也能做。第一次做这题WA到怀疑人生，想不到第二天重构就一发A了…… 一 题目 原题链接 描述某天，Lostmonkey发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 输入第一行包含一个整数n，表示地上有n个装置，装置的编号从0到n-1。 接下来一行有n个正整数，依次为那n个装置的初始弹力系数。 第三行有一个正整数m， 接下来m行每行至少有两个数i、j，若i=1，你要输出从j出发被弹几次后被弹飞，若i=2则还会再输入一个正整数k，表示第j个弹力装置的系数被修改成k。 输出对于每个i=1的情况，你都要输出一个需要的步数，占一行。 二 题解设step[i]表示从i跳出这个块需要的步数，设tp[i]表示从i跳出这个块会跳到哪里。这个tp[]实际上是可以O(length)递推出来的，然后每次修改只会影响一个块，O(sqr(n))暴力修改就好了，总复杂度为O(m·sqr(n))。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;const int CN = 2e5+5;const int CB = 1e3+3;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n,m,dist[CN];int bl[CB],br[CB],bel[CN],size;int step[CN],tp[CN];void update(int l,int r){ for(int i=r;i&gt;=l;i--) if(i+dist[i] &gt; br[bel[i]]) step[i] = 1,tp[i] = i+dist[i]; else step[i] = step[i+dist[i]]+1,tp[i] = tp[i+dist[i]];}int main(){ n = read(); for(int i=1;i&lt;=n;i++) dist[i] = read(); size = sqrt(n); if(size*size &lt; n) size += 1; for(int i=1;i&lt;=n;i++) bel[i] = (i-1)/size + 1; for(int i=1;i&lt;=size;i++){ bl[i] = (i-1)*size+1; br[i] = min(n, i*size); } update(1,n); m = read(); while(m--){ int a = read(); if(a == 1){ int b = read()+1,sum = 0; while(b &lt;= n){ sum += step[b]; b = tp[b]; } printf(\"%d\\n\",sum); } if(a == 2){ int b = read()+1; dist[b] = read(); update(bl[bel[b]], br[bel[b]]); } } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/08/15/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A/"},{"title":"「题解」教主的魔法","text":"教主最近学会了一种神奇的魔法，能够使人长高…… 一 题目 原题链接 描述教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给XMYZ信息组每个英雄看。于是N个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为1、2、……、N。 每个人的身高一开始都是不超过1000的正整数。教主的魔法每次可以把闭区间[L, R]（1≤L≤R≤N）内的英雄的身高全部加上一个整数W。（虽然L=R时并不符合区间的书写规范，但我们可以认为是单独增加第L（R）个英雄的身高） CYZ、光哥和ZJQ等人不信教主的邪，于是他们有时候会问WD闭区间 [L, R] 内有多少英雄身高大于等于C，以验证教主的魔法是否真的有效。 WD巨懒，于是他把这个回答的任务交给了你。 输入第1行为两个整数N、Q。Q为问题数与教主的施法数总和。第2行有N个正整数，第i个数代表第i个英雄的身高。第3到第Q+2行每行有一个操作：（1） 若第一个字母为“M”，则紧接着有三个数字L、R、W。表示对闭区间 [L, R] 内所有英雄的身高加上W。（2） 若第一个字母为“A”，则紧接着有三个数字L、R、C。询问闭区间 [L, R] 内有多少英雄的身高大于等于C。 输出对每个“A”询问输出一行，仅含一个整数，表示闭区间 [L, R] 内身高大于等于C的英雄数。 二 题解元素的区间排名问题。使用分块解决，不过相比于模板问题，有一个地方需要稍微改动一下。 因为题目中让求“有多少英雄的身高大于等于C”，但是模板中lower_bound()找出来的是小于C的元素个数，假设这个值为$k$，那么在整块累加答案的时候应该加上的是$bcnt-k$（$bcnt$为块的大小同时也是块数）。但是还需要注意一个细节：最后一个块的大小不一定恰好等于块数。所以需要特判（详见代码）。 最后一个点是这题卡vector，会T一个点，如果用普通数组就没有问题。但是我懒得改代码了，所以吸O2过了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;#define LL long longconst int CN=1e6+5;const int CB=1e3+3; //v defineint n,q;LL hg[CN];int sqr(int x){ for(int k=1;;k++) if(k*k &gt; x) return k;}//hzwer tqlint bel[CN],bcnt=0;LL tag[CB];vector&lt;int&gt;s[CB];void updata(int pos){ s[pos].clear(); for(int i=(pos-1)*bcnt+1; i&lt;=pos*bcnt; i++) s[pos].push_back(hg[pos]); sort(s[pos].begin(),s[pos].end());}void build(){ bcnt=sqr(n); for(int i=1;i&lt;=n;i++){ bel[i] = (i-1)/bcnt+1; s[bel[i]].push_back(hg[i]); } for(int i=1;i&lt;=bcnt;i++) sort(s[i].begin(),s[i].end());}void modify(int l,int r,LL c){ for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) hg[i] += c; updata(bel[l]); if(bel[l] != bel[r]){ for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) hg[i] += c; updata(bel[r]); } for(int i=bel[l]+1; i&lt;bel[r]; i++) tag[i] += c;}LL query(int l,int r,LL c){ LL ans=0; for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) if(hg[i]+tag[bel[i]] &gt;= c) ans++; if(bel[l] != bel[r]) for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) if(hg[i]+tag[bel[i]] &gt;= c) ans++; for(int i=bel[l]+1; i&lt;bel[r]; i++){ int x=c-tag[i]; vector&lt;int&gt;::iterator it=lower_bound(s[i].begin(),s[i].end(),x); int sum=bcnt; if(i == bcnt) //最后一个块可能不为整 sum = min(n-((i-1)*bcnt), bcnt); ans += sum-(it-s[i].begin()); } return ans;}int main(){ scanf(\"%d%d\",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;hg[i]); build(); while(q--){ char m; int l,r; LL c; cin&gt;&gt;m; scanf(\"%d%d%lld\",&amp;l,&amp;r,&amp;c); if(m == 'M') modify(l,r,c); if(m == 'A') printf(\"%lld\\n\",query(l,r,c)); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/15/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95/"},{"title":"「题解」无序字母对","text":"给定n个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有n+1个字母的字符串使得每个字母对都在这个字符串中出现…… 一 题目 原题链接 描述给定n个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有n+1个字母的字符串使得每个字母对都在这个字符串中出现。 输入第一行输入一个正整数n。以下n行每行两个字母，表示这两个字母需要相邻。 输出输出满足要求的字符串。如果没有满足要求的字符串，请输出“No Solution”。如果有多种方案，请输出前面的字母的ASCII编码尽可能小的（字典序最小）的方案。 二 题解把单个字母看作图上的点，字母的相邻关系（也就是上文中的“字母对”）看作无向边。即对于一个字母对$ab$，将$a$与$b$连无向边。 题目中描述“使得每个字母对都在这个字符串中出现”，即可看作图上的每条边都要被经过。所以得出本题为欧拉路问题，求出字典序最小的欧拉道路（或回路）即可解决问题。 因为一共26个英文字母，算上大小写区分还不到100个，所以本题使用邻接矩阵存图更为方便。直接把char型字符强制转换为int型的ascii码，求解即可。注意：在涉及类型转换时，需要注重细节的处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CP=1e3+3;const int CE=CP*CP;bool g[CP][CP]; //邻接矩阵int elm[CP]; //所有出现的字符（强转int），也可以理解为图的点集bool ap[CP]; //一个字符是否已经被记录int n;//euler pathint deg[CP]; //节点的度int list[CP]; //答案数组bool exm(){ int sum=0; for(int i=1;i&lt;=n;i++) if(deg[elm[i]]%2) sum++; return sum&lt;=2; //仅当奇点个数小于2时有解（这里没有判断图的连通性，下面还需要判断）}void dfs(int u){ for(int j=1;j&lt;=elm[0];j++) //从小到大遍历，为了字典序尽量小 { int v=elm[j]; if(g[u][v]) { g[u][v]=g[v][u]=false; //删边 dfs(v); } } list[++list[0]]=u; //必须在退栈的时候记录，想想为什么}int main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { char _x,_y; cin&gt;&gt;_x&gt;&gt;_y; int x=_x,y=_y; //转换成int g[x][y]=g[y][x]=true; //邻接矩阵 deg[x]++; //记录节点的度 deg[y]++; if(!ap[x]) //统计出现的字符 { elm[++elm[0]]=x; ap[x]=true; } if(!ap[y]) { elm[++elm[0]]=y; ap[y]=true; } } sort(elm+1,elm+elm[0]+1); //排序，为了得到最小字典序 int s=elm[1]; //无奇点从最小的点开始 for(int i=1;i&lt;=n&amp;&amp;s==elm[1];i++) if(deg[elm[i]]%2) s=elm[i]; //有奇点从最小的奇点开始 dfs(s); if(exm() &amp;&amp; list[0]==n+1) //解的长度不为n-1，图一定不联通 for(int i=list[0];i;i--) //一定倒着输出 { char c=list[i]; //再转换成char型 cout&lt;&lt;c; } else printf(\"No Solution\"); return 0; } $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/26/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%97%A0%E5%BA%8F%E5%AD%97%E6%AF%8D%E5%AF%B9/"},{"title":"「题解」旅行","text":"NOIP2018TG D2 T1小 Y 是一个爱好旅行的 OIer。它来到 X 国，打算将各个城市都玩一遍…… 一 题目 原题链接 描述小 Y 是一个爱好旅行的 OIer。她来到 X 国，打算将各个城市都玩一遍。 小Y了解到， X国的 n 个城市之间有 m 条双向道路。每条双向道路连接两个城市。 不存在两条连接同一对城市的道路，也不存在一条连接一个城市和它本身的道路。并且， 从任意一个城市出发，通过这些道路都可以到达任意一个其他城市。小 Y 只能通过这些 道路从一个城市前往另一个城市。 小 Y 的旅行方案是这样的：任意选定一个城市作为起点，然后从起点开始，每次可 以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该 城市时经过的道路后退到上一个城市。当小 Y 回到起点时，她可以选择结束这次旅行或 继续旅行。需要注意的是，小 Y 要求在旅行方案中，每个城市都被访问到。 为了让自己的旅行更有意义，小 Y 决定在每到达一个新的城市（包括起点）时，将 它的编号记录下来。她知道这样会形成一个长度为 n 的序列。她希望这个序列的字典序 最小，你能帮帮她吗？ 对于两个长度均为 n 的序列 A 和 B，当且仅当存在一个正整数 x，满足以下条件时， 我们说序列 A 的字典序小于 B。 对于任意正整数 1 ≤ i &lt; x，序列 A 的第 i 个元素 A_i 和序列 B 的第 i 个元素 B_i 相同。序列 A 的第 x 个元素的值小于序列 B 的第 x 个元素的值。 输入输入文件共 m + 1 行。第一行包含两个整数 n,m(m ≤ n)，中间用一个空格分隔。 接下来 m 行，每行包含两个整数 u,v (1 ≤ u,v ≤ n) ，表示编号为 u 和 v 的城市之 间有一条道路，两个整数之间用一个空格分隔。 输出输出文件包含一行，n 个整数，表示字典序最小的序列。相邻两个整数之间用一个空格分隔。 二 题解蒟蒻的我最先想到的是求字典序最小的拓扑序列… 实际上不然，因为走过的城市不能重复走，除非是回到上一个城市。这两种走法正好对应的dfs的向下递归与回溯。 看数据范围$n = m+1$或$n = m$，也就是说有两种情况：图是树 / 图是基环树。 先看树的情况。 那么上面的走法就可以理解为：选择树上的一个节点，遍历完它的子树，然后再选择该节点的兄弟，重复上述操作。 显然，要想让字典序小，就要让第一次“选择的节点”编号尽量小，因为它排在序列前面。于是肯定要从$1$节点开始，并且把每个节点的子节点排序，从小到大遍历，进行dfs即可。 再说基环树。 基环树：一个树上再任意添加一条边，形成一棵基环树。实际上就是树上多了一个环。 因为走过的节点不能重复走，所以只能经过$m$条边中的$m-1$条。那么我们枚举哪一条边不走，然后图就变成了树，重复上面的操作即可。 复杂度上限$O(nm)$，会T三个点。不难发现不经过的边只会是树边，否则图不连通。于是把求出基环树上的环求出来，非环边剪枝掉，就AC了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int CP=5e3+3;const int CE=CP*5;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne; }vector&lt;int&gt; E[CE];void add(int x,int y){ E[x].push_back(y); E[y].push_back(x);}int n,m,x[CP],y[CP];bool cmp(int* a,int* b){ //a&lt;b for(int i=1;i&lt;=*a;i++) if(a[i] != b[i]) return a[i] &lt; b[i];}void cpy(int *a,int *b){ //copy a -&gt; b for(int i=1;i&lt;=*a;i++) b[i]=a[i];}//求环 bool cir[CP],used[CP];int cut=0;bool getcir(int u,int prv){ used[u] = true; for(int k=0; k&lt;E[u].size(); k++) if(used[E[u][k]] &amp;&amp; E[u][k]!=prv){ //回到自身 cut = u; //记录割顶 return cir[u] = true; } else if(E[u][k]!=prv &amp;&amp; getcir(E[u][k],u)){ cir[u] = true; return u != cut; //又回到割顶时，停止向上返回true } return false;}//dfsint cur[CP],ans[CP],dx,dy;bool vis[CP];bool exm(int u,int v){ return (u!=dx || v!=dy) &amp;&amp; (u!=dy || v!=dx);}void dfs(int u){ vis[u] = true; cur[++cur[0]] = u; for(int k=0; k&lt;E[u].size(); k++) if(!vis[E[u][k]] &amp;&amp; exm(E[u][k], u)) dfs(E[u][k]);}int main(){ memset(ans,0x3f,sizeof(ans)); memset(vis,false,sizeof(vis)); n=read(); m=read(); for(int i=1;i&lt;=m;i++){ x[i]=read(); y[i]=read(); add(x[i],y[i]); } for(int i=1;i&lt;=n;i++) sort(E[i].begin(),E[i].end()); if(n == m+1) //树 { cur[0] = 0; dx = dy = 0; dfs(1); for(int i=1;i&lt;=n;i++) printf(\"%d \",cur[i]); } else //基环树 { getcir(1,0); for(int i=1;i&lt;=m;i++)//枚举每条边 { if(!cir[x[i]] || !cir[y[i]]) continue; memset(vis,false,sizeof(vis)); cur[0] = 0; dx = x[i],dy = y[i]; //删边 dfs(1); if(cur[0]==n &amp;&amp; cmp(cur,ans)) cpy(cur,ans); } for(int i=1;i&lt;=n;i++) printf(\"%d \",ans[i]); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/04/07/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%97%85%E8%A1%8C/"},{"title":"「题解」晕牛","text":"奶牛们发现，在农场里面赛跑是很有趣的一件事…… 一 题目 原题链接 描述奶牛们发现，在农场里面赛跑是很有趣的一件事.可是她们一旦在农场里面不断地转圈，就 会变得头晕目眩.众所周知，眩晕的奶牛是无法产奶的.于是，农夫约翰想要把他农场里面的双 向道路全部改为单向道路，使得他的农场里面一个圈都没有，以避免他的奶牛们被搞得晕头转 向.如果奶牛可以经过若干条道路回到起点，那么这些道路就称为一个圈. 农场有N(1 &lt; N &lt; 100000)片草地，编号为1到N.这些草地由M1条单向 道路和M2条双向道路连接起来.任何一条道路都不会把一片草地和这篇草地本 身连接起来.但是，任意两片草地之间都可能有多条道路连接.不保证任意两片草地之间都有路 径相连. 你的任务是给所有的双向道路设定一个方向，使得整个农场(只剩下单向道路)最后一个圈都 没有.也就是说，不存在一个单向道路序列的终点和起点重合.**数据保证一开始就有的单向道路中，一个圈都没有.**而且一开始就有的单向道路不能改变. 单向道路的起点是草地Ai，终点是草地Bi.双向道路连接草 地Xi,Yi 输入第一行 3 个整数 n，p1，p2，分别表示点数，有向边的数量，无向边的数量。第二行起输入 p1 行，每行 2 个整数，a，b，表示 a 到 b 有一条有向边。接下来输入 p2 行，每行 2 个整数 a，b，表示 a 和 b 中间有一条无向边。 输出对于每条无向边，我们要求按输入顺序输出你定向的结果，也就是如果你输出 a b，那表示你将 a 和 b 中间的无向边定向为 a → b。注意，也许存在很多可行的解。你只要输出其中任意一个就好。 二 题解1 思路可以从原图中存在一个DAG这点切入（上文加黑）。把这个DAG剥离出来，我们可以对其进行拓扑。 然后考虑无向边的定向。如果一个边定向（插入在这个DAG中）之后，使得图上出现了环，那么这个定向显然是错误的，于是可以推倒出最朴素的暴力解法。但是我们已经求出了DAG的拓扑序列，我们能不能通过这个解决问题呢？猜想： 对于一个任意的DAG，新加入一些边，使得这些边仍满足这个DAG的一个拓扑序（任意一个但一定是同一个），那么无论加边多少，加边所得到的新图总是一个DAG。 证明很简单，因为这个新图仍有拓扑序（为上述描述中的那个“任意一个拓扑序”），所以它是DAG。 有了这个结论，只需要按照原DAG的任意一个拓扑序定向无向边，即可解决问题。 2 实现给出代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*结论：对于一个拓扑序列，按拓扑顺序在图中连有向边，则无论加边多少，新图也必定是一个DAG。*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CP=1e5+5;const int CE=CP*2;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}int n,m,p;int u[CP],v[CP];//topo sortint list[CP],in[CP];int ap[CP];void tsort(){ queue&lt;int&gt;Q; for(int i=1;i&lt;=n;i++) if(!in[i]) Q.push(i); while(!Q.empty()) { int cur=Q.front(); Q.pop(); list[++list[0]]=cur; ap[cur]=list[0]; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; in[to]--; if(!in[to]) Q.push(to); } }}int main(){ scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;p); while(m--) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y); in[y]++; } for(int i=1;i&lt;=p;i++) scanf(\"%d%d\",&amp;u[i],&amp;v[i]); tsort(); for(int i=1;i&lt;=p;i++) if(ap[u[i]] &lt; ap[v[i]]) printf(\"%d %d\\n\",u[i],v[i]); else printf(\"%d %d\\n\",v[i],u[i]); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/22/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%99%95%E7%89%9B/"},{"title":"「题解」星球大战","text":"很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系…… 一 题目 原题链接 1 描述很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。 某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。 现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。 2 输入输入文件第一行包含两个整数，N (1 &lt; = N &lt; = 2M) 和 M (1 &lt; = M &lt; = 200,000)，分别表示星球的数目和以太隧道的数目。星球用 0 ~N−1 的整数编号。 接下来的 MM 行，每行包括两个整数 X, Y，其中（ 0 &lt; = X , Y 表示星球 X 和星球 Y 之间有 “以太” 隧道，可以直接通讯。 接下来的一行为一个整数 k ，表示将遭受攻击的星球的数目。 接下来的 k 行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这 k 个数互不相同，且都在 0 到 n-1 的范围内。 3 输出第一行是开始时星球的连通块个数。接下来的 k 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。 二 题解点数太大（$\\le 2\\times 10^5$），肯定不能暴力求连通块。 考虑使用并查集维护连通性。并查集两种基本操作：查找祖先与合并。但是题目中“摧毁一个星球，求出新的连通块数”对应的是并查集的“分裂”操作。这并不容易实现。 我们能不能想一种办法，使得“分裂”操作变成我们熟悉的合并操作。继续考虑：分裂操作增加连通块的数量，合并操作减少连通块的数量。也就是说，不断分裂实际上让连通块不断增加，不断合并让连通块不断减小。这二者有什么关系？很显然，说的通俗一些，分裂就是“倒着”的合并。 所以换个角度，尝试倒着合并。倒序处理数据，将摧毁一个星球看作添加一个星球，合并该星球直接连接的节点，并减少记录的连通块数。 也就是初始化图为炮击完成后的样子，然后第一次加入最后一个被炮击的节点，更新连通块数，以此类推，最后倒序输出连通块数。 这道题也告诉我们：在线处理数据看起来毫无头绪时，如果没有强制在线措施，要考虑能否用离线的方法解决问题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CP=4e5+5;const int CE=CP;//边表class fs{ public: int from,to,nxt; void init(int x,int y,int z) {from=x; to=y; nxt=z;}}E[CE];int hd[CP],ecnt=0;void _add(int x,int y){ E[++ecnt].init(x,y,hd[x]); hd[x]=ecnt;}void add(int x,int y) {_add(x,y); _add(y,x);}//并查集class ufs{ public: int fa[CP]; ufs() {for(int i=1;i&lt;=CP-3;i++) fa[i]=i;} int find(int x) {return fa[x]==x ? x : fa[x]=find(fa[x]);} //找根节点 bool exm(int x,int y) {return find(x)!=find(y);} //判断能否合并 void merge(int x,int y) {fa[find(x)]=find(y);} };ufs s;int n,m,p;int brk[CP];bool isbrk[CP];int ans[CP],tot;void add_node(int x) //添加节点x{ isbrk[x]=false; tot++; //新增一个节点，默认为独立联通块 for(int k=hd[x]; k; k=E[k].nxt) { int to=E[k].to; if(to!=x &amp;&amp; !isbrk[to] &amp;&amp; s.exm(x,to)) { tot--; s.merge(x,to); } }} int main(){ memset(isbrk,false,sizeof(isbrk)); //scan scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y); } scanf(\"%d\",&amp;p); for(int i=1;i&lt;=p;i++) { scanf(\"%d\",&amp;brk[i]); isbrk[brk[i]]=true; } //calc tot=n-p; //初始为没有点 for(int k=1;k&lt;=ecnt;k++) //遍历边表 { fs cur=E[k]; if(isbrk[cur.from] || isbrk[cur.to]) continue; if(s.exm(cur.from, cur.to)) //合并 { tot--; s.merge(cur.from, cur.to); } } ans[p]=tot; //这是最后的连通块数 for(int i=p; i; i--) //倒序加点 { add_node(brk[i]); ans[i-1]=tot; } //print for(int i=0; i&lt;=p; i++) printf(\"%d\\n\",ans[i]); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/03/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98/"},{"title":"「题解」派","text":"你感受过被疯狂卡精度的恐惧吗…… 一 题目 原题链接 描述我的生日要到了！根据习俗，我需要将一些派分给大家。我有N个不同口味、不同大小的派。有F个朋友会来参加我的派对，每个人会拿到一块派（必须一个派的一块，不能由几个派的小块拼成；可以是一整个派）。 我的朋友们都特别小气，如果有人拿到更大的一块，就会开始抱怨。因此所有人拿到的派是同样大小的（但不需要是同样形状的），虽然这样有些派会被浪费，但总比搞砸整个派对好。当然，我也要给自己留一块，而这一块也要和其他人的同样大小。 请问我们每个人拿到的派最大是多少？每个派都是一个高为1，半径不等的圆柱体。 输入第一行包含两个正整数N和F，1 ≤ N, F ≤ 10 000，表示派的数量和朋友的数量。第二行包含N个1到10000之间的整数，表示每个派的半径。 输出输出每个人能得到的最大的派的体积，精确到小数点后三位。 二 题解先分析这个“派的体积”。柱体体积公式$v=sh$，其中底面积$s=\\pi r^2$，故$v=\\pi r^2h$。 再继续分析。若当前确定的派的体积为$v_1$，半径为$r_1$；并且存在一个原体积为$v_2$,半径为$r_2$的派。那么当前这个派可以被切成$\\dfrac{v_1}{v_2}$块，也就是可以分给$\\dfrac{v_1}{v_2}$个人。 分析这个$\\dfrac{v_1}{v_2}$，有$\\dfrac{v_1}{v_2}=\\dfrac{\\pi r_1^2 h_1}{\\pi r_2^2 h_2}$。因$h_1=h_2=1$，上述分式可简化成$\\dfrac{v_1}{v_2}=\\dfrac{r_1^2}{r_2^2}$，也就是说一个派被分成的块数仅与当前确定的$r_1^2$有关（注意是平方）。 那么可以二分这个$r_1^2$，再计算面积即可。为什么不直接二分体积？体积是带着$\\pi$的，一定会是一个浮点数（小数）。二分本来就有精度折损，因此二分体积可能会带来极大的精度问题。 但是本题疯狂卡精度！！既卡最终得数的精度，甚至还卡$\\pi$的精度！真是丧心病狂…解决方法：对于最终得数，用long long储存$r_2$，并且每个$r^2$都乘上1e4以避免精度问题。虽然题面说保留三位小数，但并不代表乘上1e2就能避免被卡！对于$\\pi$，在定义的时候令pi=acos(-1.0)即可。注意要引用cmath（即c中的math.h）库。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;#define LL long longconst int CN=1e4+4;const double pi=acos(-1.0);LL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}//v defineLL n,m,_r[CN];LL l=0,r,mid;LL calc(LL k){ LL sum=0; for(int i=1;i&lt;=n;i++) sum += _r[i]/k; return sum;}int main(){ n=read(); m=read(); m+=1; for(int i=1;i&lt;=n;i++){ _r[i]=read(); (_r[i]*=_r[i])*=10000; //精度 r = max(r, _r[i]); } while(l &lt; r){ mid = (l+r+1)&gt;&gt;1; //强制上取整，避免死循环 if(calc(mid) &gt;= m) l = mid; else r = mid-1; } double v=(pi*l)/10000.0; printf(\"%.3lf\",v); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/04/20/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%B4%BE/"},{"title":"「题解」树的重量","text":"树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”…… 一 题目 原题链接 描述树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。 令N={1..n}，用一个N上的矩阵M来定义树T。其中，矩阵M满足：对于任意的i，j，k，有M[i,j] + M[j,k] &gt;= M[i,k]。树T满足：1．叶节点属于集合N；2．边权均为非负整数；3．dT(i,j)=M[i,j]，其中dT(i,j)表示树上i到j的最短路径长度。 如下图，矩阵M描述了一棵树。树的重量是指树上所有边权之和。对于任意给出的合法矩阵M，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵M。你的任务就是，根据给出的矩阵M，计算M所表示树的重量。下图是上面给出的矩阵M所能表示的一棵树，这棵树的总重量为15。 输入输入数据包含若干组数据。每组数据的第一行是一个整数n(2&lt;n&lt;30)。其后n-1行，给出的是矩阵M的一个上三角(不包含对角线)，矩阵中所有元素是不超过100的非负整数。输入数据保证合法。输入数据以n=0结尾。 输出对于每组输入，输出一行，一个整数，表示树的重量。 二 题解先考虑仅有三个点的情况。如下方左图所示，图中蓝线的长度为$(\\text{dist}(1,3)+\\text{dist}(3,2)-\\text{dist}(1,2))/2$，重量是$dist(1,2)+(\\text{dist}(1,3)+\\text{dist}(3,2)-\\text{dist}(1,2))/2$。不难发现当确定$1\\text{~}k$在树中的位置时，$k+1$可以由前面确定过的任意一条弧（树边）分支而来。类比至右图，蓝线长度依然是$(\\text{dist}(1,n)+\\text{dist}(n,k)-\\text{dist}(1,k))/2$。我们可以得到一个基本公式，即在弧$(1,k)$上新增分支$n$，树的重量会增加图中蓝线大小，也就是$(\\text{dist}(1,n)+\\text{dist}(n,k)-\\text{dist}(1,k))/2$。 那么枚举$n$（设$N$为节点数，$1&lt;n\\leqslant N$），下面的问题就是怎么确定$k$值。边界显然是$1&lt;k&lt;n$，但是这样显然会出现很多种情况，也就是说蓝线的长度是不一定的。但是题目说“对于任意给出的合法矩阵M，它所能表示树的重量是惟一确定的”，也就是说我们需要选出一种长度。题目要求dT(i,j)=M[i,j]，也就是说$\\forall$(n,p),dT(n,p)=M[n,p]，而M[n,p]表示$(n,p)$最短距离，考虑只有一种方案，所以一定要让图中的蓝线最短。故枚举$k$，对每次得到的蓝线长度取$\\min$。 于是可以得到$n-1$个$\\min$值，对其求和就是答案。特殊的，当$n=2$时，蓝线的最小长度就是边$(1,2)$的长度。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN=40;const int INF=0x3f3f3f3f;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n,dist[CN][CN];int main(){ for(n=read();n;n=read()) { memset(dist,0,sizeof(dist)); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) dist[i][j] = dist[j][i] = read(); int ans=dist[1][2]; //确定点 1,2 for(int k=3;k&lt;=n;k++){ int mn=INF; for(int r=2;r&lt;k;r++) //尝试在路径 (1,r) 上构造分支 k mn = min(mn, (dist[1][k]+dist[k][r]-dist[1][r])/2); ans += mn; } printf(\"%d\\n\",ans); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/05/12/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%A0%91%E7%9A%84%E9%87%8D%E9%87%8F/"},{"title":"「题解」消防局的设立","text":"2020年，人类在火星上建立了一个庞大的基地群….. 一 题目 原题链接 描述2020年，人类在火星上建立了一个庞大的基地群，总共有n个基地。起初为了节约材料，人类只修建了n-1条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地A到基地B至少要经过d条道路的话，我们称基地A到基地B的距离为d。 由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过2的基地的火灾。 你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。 输入输入文件的第一行为n （n&lt;=1000），表示火星上基地的数目。接下来的n-1行每行有一个正整数，其中文件第i行的正整数为a[i]，表示从编号为i的基地到编号为a[i]的基地之间有一条道路，为了更加简洁的描述树状结构的基地群，有a[i]&lt;i。 输出输出文件仅有一个正整数，表示至少要设立多少个消防局才有能力及时扑灭任何基地发生的火灾。 二 题解DP解法会很麻烦，并且相对于正常的最小点覆盖，状态更复杂。蒟蒻看了题解的状态设计才有点懂，于是整理下思路（原帖地址）。 首先可以看得出是最小点覆盖问题。一个点可以覆盖和它相邻的点与和它相隔恰好一个点的点。首先是无根树转有根树，题目中说“为了更加简洁的描述树状结构的基地群，有a[i]&lt;i”，所以可以设$1$为总根。 1 状态设计设$f_i$为考虑以$i$为根的子树时的情况。 那么节点$i$有三种可能： 自己是消防站 被子节点（或孙子）覆盖 被父节点（或爷爷）覆盖 其中因为仅考虑以$i$为根的子树，故可能性三表示节点$i$不被覆盖。此时又有两种可能： $i$的儿子和孙子节点都可以被覆盖 $i$的儿子节点不能被覆盖，但是孙子节点可以被覆盖 于是可以得到$f_i$的五种不同状态： 设$f_{i,0}$为$i$节点自己是消防站时，以$i$为根的子树中的最小点覆盖 设$f_{i,1}$为$i$节点的至少一个儿子是消防站时，以$i$为根的子树中的最小点覆盖 设$f_{i,2}$为$i$节点的至少一个孙子是消防站时，以$i$为根的子树中的最小点覆盖 设$f_{i,3}$为$i$节点不能被覆盖，但是它的儿子和孙子节点都可以被覆盖时，以$i$为根的子树中的最小点覆盖 设$f_{i,4}$为$i$节点和它的儿子节点不能被覆盖，但是孙子节点都可以被覆盖时，以$i$为根的子树中的最小点覆盖 2 转移设当前节点为$i$，它的儿子节点为$j$，孙子节点为$k$。为了简便，称以$i$为根的子树为“子树$i$”。 $i$节点自己是消防站时，它的曾孙子节点必须被覆盖。也就是儿子的孙子必须被覆盖，对应$f_{j,4}$（$j$是儿子）故： $$ f_{i,0} = 1+\\sum\\limits_{(i,j)\\in E} f_{j,4}$$ $i$节点的儿子$j$是消防站时：不考虑子树$j$，在$i$其他的所有子树$k_{1,2…}$中，$i$的孙子节点必须被覆盖，对应状态$f_{i,4}$。因为通过$j$可以覆盖到$i$的所有儿子，但是无法覆盖$i$的孙子。故：$$ f_{i,1} =\\min f_{i,4} + f_{j,0} |(i,j)\\in E$$但是有一小部分会重复累加，就是子树$j$中$i$的孙子(也就是$j$的儿子)。所以要减去$j$的儿子全部覆盖时的状态，对应$f_{j,3}$，故：$$ f_{i,1} = \\min f_{i,4} + f_{j,0} - f_{j,3} | (i,j) \\in E$$ $i$节点的孙子$p$是消防站时：若它的父亲为$j$，则$i$的儿子中只有$j$能被覆盖。与上面类似，需要保证$i$的儿子全部被覆盖，对应状态$f_{i,3}$。还是有重复：与上面类似，子树$j$中$i$的曾孙子（$p$的儿子，$j$的孙子）被统计两次，故减去$f_{j,2}$。 $$ f_{i,2} = \\min f_{i,3}+f_{j,1}-f_{j,2} | (i,j) \\in E $$ $i$节点不能被覆盖，那么儿子和孙子一定不是消防站但却能被覆盖（曾孙子是消防站）。考虑到状态的继承，只需要从儿子的状态转移过来就好了。对应状态$f_{j,2}$（$j$是儿子）。 $$ f_{i,3} = \\sum\\limits_{(i,j) \\in E}f_{j,2}$$ $i$节点和它的儿子节点（设为$j$）不能被覆盖，那么$i$的孙子一定不是消防站但却能被覆盖。也就是说$j$的儿子能被覆盖，考虑状态继承，从儿子的状态转移，对应$f_{j,3}$。 $$ f_{i,4} = \\sum\\limits_{(i,j) \\in E}f_{j,3} $$ 3 实现有了方程，实现就简单了。状态二、三的转移需要用到状态四，所先转移状态四。 最后有个地方很迷：$f_{i,1/2/3/4}$需要继承一下前面的状态（就是取一个最小值，见代码44~48行），不然会WA。可能是为了达到最优，但是这会让状态跟定义不符，所以蒟蒻也不是很懂。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN=1e3+3;const int INF=0x7f7f7f7f;class fs{ public: int to,nxt;}E[CN];int hd[CN],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}int n;//dpint f[CN][5];void dfs(int cur){ f[cur][0] = 1; int cst1=INF,cst2=INF; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; dfs(to); f[cur][0] += f[to][4]; //转移需要用到下层状态的状态 f[cur][3] += f[to][2]; f[cur][4] += f[to][3]; cst1 = min(cst1, f[to][0]-f[to][3]); cst2 = min(cst2, f[to][1]-f[to][2]); } //更新并继承下最优解 f[cur][1] = min(f[cur][4]+cst1 ,f[cur][0]); f[cur][2] = min(f[cur][3]+cst2, min(f[cur][0],f[cur][1])); f[cur][3] = min(f[cur][3], f[cur][2]); f[cur][4] = min(f[cur][3], f[cur][4]);}int main(){ scanf(\"%d\",&amp;n); for(int i=2;i&lt;=n;i++) { int x; scanf(\"%d\",&amp;x); add(x,i); } dfs(1); int ans=min(f[1][0], min(f[1][1], f[1][2])); //选一个小的 printf(\"%d\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/03/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B/"},{"title":"「题解」硬币购物","text":"一道有意思的容斥题 + 对于背包求方案数的总结…… 一 题目 原题链接 描述硬币购物一共有4种硬币。面值分别为c1,c2,c3,c4。某人去商店买东西，去了tot次。每次带di枚ci硬币，买si的价值的东西。请问每次有多少种付款方法。 输入第一行 c1,c2,c3,c4,tot 下面tot行 d1,d2,d3,d4,s。 输出每次的方法数。 二 题解直接拆分物品多重背包肯定是要T掉的。 先考虑没有硬币限制的情况，那么就是完全背包求方案数。这里有点东西可说。 完全背包求方案数实际上就是一个完全背包的变形，不过有两种写法：不去重 和 去重，代码如下： 12345678910/* 不去重 */for(int j=1;j&lt;=m;j++) for(int i=1;i&lt;=n;i++) if(j - c[i] == 0) f[j] += 1; else if(j - c[i] &gt; 0) f[j] += f[ j - c[i] ];/* 去重 */for(int i=1;i&lt;=n;i++){ f[ c[i] ] += 1; for(int j=c[i];j&lt;=m;j++) f[j] += f[ j - c[i] ];} 这两份代码的本质区别就是循环的顺序：先枚举物品 还是 先枚举空间。但是为什么对呢。 实际上，先枚举物品可以理解做人为地制定了一个取物品的“顺序”，一个物品在转移的时候，前面的物品就已经不可能再次被用来转移状态，因此不会出现重复；先枚举空间则反之。 然后是考虑容斥。 答案的容斥首先，对于给定的 s ，在不考虑限制的情况下，答案一定为 f[s] 。 现在来考虑限制。什么样的状态是不合法的？不妨我们先假定取了 (di+1) 枚硬币 i ，这肯定是不行的。考虑这部分硬币对答案的贡献：取过它们之后，还剩下 (s-ci(di+1)) 的面值没有被凑出，这一部分一共有 f[s-ci(di+1)] 种选取方案，那么一定包含 (di+1) 枚硬币 i 的方案的数量就是 1×f[s-ci(di+1)] = f[s-ci(di+1)] 。这部分是不合法的，因此减掉，答案变成 f[s] - f[s-ci(di+1)] 。 然后就是简单的容斥了：把减了两遍的部分加回来，再把加了两遍的部分减回去，再加，再减 …… 直到最后的区间两两无交（或只剩一个区间）。 然后就做完了，代码太丑就不放了，核心部分是这样的： 12345678910111213141516int k1 = (d[1]+1)*c[1],k2 = (d[2]+1)*c[2],k3 = (d[3]+1)*c[3],k4 = (d[4]+1)*c[4];if(s-k1 &gt;= 0) ans -= f[s-k1];if(s-k2 &gt;= 0) ans -= f[s-k2];if(s-k3 &gt;= 0) ans -= f[s-k3];if(s-k4 &gt;= 0) ans -= f[s-k4];if(s-k1-k2 &gt;= 0) ans += f[s-k1-k2];if(s-k1-k3 &gt;= 0) ans += f[s-k1-k3];if(s-k1-k4 &gt;= 0) ans += f[s-k1-k4];if(s-k2-k3 &gt;= 0) ans += f[s-k2-k3];if(s-k2-k4 &gt;= 0) ans += f[s-k2-k4];if(s-k3-k4 &gt;= 0) ans += f[s-k3-k4];if(s-k1-k2-k3 &gt;= 0) ans -= f[s-k1-k2-k3];if(s-k1-k2-k4 &gt;= 0) ans -= f[s-k1-k2-k4];if(s-k1-k3-k4 &gt;= 0) ans -= f[s-k1-k3-k4];if(s-k2-k3-k4 &gt;= 0) ans -= f[s-k2-k3-k4];if(s-k1-k2-k3-k4 &gt;= 0) ans += f[s-k1-k2-k3-k4]; $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/10/23/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/"},{"title":"「题解」直径","text":"小Q最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有N个节点，可以证明其有且仅有N-1 条边…… 一 题目 原题链接 描述小Q最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有N个节点，可以证明其有且仅有N-1 条边。 路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用 dis(a,b)表示点a和点b的路径上各边长度之和。称dis(a,b)为a、b两个节点间的距离。 直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。 现在小Q想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。 输入第一行包含一个整数N，表示节点数。 接下来N-1行，每行三个整数a, b, c ，表示点 a和点b之间有一条长度为c的无向边。 输出共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。 二 题解第一问模板题水题渣渣题秒切不用多说，关于树的直径的两遍dfs求法请参见。 关键是第二问。如下图，不难发现，树上的若干直径必然有交且相交的部分必然是一个连续的区间。设该区间的两个端点为$M,N$，我们只需要确定$M,N$的位置即可。 先考虑橙色的那条直径，设它的两个端点为$l,r$，如下图。设$lgstchain[i]$为从任意一个橙色节点$i$，不经过任何橙色节点所能得到的最长链的长度。例如图中，有$lgstchain[1]=lgstchain[2]=lgstchain[3]=0,lgstchain[4]=100$。由$l\\to r$遍历这条直径（转为有根树），假设当前遍历到的节点为$x$。假定$l\\to x$部分为另一条直径，则当存在$lgstchain[i] = \\text{dist}(x,r)$时，当前直径剩下的路程可以被另一条链替代，我们即找到了两条直径的分叉点，即图中的$M$点。注意，需要找到离$l$最近的那个分叉点。同理，由$r\\to l$遍历直径，可以找到另外一个分叉点$N$点。求出$(M,N)$之间有多少条边，即解决了问题二。 代码有点长，效率其实也不高，不过AC足矣。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CP=2e5+5;const int CE=CP*10;const LL INF=0x3f3f3f3f3f3f3f3f;//快读 LL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;} //边表 class fs{ public: int to,nxt; LL dist; void init(int x,int y,LL d) {to=x; nxt=y; dist=d;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y,LL z){ E[++ecnt].init(y,hd[x],z); hd[x]=ecnt;}int n;//diameterint l,r,N,M;LL dr[CP],D;bool vis[CP];void dfs1(int u){ vis[u] = true; for(int k=hd[u]; k; k=E[k].nxt){ int v=E[k].to; if(!vis[v]){ dr[v] = dr[u] + E[k].dist; dfs1(v); } }}LL dm(){ memset(dr,-0x3f,sizeof(dr)); memset(vis,0,sizeof(vis)); dr[1] = 0; dfs1(1); LL mx=-INF; for(int i=1;i&lt;=n;i++) if(dr[i] &gt; mx) mx = dr[r=i]; memset(dr,-0x3f,sizeof(dr)); memset(vis,false,sizeof(vis)); dr[r] = 0; dfs1(r); mx = -INF; for(int i=1;i&lt;=n;i++) if(dr[i] &gt; mx) mx = dr[l=i]; return D = dr[l];}//对于直径点跑新的最长链 LL lgstchain[CP];void dfs2(int u,int prv,LL curchain,LL&amp; rec){ for(int k=hd[u];k;k=E[k].nxt){ int v=E[k].to; if(v!=prv &amp;&amp; !vis[v]){ rec = max(rec, curchain+E[k].dist); dfs2(v,u,curchain+E[k].dist,rec); } }} //寻路算法 int nxtnode[CP];bool find_path(int u,int prv,int t){ if(u == t){ nxtnode[u] = 0; return true; } for(int k=hd[u]; k; k=E[k].nxt){ int v = E[k].to; if(v != prv){ if(find_path(v,u,t)){ nxtnode[u] = v; return true; } } } return false;}int main(){ n = read(); for(int i=1;i&lt;n;i++){ int x=read(),y=read(); LL z=read(); add(x,y,z); add(y,x,z); } printf(\"%lld\\n\",dm()); memset(vis,false,sizeof(vis)); memset(nxtnode,0,sizeof(nxtnode)); find_path(l,0,r); for(int i=l;i;i=nxtnode[i]) vis[i] = true; for(int i=l;i;i=nxtnode[i]){ lgstchain[i] = 0; dfs2(i,0,0,lgstchain[i]); } M = N = 0; for(int i=l;i;i=nxtnode[i]) //l -&gt; r if(lgstchain[i] == dr[i]){ N = i; break; } memset(nxtnode,0,sizeof(nxtnode)); find_path(r,0,l); for(int i=r;i;i=nxtnode[i]) //r -&gt; l if(lgstchain[i] == D-dr[i]){ M = i; break; } memset(nxtnode,0,sizeof(nxtnode)); find_path(N,0,M); int cnt = 0; for(int i=N;i;i=nxtnode[i]) cnt++; printf(\"%d\",cnt-1); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/24/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%9B%B4%E5%BE%84/"},{"title":"「题解」灾后重建","text":"B地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车…… 一 题目 原题链接 描述给出B地区的村庄数N，村庄编号从0到N-1，和所有M条公路的长度，公路是双向的。并给出第i个村庄重建完成的时间t_i ，你可以认为是同时开始重建，并在第t_i天重建完成，并且在当天即可通车。若t_i为0则说明地震未对此地区造成损坏，一开始就可以通车。之后有Q个询问(x, y, t)，对于每个询问你要回答在第t天，从村庄x到村庄y的最短路径长度为多少。如果无法找到从x村庄到y村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未重建完成 ，则需要返回−1。 输入第一行包含两个正整数N,M，表示了村庄的数目与公路的数量。 第二行包含N个非负整数$ t_0, t_1,…, t_{N-1} $，表示了每个村庄重建完成的时间，数据保证了$t_0 ≤ t_1 ≤ … ≤ t_{N-1}$。 接下来M行，每行3个非负整数i,j,w，w为不超过10000的正整数，表示了有一条连接村庄i与村庄j的道路，长度为w，保证i≠j，且对于任意一对村庄只会存在一条道路。 接下来一行也就是M+3行包含一个正整数Q，表示Q个询问。接下来Q行，每行3个非负整数x,y,t，询问在第t天，从村庄x到村庄y的最短路径长度为多少，数据保证了t是不下降的。 二 题解简化题意，就是给定一张无向图，并且节点$i$在时间$t_i$时才可用，求任意时间两个节点间的最短路（不连通输出-1）。 “任意点间最短路”，是不是有点钦点floyd的意味？ 看floyd的转移方式。设$f_{i,j,k}$表示仅考虑经过前$k$个点中转，点$i$到$j$的最短路。 $f_{i,j,k}$可以继承前面的状态（$f_{i,j,k-1}$），也可以尝试用新增的节点$k$来中转，那么转移方程：$$ f_{i,j,k} = \\min f_{i,j,k-1},f_{i,k,k-1}+f_{k,j,k-1} |(i,k) \\in E,(k,j) \\in E $$ 状态$f_{i,j}$的转移来自同一个层级（都是$k-1$），那么$k$这一维可以滚动（不过$k$一定在最外重循环）。转移方程变成：$$ f_{i,j} = \\min f_{i,j},f_{i,k}+f_{k,j} |(i,k) \\in E,(k,j) \\in E $$ 那么也就是说：随着$k$的变化，所经过的中转节点不断增加，从而使得最短路不断松弛。而本题就是要控制最短路经过的中转节点，在仅经过一些节点的情况下求出最短路。 也就有了下面的想法：把村庄按修建时间升序排序，以该顺序作为$k$这一维循环的顺序，来更新最短路。这样就能控制在某一时刻内，仅有$t_i \\leqslant t_k$的村庄$i$可以参与中转最短路。然后离线处理询问。把每个询问按照询问时间升序排序，若当前前$k$个村庄更新后可以回答（排序后的）第一个问题（$t_k \\geqslant t_q$，$t_q$是询问的时间），那么就记录答案，并删掉这个问题。不考虑排序消耗的时间，复杂度大约是$O(n^3+q)$。 但是出题人很良心：数据是排好序的（题目中加粗了）。那么直接排，然后顺序处理询问就好了。 注意点的编号是$0 \\text{~} n-1$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CN=220;const int INF=0x3f3f3f2f;//v defineint f[CN][CN],k=1,n,m,q;int bt[CN];void init(){ memset(f,0x3f,sizeof(f)); for(int i=1;i&lt;=n;i++) f[i][i]=0;}int main(){ n=read(); m=read(); init(); for(int i=1;i&lt;=n;i++) bt[i] = read(); while(m--){ int x=read(),y=read(),z=read(); x+=1; y+=1; //把编号变成1 ~ n f[x][y] = f[y][x] = z; } q=read(); while(q--) { int x=read(),y=read(),t=read(); x+=1; y+=1; if(bt[x]&gt;t || bt[y]&gt;t){ printf(\"-1\\n\"); continue; } while(bt[k]&lt;=t &amp;&amp; k&lt;=n){ //分段更新，每次一直更新到当前时间 = 询问时间 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) f[i][j] = min(f[i][j], f[i][k]+f[k][j]); k++; } if(f[x][y] &gt; INF) printf(\"-1\"); else printf(\"%d\",f[x][y]); printf(\"\\n\"); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/24/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA/"},{"title":"「题解」糖果","text":"幼儿园里有 $N$ 个小朋友，$\\text{lxhgww}$ 老师现在想要给这些小朋友们分配糖果…… 一 题目 原题链接 描述幼儿园里有 $N$ 个小朋友，$\\text{lxhgww}$ 老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，$\\text{lxhgww}$ 需要满足小朋友们的 $K$ 个要求。幼儿园的糖果总是有限的，$\\text{lxhgww}$ 想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求 输入输入的第一行是两个整数 $N$，$K$。接下来 $K$ 行，表示这些点需要满足的关系，每行 $3$ 个数字，$X$，$A$，$B$。如果 $X=1$， 表示第 $A$ 个小朋友分到的糖果必须和第 $B$ 个小朋友分到的糖果一样多；如果 $X=2$， 表示第 $A$ 个小朋友分到的糖果必须少于第 $B$ 个小朋友分到的糖果；如果 $X=3$， 表示第 $A$ 个小朋友分到的糖果必须不少于第 $B$ 个小朋友分到的糖果；如果 $X=4$， 表示第 $A$ 个小朋友分到的糖果必须多于第 $B$ 个小朋友分到的糖果；如果 $X=5$， 表示第 $A$ 个小朋友分到的糖果必须不多于第 $B$ 个小朋友分到的糖果。 输出输出一行，表示 $\\text{lxhgww}$ 老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 $-1$。 二 题解本题的差分约束实现需要变一下，但不着急，先分析给出的条件。 罗列如下： |编号|条件|变换||—-|—-|—-|—-||1|$x_a=x_b$|$x_a-x_b \\leqslant 0,x_b-x_a \\leqslant 0$||2|$x_a-x_b &lt; 0$|$x_a-x_b \\leqslant -1$||3|$x_a-x_b \\geqslant 0$|$x_b-x_a \\leqslant 0$||4|$x_a-x_b &gt; 0$|$x_b-x_a \\leqslant -1$||5|$x_a-x_b \\leqslant 0$| \\ | 在使用最短路求解差分约束的时候，不难发现影响系统的解（单源最短路）的只有图上的负权边。 对于本题，因为边权仅存在$0$或$-1$两种情况，故所求的最短路长度一定为负数或零。对于负数，原来的不等关系会不成立（它们仅针对正数），从而使求解出现一些偏差。也就是说，我们求出的解实际上是不等式解的相反数。进一步来讲，对于所有的$d_i$，满足$ -d_a - (-d_b) \\leqslant C$，与题目中推出的三角形不等式恰好相反！那直接这样建边一定是不行的。我们需要把题目中的条件乘上一个$-1$，这样我们求解最短路之后，$x_i=-d_i$才会是答案。 如下： 编号 原不等式 新不等式 对应连边 1 $x_a-x_b \\leqslant 0,x_b-x_a \\leqslant 0$ 同前 $ \\text{add(a,b,0) ;add(b,a,0)}$ 2 $x_a-x_b \\leqslant -1$ $x_b-x_a \\leqslant -1$ $ \\text{add(a,b,-1)}$ 3 $x_b-x_a \\leqslant 0$ $x_a-x_b \\leqslant 0$ $ \\text{add(b,a,0)}$ 4 $x_b-x_a \\leqslant -1$ $x_a-x_b \\leqslant -1$ $ \\text{add(b,a,-1)}$ 5 $x_a-x_b \\leqslant 0$ $x_b-x_a \\leqslant 0$ $ \\text{add(a,b,0)}$ 另，每个小朋友至少有一个糖果，所以最短路径长度需要初始为$-1$。 还有一个坑点（毒瘤），测试点#6是一个很长的链，所以在新建原点时，必须倒序连边，防止每次都会走链然后被卡TLE。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int CP=1e5+5;const int CE=CP*1008;const LL INF=0x7f7f7f7f7f7f3f3f;class fs{ public: int to,nxt; LL dist; void init(int t,int n,LL d){ to=t; nxt=n; dist=d; }}E[CE];int hd[CP],ecnt=0;void add(int x,int y,LL z){ E[++ecnt].init(y,hd[x],z); hd[x]=ecnt;}int n,m;//spfaLL d[CP];int times[CP];bool ins[CP];bool spfa(int s){ memset(d,0x3f,sizeof(d)); memset(ins,false,sizeof(ins)); memset(times,0,sizeof(times)); d[s]=0; queue&lt;int&gt;Q; Q.push(s); while(!Q.empty()) { int u=Q.front(); Q.pop(); ins[u]=false; for(int k=hd[u]; k; k=E[k].nxt) { fs e=E[k]; if(d[e.to] &gt; d[u]+e.dist) //最短路 { d[e.to] = d[u]+e.dist; if(!ins[e.to]) { Q.push(e.to); ins[e.to]=true; if(++times[e.to] == n) //判负环 return false; } } } } return true;}int main(){ bool flag=false; scanf(\"%d%d\",&amp;n,&amp;m); while(m--) { int x,a,b; scanf(\"%d%d%d\",&amp;x,&amp;a,&amp;b); if(x==1){ add(a,b,0); add(b,a,0); } if(x==2){ //出现负自环边直接退出 if(a == b){ flag=true; break; } add(a,b,-1); } if(x==3) add(b,a,0); if(x==4){ if(a == b){ flag=true; break; } add(b,a,-1); } if(x==5) add(a,b,0); } for(int i=n; i; i--) //新建总源（必须倒序循环） add(0,i,-1); //这里相当于初始最短路径长度 if(spfa(0) &amp;&amp; !flag) { LL sum=0; for(int i=1;i&lt;=n;i++) sum+=d[i]; printf(\"%lld\",-sum); //对sum取相反数 } else printf(\"-1\"); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%B3%96%E6%9E%9C/"},{"title":"「题解」统计单词个数","text":"阶梯（打表）式AC…… 一 题目 原题链接 描述给出一个长度不超过200的由小写英文字母组成的字母串(约定;该字串以每行20个字母的方式输入，且保证每行一定为20个)。要求将此字母串分成kk份(1&lt;k≤40)，且每份中包含的单词个数加起来总数最大(每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串this中可包含this和is，选用this后就不能包含th)。 单词在给出的一个不超过6个单词的字典中。 要求输出最大的个数。 输入每组的第一行有2个正整数(p,k)p表示字串的行数,k表示分为k个部分。接下来的p行，每行均有20个字符。再接下来有1个正整数s，表示字典中单词个数。(61≤s≤6)接下来的s行，每行均有1个单词。 输出1个整数，分别对应每组测试数据的相应结果。 二 题解个人感觉比较可做的一道DP。 解法：预处理+DP 设$f_{i,j}$为考虑区间$[1,j]$，划分$i$个区间的最优解。设$s_{i,j}$为区间$[i,j]$内单词的数量，那么转移方程：$$ f_{i,j} = \\max\\limits_{i-1 \\leqslant b &lt; j} f_{i-1,b}+s_{b+1,j} $$ 剩下的问题是预处理$s_{i,j}$。很明显它可以由上层状态得出，即$s_{i,j}=s_{i+1,j}$。上面的式子是状态继承，下面考虑更新：若存在以当前第$i$个字符开头的单词，并且该单词能在区间$[i,j]$里与原文本串匹配，那么$s_{i,j} = s_{i+1,j}+1$。只需要加一，因为同开头的单词只考虑一个。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN=5e2+2;int p,k,s;string org,dic[10];int sum[CN][CN]; //sum[i][j] : 区间 [i,j] 所包含的单词数 int f[CN][CN]; //f[i][j] : 前 j 个字符划 i 个区间的最大单词总数 bool match(int bg,int ed){ for(int i=1;i&lt;=s;i++){ //遍历字典 int pos=0,sz=dic[i].size(); while(org[bg+pos]==dic[i][pos] &amp;&amp; bg+pos&lt;=ed) pos++; if(pos==sz) //当前单词可以在区间 [bg,ed] 中被匹配到 return true; } return false;} int main(){ scanf(\"%d%d\",&amp;p,&amp;k); for(int i=1;i&lt;=p;i++){ string line; cin&gt;&gt;line; org += line; } scanf(\"%d\",&amp;s); for(int i=1;i&lt;=s;i++) cin&gt;&gt;dic[i]; int n=org.size(); for(int i=n; i; i--) for(int j=i; j&lt;=n; j++) sum[i][j] = match(i-1,j-1) ? sum[i+1][j]+1 : sum[i+1][j]; for(int i=1; i&lt;=k; i++) for(int j=1; j&lt;=n; j++) //[1,j] for(int brk=i-1; brk&lt;j; brk++) //枚举断点 f[i][j] = max(f[i][j], f[i-1][brk]+sum[brk+1][j]); printf(\"%d\",f[k][n]); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/04/23/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0/"},{"title":"「题解」组合数问题","text":"组合数 $C_n^m$ 表示的是从 n 个物品中选出 m 个物品的方案数。举个例子，从 (1,2,3) 三个物品中选择两个物品可以有 (1,2),(1,3),(2,3) 这三种选择方法…… 一 题目 原题链接 描述组合数 $C_n^m$ 表示的是从 n 个物品中选出 m 个物品的方案数。举个例子，从 (1,2,3) 三个物品中选择两个物品可以有 (1,2),(1,3),(2,3) 这三种选择方法。根据组合数的定义，我们可以给出计算组合数 $C_n^m$ 的一般公式：$$ C_n^m=\\dfrac{n!}{m!(n-m)!} $$其中n!=1×2×⋯×n；特别地，定义 0!=1。 小葱想知道如果给定 n,m 和 k，对于所有的 0≤i≤n,0≤j≤min(i,m) 有多少对 (i,j)满足 $C_i^j$ 是 k 的倍数。 输入第一行有两个整数 t,k，其中 t 代表该测试点总共有多少组测试数据，k 的意义见问题描述。接下来 t 行每行两个整数 n,m，其中 n,m 的意义见问题描述。 输出共 t 行，每行一个整数代表所有的 0≤i≤n,0≤j≤min(i,m) 中有多少对 (i,j) 满足 $C_i^j$ 是 k 的倍数。 二 题解打表出奇迹系列。 排列组合排列数$A_n^m$表示从$n$个不同元素中取$m$($m\\leqslant n$)个形成一个排列，所得到的排列的总数。组合数 $C_n^m$表示从$n$个不同元素中取$m$个形成一个集合，所得到的集合的个数。因为集合具有互异性，故集合是不能存在重复的（排列不同），因此组合数可以看作去重之后的排列数。 排列数计算通式：$A_n^m = \\dfrac{n!}{(n-m)!} $组合数计算通式：$ C_n^m = \\dfrac{A_n^m}{m!} = \\dfrac{n!}{m!(n-m)!} $组合恒等式：$C_n^m = C_{n-1}^{m-1} + C_{n-1}^m $ 其中当$m=0$或$m=n$时，有$C_n^m=1$。此题数据范围小（$n,m\\leqslant 2000$），故我们可以预先处理出所有的$C$值，用组合恒等式递推即可。题目中要求出能被$k$整除的组合数个数，所以每个$C$值都模上一个$k$，那么模完为$0$的$C$值即可被$k$整除。 前缀和题目要求出某一矩阵内的为$0$的$C$值的数量，这个用前缀和跑一下就可以了。矩阵的前缀和定义为矩阵内所有元素的权值之和。 数列前缀和递推式：$s_i = s_{i-1} + a_i$矩阵前缀和递推式：$s_{i,j} = s_{i-1,j}+s_{i,j-1}-s_{i-1,j-i} +a_{i,j}$ 然后所有数据我们都预处理出来了，接下来一个一个回答询问就好了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=((s&lt;&lt;1)+(s&lt;&lt;3))+c-'0'; return s*ne;}const int CN=2e3+2;int t,k,n,m;int c[CN][CN],ans[CN][CN];int calc(int sz){ for(int i=0;i&lt;=sz;i++) c[i][0] = c[i][i] = 1; for(int i=1;i&lt;=sz;i++) //递推组合数 for(int j=1;j&lt;i;j++) c[i][j] = (c[i-1][j-1]%k+c[i-1][j]%k)%k; for(int i=1;i&lt;=sz;i++) //前缀和 for(int j=1;j&lt;=sz;j++){ ans[i][j] = ans[i][j-1]+ans[i-1][j]-ans[i-1][j-1]; if(!c[i][j] &amp;&amp; i&gt;=j) ans[i][j]++; //i&lt;j的组合数是没有意义的 }}int main(){ t=read(); k=read(); calc(2000); //直接把数据范围内的全部处理出来 while(t--) printf(\"%d\\n\",ans[read()][read()]); //回答询问 return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/"},{"title":"「题解」糖果传递","text":"我真是烦这种数学题啊，让人头秃。 ——某巨佬 一 题目 原题链接 描述有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。现要使每个小朋友获得均等糖果，请求出最小代价。 输入小朋友个数n。下面n行 ai。 输出求使所有人获得均等糖果的最小代价。 二 题解这种题型大概有两种通解：费用流解法（如网络流24题中的负载平衡问题）和数学解法。但是解法一特别容易被卡MLE，能运行的数据范围大概只有$n\\leqslant 100$，所以这题来谈谈数学解法。 假设有五个小朋友1,2,3,4,5，其中1号给了2号5颗糖，2号给了1号1颗糖，1号给了5号3颗糖，也可以看作1号给了5号3颗糖，2号给了1号-4颗糖。于是可以得出一个结论，即任意一个人给别人的糖数总可以看作一个定值。假设1号只给5号糖，2号只给1号糖，……，5号只给4号糖，且给的糖数分别为$x_1,x_2,…,x_5$，那么$x_1,x_2,…,x_5$一定有绝对值最小的确定的值。现在我们要使$\\sum\\limits_{1\\leqslant i\\leqslant 5}|x_i|$最小，显然要求出这些“确定的值”。 因为每个人最终拿到的糖数为$\\sum\\limits_{1\\leqslant i\\leqslant n}a_i \\div n$，设这个数为$\\overline a$，则有以下等式：$$\\begin{aligned} &amp; a_1 = \\overline a - x_2 + x_1 \\newline &amp; a_2 = \\overline a - x_3 + x_2 \\newline &amp; … \\newline &amp; a_5 = \\overline a - x_1 + x_5 \\end{aligned}$$移项，得：$$\\begin{aligned} &amp; x_2 = x_1 - (a_1-\\overline a) \\newline &amp; x_3 = x_2 - (a_2 - \\overline a) \\newline &amp; … \\newline &amp; x_5 = x_1 - (a_5 - \\overline a)\\end{aligned}$$将前式分别带入后式可得：$$\\begin{aligned} &amp; x_1 = x_1 \\newline &amp;x_2 = x_1 - (a_1-\\overline a) \\newline &amp;x_3 = x_1 - (a_1 + a_2 - 2\\overline a) \\newline &amp;… \\newline &amp;x_5 = x_1 - (a_1+a_2+a_3+a_4 - 4\\overline a)\\end{aligned}$$可知：$$ x_n = x_1 - (\\sum\\limits_{1\\leqslant 1&lt; n}a_i - (n-1)\\times \\overline a) $$ 设$c_1 = a_1 - \\overline a,c_2 = a_1 + a_2 - 2\\overline a,…$，以此类推，可知$x_n = x_1 - c_{n-1}$。同时有递推式$c_i = c_{i-1} + a_i - \\overline a$。这个递推式与$x$取值无关，且总有$c_0 = 0$，因此可以计算出所有$c_i$的值。 又有$x_2 = x_1 - c_1,x_3= x_1- c_2,…$，则$\\sum\\limits_{1\\leqslant i\\leqslant 5}|x_i|$可表示为：$$ |x_1| + |x_1 -c_1| +|x_1-c_2| + … +|x_1-c_4| $$这也可以看作数轴上每个$c_i$到$x_1$的距离之和。那么我们就要找一个$x_1$，使得在数轴上它到每个$c_i$的距离最小。这个$x_1$即是$c_1,c_2,…,c_4$的中位数。 证明先把$c_1,c_2,…,c_4$排好序，表示在数轴上，如下图所示。任取一$x_1$，则距离之和可以化为$\\text{dist}(c_1,c_4) + \\text{dist}(c_2,c_3) +2\\times \\text{dist}(c_2,x_1)$。其中$\\text{dist}(c_1,c_4) + \\text{dist}(c_2,c_3)$为定值，那么让$\\text{dist}(c_2,x_1) $最小一定会更优一点。它的最小值为$0$，此时$x_1$选在$c_2$上。归纳，可知将$x_1$选在$c_1\\text{~}c_4$中的一个点上一定要优一点。 然后再分别尝试$c_1,c_2,…,c_4$这些点，不难发现$x_1$选的越靠中间距离之和越小，故可知$x_1$取$c_1,c_2,…,c_4$的中位数。 那么$x_1$就很好求了，于是我们就解决了这个问题。注意当$n$为偶数时，两个中位数取哪一个都可以。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define LL long longLL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=((s&lt;&lt;1)+(s&lt;&lt;3))+c-'0'; return s*ne;}const int CN=1e6+6;LL n,x1,a[CN],c[CN],_a;LL llabs(LL a) {return a&gt;0 ? a:-a;}int main(){ n=read(); LL sigma = 0; for(int i=1;i&lt;=n;i++) a[i] = read(),sigma += a[i]; _a = sigma/n; //求平均值 c[0] = 0; for(int i=1;i&lt;=n;i++) c[i] = c[i-1]+a[i]-_a; //递推c[i] sort(c+1,c+n+1); x1 = c[(n+1)/2]; //计算中位数 LL ans=0; for(int i=1;i&lt;=n;i++) ans += llabs(x1-c[i]); //求代价 printf(\"%lld\\n\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92/"},{"title":"「题解」苗条的生成树","text":"给定一张连通图，求所有生成树中最大边权与最小边权差最小的，输出它们的差值…… 一 题目 原题链接 描述求所有生成树中最大边权与最小边权差最小的，输出它们的差值。 输入输入文件包含多组测试数据，每组测试数据如下： 第1行：2个整数n m （2 ≤ n ≤ 100 and 0 ≤ m ≤ n(n − 1)/2），n表示顶点数，m表示边数。接下来m行，每行3个空格分开的整数a b w（1 ≤ w ≤ 10000） , 表示顶点a与顶点b之间有一条边，权值为w。 输出对每组测试数据，如果图存在生成树，输出生成树的差值最小的；否则，输出-1。 二 题解$n$不大，考虑暴力。 把边权升序排序，每次固定mst的第一条边，那么最后一条边也肯定固定了。（贪心原理：最后一条边越靠前差值越少）。枚举起始边，kruskal求最小生成树，维护最优解就好了。 复杂度大约是$O(q(m^2 +mlogm))$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CP=110;const int CE=CP*CP;const int INF=0x3f3f3f3f;class fs{ public: int from,to,dist; void init(int f,int t,int d) {from=f; to=t; dist=d;} bool operator &lt; (const fs&amp; e)const {return dist&lt;e.dist;}}E[CE];int ecnt=0;void add(int x,int y,int z){ E[++ecnt].init(x,y,z);}//并查集class ufs{ public: int fa[CP]; ufs() {for(int i=1;i&lt;CP;i++) fa[i]=i;} void init() {for(int i=1;i&lt;CP;i++) fa[i]=i;} int find(int u) {return fa[u]==u ? u : fa[u]=find(fa[u]);} bool exm(int x,int y) {return find(x)!=find(y);} void merge(int x,int y) {fa[find(x)]=find(y);}}s;//v defineint n,m;//mstint mst(){ sort(E+1,E+ecnt+1); int ans=INF; for(int st=1; st&lt;=ecnt; st++) //枚举起始边 { s.init(); int cnt=0,lst=-1; for(int k=st; k&lt;=ecnt&amp;&amp;cnt!=n-1; k++) //kruskal { fs e=E[k]; if(!s.exm(e.from,e.to)) continue; s.merge(e.from,e.to); lst=k; cnt++; } if(cnt != n-1) continue; //没能生成mst ans = min(ans, E[lst].dist-E[st].dist); //维护 } return ans==INF ? -1 : ans;}int main(){ //freopen(\"out.out\",\"w\",stdout); n=read(); m=read(); while(n) { ecnt = 0; //forward-star init while(m--) { int x=read(),y=read(),z=read(); add(x,y,z); } printf(\"%d\\n\",mst()); n=read(); m=read(); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/24/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%8B%97%E6%9D%A1%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91/"},{"title":"「题解」秦腾与教学评估","text":"在秦腾进入北京大学学习的第一个学期，就不幸遇到了前所未有的教学评估…… 一 题目 原题链接 描述在秦腾进入北京大学学习的第一个学期，就不幸遇到了前所未有的教学评估。 在教学评估期间，同学们被要求八点起床，十一点回宿舍睡觉，不 准旷课，上课不准迟到，上课不准睡觉……甚至连著名的北大三角地也在教学评估期间被以影响校容的理由被拆除。这些“变态”规定令习惯了自由自在随性生活学习的北大同学叫苦不迭。 这一天又到了星期五，一大早就是秦腾最不喜欢的高等代数课。可是因为是教学评估时期，不能迟到，于是他在八点五分的 时候挣扎着爬出了宿舍，希望能赶快混进在八点钟已经上课了的教室。 可是，刚一出宿舍楼门他就傻眼了: 从宿舍到教学楼的路上已经站满了教学评估团的成员。他们的目的就是抓住像他这样迟到的学生，扣除学校的分数。 秦腾当然不能让评估团得逞。他经过观察发现，整个评估团分成了N个小组，每个小组的成员都分布在从宿舍楼到教学楼的路上的某一段，并且同一小组的成员间的距离是相等的。于是，我们可以用三个整数S, E, D来描述评估团的小组: 既该小组的成员在从宿舍到教学楼的路上的:S, S + D, S + 2D, …, S + KD (K ∈ Z, S + KD ≤ E, S + (K + 1)D &gt; E)位置。 观 察到了教学评估团的这一特点，又经过了认真的思考，秦腾想出了对策: 如果在路上的某一位置有奇数个教学评估团成员，他就可以运用调虎离山，声东击西，隔山打牛，暗度陈仓……等方法，以这一地点为突破口到达教学楼。 但是由于 教学评估团的成员的十分狡猾，成员位置安排的设计极其精妙，导致在整条路上几乎没有这样的位置出现。即使由于安排不慎重出现了这样的位置，最多也仅有一个。 现在秦腾观察出了所有小组的安排，但是由于整个教学评估团的人数太多，他实在看不出这样的位置是否存在。 现在，你的任务是写一个程序，帮助他做出判断。 输入输入文件的第一行为一个整数T。接下来输入T组相互独立的测试数据。每组测试数据的第一行包含一个整数，代表N接下来的N行，每行三个整数Si, Ei, Di, 代表第i个小组对应的三个参数。 输出对于每个测试数据，如果题目中所求的位置不存在，既任意位置都有偶数个教学评估团的成员存在，在输出文件的中打印一行:Poor QIN Teng:( (不包含引号)否则打印两个整数Posi, Count，代表在唯一的位置Posi，有Count个教学评估团的成员。根据题意，Count应为奇数。 二 题解简化题意：在一条线段上分布着$n$组点，每组点有三个参数$s_i,e_i,d_i$，表示在区间$[s_i,e_i]$内，该线段从$s_i$处开始每隔$d_i$的距离有一个点。已知线段上有至多一处位置上的点数为奇数，现在要求你判断是否存在这样的位置，求出它的位置和该位置上点的数量。 至多有一个位置上的点数为奇数，说明若存在奇点，则在该点之前，线段上点的总数总是偶数；在该点及该点之后，线段上的点的总数总是奇数。显然这个点可以用二分来找到。关键的问题是确定一个位置，怎么求出该位置及之前的点的总数。因为线段的长度太大，用前缀和预处理显然是不行的，只能在线求。对于每一组点，用除法求出在该点之前的点的总数就好了。 时间复杂度$O(nlog_2l)$（$l$为线段长） 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longLL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CN=2e5+5;int t,n;LL s[CN],e[CN],d[CN];LL calc(LL pos){ LL ret = 0; for(int i=1;i&lt;=n;i++){ if(s[i] &gt; pos) continue; if(e[i] &lt; pos) ret += (e[i]-s[i])/d[i]+1; else ret += (pos-s[i])/d[i]+1; } return ret;}int main(){ t=read(); while(t--){ n=read(); for(int i=1;i&lt;=n;i++) s[i]=read(),e[i]=read(),d[i]=read(); LL l=1,r=0,mid; for(int i=1;i&lt;=n;i++) r = max(r, e[i]); if(!(calc(r) &amp; 1)){ //特殊情况 printf(\"Poor QIN Teng:(\\n\"); continue; } while(l &lt; r){ mid = (l+r)&gt;&gt;1; if(calc(mid) &amp; 1) r = mid; else l = mid+1; } printf(\"%lld \",r); LL cnt = 0; for(int i=1;i&lt;=n;i++){ if(s[i]&gt;r || e[i]&lt;r) continue; if(!((r-s[i]) % d[i])) cnt++; } printf(\"%lld\\n\",cnt); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/23/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%A7%A6%E8%85%BE%E4%B8%8E%E6%95%99%E5%AD%A6%E8%AF%84%E4%BC%B0/"},{"title":"「题解」负载平衡问题","text":"2019.4第一道题，也是第二道wll24题，希望能rp++…… 一 题目 原题链接 描述G 公司有 n 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 n 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。 输入文件的第 1 行中有 1 个正整数 n，表示有 n 个仓库。第 2 行中有 n 个正整数，表示 n 个仓库的库存量。 输出输出最少搬运量。 二 题解wll24题中蓝色的题目2/3，rp++。 本题有数学解法！但是我太菜了。 既然是最少搬运量，那么肯定跟费用流有关。关键就是这个怎么均分负载的问题了。 可以计算库存量（设它为$a_i$）的平均数$\\overline a$。如果有解，那么最后每个仓库的库存量都一定会是$\\overline a$。可以把仓库分成两类： $a_i &gt; \\overline a$ 的仓库$i$，记为图$L$。 $a_i &lt; \\overline a$ 的仓库$i$，记为图$R$。 $a_i = \\overline a$的仓库不会影响答案，所以放在哪一类里面都行。 很明显，$L$中节点的点权需要转移到$R$中节点去。把这个点权变成边权，那么新建总源$s$和总汇$t$，连边$s\\to L$，$L \\rightleftarrows R$与$R\\to t$。$s\\to L$边上的流量限制为$L$中节点点权超出$\\overline a$的部分，即$a_i - \\overline a$。$R\\to t$边上的流量限制为$R$中节点点权不足$\\overline a$的部分，即$\\overline a- a_i$。图上所有相邻节点互相连双向边，边上没有流量限制，因为可以无限转移。不过转移的费用就是$1$。 这样，当增广一条路时，$s\\to L$的边流量增大，$R\\to t$的边流量也增大，其实意味着$L,R$中点的点权会更接近于平均值$\\overline a$。当网络流达到最大时，也就是说所有不等于平均值的点权都已经被增广到平均值大小，也就达到了负载平衡（前提是保证有解！）。 然后只需要处理一下环。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CP=101*10;const int CE=CP*CP;const int INF=0x3f3f2f3f;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int from,to,nxt,flow,cap,cost; void init(int f,int t,int n,int w,int c,int s) {from=f; to=t; nxt=n; flow=w; cap=c; cost=s;}}E[CE];int hd[CP],ecnt=1;void _add(int x,int y,int c,int w){ E[++ecnt].init(x,y,hd[x],0,c,w); hd[x] = ecnt;}void add(int x,int y,int c,int w){ _add(x,y,c,w); _add(y,x,0,-w); //反向边 }//v defineint n,_a,s,t;int a[CP];//mcmfint maxflow=0,mincost=0;int d[CP],rst[CP],prv[CP];bool ins[CP];bool Augment(int _s,int _t){ memset(d,0x3f,sizeof(d)); memset(ins,false,sizeof(ins)); memset(prv,0,sizeof(prv)); memset(rst,0x3f,sizeof(rst)); queue&lt;int&gt;Q; Q.push(_s); d[_s] = 0; ins[_s] = true; while(!Q.empty()) { int u = Q.front(); Q.pop(); ins[u] = false; for(int k=hd[u]; k; k=E[k].nxt) { fs e=E[k]; if(e.cap-e.flow&gt;0 &amp;&amp; d[e.to]&gt;d[u]+e.cost){ d[e.to] = d[u]+e.cost; prv[e.to] = k; rst[e.to] = min(rst[u], e.cap-e.flow); if(!ins[e.to]) Q.push(e.to),ins[e.to] = true; } } } return d[_t] &lt; INF;}void update(int _s,int _t,int r){ int pos=_t; while(pos != _s){ E[prv[pos]].flow += r; E[prv[pos]^1].flow -= r; pos = E[prv[pos]].from; }}void mcmf(int _s,int _t){ while(Augment(_s, _t)){ maxflow += rst[_t]; mincost += d[_t]*rst[_t]; update(_s,_t, rst[_t]); }}int main(){ n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),_a+=a[i]; _a /= n; s=n+1; t=n+2; for(int i=1;i&lt;=n;i++) //connect s/t with i if(a[i] &gt; _a) add(s,i, a[i]-_a, 0); else add(i,t, _a-a[i], 0); for(int i=2;i&lt;n;i++){ //connect between nodes add(i,i+1, INF, 1); add(i,i-1, INF, 1); } //circle add(1,n, INF, 1); add(1,2, INF, 1); add(n,1, INF, 1); add(n,n-1, INF, 1); mcmf(s,t); printf(\"%d\",mincost); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/04/02/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/"},{"title":"「题解」解方程","text":"求高次方程$a_0+a_1x+a_2x^2+a_3x^3+…+a_nx^n=0$在区间$[1,m]$内的所有整数解…… 一 题目 原题链接 描述如题，求高次方程$a_0+a_1x+a_2x^2+a_3x^3+…+a_nx^n=0$在区间$[1,m]$内的所有整数解。 数据范围：$n\\leqslant 100,|a_i|\\leqslant 10^{10000},a_n\\ne 0,m&lt; 10^6$ 二 题解数据范围一看就是坑。首先$n\\leqslant 100,m&lt; 10^6$，那么就可以枚举答案，每次花$O(n)$的时间去验证答案的正误。但是系数太大了！高次方程又不存在通解公式，那我们只能把系数模大质数以储存下来。 分析不妨将方程看作函数。设高次函数$f(x) = a_0+a_1x+a_2x^2+a_3x^3+…+a_nx^n$，然后我们要把$a_0\\text{~}a_1$都模$R$，也就是把原函数变成$f’(x) = a_0\\text{ mod } R+(a_1\\text{ mod } R)x+(a_2\\text{ mod } R)x^2+(a_3\\text{ mod } R)x^3+…+(a_n\\text{ mod } R)x^n$。实际上这个函数应该在对$R$取模的情况下才有意义（即在取模意义下与$f(x)$大致重合）。 验证画出了$f(x) = 879+653x+597x^2+497x^3+432x^4+421x^5$的图像，$r(x)=f(x)\\text{ mod }397$的图像和$f’(x) = (85+256x+200x^2+100x^3+35x^4+24x^5)\\text{ mod }397$的图像。其中，对于相同的$x$，总存在$f(x) \\equiv r(x)(\\text{mod }397)$。而$r$与$f’$基本重合，故推出：若有$x$使得$f’(x)=k$，那么$f(x)\\equiv k(\\text{mod }397)$有几率成立。 但是别忘了：我们推出来的只是同余。也就是说，只是有几率会有$f’(x)=k \\Rightarrow f(x)\\equiv k (\\text{mod }R)$，实际上$f(x)$不一定恰好等于$k$。所以为了避免这个问题，$R$不妨选的大一点，然后最好是质数。当然，为了保证准确，也可以多选择几个$R$值，不过这会拖慢程序运行效率。 回到题目那么不妨选取两个大质数$R_1,R_2$，然后得到两个系数分别模$R_1,R_2$的函数$f’_1,f’_2$。枚举$x\\in [1,m]$，若对于同一个$x$，有$f’_1(x)=f’_2(x)=0$，则基本可以断定$x$是我们想要的解。 但是还要考虑运行效率。取余运算是很慢的，而算法复杂度为$O(nm)$，最高$O(10^8)$，再乘上一个大常数，无疑会TLE。但是可以发现，若$f’(x)\\text{ mod } R=0$，则一定有$f’(x+kR)\\text{ mod } R=0$。 证明把$a_n(x+kR)^n$展开，得：$$ \\begin{aligned} a_n(x+kR)^n &amp;= a_n[x^n+ b_1x^{n-1}kR + …+b_{n-1}x(kR)^{n-1}+(kR)^n] \\newline &amp; = a_nx^n + a_nb_1x^{n-1}kR+ … + a_nb_{n-1}x(kR)^{n-1}+a_n(kR)^n\\end{aligned}$$其中$(a_nb_1x^{n-1}kR+ … + a_nb_{n-1}x(kR)^{n-1}+a_n(kR)^n )\\text{ mod } R = 0$，因为都可以提出因式$kR$。所以得：$$ a_n(x+kR)^n \\equiv a_nx^n (\\text{mod }R) $$一般情况证明完成，也就是说对于任意正整数$n$都满足上面的式子。故$a_1\\text{}a_n$都分别同余于$a_1(x+kR)\\text{}a_n(x+kR)^n$。那么一定有$f’(x) \\equiv f’(x+kR) (\\text{mod }R)$。 所以我们只需要枚举$k\\in [1,R_1)$，处理出有哪些$k$，使$f’_1(k)=0$。然后再枚举$i\\in [1,m]$，若$i\\text{ mod }k=0$且$f’_2(i)=0$，则断定$i$是解。 附：常用大质数1e5+7,99991,1e8+7,1e9+7,998244353。 代码，其实long long可以不开。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 110;const int R1 = 99991; //R1小一点，提高运行效率const int R2 = 1e8+7; //R2大一点，提高精度int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n,m;LL a1[CN],a2[CN]; //f1,f2的系数bool is[CN*CN*CN]; //is[x] : 判断f1(x)是否为0int ans[CN*CN*CN];void aread(int i){ LL ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()){ a1[i]=((a1[i]&lt;&lt;1)+(a1[i]&lt;&lt;3)+c-'0')%R1; //记录系数 a2[i]=((a2[i]&lt;&lt;1)+(a2[i]&lt;&lt;3)+c-'0')%R2; } a1[i] *= ne; a2[i] *= ne;}bool calc(LL x,int R,LL* a){ LL f = 0; //f(x) for(int i=n;i;i--) ((f += a[i]) *= x) %= R; //秦九韶公式 (f += a[0]) %= R; //只有在取模意义下上面的推导才会成立 return !f;}int main(){ n = read(); m = read(); for(int i=0;i&lt;=n;i++) aread(i); for(LL i=1;i&lt;R1;i++) if(calc(i,R1,a1)) is[(int)i] = true; for(LL i=1;i&lt;=m;i++) if(is[(int)i%R1] &amp;&amp; calc(i,R2,a2)) ans[++ans[0]] = i; //记录答案 printf(\"%d\\n\",ans[0]); for(int i=1;i&lt;=ans[0];i++) printf(\"%d\\n\",ans[i]); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/12/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%A7%A3%E6%96%B9%E7%A8%8B/"},{"title":"「题解」请柬","text":"在电视时代,没有多少人观看戏剧表演。Malidinesia古董喜剧演员意识到这一事实，他们想宣传剧院,尤其是古色古香的喜剧片…… 一 题目 原题链接 描述在电视时代,没有多少人观看戏剧表演。Malidinesia古董喜剧演员意识到这一事实，他们想宣传剧院,尤其是古色古香的喜剧片。他们已经打印请帖和所有必要的信息和计划。许多学生被雇来分发这些请柬。每个学生志愿者被指定一个确切的公共汽车站，他或她将留在那里一整天,邀请人们参与。 这里的公交系统是非常特殊的:所有的线路都是单向的，连接两个站点。公共汽车离开起始点，到达目的地之后又空车返回起始点。学生每天早上从总部出发，乘公交车到一个预定的站点邀请乘客。每个站点都被安排了一名学生。在一天结束的时候,所有的学生都回到总部。现在需要知道的是，学生所需的公交费用的总和最小是多少。 输入第1行有两个整数n、m(1&lt;=n,m&lt;=1000000)，n是站点的个数，m是线路的个数。然后有m行，每行描述一个线路，包括3个整数，起始点，目的地和价格。总部在第1个站点，价钱都是整数，且小于1000000000。 输出输出一行，表示最小费用。 二 题解简化题意：不妨称$ 1\\text{~}n $号节点到某一结点$ t $的最短路为$ t $的单汇最短路（与单源最短路相对）。设$ d_i $表示$s\\to i$的单源最短路，$d’i $表示$ i\\to s $的单汇最短路。现给定一张有向图，试求出$ \\sum\\limits_{i=1}^ndi+\\sum\\limits_{i=1}^n d’i $。 不难发现，在无向图中，总有$d_i = d’_i$。但在有向图中呢？设有向图$G^T$为有向图$G$的反图（定义为每条边的方向相反），则一定有$d^T_i = d’_i$。简单来说，就是反图中的单源最短路长度总等于正图中的单汇最短路长度。 这个结论并不难证明，因为在反图中发生反转的只有边的方向。 剩下的问题就很简单了，代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int CP=1e6+6;const int CE=CP+2e3;LL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int to,nxt; LL dist; void init(int t,int n,LL d) {to=t;nxt=n;dist=d;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y,LL z){ E[++ecnt].init(y,hd[x],z); hd[x] = ecnt;}void fsinit(){ memset(hd,0,sizeof(hd)); ecnt = 0;}//v defineint n,m,X[CE],Y[CE]; LL Z[CE],ans = 0;//DJclass DJ{ public: int c; LL v; bool operator &lt; (const DJ &amp;a)const {return v &gt; a.v;}};priority_queue&lt;DJ&gt; Q;LL d[CP];bool vis[CP];void sp(int s){ memset(d,0x3f,sizeof(d)); memset(vis,false,sizeof(vis)); d[s] = 0; Q.push((DJ){s,d[s]}); while(!Q.empty()){ DJ u = Q.top(); Q.pop(); if(vis[u.c]) continue; vis[u.c] = true; for(int k=hd[u.c]; k; k=E[k].nxt){ fs v = E[k]; if(d[v.to] &gt; d[u.c]+v.dist){ d[v.to] = d[u.c]+v.dist; if(!vis[v.to]) Q.push((DJ){v.to,d[v.to]}); } } }}int main(){ n = read(); m = read(); for(int i=1;i&lt;=m;i++){ X[i] = read(); Y[i] = read(); Z[i] = read(); add(Y[i],X[i],Z[i]); //反图 } sp(1); for(int i=1;i&lt;=n;i++) ans += d[i]; fsinit(); for(int i=1;i&lt;=m;i++) add(X[i],Y[i],Z[i]); //正图 sp(1); for(int i=1;i&lt;=n;i++) ans += d[i]; printf(\"%lld\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%AF%B7%E6%9F%AC/"},{"title":"「题解」能量采集","text":"又是一道可爱的数学题…… 一 题目 原题链接 描述栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。 栋栋的植物种得非常整齐，一共有n列，每列有m棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标(x, y)来表示，其中x的范围是1至n，表示是在第x列，y的范围是1至m，表示是在第x列的第y棵。 由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是(0, 0)。 能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有k棵植物，则能 量的损失为2k + 1。例如，当能量汇集机器收集坐标为(2, 4)的植物时，由于连接线段上存在一棵植物(1, 2)，会产生3的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为1。现在要计算总的能量损失。 输入仅包含一行，为两个整数n和m。 输出仅包含一个整数，表示总共产生的能量损失。1 ≤ n, m ≤ 100,000。 二 题解这题实际上没那么难，我都能推出来…… 首先有一个结论就是说：若在坐标系中从 (0,0) 向 (x,y) 连一条线段，那么这条线段经过的整点的数量（不包含端点）为 gcd(x,y)-1 。 实际上上面那个东西很显然，如果你没办法感性理解，你可以用相似三角形或者斜率或者什么奇奇怪怪的东西理解一下，以下是一种理解：假设 (a,b) 在 (0,0) 到 (x,y) 线段上，那么一定有 a/b = x/y 。你把 x/y 约分，即 x / y = (x0×gcd(x,y)) / (y0×gcd(x,y)) = x0 / y0 。那么对于所有整数 i∈[1,gcd(x,y)) ，(x0×i) / (y0×i) 都是一个满足条件的整点，这样的整点一共有 gcd(x,y)-1 个。 实际上这个结论还可以推广到任意两点间线段上整点的数量，不过我懒得推，感性理解。 然后就好办了，实际上就是让你求$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m 2\\times(\\text{gcd}(i,j)-1)+1$。把常数都提出来，很显然上面等价于$( 2\\times \\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\text{gcd}(i,j) ) -n\\times m$。剩下的问题是求$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\text{gcd}(i,j)$。 考虑一个因子 g 对和的贡献，它会被形如 (k×g, h×g) 的点累加到 sigma 里面，并且前面的 k,h 互质。先不考虑互质，那么直接乘法原理，这样的点有 ⌊n/g⌋×⌊m/g⌋ 个。考虑有哪些东西是多出来的。对于一个因子 g ，满足 gcd(x,y) = kg (k∈{1,2,3 … }) 的点 (x,y) 实际上被多累加了。那么枚举一个系数 k ，我们在 ⌊n/g⌋×⌊m/g⌋ 中减掉 ⌊n/kg⌋×⌊m/kg⌋ 就好了。不过还有一部分可能会被多减掉（考虑简单的容斥原理），然后我也不想容斥，于是设 cnt[g] 表示“形如 (k×g, h×g) ，其中 k,h 互质”的点的个数，从大到小枚举 g ，然后枚举 k ， cnt[g] -= cnt[kg] 就好了，正确性感性理解。 然后$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\text{gcd}(i,j) = \\sum\\limits_{g=1}^{\\max n,m}g\\times cnt[g]$，然后切了。 代码： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 1e6+6;LL n,m,sigma = 0,cnt[CN];LL gcd(LL a,LL b) {return b ? gcd(b, a%b) : a;}int main(){ scanf(\"%lld%lld\",&amp;n,&amp;m); for(LL g = 1; g &lt;= max(n, m); g++) cnt[g] = (n / g) * (m / g); for(LL g = max(n, m); g; g--) // 一定倒序枚举 for(LL k = 2; k * g &lt;= max(n, m); k++) cnt[g] -= cnt[k * g]; for(LL g = 1; g &lt;= max(n, m); g++) sigma += g * cnt[g]; printf(\"%lld\",sigma * 2 - n * m); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/10/24/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"title":"「题解」选择客栈","text":"丽江的客栈的格局，是和别处不同的：都是当街一个曲尺形的大柜台，柜里面预备着咖啡，可以随时提神。搞OI的人，深更半夜下了机，每每花四文铜钱，买一碗咖啡，到宿舍坐着，热热的喝了继续肝题…… 一 题目 原题链接 描述丽江河边有n家很有特色的客栈，客栈按照其位置顺序从1到n编号。每家客栈都按照某一种色调进行装饰（总共 k 种，用整数 0~k−1 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。 两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 p 。 他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 p元的咖啡店小聚。 输入共n+1 行。 第一行三个整数n ,k ,p（氮钾磷），每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值； 接下来的n 行，第 i+1 行两个整数，之间用一个空格隔开，分别表示 i 号客栈的装饰色调和i 号客栈的咖啡店的最低消费。 输出一个整数，表示可选的住宿方案的总数。 二 题解因为咖啡店的颜色不没有限制，所以若可以在第$j$家客栈喝咖啡，则第$1\\text{~}j$家客栈都可以选为第一个人住的地方。对于第二个人住的客栈（设为$b$），当$b$一定时，最大的$j$也一定是一个定值，它表示在$b$点之前、距离$b$最近的且可以喝酒的客栈。 对于每个客栈$i$，设它的颜色是$col_i$，设$last_i$为当前客栈对应的最大的$j$，设$f_{i,k}$为前$i$个（包括$i$）客栈中，颜色为$k$的数量。则当前客栈作为第二人住的客栈时，共有$f_{last_i,col_i}$种方案。那么总方案数就是 ：$\\sum\\limits_{1\\leqslant i \\leqslant n}f_{last_i,col_i}$。注意，当$last_i = i$时，方案数应为$f_{i-1,col_i}$，因为两个人不能住在一个酒店。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN=2e5+1;const int CK=51;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n,k,p;int col[CN],prc[CN];int f[CN][CK],last[CN];int main(){ n=read(); k=read(); p=read(); for(int i=1;i&lt;=n;i++) col[i]=read(),prc[i]=read(); for(int c=0;c&lt;k;c++) for(int i=1;i&lt;=n;i++) f[i][c] = f[i-1][c]+(col[i]==c ? 1 : 0); last[0] = 0; for(int i=1;i&lt;=n;i++) if(prc[i] &lt;= p) last[i] = i; else last[i] = last[i-1]; //求sigma int ans=0; for(int i=1;i&lt;=n;i++) if(last[i] == i) ans += f[i-1][col[i]]; else ans += f[last[i]][col[i]]; printf(\"%d\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/05/12/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%80%89%E6%8B%A9%E5%AE%A2%E6%A0%88/"},{"title":"「题解」逃学的小孩","text":"Chris家的电话铃响起了，里面传出了Chris的老师焦急的声音：“喂，是Chris的家长吗？你们的孩子又没来上课，不想参加考试了吗？”…… 一 题目 原题链接 描述Chris家的电话铃响起了，里面传出了Chris的老师焦急的声音：“喂，是Chris的家长吗？你们的孩子又没来上课，不想参加考试了吗？”一听说要考试，Chris的父母就心急如焚，他们决定在尽量短的时间内找到Chris。他们告诉Chris的老师：“根据以往的经验，Chris现在必然躲在朋友Shermie或Yashiro家里偷玩《拳皇》游戏。现在，我们就从家出发去找Chris，一但找到，我们立刻给您打电话。”说完砰的一声把电话挂了。 Chris居住的城市由N个居住点和若干条连接居住点的双向街道组成，经过街道x需花费Tx分钟。可以保证，任两个居住点间有且仅有一条通路。Chris家在点C，Shermie和Yashiro分别住在点A和点B。Chris的老师和Chris的父母都有城市地图，但Chris的父母知道点A、B、C的具体位置而Chris的老师不知。 为了尽快找到Chris，Chris的父母会遵守以下两条规则： 如果A距离C比B距离C近，那么Chris的父母先去Shermie家寻找Chris，如果找不到，Chris的父母再去Yashiro家；反之亦然。 Chris的父母总沿着两点间唯一的通路行走。 显然，Chris的老师知道Chris的父母在寻找Chris的过程中会遵守以上两条规则，但由于他并不知道A，B，C的具体位置，所以现在他希望你告诉他，最坏情况下Chris的父母要耗费多长时间才能找到Chris？ 输入输入文件第一行是两个整数N（3 ≤ N ≤ 200000）和M，分别表示居住点总数和街道总数。 以下M行，每行给出一条街道的信息。第i+1行包含整数Ui、Vi、Ti（1≤Ui, Vi ≤ N，1 ≤ Ti ≤ 1000000000），表示街道i连接居住点Ui和Vi，并且经过街道i需花费Ti分钟。街道信息不会重复给出。 输出输出文件仅包含整数T，即最坏情况下Chris的父母需要花费T分钟才能找到Chris。 二 题解把花费的时间看作距离，那么我们可以得到chris行走的总距离$d = \\text{dist}(A,B) + \\min(\\text{dist}(A,C),\\text{dist}(B,C))$。显然 $\\text{dist}(A,B)$是一个定值，想让$d$最大就得让它先最大。题目中的图是一棵树，那么树上两点间最长距离就是树的直径。所以可以固定前面的$ \\text{dist}(A,B)$。 剩下的问题就是怎么让$\\min(\\text{dist}(A,C),\\text{dist}(B,C))$最大。显然，求出直径之后，$A,B$（也就是直径的两个端点）是固定的。虽然直径可能有多条，存在多个端点，但是并不会影响答案（可以自己画棵树试试）。那么我们任选一个直径，求出它的长及两个端点$A,B$。然后预处理出树上每个节点到$A$和到$B$的距离，枚举哪个点作为$C$点即可。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int CP=2e5+5;const int CE=CP*3;const LL INF=0x3f3f3f3f3f3f3f3f;LL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int from,to,nxt; LL dist; void init(int f,int t,int n,LL d) {from=f; to=t; nxt=n; dist=d;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y,LL z){ E[++ecnt].init(x,y,hd[x],z); hd[x]=ecnt;}//v defineint n,m;int s,t;LL ans=0;void cpy(LL* a,LL* b,int lth){ //复制 a[] 到 b[] for(int i=1;i&lt;=lth;i++) b[i]=a[i];}//diameterLL d[CP],ds[CP],dt[CP]; void dfs(int u){ for(int k=hd[u]; k; k=E[k].nxt){ fs e=E[k]; if(!d[e.to]){ d[e.to] = d[u]+e.dist; dfs(e.to); } }}LL diameter(){ memset(d,0,sizeof(d)); dfs(1); LL mx=-INF; for(int i=1;i&lt;=n;i++) if(mx &lt; d[i]) mx = d[s=i]; memset(d,0,sizeof(d)); dfs(s); mx=-INF; for(int i=1;i&lt;=n;i++) if(mx &lt; d[i]) mx = d[t=i]; return mx;}int main(){ n=read(); m=read(); while(m--){ int x=read(),y=read(); LL z=read(); add(x,y,z); add(y,x,z); } LL dm=diameter(); memset(d,0,sizeof(d)); dfs(s); cpy(d,ds,n); memset(d,0,sizeof(d)); dfs(t); cpy(d,dt,n); for(int i=1;i&lt;=n;i++) //枚举 if(i!=s &amp;&amp; i!=t) ans = max(ans, dm + min(ds[i],dt[i])); printf(\"%lld\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/04/14/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%80%83%E5%AD%A6%E7%9A%84%E5%B0%8F%E5%AD%A9/"},{"title":"「题解」通往奥格瑞玛的道路","text":"在艾泽拉斯大陆上有一位名叫歪嘴哦的神奇术士，他是部落的中坚力量。有一天他醒来后发现自己居然到了联盟的主城暴风城。在被众多联盟的士兵攻击后，他决定逃回自己的家乡奥格瑞玛…… 一 题目 原题链接 描述在艾泽拉斯，有n个城市。编号为1,2,3,…,n。城市之间有m条双向的公路，连接着两个城市，从某个城市到另一个城市，会遭到联盟的攻击，进而损失一定的血量。 每次经过一个城市，都会被收取一定的过路费（包括起点和终点）。路上并没有收费站。假设1为暴风城，n为奥格瑞玛，而他的血量最多为b，出发时他的血量是满的。 歪嘴哦不希望花很多钱，他想知道，在可以到达奥格瑞玛的情况下，他所经过的所有城市中最多的一次收取的费用的最小值是多少。 输入第一行3个正整数，n，m，b。分别表示有n个城市，m条公路，歪嘴哦的血量为b。接下来有n行，每行1个正整数，fi。表示经过城市i，需要交费fi元。再接下来有m行，每行3个正整数，ai，bi，ci(1&lt;=ai，bi&lt;=n)。表示城市ai和城市bi之间有一条公路，如果从城市ai到城市bi，或者从城市bi到城市ai，会损失ci的血量。 输出仅一个整数，表示歪嘴哦交费最多的一次的最小值。如果他无法到达奥格瑞玛，输出AFK。 二 题解最大花费最小，显然是二分。直接二分这个“最大花费”，然后把城市$a,b$之间的边权定义为走这条边损失的血量，跑spfa求最短路，注意这时候不能经过花费大于“最大花费”的城市。那么只需要判断“最小损失血量”，也就是最短路，是不是小于总血量，然后更新边界即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int CP=1e4+3;const int CE=1e5+3;const LL INF=0x3f3f3f3f3f3f2f3f;LL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int to,nxt; LL dist; void init(int t,int n,LL d) {to=t; nxt=n; dist=d;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y,int z){ E[++ecnt].init(y,hd[x],z); hd[x]=ecnt;}//v defineint n,m;LL bld,cost[CP];LL l,r,mid;//spfaLL d[CP];bool ins[CP];bool spfa(int s,int t,LL lmt){ //lmt : 当前二分的最大花费 memset(d,0x3f,sizeof(d)); memset(ins,false,sizeof(ins)); queue&lt;int&gt;Q; Q.push(s); ins[s] = true; d[s] = 0; while(!Q.empty()){ int u=Q.front(); Q.pop(); ins[u] = false; for(int k=hd[u]; k; k=E[k].nxt){ int v=E[k].to; if(d[v]&gt;d[u]+E[k].dist &amp;&amp; cost[v]&lt;=lmt){ //城市 v 的花费不能大于最大花费 d[v] = d[u]+E[k].dist; if(!ins[v]){ Q.push(v); ins[v] = true; } } } } return d[t]&lt;=bld;}int main(){ n=read(); m=read(); bld=read(); for(int i=1;i&lt;=n;i++){ cost[i]=read(); r = max(r, cost[i]); //上界初始值 } while(m--){ int x=read(),y=read(); LL z=read(); add(x,y,z); add(y,x,z); } if(!spfa(1,n,INF)){ //特判 printf(\"AFK\"); return 0; } l = max(cost[1],cost[n]); //1,n 这两个城市总需要经过，所以是下界的初始值 while(l &lt; r){ mid = (l+r)&gt;&gt;1; if(spfa(1,n,mid)) r = mid; else l = mid+1; } printf(\"%lld\",r); return 0;}​ $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/05/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF/"},{"title":"「题解」货币系统","text":"在网友的国度中共有 n 种不同面额的货币，第 i 种货币的面额为 a[i]…… 一 题解 原题链接 描述在网友的国度中共有 n 种不同面额的货币，第 i 种货币的面额为 a[i]，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 n、面额数组为 a[1..n] 的货币系统记作 (n,a)。 在一个完善的货币系统中，每一个非负整数的金额 x 都应该可以被表示出，即对每一个非负整数 x，都存在 n 个非负整数 t[i] 满足 a[i]×t[i] 的和为 x。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 x 不能被该货币系统表示出。例如在货币系统 n=3, a=[2,5,9] 中，金额 1,3 就无法被表示出来。 两个货币系统 (n,a) 和 (m,b) 是等价的，当且仅当对于任意非负整数 x，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 现在网友们打算简化一下货币系统。他们希望找到一个货币系统 (m,b)，满足 (m,b) 与原来的货币系统 (n,a) 等价，且 m 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 m。 输入输入文件的第一行包含一个整数 T，表示数据的组数。 接下来按照如下格式分别给出 T 组数据。 每组数据的第一行包含一个正整数 n。接下来一行包含 n 个由空格隔开的正整数 a[i]。 输出输出文件共有 T 行，对于每组数据，输出一行一个正整数，表示所有与 (n,a) 等价的货币系统 (m,b) 中，最小的 m。 样例输入 243 19 10 6511 29 13 19 17 输出 25 二 题解先来分析一下给的样例：有四种面值，分别是$3,19,10,6$， 可以用集合表示成$A={ 3,19,10,6 }$。然后我们发现其中有些面值可以被其它面值组成，如$6$可以被$3$组成。我们把这些面值从集合里面删去，得到一个新的集合$A’={ 3,10 }$。然后我们发现只剩下两个元素，恰好是答案？！ 这难道就是数学题的魅力？ 于是可以猜想：若把答案货币系统$B={ m,b }$中的$b$数组看作集合$B$，当$B$中的元素最少时，总有一种方案是$B=A’$（$A’$是集合$A$中不能被集合内其他元素组成的元素组成的的集合）。 简单的证明：若$B$存在一种元素数更少的方案，则$B$中一定有若干元素能组成$A’$中的所有元素。因为$A’$中的元素是不能互相组成的，所以此时$B$中一定存在不在$A’$中的元素，也就是不在$A$中的元素。所以$A \\cap B \\neq A$，也就是说货币系统$A$不与$B$等价。 之后的问题就是怎么求出$A’$来。设$f_j$表示凑足$j$元钱最多能用到的钱币数，很明显有转移方程$$ f_j = \\max f_{j-a_i}+1 | a_i \\in A$$其实就是完全背包。跑一边然后找出所有$f$值等于$1$的面值$j$，则$j \\in A’$。因为只让求集合大小，所以累加答案就好了。 代码（真是简短）： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN=2.5e4+4;const int INF=0x3f3f3f3f;int read(){ //快读 int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=((s&lt;&lt;1)+(s&lt;&lt;3))+c-'0'; return s*ne;}//v defineint t,n,a[CN],f[CN];int main(){ t=read(); while(t--){ memset(f,0,sizeof(f)); n=read(); int mx=-INF; //面值最大值，下面跑背包用 for(int i=1;i&lt;=n;i++){ a[i]=read(); mx = max(mx,a[i]); } for(int i=1;i&lt;=n;i++) //完全背包 for(int j=a[i]; j&lt;=mx; j++) if(f[j-a[i]] || !(j-a[i])) f[j] = max(f[j], f[j-a[i]]+1); //转移 int cnt=0; for(int j=1;j&lt;=mx;j++) if(f[j]==1) cnt++; printf(\"%d\\n\",cnt); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/17/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F/"},{"title":"「题解」青蛙的约会","text":"exgcd大水题…… 一 题目 原题链接 描述两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 输入输入只包括一行5个整数x，y，m，n，L。其中0&lt;x≠y &lt; =2000000000，0 &lt; m、n &lt; =2000000000，0 &lt; L &lt; =2100000000。 输出输出碰面所需要的天数，如果永远不可能碰面则输出一行”Impossible”。 二 题解实际上就是让你解一个同余方程……设k天之后相遇，那么就有x+km≡y+kn(mod L)，然后展开就是x+km=y+kn+qL，整理得到k(m-n)-qL=y-x，这不就是个exgcd么……处理一下负数问题就好了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longLL x,y,m,n,L;LL gcd(LL a,LL b) {return b?gcd(b,a%b):a;}void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(!b){ x = 1,y = 0; return; } _exgcd(b,a%b,x,y); LL t = x; x = y; y = t-(a/b)*y;}bool exgcd(LL a,LL b,LL c,LL &amp;x,LL &amp;kx){ //通解 x + p*kx (p ∈ Z) LL g = gcd(a,b); if(c % g) return false; LL y; _exgcd(a,b,x,y); x *= c/g; kx = b/g; return true;}int main(){ scanf(\"%lld%lld%lld%lld%lld\",&amp;x,&amp;y,&amp;m,&amp;n,&amp;L); LL ans,kx; bool flag = true; if(m-n &lt; 0){ if(!exgcd(n-m,L,y-x,ans,kx)) flag = false; else{ ans = -ans; ans %= kx; if(ans &lt; 0) ans += kx; //搞成最小正数解 flag = true; } } else{ if(!exgcd(m-n,L,y-x,ans,kx)) flag = false; else{ ans %= kx; if(ans &lt; 0) ans += kx; //搞成最小正数解 flag = true; } } if(flag) printf(\"%lld\",ans); else printf(\"Impossible\"); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/08/16/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A/"},{"title":"「题解」重建道路","text":"第一道自己切掉的树形DP，写个题解纪念一下…… 一 题目 原题链接 描述一场可怕的地震后，人们用N个牲口棚(1≤N≤150，编号1..N)重建了农夫John的牧场。由于人们没有时间建设多余的道路，所以现在从一个牲口棚到另一个牲口棚的道路是惟一的。因此，牧场运输系统可以被构建成一棵树。John想要知道另一次地震会造成多严重的破坏。有些道路一旦被毁坏，就会使一棵含有P(1≤P≤N)个牲口棚的子树和剩余的牲口棚分离，John想知道这些道路的最小数目。 输入第1行：2个整数，N和P第2..N行：每行2个整数I和J，表示节点I是节点J的父节点。 输出单独一行，包含一旦被破坏将分离出恰含P个节点的子树的道路的最小数目。 二 题解首先可以有这么一个想法：设 f[u][s] 表示在节点 u ，获得大小为 s 的子树所需要删除的边的个数。 考虑转移要做什么考虑对于一个 s ，我们需要找到一种“空间”的分配方案。讲的形象一点，设 s(vi) 表示在子树 vi 内我们留下的节点个数，其中 vi 表示当前节点 u 的第 i 个子节点；再设 c(vi) 表示我们在子树 vi 中留下 s(vi) 个节点所删除的边的数量。那么现在我们要做的事情就是：对于全部 vi ，找到一种 s(vi) 的分配方式，使得 ∑s(vi) = s ，且 ∑c(vi) 最小，然后我们就可以令 f[u][s] = ∑c(vi)，也就完成了状态的转移。 然后上面那句“对于全部 vi ，找到一种 s(vi) 的分配方式，使得 ∑s(vi) = s ，且 ∑c(vi) 最小”，你不觉得这是一个背包么？然后这个时候你就会发现我们所设的 f[u][s] 这个状态实际上是不完全的。不考虑滚动数组，我们应该设 f[u][k][s] 表示考虑节点 u 的前 k 个子节点，取 s 个节点所需要的最小花费，这就是一个背包。 方程那么可以写出一个转移：f[u][k][s] = min(f[u][k-1][s] + 1, f[u][k-1][s-sv] + f[v][kv][sv])，其中 kv 表示 v 的所有子节点数量，sv 表示在子树 v 上选取的点的数量。上面那个方程很好理解：前面表示不从子树 v 选取节点，那么要删除 (u,v) 这条边，答案 +1 ；后面是在考虑子树 v 内选取的节点个数。 考虑滚动然后上面那个方程它一点也不可爱，考虑滚动掉 k 这一维，方程变成 f[u][s] = min(f[u][s] + 1, f[u][s-sv] + f[v][sv])，但是在转移的顺序上还有点小问题。我们发现 f[u][k][s] 总从 f[u][k-1][s] 或 f[u][k-1][s-sv] 的状态更新。也就是说，去掉 k 这一维，我们需要保证 f[u][s-sv] 比 f[u][sv] 后更新，这样 f[u][sv] 才是我们想要用来转移的“上层状态”。那么也就是倒序枚举 s 去更新。 于是我们只需要枚举 s，然后再枚举 sv，去转移就好了。 考虑答案的统计上面那个状态里面， u 实际上是强制选择的，否则就缺少一个能把若干子树连接起来的“桥梁”。但是贪心的想，我们不一定非得强制选择某一个节点啊。那么答案应该对所有的 f[u][p] 取一个 min 。然后还有一个问题，就是在某一个非根节点的位置，我们想要取出这棵子树，还得把这个节点和它的父亲节点断掉，那么答案还得 +1，细节见代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 160;class fs{ public: int to,nxt; void init(int t,int n) {to=t;nxt=n;}}E[CN * 2];int hd[CN],ecnt = 0;void add(int x,int y) {E[++ecnt].init(y,hd[x]);hd[x]=ecnt;}int n,P,ans,sum[CN],f[CN][CN]; // sum[u] 表示子树 u 的大小void dfs(int u,int p){ sum[u] = 1; f[u][1] = 0; // 初始时不考虑子树，因此 f[u][1] = 1 for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v == p) continue; dfs(v, u); // 求出子树的答案 sum[u] += sum[v]; // 累加大小 for(int s=sum[u]; s; s--){ // 考虑背包问题的更新方式，那么一定要每次都更新一下 f[u][s] += 1; // 实际上是 f[u][k][s] = f[u][k-1][s] + 1 ，滚动了 k 这一维 for(int sv=0;sv&lt;=min(s-1, sum[v]);sv++) // s-1 为了强制选根 f[u][s] = min(f[u][s], f[u][s - sv] + f[v][sv]); } } }int main(){ //freopen(\"p1272.in\",\"r\",stdin); scanf(\"%d%d\",&amp;n,&amp;P); for(int i=1;i&lt;n;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y); add(y,x); } memset(f,0x3f,sizeof(f)); dfs(1,0); ans = f[1][P]; for(int i=2;i&lt;=n;i++) ans = min(ans, f[i][P] + 1); // 加上与父亲之间的那条边 printf(\"%d\", ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/10/26/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%87%8D%E5%BB%BA%E9%81%93%E8%B7%AF/"},{"title":"「题解」飞行员配对方案问题","text":"第二次世界大战时期，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2 名飞行员…… 一 题目 原题链接 描述英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2 名飞行员，其中1 名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 输入第 1 行有 2 个正整数 m 和 n。n 是皇家空军的飞行员总数(n&lt;100)；m 是外籍飞行员数(m&lt;=n)。外籍飞行员编号为 1m；英国飞行员编号为 m+1n。 接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。最后以 2个-1 结束。 输出第 1 行是最佳飞行员配对方案一次能派出的最多的飞机数 M。接下来 M 行是最佳飞行员配对方案。每行有 2个正整数 i 和 j，表示在最佳飞行员配对方案中，飞行员 i 和飞行员 j 配对。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。若存在多个方案，输出任意一个。 二 题解二分图匹配问题，要求输出最大基数匹配方案。 匈牙利算法在解决二分图问题上还是有一定局限的。它完全可以被网络流所替代，此处通过最大流来解决（详见费用流 四-1）。 新建总源点与总汇点，总源$s$为$n+1$，总汇$t$为$n+2$，dinic增广。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CP=210;const int CE=CP*CP*10;const int INF=0x3f3f3f3f;class fs{ public: int from,to,nxt,cap,flow; void init(int f,int t,int n,int c,int w) {from=f; to=t; nxt=n; cap=c; flow=w;}}E[CE];int hd[CP],ecnt=1;void _add(int f,int t,int c,int w){ E[++ecnt].init(f,t,hd[f],c,w); hd[f]=ecnt;}void add(int f,int t,int c){ _add(f,t,c,0); _add(t,f,0,0);}//v defineint n,m;//dinicint dph[CP];bool bfs(int _s,int _t){ memset(dph,0,sizeof(dph)); dph[_s] = 1; queue&lt;int&gt;Q; Q.push(_s); while(!Q.empty()){ int u=Q.front(); Q.pop(); for(int k=hd[u]; k; k=E[k].nxt){ fs e=E[k]; if(!dph[e.to] &amp;&amp; e.cap-e.flow&gt;0) { dph[e.to] = dph[u]+1; Q.push(e.to); } } } return dph[_t];}int cur[CP];int Augment(int u,int _t,int rst){ if(u == _t) return rst; int used=0; for(int k=cur[u]; k; k=E[k].nxt) { cur[u] = k; fs e = E[k]; if(dph[u]==dph[e.to]-1 &amp;&amp; e.cap-e.flow&gt;0){ int a=Augment(e.to,_t, min(rst-used, e.cap-e.flow)); if(a){ E[k].flow += a; E[k^1].flow -= a; used += a; } if(used == rst) return rst; } } return used;}int dinic(int _s,int _t){ int mf=0; while(bfs(_s,_t)){ for(int i=1;i&lt;=n+m;i++) cur[i] = hd[i]; mf += Augment(_s,_t,INF); } return mf;}int main(){ m=read(); n=read(); int x=read(),y=read(); while(x != -1){ add(x,y,1); x=read(); y=read(); } //build s : (n+m+1) for(int i=1;i&lt;=m;i++) add(n+1,i,1); //build t : (n+m+2) for(int i=m+1;i&lt;=n;i++) add(i,n+2,1); //solve int ans=dinic(n+1, n+2); printf(\"%d\\n\",ans); for(int k=2; k&lt;=ecnt; k++) //遍历每条边 if(E[k].from&lt;=m &amp;&amp; E[k].to&lt;=m+n &amp;&amp; E[k].cap==1 &amp;&amp; E[k].flow==1) printf(\"%d %d\\n\",E[k].from,E[k].to); return 0;} 另一个例子HDU2063 过山车，实际上就多了一个多组数据，因为上面的码风太丑（这是时隔六个月的更新）就再放一个好了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CN = 1050;const int INF = 0x7f7f7f7f;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int from,to,nxt,cap,flow; void init(int f,int t,int n,int c,int ff){ from=f;to=t;nxt=n;cap=c;flow=ff; }}E[CN&lt;&lt;3];int hd[CN],ecnt = 1;void _add(int x,int y,int z){ E[++ecnt].init(x,y,hd[x],z,0); hd[x] = ecnt;}void add(int x,int y,int z){ _add(x,y,z); _add(y,x,0);}void fs_init(){ memset(hd,0,sizeof(hd)); ecnt = 1;}int ln,rn,m;//dinicint dep[CN];bool build(int _s,int _t){ memset(dep,0,sizeof(dep)); queue&lt;int&gt;Q; Q.push(_s); dep[_s] = 1; while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int k=hd[u];k;k=E[k].nxt){ fs e = E[k]; if(!dep[e.to] &amp;&amp; e.flow&lt;e.cap){ dep[e.to] = dep[u]+1; Q.push(e.to); } } } return dep[_t];}int augment(int u,int _t,int rst){ if(u == _t) return rst; int used = 0; for(int k=hd[u];k;k=E[k].nxt){ fs e = E[k]; if(dep[e.to]==dep[u]+1 &amp;&amp; e.flow&lt;e.cap){ int a = augment(e.to,_t,min(rst-used, e.cap-e.flow)); if(a){ used += a; E[k].flow += a; E[k^1].flow -= a; if(used == rst) return used; } } } return used;}int dinic(int _s,int _t){ int mf = 0; while(build(_s,_t)) mf += augment(_s,_t,INF); return mf;}int main(){ m = read(); while(m){ fs_init(); ln = read(); rn = read(); while(m--){ int x = read(),y = read()+ln; add(x,y,1); } int s = ln+rn+1,t = ln+rn+2; for(int i=1;i&lt;=ln;i++) add(s,i,1); for(int i=ln+1;i&lt;=ln+rn;i++) add(i,t,1); printf(\"%d\\n\",dinic(s,t)); m = read(); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/24/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98/"},{"title":"【题解】靶形数独","text":"小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏…… 一 题目 原题链接 描述小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。 靶形数独的方格同普通数独一样，在9格宽×9格高的大九宫格中有 9 个3 格宽×3格高的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 1 到 9 的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）上图具体的分值分布是：最里面一格（黄色区域）为 10 分，黄色区域外面的一圈（红色区域）每个格子为 9 分，再外面一圈（蓝色区域）每个格子为 8 分，蓝色区域外面一圈（棕色区域）每个格子为 7 分，最外面一圈（白色区域）每个格子为 6 分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和 总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。 由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。 输入一共 9 行。每行 9个整数（每个数都在 0−9 的范围内），表示一个尚未填满的数独方格，未填的空格用“0”表示。每两个数字之间用一个空格隔开。 输出输出共 1 行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数−1。 二 题解这题好像没想象的那么难。 先考虑大爆搜怎么写。最初的想法是写两个递归函数$ dfs(i) $和$ fill(j) $，其中$ dfs() $函数用来填每一列，$fill()$函数用来填每一行，但是这样不好回溯。于是把行列整合到一个递归函数里面，即$dfs(i,j,sum)$表示填格子$ (i,j) $，当前分数为$ sum $。实现就是先递归填好当前行，然后再递归下一行。 再考虑剪枝。先搜方案数少的行肯定要优一点。所以记录每一行的空余数量$ rst[\\text{ }] $，再搞一个结构体排序，把dfs函数改成$dfs(k,j,sum)$，$k$表示$rst[\\text{ }]$的下标，然后就AC了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int map[10][10]; bool h[10][10],l[10][10],g[10][10]; //行 列 小方格 的标记数组int ans=-1;class t{ public: int c,r; //c下标 ； r剩余量 bool operator &lt; (const t a)const{return r&lt;a.r;}}rst[10]; //结构体排序//dfsint ge(int x,int y){ //返回格子编号 if(x &lt;= 3){ if(y &lt;= 3) return 1; if(y &lt;= 6) return 2; return 3; } if(x &lt;= 6){ if(y &lt;= 3) return 4; if(y &lt;= 6) return 5; return 6; } if(y &lt;= 3) return 7; if(y &lt;= 6) return 8; return 9;}int sco(int x,int y){ //返回格子分数 if(x==1 || y==1 || x==9 || y==9) return 6; if(x==2 || y==2 || x==8 || y==8) return 7; if(x==3 || y==3 || x==7 || y==7) return 8; if(x==4 || y==4 || x==6 || y==6) return 9; return 10;}void dfs(int k,int j,int sum){ if(k &gt; 9){ //全部填完 ans = max(ans,sum); return; } int i=rst[k].c; //当前列 if(j &lt;= 9) while(map[i][j]){ //把已将填好的格子跳过去 sum+=map[i][j]*sco(i,j); j++; } if(j &gt; 9) dfs(k+1,1,sum); //搜索列 else for(int d=1;d&lt;=9;d++) //枚举数字 { int _g=ge(i,j); if(!g[_g][d] &amp;&amp; !h[i][d] &amp;&amp; !l[j][d]){ g[_g][d] = h[i][d] = l[j][d] = true; dfs(k,j+1, sum+d*sco(i,j)); //搜索行 g[_g][d] = h[i][d] = l[j][d] = false; } }}int main(){ for(int i=1;i&lt;=9;i++){ rst[i].c=i; for(int j=1;j&lt;=9;j++){ scanf(\"%d\",&amp;map[i][j]); if(!map[i][j]) rst[i].r++; int _g=ge(i,j); g[_g][map[i][j]] = h[i][map[i][j]] = l[j][map[i][j]] = true; } } sort(rst+1,rst+10); //排序 dfs(1,1,0); printf(\"%d\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/17/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%9D%B6%E5%9E%8B%E6%95%B0%E7%8B%AC/"},{"title":"二分图匹配","text":"设$G=(V,E)$（$V$为点集，$E$为边集）是一个无向图，如果顶点$V$可分割为两个互不相交的子集$(A,B)$，并且图中的每条边$(i，j)$所关联的两个顶点$i$和$j$分别属于这两个不同的顶点集 $(i \\in A,j \\in B)$，则称图$G$为一个二分图…… 一 定义1 什么是二分图 设$G=(V,E)$（$V$为点集，$E$为边集）是一个无向图，如果顶点$V$可分割为两个互不相交的子集$(A,B)$，并且图中的每条边$(i，j)$所关联的两个顶点$i$和$j$分别属于这两个不同的顶点集 $(i \\in A,j \\in B)$，则称图$G$为一个二分图。 ——Baidu 如下图，一张图被分为$U$，$V$两个点集，每个点集内部均无边，则是一个二分图。 2 什么是匹配在一个二分图$G$中选出$k$条边，组成新图$G’$，使得任意一条边的两个端点都与其他边的端点不重合，则称$G’$为$G$的一个匹配。 上图中，若$U$集编号从上至下为$1,2,3,4,5$，$V$集编号从上至下为$a,b,c,d$，则$(2,b),(5,a)$是一个匹配。 3 最大匹配在一个二分图$G$中，匹配$G_m$的边数最大（仅考虑不带权匹配），则称$G_m$为$G$的最大匹配。 上图中，若$U$集编号从上至下为$1,2,3,4,5$，$V$集编号从上至下为$a,b,c,d$，则$(1,a),(2,b),(3,c),(5,d)$是最大匹配。 4 增广与增广路从$U$集一未匹配点开始，找一个并$V$集的未匹配点并进行匹配（前提是有连边）的过程称为增广。连接两个新匹配点间的边被称为增广路。 二 判定二分图的判定可以有染色法解决。因为二分图中不存在奇圈，故若用两种颜色将二分图中的每个节点染色，且使得相邻的节点颜色不同，若存在一种合法方案，就可以判定图是二分图。 用dfs模拟染色过程，一旦发现颜色冲突就跳出染色，否则返回染色成功即可。 1234567891011121314151617181920212223242526272829303132333435const int CP=1e4;const int CE=1e5;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}//paintint col[CP]; //col[i]=0 : 未染色 //col[i]=1 : 颜色1 //col[i]=-1 : 颜色2 bool dfs(int u,int c){ col[u] = c; for(int k=hd[u]; k; k=E[k].nxt){ int to=E[k].to; if(col[to] == c) return false; //冲突 if(!col[to] &amp;&amp; !dfs(to,-c)) return false; //向下递归 } return true;}bool examine(){ for(int i=1;i&lt;=n;i++) if(!col[i]){ int flag = dfs(i,1); if(!flag) return false; } return true;} 三 匈牙利算法1 流程 step1以$1$为起点，找一条增广路，选中$(1,a)$（蓝线）。 step2以$2$为起点，找一条增广路，试图选中$(2,a)$（红线）。发现$a$已被匹配，故从$2$开始，走匹配边（蓝线）到$1$，试图寻找增广路，失败。故$a$无法失配，配对失败。 注：此处若能寻找到增广路$(1,x)$，则$a$失配并与$2$配对，$1$重新与$x$配对，因为这样实际上增加了一条匹配边。 step 3继续以$2$为起点，找一条增广路，选中$(2,c)$（蓝线）。 step 4以$3$为起点，找一条增广路，选中$(3,b)$（蓝线）。至此，左图中所有点皆以匹配完成，算法结束。 2 代码实现（match）判断能否增广的过程需要一遍dfs，且需要知道 能(true)与否(false)。故我们需要定义一个返回值为bool的dfs。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//match/*节点1~n:左图节点节点n+1~2n:右图节点边表存图，E为边集*/const int CON=2e3+3;//边表class fs{ public: int to,nxt;}E[CON];int hd[CON],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}bool ins[CON]; //判断右图的节点是否已经被访问过int mtclf[CON]; //mtclf[i]为左图节点i在右图中的匹配节点int mtcrt[CON]; //mtclf[i]为右图节点i在左图中的匹配节点bool dfs(int cur){ for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; //to一定在右图中 if(!ins[to]) //不走回头路 { ins[to] = true; if(!mtcrt[to] || dfs(mtcrt[to])) //若to为没有匹配的节点，或从to节点开始可以找到新的增广路 { mtclf[cur] = to; //to失配并与当前节点配对 mtcrt[to] = cur; return true; //找到了一条增广路 } } } return false; //无法增广}int match(){ int ret=0; //统计答案数 for(int st=1; st&lt;=n; st++) //遍历起点（左图中） if(!mtclf[st]) { memset(ins,false,sizeof(ins)); if(dfs(st)) ret++; //每次dfs仅找到一条增广路，故答案+1 } return ret; //返回答案} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"},{"title":"十月划水贴","text":"“第100篇post，划个水” 以及 2019.10 JN 学习总结…… 一篇敷衍了事的没卵用总结然后就划水完了？ 还没来得及写的博：[ ] 2-SAT问题[ ] 棋盘问题与二分图有时间再整理。 $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/10/07/%E5%8D%81%E6%9C%88%E5%88%92%E6%B0%B4%E5%B8%96/"},{"title":"分块-区间加法","text":"神犇hzwer太强啦！Orz…… 一 分块基础数据结构问题的基本模型可以概括为：维护一段长为$n$的数列，支持对指定区间$[L,R]$进行某种修改（modify）与查询（query）操作。 解决这类问题很暴力的想法就是：对于每段区间的元素都去暴力修改和暴力求解。 在这样的暴力想法下，如果能找到一种方法，使得对于所有的区间都可以被分成若干个部分，每个部分可以整体进行修改或查询操作，那么修改或查询的复杂度会大大地降低。这就是分块的思想。很暴力，但是很优雅。 把一段长为$n$的数列分成$\\sqrt{n}$块，对于区间$[L,R]$中完整的块进行整体修改，不完整的块进行暴力修改。完整的块至多有$\\sqrt{n}$块，不完整的块至多长$\\sqrt{n}$，所以我们能在至多$\\sqrt{n} \\times c$的时间里实现一次修改或查询操作（$c$为修改或查询本身需要的复杂度）。虽说比$log_2 n $还是慢了点，不过对于大部分数据已经足够了。 画出下面的图，以便于形象的理解。 二 模型维护一段长为$n$数列，支持区间加法，并查询指定区间和。 依然是上面的思想，整块用tag来维护，不完整的块直接暴力修改并更新区间和。 三 代码给出两种写法 1 单点查询（树状数组）模板 1234567891011121314151617181920212223const int CN=5e4+4;int n,v[CN];//hzwer tqlint bel[CN],bcnt; //bel : 所属块的编号 ; bcnt : 块数int tag[CN]; //tag : 标记void build(){ //构造 bcnt=sqrt(n); for(int i=1;i&lt;=n;i++) bel[i]=(i-1)/bcnt+1; //除法强制上取整 }void modify(int l,int r,int c){ //修改 //暴力 for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) //注意这里的边界，可以手推一下，bel[i]*bcnt表示区间i的结尾 v[i] += c; if(bel[l] != bel[r]) for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) //注意边界 v[i] += c; //整块 for(int i=bel[l]+1; i&lt;bel[r]; i++) tag[i] += c; //打标记（单点查询，只加一次） } 2 区间查询（线段树）模板 1234567891011121314151617181920212223242526272829303132333435363738394041#define LL long longconst int CN=5e4+4;int n;LL v[CN];//hzwer tqlint bel[CN],bcnt; //bel : 所属块的编号 ; bcnt : 块数 LL tag[CN],sum[CN]; //tag : 标记 ; sum : 区间和void build(){ //构造 bcnt=sqrt(n); for(int i=1;i&lt;=n;i++){ bel[i]=(i-1)/bcnt+1; sum[bel[i]] += v[i]; //累加和 }}void modify(int l,int r,int c){ //修改 for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++){ v[i] += c; sum[bel[i]] += c; //修改区间和 } if(bel[l] != bel[r]) for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++){ v[i] += c; sum[bel[i]] += c; } for(int i=bel[l]+1; i&lt;bel[r]; i++) tag[i] += c; }LL query(int l,int r){ //查询 LL ans=0; for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) ans += v[i]+tag[bel[i]]; //注意别忘了加上tag if(bel[l] != bel[r]) for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) ans += v[i]+tag[bel[i]]; for(int i=bel[l]+1; i&lt;bel[r]; i++) ans += sum[i]+tag[i]*bcnt; //tag*区间长度 return ans;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/13/%E5%88%86%E5%9D%97-%E5%8C%BA%E9%97%B4%E5%8A%A0%E6%B3%95/"},{"title":"利用vector重现set","text":"提供一种小数据下运行效率极高的std::set替代方法。 此页面存在相关页面。关于普通平衡树，请参见「Splay」。 众所周知，平衡树有两类：一类维护集合，一类维护序列。维护序列的平衡树通常作为线段树的替代，用于解决线段树并不支持的区间翻转操作；而维护集合的平衡树则可以被看作是在重现std::set。 但是这并不是最简便的方案，实际上，我们可以利用std::vector去吊锤维护集合的平衡树。此种方法在 $10^5$ 量级下速度极快，运行时间甚至优于普通 Splay。 维护集合的平衡树被用来解决这样一类问题： 您需要写一种数据结构，来维护一些数，其中需要提供以下操作： 插入 $x$ 数 删除 $x$ 数（若有多个相同的数，因只删除一个） 查询 $x$ 数的排名（排名定义为比当前数小的数的个数 $+1$） 查询排名为 $x$ 的数 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数） 求 $x$ 的后继（后继定义为大于 $x$，且最小的数） 设 $n$ 为集合的最大大小，对所有数据，满足 $n\\le 10^5$。 利用std::lower_bound和std::upper_bound，可以得到下面的这样两条语句： 12lower_bound(v.begin(), v.end(), x) - v.begin() // &lt; x 的元素个数upper_bound(v.begin(), v.end(), x) - v.begin() // &lt;= x 的元素个数 于是可以得到下面这份代码实现。显然，它吊锤了 Splay。 1234567891011vector&lt;int&gt; v; int n = read();while(n--){ int tp = read(), x = read(); if(tp == 1) v.insert(lower_bound(v.begin(), v.end(), x), x); if(tp == 2) v.erase(lower_bound(v.begin(), v.end(), x)); if(tp == 3) printf(\"%d\", lower_bound(v.begin(), v.end(), x) - v.begin() + 1); if(tp == 4) printf(\"%d\", v[x - 1]); if(tp == 5) printf(\"%d\", v[lower_bound(v.begin(), v.end(), x) - v.begin() - 1]); if(tp == 6) printf(\"%d\", v[upper_bound(v.begin(), v.end(), x) - v.begin()]); if(tp &gt; 2) puts(\"\");} 理性分析一下，这份代码的时间复杂度为 $O(n^2\\log n)$，瓶颈在于erase()和insert()。 但是我们可以对其进行测试，Generator 如下： 12345678910111213#include&lt;cstdio&gt;#include&lt;string&gt;int n = 100000;int main() { freopen(\"_in.in\", \"w\", stdout); printf(\"%d\", n), puts(\"\"); int t1 = 1, t2 = 1000000000; for(int i = 1; i &lt; n; i++){ if(i &amp; 1) printf(\"1 %d\", t1++), puts(\"\"); else printf(\"1 %d\", t2--), puts(\"\"); } printf(\"4 %d\", n / 2);} 本机测试结果如下： 数据范围 $n=5\\times10^4$ $n=10^5$ $n=5\\times 10^5$ $n=10^6$ 运行时间（平均，向下近似） 100ms 280ms 7.7s 30s 运行时间（平均，向下近似，O2） 70ms 280ms 7s 28s 对比（普通 Splay） 30ms 30ms 260ms 380ms 容易发现当 $n$ 超过 $10^5$ 的量级后，其运行效率略大于 $O(n\\sqrt{n})$，而在之前效率及其优秀。但是实际上题目中插入操作的数量并没有达到测试中的量级，因此出现了吊锤 Splay 的现象。 于是我们可以初步地得出结论：在 $10^5$ 的数据量级下，利用vector代替 Splay 有着优秀的运行效率。 一个栗子 $n$ 个点的图，给出 $m$ 对点和 $q$ 条边。顺序尝试加入每条边，如果不会使得 $m$ 对点中的任意一对点联通，则加入，否则不加入。判断每条边是否会被加入。$n,m,q\\le 10^5$ 条件反射：看到不可逆性修改操作，就应该想到结构合并。 容易想到对每个点维护一个set，表示该点不能到达的点集，然后连一条边相当于合并两个set，在合并前判断一下，然后启发式合并就好了。然后把set换成vector，运行时间得以缩小一半。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int CN = 2e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class DSU { public: int fa[CN]; DSU() {for(int i = 1; i &lt;= 100000; i++) fa[i] = i;} int fd(int x) {return fa[x] ^ x ? fa[x] = fd( fa[x] ) : x;}} C;int n, m, q; vector&lt;int&gt; v[CN];int main(){ // freopen(\"_in.in\", \"r\", stdin); n = read(), m = read(), q = read(); while(m--){ int x = read(), y = read(); v[x].push_back(y), v[y].push_back(x); } while(q--){ int x = read(), y = read(), fx = C.fd(x), fy = C.fd(y); if(fx == fy) {putchar('1'); continue;} int szx = v[fx].size(), szy = v[fy].size(); if(szx &gt; szy) swap(fx, fy), swap(szx, szy); bool flag = true; for(int i = 0; i &lt; szx &amp;&amp; flag; i++) if(C.fd( v[fx][i] ) == fy) flag = false; if(!flag) {putchar('0'); continue;} putchar('1'); /* fx -&gt; fy */ C.fa[fx] = fy; for(int i = 0; i &lt; szx; i++){ int u = v[fx][i], p = lower_bound(v[fy].begin(), v[fy].end(), u) - v[fy].begin() - 1; if(v[fy][p] == u) continue; v[fy].insert(lower_bound(v[fy].begin(), v[fy].end(), u), u); } }}","link":"/2020/08/28/%E5%88%A9%E7%94%A8vector%E9%87%8D%E7%8E%B0set/"},{"title":"单调队列","text":"常见的队列一般分为两类：FIFO（先进先出）型和特定元素优先型。第一类常称作普通队列，第二类常被称作优先队列，它实际上更像是一个小根堆…… 一 引入在讲解单调队列之前， 让我们先回顾一下普通队列。 1 为什么需要单调队列常见的队列一般分为两类：FIFO（先进先出）型和特定元素优先型。第一类常称作普通队列，第二类常被称作优先队列，它实际上更像是一个小根堆。二者的用处也不尽相同，前者用于维护进队次序上的先入队者，而后者用来维护数值上的极大（小）者。对于这两类，STL中都有相应的模板，常数也不是很大，而且支持的操作也很多，因此只在这里罗列一下： 123456789101112131415//queue and priority_queue in STL#include&lt;queue&gt;using namespace std;queue&lt;int&gt;Q;Q.push(); //插入Q.front(); //返回队首元素Q.pop(); //出对Q.empty(); //返回是否队空priority_queue&lt;int&gt;heap;heap.push(); //插入heap.top(); //返回堆顶heap.pop(); //删除heap.empty(); //返回是否堆空 但是如果我们遇到这样一个问题：维护一段数列，支持在末尾插入一个数据，在首端删除一个数据，和查询在某一范围内的最大（小）值。这样，普通队列和优先队列都会黯然失色。因为普通队列仅能维护次序性而忽略了元素本身，而优先队列仅维护了元素大小关系却忽略了它们的入队次序。这时，我们就需要单调队列。 2 什么是单调队列正如上面的问题，单调队列就是这样的一个数据结构：维护一段数列，支持在末尾插入一个数据，在首端删除一个数据，和查询数列的最大（小）值。 显然我们还有一种强大的数据结构可以部分替代它——为所欲为的线段树。但有时候它会跑的很慢，因为它还有一个$O(\\log n)$的累赘，而单调队列是$O(n)$的。 二 实现1 实现思想那么单调队列怎么实现这些操作呢？ 可以这样设想：保证队首的元素最大，这样就可以$O(1)$的查询最大值。但是，在首端删除需要维护元素的次序性，因为最大元素不一定是数列的第一个元素。又要使得这个队列内的元素单调下降，因为只有这样，才能保证首端删除后的新首端依然是最大的。 插入元素的时候该怎样维护？不难发现，若当前队尾为$s_t$，新插入的元素为$s_k$，且队列中存在元素$s_i$满足$s_i &lt; s_k$且$s_{i-1} &gt; s_k$，那么$s_{i},s_{i+1},…,s_t$这一部分都是无用的，因为它们比新插入的元素小，对最大值已经没了贡献。删掉它们（这时从队尾出队），既能维护单调性，又可以维护次序性。 这样就实现了单调队列：在维护次序性的同时维护元素单调递减。 2 代码实现123456789101112131415161718192021222324const int C=1e6+6;class mqueue{ public: int d[C],key[C]; //元素的值与下标 int head,tail; //首尾指针 mqueue() {tail=-1;head=0;} void pop(int s) //出队，s为出队后队首的下标 { while(key[head]&lt;s &amp;&amp; head&lt;=tail) head++; } int front() {return d[head];} //返回队首 void push(int v,int k) //插入： v 值; k 下标 { while(head&lt;=tail &amp;&amp; d[tail]&gt;v) //出队直到满足单调性 tail--; d[++tail]=v; //插入 key[tail]=k; }}; $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/28/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"title":"博弈论学习笔记","text":"Alice 和 Bob 又开始玩游戏了…… SG 函数对于博弈论中的局面 $S$，定义它的 SG 函数为 $SG(S)=\\text{mex} SG(T)$，其中 $T$ 是 $S$ 的后继局面。对于无法做出任何移动的局面（先手必败态），我们称之为 P 态，否则称之为 N 态（先手必胜态）。 SG 定理：一个局面 $S$ 是 P 态当且仅当 $SG(S)=0$ 这个定理也可以这样理解：可以到达 P 态的局面是 N 态，所有移动都导致 N 态的局面是 P 态。另一个非常有用的结论：对于由多个局面 $S_1, S_2,…S_n$ 组成的博弈游戏，该局面的 SG 函数是所有 $SG(S_i)$ 的异或和。 经典 Nim 有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取，最后没石子可取的人就输了。问是否存在先手必胜的策略。$n\\le 10^7, a_i\\le 10^9$ 根据 SG 定理，容易发现 $SG(S_i)=a_i$，故先手必胜当且仅当 $a_i$ 的异或和不为0。 阶梯 Nim 有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出任意多枚石子移动到前面一堆石子，可以取完，不能不取，最后无法移动的人就输了（此时所有石子都在位置0）。问是否存在先手必胜的策略。$n\\le 10^7, a_i\\le 10^9$ 若先手移动偶数堆的石子到奇数堆去，那么后手可以立刻将其移入下一个偶数堆，这样看起来对奇数堆毫无影响。但是如果先手移动奇数堆的石子去偶数堆，则可能会将其移入第 0 堆。因此，只有在奇数堆移动石子是本质的。 “从奇数堆移动一些石子去偶数堆”等价于从奇数堆拿走一些石子扔掉，因子对奇数堆做 Nim 即可。 一道栗题 有 $n$ 个箱子，每个箱子有 $a_i$ 个石头，一开始所有箱子都是关着的。Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。不能操作的输，求先手必胜还是后手必胜。$1\\le n\\le 10^5, 0\\le a_i\\le 10^9$ 考虑如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。 因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。 又一道栗题 有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出一枚石子扔掉，但任意两次不能取同堆的石子。最后无法移动的人输，问是否存在先手必胜的策略。$n\\le 10^7, a_i\\le 10^9$ 若存在一堆石子，满足其中石子的个数比其它堆石子个数总和还多，则先手是必胜的，即一直取这一堆就好了。如果不存在呢？那么任意时刻，不能存在一堆石子，使得其中石子的个数多于其它堆石子个数总和。这意味着所有石子都要被取走，因此直接判断奇偶性即可，复杂度 $O(n)$。 双一道栗题 给你 $n$ 张卡片，每张卡片的两个面各有数字 $a_i$ 和 $b_i$，每个面都有 $1/2$ 的概率出现为卡片的正面，卡牌正反面的概率相互独立，求把所有卡牌正面数字拿来玩 Nim 游戏，先手必胜的概率。$n\\le 5\\times 10^5, a_i,b_i\\le 10^{18}$ 设 $S=\\bigoplus\\limits_{i=1}^na_i$，定义序列 $c_i=a_i\\oplus b_i$，则问题等价于求序列 $c$ 有多少个子集使得异或和为 $S$，线性基维护即可，复杂度 $O(n\\log a_i)$。 代码： 1234567891011121314151617181920212223242526class LB { public: LL a[101]; void ins(LL x){ for(int i = 63; i + 1; i--){ if(!(x &amp; (1ll &lt;&lt; i))) continue; if(a[i]) x ^= a[i]; else{ for(int j = i - 1; j + 1; j--) if(x &amp; (1ll &lt;&lt; j)) x ^= a[j]; for(int j = i + 1; j &lt;= 63; j++) if(a[j] &amp; (1ll &lt;&lt; i)) a[j] ^= x; a[i] = x; break; } } } int sz() {int cnt = 0; for(int i = 0; i &lt;= 63; i++) if(a[i]) cnt++; return cnt;} bool ext(LL x) {for(int i = 63; i + 1; i--) if(x &amp; (1ll &lt;&lt; i)) x ^= a[i]; return x == 0 ? 1 : 0;}} D;LL n, sum, a[CN], b[CN];n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), b[i] = read(), D.ins(a[i] ^ b[i]), sum ^= a[i];if(!D.ext(sum)) puts(\"1/1\");else{ int k = D.sz(); LL ans = 1; while(k--) ans &lt;&lt;= 1; printf(\"%lld/%lld\", ans - 1, ans);} 叒一道栗题 有 $n$ 堆石子（$n$ 是偶数），每堆石子有 $a_i$ 个，每人每次可从任意 $n/2$ 堆石子里取出至少一枚石子扔掉。最后无法移动（有石子的堆的数量 $\\le n/2$）的人输，问是否存在先手必胜的策略。$n\\le 10^7, a_i\\le 10^9$ 考虑若存在石子个数为 1 的堆，设堆数为 $x(x&gt;0)$，则有情况如下： $x &gt; n/2$，则先手必败，因为无法避免在操作中形成空堆； $x\\le n/2$，则先手必胜，因为先手只要令操作后 $x&gt;n/2$ 即可 剩下的唯一问题是不存在石子个数为 1 的堆的情况。可以考虑放宽限制，即考虑石子个数为 2 的堆的情况。容易发现石子个数为 2 的情况依然可以归结到上述的两种讨论，因此直接猜出结论：先手必胜当且仅当石子个数最小的堆的数量 $\\le n / 2$。","link":"/2020/09/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"后缀树","text":"众所周知：后缀树是不对劲的 Tire 树…. 后缀树即是路径压缩之后的后缀 Trie ，满足其中的 一些节点 可以双射原串的所有后缀。其分为 显示构造 与 隐式构造 两种，区别在于是否在字符串尾添加一个终止符。其中，显示构造的后缀树满足每个叶子双射原串的一个后缀。 众所周知，SAM 的 Parent 树是反串的后缀树，从而可以通过将字符串倒着插入 SAM 来得到一个串的后缀树。注意，这样得到的后缀树是隐式构造的。 后缀树为我们提供了一个新的思路：两个字符串的 LCP 是它们在 Trie 上的 LCA ，则两个后缀的 LCP 也是它们在后缀树上的 LCA。这可以被形式化地表达如下： $$ \\text{LCP}(s[i:n], s[j:n]) = \\text{len}[ \\text{LCA}(i, j) ] $$ 其中等号后面的 $i, j$ 应当对应为在树上的编号，$\\text{len}[]$ 即为 SAM 中的 len[] 数组。 给出一份查询两个后缀的 LCP 的代码。显然，该份代码也可以通过 SA 实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;const int CN = 1e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SAM{ public: int len[CN &lt;&lt; 1], nxt[CN &lt;&lt; 1], son[CN &lt;&lt; 1][26], lst, idx; SAM() {nxt[0] = -1, idx = lst = 0;} int et(int c){ int u = ++idx, p = lst; len[u] = len[p] + 1, lst = u; while(p ^ -1 &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p]; if(p == -1) return idx; int d = son[p][c]; if(len[d] == len[p] + 1) return nxt[u] = d, idx; int v = ++idx; nxt[v] = nxt[d], nxt[d] = nxt[u] = v, len[v] = len[p] + 1, memcpy(son[v], son[d], sizeof(son[d])); while(p ^ -1 &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p]; return idx - 1; }} D;int n, id[CN]; char ch[CN];vector&lt;int&gt; to[CN];void rbd(){ for(int i = 1; i &lt;= D.idx; i++) to[ D.nxt[i] ].push_back(i);}int fa[CN][30], dep[CN];void dfs(int u, int p){ fa[u][0] = p, dep[u] = dep[p] + 1; int sz = to[u].size(); for(int i = 0; i &lt; sz; i++){ int v = to[u][i]; if(v ^ p) dfs(v, u); }}int lca(int u, int v){ if(dep[u] &lt; dep[v]) swap(u, v); for(int k = 20; k + 1; k--) if(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k]; if(u ^ v) {for(int k = 20; k + 1; k--) if(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][0];} return u;}int main(){ freopen(\"_in.in\", \"r\", stdin); cin &gt;&gt; ch; n = strlen(ch); for(int i = n - 1; i + 1; i--) id[i + 1] = D.et( ch[i] - 'a' ); rbd(), dfs(0, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= D.idx; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; int q = read(); while(q--){ int i = read(), j = read(), l = lca( id[i], id[j] ); printf(\"%d\", D.len[l]), puts(\"\"); }}","link":"/2020/08/16/%E5%90%8E%E7%BC%80%E6%A0%91/"},{"title":"差分约束系统","text":"给定若干组形如$x_i - x_j \\leqslant k_a$（$k$为常数）的不等式，询问该不等式组的一组解。解是指一组$x$，使得$x_1,x_2,…x_n$均满足上述不等式组的限制…… 一 基本概念1 什么是差分约束系统给定若干组形如$x_i - x_j \\leqslant k_a$（$k$为常数）的不等式，询问该不等式组的一组解。解是指一组$x$，使得$x_1,x_2,…x_n$均满足上述不等式组的限制。 2 求解将不等式变形可得$x_i \\leqslant k_a+x_j$。这个限制类似于单源最短路径中总存在$d_i \\leqslant dist(j,i)+d_j | (j,i) \\in E$。于是我们从$j$向$i$建立一条权为$k_a$的有向边。再将每个节点与一个源点相连，将这些从源点出发的边的边权定义为一个固定的常数$c$，求出单源最短路，则$x_1=d_1,x_2=d_2,…,x_n=d_n$就是差分约束系统的一组解。当常数$c$改变时，得到的解也会相应地变化（若常数$c$加上$y$，则所有的$d$值均加上$y$，对满足不等关系无影响）。 对上面的不等式，建图得到下图，$s$为源点。 二 实现差分约束系统是可能无解的。在求解之前，首先要讨论解的存在性。 1 有解与无解（图上的环）在一个图上，环的有无及性质决定了差分约束系统解的有无。 环可以分为以下三种： 正权环：一个正权环在最短路中至多被经过一次。因为当绕这个环第二圈时，只会让走过的路径增大，并且这种增大总是无意义的。 零权环：相似于正权环，零权环至多被经过一次。因为它并不能使最短路改变。 负权环：对于一个包含负权环的图，不存在最短路。因为只要在负环中无限转圈，就可以让路径无限变短。 因此任意一个节点最多被$n-1$个节点松弛。则存在负权环时，一个环上的节点会被松弛无限次，则当任意一个点的松弛次数达到$n$时，不存在最短路，同样不存在差分约束系统的解。 我们只需要记录节点被松弛的次数，即可求出是否有解。 2 SPFA求解差分约束1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int CP=1e3+3;const int CE=CP*404;const int INF=0x3f3f3f2f;//边表class fs{ public: int to,nxt,dist;}E[CE];int hd[CP],ecnt=0;void add(int x,int y,int z){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; E[ecnt].dist=z; hd[x]=ecnt;}//spfabool ins[CP]; //是否在队列中int times[CP]; //times[i] : 节点i被松弛的次数int d[CP]; //保存单源最短路bool spfa(int s) //返回有解（true）或无解（false）{ memset(d,0x3f,sizeof(d)); memset(ins,false,sizeof(ins)); memset(times,0,sizeof(times)); queue&lt;int&gt;Q; Q.push(s); d[s]=0; while(!Q.empty()) { int u=Q.front(); Q.pop(); ins[u]=false; for(int k=hd[u]; k; k=E[k].nxt) { fs e=E[k]; if(d[u]+e.dist &lt; d[e.to]) //松弛 { d[e.to]=d[u]+e.dist; if(!ins[e.to]) //不在队列中就入队 { Q.push(e.to); ins[e.to]=true; if(++times[e.to] == n) //松弛了超过n次，存在负环 return false; } } } } return true;} 3 dfs判断解的存在性相对于上文算法，这里的dfs算法具有一定激进性。它的复杂度是极不稳定的，在某些保证有解并需要求解的题目中，它比上文算法更好卡掉。这种方法的主要思路就是记录有哪些元素在当前路径（也就是dfs栈）中。若当松弛操作时，发现正在使用在栈内的元素松弛当前节点（也就是dfs路径绕了一个圈），此时可以直接判定存在负环，不需要松弛$n$次才可以判定。 这种思想有点暴力的意味，因此复杂度不稳定，在某些数据中可能跑的比某某记者还快。给出核心代码： 123456789101112131415161718192021const int INF=0x3f3f3f3f;bool ins[CP]; //判断是否在当前路径中int d[CP]; //最短路数组，需要初始化为INFbool spfa(int u){ ins[u]=true; for(int k=hd[u]; k; k=E[k].nxt) { fs e=E[k]; if(d[e.to] &gt; d[u]+e.dist) { d[e.to]=d[u]+e.dist; if(ins[e.to] || !spfa(e.to)) //又绕回到栈内元素，即出现负环 return false; } } ins[u]=false; return true; //全部检查完毕} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/25/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/"},{"title":"学习总结 2019.7.21","text":"第一次写学习总结（貌似类似“游记”）的东西。2019.7外出，D1和D6的模拟考试也是让我收获了很多，于是我又来水博客了…… 这篇博就写的随便点吧，多半是给自己看的。 单说D6模拟赛，因为D1模拟赛已经忘得差不多了。T1正解应该是可以yy出来的，T2打表也能拿70分部分分，已经很高了，T3如果我对状压DP能稍微敏感点也能拿到50分的部分分，即使不敏感还有20的暴力分，实际上理想得分应该是100+70+20=190，但是我只拿到70+40+20=120。这未免让人要分析一下原因。 问题一：考试经验少数据范围是有1≤D≤N≤5000，实际上一眼就能看出来这题正解一定要O(1)转移状态，O(n)递推某固定长度下的所有状态，然后O(n^2)完成所有状态。O(1)转移的方法也不难想，都是常见的套路，但是我就硬是没看出来怎么O(1)转移状态。于是我就去想有没有别的办法，而这基本与正解背道而驰。也就是说，实际上缺乏的是一种快速定位到正解，或者猜出正解所考虑的方向的能力。那么只有通过多打模拟赛来弥补。codeforces的比赛有点修仙，于是我从某黄学长的博客里搞到几组套题，预备以后刷掉。 问题二：时间分配失败，瞎搞不会，思路不清晰，部分分拿不到D6T2实际上让我涨了有关这个的许多教训。70%的数据有n≤50000，挺多了，于是不难想到一种很优秀的打表思路：如果我能知道所有互质的勾股数对，那么我就可以用O(n)的时间算出答案（因为每次只需要做除法）。进一步发现，你作除法只用到了勾股数对里面最大的那个数，也就是c，于是我写了这么一个Generator： 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define LL long longLL gcd(LL a,LL b) {return b ? gcd(b,a%b) : a;}LL ans(int r){ LL cnt = 0,last_b = 0; for(LL a=1;a&lt;=r;a++){ bool flag = false; for(LL b=a+1;b&lt;=r;b++){ LL c = sqrt(a*a+b*b); if(c &gt; r) break; if(a*a+b*b == c*c){ //if(!flag) flag = true,last_b = b; //if(c &lt;= r) cnt += r/c; if(c &lt;= r){ cnt++; if(gcd(a,gcd(b,c)) == 1) printf(\"%lld,\",c); } } } } return cnt;}int main(){ freopen(\"g.out\",\"w\",stdout); ans(50000); return 0;} 实际上你刚刚写出来并不会知道它是不是正确的。于是我又写了一个examine.cpp 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;#define LL long longLL gcd(LL a,LL b) {return b ? gcd(b,a%b) : a;} LL ans(int r){ LL cnt = 0,last_b = 0; for(LL a=1;a&lt;=r;a++){ bool flag = false; for(LL b=a+1;b&lt;=r;b++){ LL c = sqrt(a*a+b*b); if(c &gt; r) break; if(a*a+b*b == c*c){ //if(!flag) flag = true,last_b = b; //if(c &lt;= r) cnt += r/c; if(c &lt;= r){ cnt++; if(gcd(a,gcd(b,c)) == 1) printf(\"%lld %lld %lld\\n\",a,b,c); } } } } return cnt;}int main(){ //freopen(\"g.out\",\"w\",stdout); printf(\"%d\",ans(30)); return 0;} 检查的结果是上面的Generator正确，于是我写了这么一个打表程序 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;#define LL long longconst int GouGuNum[20000] = {...略去表}; const int Sum = 7960;LL ans(int r){ LL cnt = 0; for(int i=0;GouGuNum[i]!=0;i++) cnt += r/GouGuNum[i]; return cnt;}int main(){ //freopen(\"g.out\",\"w\",stdout); LL a; scanf(\"%lld\",&amp;a); printf(\"%lld\",ans(a)); return 0;} 实际上它是正确的，大小也被控制在了46k，已经很优秀了，也和我的理想预估得分相符。但是我为什么没有交这个程序呢？因为当时给的大数据没过（后来我发现这个数据是100分分数段里的数据，当然应该不过），然后我就放弃了。也是因为当时只剩下最后30min，整个人都处在一种混乱的状态里面，理不清思路，无法快速的定位到出错点。一方面是缺少比赛经验，而另一方面则是思维不够冷静和灵活。对于这两个方面来说只能去多打模拟赛，另外准备了一些学习资料以总体提升水平。然后就是时间分配。即便是根据中考模拟的时候AK数学的经验，也要知道合理的去分配时间。这个东西最好是你自己给自己规定好：那么好，以后打模拟赛，时间分配40:60:80:30(min)，最后30min用来弹性分配和yy某稍难题目的正解。 问题三：对题目不敏感这就是司空见惯的刷题不够导致的了，不再多说。 然后我想我分析的重点应该往NOIP上靠靠，毕竟还是要准备这个首先先问候出题人为敬，NOIP的题总能让你感受到反手的一个大嘴巴子（例如去年PJ T3）。分析题目，然后你会发现那种一眼就有思路的题并没有几道（反正对于我这个垃圾来说是这样）。也就是说你要拼命的去搞部分分，而搞部分分就得用到上面所提到的“瞎搞”能力。而锻炼这个能力一方面需要解题经验的储备，一方面还需要考试经验的储备，因为解题经验并不会直接变成考场上的分数。那么好了，就从三方面入手：近年NOIP题解题思路也听过了，抽时间写写代码，也提升提升代码能力；然后去学上面的课件；然后逼着自己限时去肝上面的组题（其实在侧边的链接栏里就有链接）。好了，也就总结到这里，也明确下一步的方向。 $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/21/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%202019.7.21/"},{"title":"带权并查集","text":"带权并查集，是指在原有并查集数据结构的基础上，每个节点再维护一个权值，以达到求解既有合并传递性又存在节点权值的数据结构问题…… 一 概念带权并查集，是指在原有并查集数据结构的基础上，每个节点再维护一个权值。该问题的基本模型为： 维护一组数据，数据由若干个集合组成，集合之间支持合并操作，并支持查询某一特定数据的值。 也就是说该数据的任意元素$e$应该由两元构成，即$e=(k,c)$，其中$k$是元素编号，$c$是元素权值。 然后来看题目： LG-P2342 叠积木约翰和贝西在叠积木。共有30000块积木，编号为1到30000。一开始，这些积木放在地上，自然地分成N堆。贝西接受约翰的指示，把一些积木叠在另一些积木的上面。一旦两块积木相叠， 彼此就再也不会分开了，所以最后叠在一起的积木会越来越高。约翰让贝西依次执行P条操作，操作分为两种：第一种是移动操作，格式为“移动X到Y的上面”。X和Y代表两块积木的编号，意思是将X所的那堆积木，整体叠放到Y所在的那堆积木之上；第二种是统计操作，格式为“统计Z下方的积木数量”。Z代表一块积木的编号，意思是贝西需要报告在编号为Z的积木之下还有多少块积木请编写一个程序，帮助贝西回答每条统计问题。 显然，题目中的“移动操作”具有传递性。于是可以把“积木编号”看作$k$，“积木下面有多少积木”看作$c$。关键就是找到集合合并时$c$这一维的变化规律。 如果把积木堆看作队列，那么$i_c$应该是元素$i$到队首的距离。两个队列$A,B$合并时，$A$的队首接在$B$的队尾，会使这个距离扩大$B$队列的长度（那么就得维护这个长度）。这时我们再更新一下$A$队中每个元素的$c$值就好了。 二 实现具体的实现方法如下： 执行操作M A B时，仅更新$A$队队首的权值$c$，然后更新新得到的队列的长度。 对于$A$队中剩下的节点，在每个节点找根（也就是队首）的操作中，再去更新该节点的$c$值（类似于线段树的tag）。这需要知道某一节点$v$与它的父节点$u$的$c$值之间的关系。不难发现新的$v_c$应该等于$ u_c + v_c $，也就$v$到$u$的距离再加上$u$到根的距离。 代码如下： 12345678910111213141516171819class ufs{ public: int fa[CN],dis[CN],siz[CN]; ufs() {for(int i=1;i&lt;CN;i++) fa[i]=i,dis[i]=0,siz[i]=1;} //构造函数 int find(int x){ //找根 if(fa[x] == x) return x; int rt = find(fa[x]); dis[x] += dis[fa[x]]; //维护距离 return fa[x] = rt; //维护完再路径压缩 } bool exm(int x,int y){return find(x)!=find(y);} void merge(int x,int y){ //把 x 接在 y 下面 x = find(x),y = find(y); //找根 fa[x] = y; dis[x] = siz[y]; //更新根到队首的距离 siz[y] += siz[x]; //更新得到的树的大小 } int query(int x){return dis[x];} //查询节点到队首的距离}s; 类似题目LG-P1196 银河英雄传说，这题就是求一下两个节点到队首的距离之差。 $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/04/07/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"归并排序","text":"归并排序，即将原排序序列不断二分为新的序列进行排序，再对这两个序列进行归并，使当前序列变为有序，以达到排序的目的…… 一 算法思想归并排序，即将原排序序列不断二分为新的序列进行排序，再对这两个序列进行归并，使当前序列变为有序，以达到排序的目的。 实际上排序过程建立了一棵对区间的二分递归树，如下图。也可以把它不严谨的理解为一棵线段树。 该算法的实现思路如下：将当前的无序区间$[l,r]$分为区间$[l,m]$和$(m,r]$进行递归，得到有序的两个序列$a_{l\\text{}m}$和$a_{m+1\\text{}j}$。令$j=m+1$，假设有$\\forall i\\in [l,m] ,a_i \\leqslant a_{j}$，我们不断增加$i$的大小并将所有满足假设的$a_i$加入到原序列中。当假设不成立时，增加$j$的大小，并重复上述操作，直到$i$或$j$达到边界限制。那么我们得到的“原序列”一定是有序（升序）的，剩下的$a_i$与$a_j$也一定满足假设（也就是说把$j$所在的序列接在$i$所在的序列后面，得到的新序列有序）。那么我们只要把剩余的部分按序接在原序列的后面就好了。 小性质：排序操作中“假设不成立”的次数即为原序列中逆序对的个数。 时间复杂度：严格的$O(nlog_2 n)$。 二 代码123456789101112131415161718//merge sortint a[CN],rec[CN],n; //a[]:原序列 rec[]:记录新得到的序列（即排好序的序列）void merge_sort(int l,int r){ if(l == r) return; //叶节点无需排序 int m = (l+r)&gt;&gt;1; //取中点 merge_sort(l,m); merge_sort(m+1,r); //二分递归 int i=l,j=m+1,k=l; while(i&lt;=m &amp;&amp; j&lt;=r) //合并 if(a[i] &lt;= a[j]) rec[k++] = a[i++]; else rec[k++] = a[j++]; while(i &lt;= m) rec[k] = a[i],k++,i++; //接到序列后面 while(j &lt;= r) rec[k] = a[j],k++,j++; //接到序列后面 for(int i=l;i&lt;=r;i++) a[i] = rec[i]; //原序列更新} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/08/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"title":"悬线法","text":"有边界限制的最大子矩阵问题一般可以通过悬线法（玄线法）解决，即通过处理出每个节点可以向四周扩张的长度，来计算包含该节点的最大矩阵面积…… 一 模型1 最大子矩阵问题最大子矩阵问题，通常是指在一个$n\\times m$的矩阵中，除去若干不能被包含的点（障点），找出一个面积最大的子矩阵。 2 悬线从矩阵中的一个格点出发，到某一障点引一条竖直的线段被称作悬线。广义的悬线可以被理解为从格点到障点竖直或水平的线段。 3 定义与递推对于每个格点$(i,j)$，定义三种变量如下： $l_{i,j}$：格点$(i,j)$的向左端的悬线长度。 $r_{i,j}$：格点$(i,j)$的向右端的悬线长度。 $up_{i,j}$：格点$(i,j)$的向上的悬线长度。 这些数据可以通过递推处理出来。当$(i,j)$不是障点时（障点的悬线长度均为$0$），有以下递推式：$$ l_{i,j} = l_{i,j-1}+1 \\newline r_{i,j} = l_{i,j+1}+1 \\newline up_{i,j} = up_{i-1,j}+1 $$ 4 数据的处理通过这些数据，我们就可以得出经过格点$(i,j)$的最长宽度（$l_{i,j}+r_{i,j}-1$）和最大高度（$up_{i,j}$）。但是仅凭这些数据还不能得出正确答案。 看下面的图： 不难发现，当前包含该节点的最大子矩阵（实线框出）面积，与橙色线段和绿色线段中长度最小的那两个有关。也就是说当前得到的面积应该表示为：$$ S_{max} = up_{i,j}(\\min\\limits_{i-up_{i,j}&lt; k\\leqslant i} l_{k,j} + \\min\\limits_{i-up_{i,j}&lt; k\\leqslant i} r_{k,j} -1)$$ 其中这两个$\\min$值也是可以直接递推出来的。即当上方格点不是障点时，令$l_{i,j} = \\min l_{i,j},l_{i-1,j}$，那么实际上满足了$l_{i,j} =\\min\\limits_{i-up_{i,j}&lt; k \\leqslant i} l_{k,j} $。$r_{i,j}$同理。 那么当递推完成时，该面积为：$$ S_{max} = up_{i,j}(l_{i,j} + r_{i,j} -1)$$预处理之后，枚举每个格点，用上面的式子算面积，取最大值就好了。 二 代码总共需要有三遍递推，每遍复杂度均为$O(nm)$，总复杂度$O(nm)$。模板题目。 1234567891011121314151617181920212223242526const int CN=1e3+3;bool G[CN][CN];int n,m;int up[CN][CN],l[CN][CN],r[CN][CN];for(int i=1;i&lt;=n;i++){ //第一遍递推处理初值 for(int j=1;j&lt;=m;j++) if(G[i][j]) l[i][j] = l[i][j-1]+1; for(int j=1;j&lt;=m;j++) if(G[i][j]) up[i][j] = up[i-1][j]+1; for(int j=m;j;j--) if(G[i][j]) r[i][j] = r[i][j+1]+1; }for(int i=2;i&lt;=n;i++) //第二遍递推求出min值 for(int j=1;j&lt;=m;j++) if(G[i][j] &amp;&amp; G[i-1][j]){ l[i][j] = min(l[i][j], l[i-1][j]); r[i][j] = min(r[i][j], r[i-1][j]); } int ans=0;for(int i=1;i&lt;=n;i++) //第三遍遍历求出答案 for(int j=1;j&lt;=n;j++) ans = max(ans, (l[i][j]+r[i][j]-1)*up[i][j]); 三 变形 ZJOI2007 棋盘制作 国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个8×8大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。而我们的主人公小Q，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小W决定将棋盘扩大以适应他们的新规则。小Q找到了一张由N×M个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小Q想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。不过小Q还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。于是小Q找到了即将参加全国信息学竞赛的你，请编程输出可以找到的最大正方形棋盘和最大矩形棋盘的面积。 这题中没有“障点”，那么悬线应该定义为“从某一格点开始沿竖直或水平方向所能走出的最长的黑白相间的道路”。依然按照上面的方法处理即可，细节参见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN=2e3+3;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}bool G[CN][CN];int n,m;int up[CN][CN],l[CN][CN],r[CN][CN];int main(){ n=read(),m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ int c=read(); G[i][j] = c ? true : false; l[i][j] = r[i][j] = up[i][j] = 1; } //preparation for(int i=1;i&lt;=n;i++){ for(int j=2;j&lt;=m;j++) if(G[i][j] != G[i][j-1]) //不同时转移 l[i][j] = l[i][j-1]+1; for(int j=m-1;j;j--) if(G[i][j] != G[i][j+1]) r[i][j] = r[i][j+1]+1; } for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(G[i][j] != G[i-1][j]) up[i][j] = up[i-1][j]+1; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(G[i][j] != G[i-1][j]){ //求出min值 l[i][j] = min(l[i][j], l[i-1][j]); r[i][j] = min(r[i][j], r[i-1][j]); } //solve int ans = 0; for(int i=1;i&lt;=n;i++) //正方形 for(int j=1;j&lt;=m;j++){ int a = min(up[i][j], (l[i][j]+r[i][j]-1)); //从两个边长里面取一个小的 ans = max(ans, a*a); } printf(\"%d\\n\",ans); ans = 0; for(int i=1;i&lt;=n;i++) //矩形 for(int j=1;j&lt;=m;j++) ans = max(ans, (l[i][j]+r[i][j]-1)*up[i][j]); printf(\"%d\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/05/19/%E6%82%AC%E7%BA%BF%E6%B3%95/"},{"title":"01-Trie","text":"众所周知，01-Trie 是字符集为 $\\begin{Bmatrix}0,1\\end{Bmatrix}$ 的 Trie ，可用于维护若干数字的二进制位，处理点对异或最值、某种动态异或和问题。 与线性基不同，01-Trie 无法处理子集异或问题，但是可以通过前缀和转化来处理区间异或问题。 1 简介01-Trie 支持在 $O(\\log a_i)$ 的时间内完成如下操作： 查询全局异或和 数列全局加一，维护全局异或和 查询数列中某个数与指定数字异或的最大值 合并两棵 01-Trie 维护的信息 通过将其可持久化，还可以支持如下操作： 查询区间异或和 查询区间中某个数与指定数字异或的最大值 通过观察容易实现上述若干操作，则可以得到这样一份代码： 1234567891011121314151617181920212223/* 非可持久化 */class TRIE { public: int ch[CN * 30][2], d[CN * 30], w[CN * 30], idx, rt, MAXH; #define lc ch[u][0] #define rc ch[u][1] TRIE() {rt = idx = 0, MAXH = 30;} int make() {return ++idx;} void mt(int u){ d[u] = 0, w[u] = w[lc] + w[rc]; if(rc) d[u] ^= (d[rc] &lt;&lt; 1) | (w[rc] &amp; 1); if(lc) d[u] ^= d[lc] &lt;&lt; 1; w[u] &amp;= 1; } void ins(int &amp;u, int x, int dep){ // 插入一个数 if(!u) u = make(); if(dep == MAXH) return (void)(w[u] ^= 1); if(x &amp; 1) ins(rc, x &gt;&gt; 1, dep + 1); else ins(lc, x &gt;&gt; 1, dep + 1); mt(u); } void add(int u) {if(rc) add(rc); swap(lc, rc), mt(u);} // 全局加一 int sum() {return d[rt];} // 全局异或和} D; 注意，01-Trie 的可持久化看上去并不支持版本修改，因为无法使用树状数组维护子树交换信息。 2 一道栗题 「TJOI2017」异或和 给定一段数列，定义数列的“连续和”为数列的某个子串的所有数之和，求序列所有连续和的异或值。 考虑固定左端点 $l$ ，$O(n)$ 枚举右端点 $r$ ，则可以求出一些左端点固定的区间 $[l,r]$ 权值和异或和。 考虑优化这个过程：对于一个左端点 $l$ ，如何快速求出其能对应的所有区间 $[l,r]$ 的异或和。由于数列是静态的，那么我们考虑 $l\\to l-1$ 时贡献的变化，它应该是这个样子： $$\\begin{aligned} &amp; (s[n]-s[l])\\oplus (s[n-1]-s[l])\\oplus … \\oplus (s[l+1]-s[l]) \\newline \\to &amp;(s[n]-s[l]+a[l-1])\\oplus (s[n-1]-s[l]+a[l-1])\\oplus …\\oplus a[l-1] \\end{aligned}$$ 其中 $s[]$ 代表 $a[]$ 的前缀和。容易发现这个变化是对每一项同时加了一个值之后再查询异或和，显然可以通过 01-Tire 来维护，总复杂度 $O((n+\\sum a_i)\\log a_i)$；由于 $\\sum a_i \\le 10^6$，所以可以通过。 代码： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1e5 + 5;int read() { /* 略 */ }class TRIE { /* 同上 */ } D;int n, a[CN];int main(){ n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); int ans = 0; for(int i = n - 1; i + 1; i--){ int s = a[i + 1]; while(s--) D.add( D.rt ); D.ins(D.rt, a[i + 1], 1); ans ^= D.sum(); } printf(\"%d\", ans);} 3 又一道栗题 「TJOI2018」异或 现在有一颗以 $1$ 为根节点的由 $n$ 个节点组成的树，节点从 $1$ 至 $n$ 编号。树上每个节点上都有一个权值 $v_i$。现在有 $q$ 次操作，操作如下： 1 x z：查询节点 $x$ 的子树中的节点权值与 $z$ 异或结果的最大值。 2 x y z：查询节点 $x$ 到节点 $y$ 的简单路径上的节点的权值与 $z$ 异或结果最大值。 容易想到树剖，则转化为序列上的查询操作。通过版本来区分区间，即将 01-Tire 可持久化，即可解决本题。 可持久化 01-Trie 一般用于处理静态区间异或最大值问题。 容易得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 5e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}class TRIE { public: int rt[CN], ch[CN * 30][2], w[CN * 30], MAXH, idx; #define lc ch[u][0] #define rc ch[u][1] TRIE() {idx = 0, MAXH = 31;} int make() {return ++idx;} void ins(int &amp;u, int v, int x, int dep){ if(!u) u = make(); if(dep &lt; 0) return (void)(w[u] = w[v] + 1); int b = (x &gt;&gt; dep) &amp; 1; ch[u][!b] = ch[v][!b]; ins(ch[u][b], ch[v][b], x, dep - 1); w[u] = w[lc] + w[rc]; } int qm(int u, int v, int k, int dep){ if(dep &lt; 0) return 0; int b = (k &gt;&gt; dep) &amp; 1; if(w[ ch[u][!b] ] &gt; w[ ch[v][!b] ]) return (1 &lt;&lt; dep) | qm(ch[u][!b], ch[v][!b], k, dep - 1); else return qm(ch[u][b], ch[v][b], k, dep - 1); }} D;int n, q, v[CN], oid[CN];int top[CN], id[CN], sz[CN], imp[CN], dep[CN], fa[CN], idx = 0;void dfs1(int u, int p) { dep[u] = dep[p] + 1, sz[u] = 1, fa[u] = p; int mx = 0; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p) dfs1(v, u), sz[u] += sz[v], mx = sz[v] &gt; mx ? imp[u] = v, sz[v] : mx; }}void dfs2(int u, int t){ top[u] = t, id[u] = ++idx; if(imp[u]) dfs2(imp[u], t); for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ imp[u] &amp;&amp; v ^ fa[u]) dfs2(v, v); }}int qu(int x, int y, int z){ int ans = 0; while(top[x] != top[y]){ if(dep[ top[x] ] &lt; dep[ top[y] ]) swap(x, y); ans = max(ans, D.qm(D.rt[ id[x] ], D.rt[ id[ top[x] ] - 1 ], z, D.MAXH)); x = fa[ top[x] ]; } if(dep[x] &lt; dep[y]) swap(x, y); ans = max(ans ,D.qm(D.rt[ id[x] ], D.rt[ id[y] - 1 ], z, D.MAXH)); return ans;}bool cmp(int x, int y) {return id[x] &lt; id[y];}int main(){ n = read(), q = read(); for(int i = 1; i &lt;= n; i++) v[i] = read(), oid[i] = i; for(int i = 1; i &lt; n; i++) {int u = read(), v = read(); add(u, v), add(v, u);} dfs1(1, 0), dfs2(1, 1); sort(oid + 1, oid + n + 1, cmp); for(int i = 1; i &lt;= n; i++) D.ins(D.rt[i], D.rt[i - 1], v[ oid[i] ], D.MAXH); while(q--){ int o = read(), x = read(), y = read(), z; if(o == 1) printf(\"%d\", D.qm(D.rt[ id[x] + sz[x] - 1 ], D.rt[ id[x] - 1 ], y, D.MAXH)), puts(\"\"); else z = read(), printf(\"%d\", qu(x, y, z)), puts(\"\"); }} 4 双一道栗题 「联合省选 2020 A」树 给定一棵 $n$ 个结点的有根树 $T$，结点从 $1$ 开始编号，根结点为 $1$ 号结点，每个结点有一个正整数权值 $v_i$。设 $x$ 号结点的子树内（包含 $x$ 自身）的所有结点编号为 $c_1,c_2,\\dots,c_k$，定义 $x$ 的价值为：$$val(x)=(v_{c_1}+d(c_1,x)) \\oplus (v_{c_2}+d(c_2,x)) \\oplus \\cdots \\oplus (v_{c_k}+d(c_k, x))$$其中 $d(x,y)$ 表示树上 $x$ 号结点与 $y$ 号结点间唯一简单路径所包含的边数，$d(x,x) = 0$。$\\oplus$ 表示异或运算。请你求出 $\\sum\\limits_{i=1}^n val(i)$ 的结果。 对每个叶子建立一棵 01-Trie ，然后每次合起来再全局加一即可得到父亲的 01-Trie ，统计答案即可。 01-Trie 合并的序列意义是：把两段序列的所有数字插入同一个 01-Trie ，并维护异或和。 容易得到如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 6e5+5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;}}E[CN &lt;&lt; 2];int hd[CN],ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}class trie{ // dep = 0,dep &gt; 20 public: int ch[CN * 30][2], w[CN * 30], val[CN * 30], rt[CN], tot; trie() {memset(rt, 0, sizeof(rt)); tot = 0;} #define lc ch[u][0] #define rc ch[u][1] int make() {int u = ++tot; lc = rc = w[u] = val[u] = 0; return tot;} void maintain(int u){ w[u] = val[u] = 0; if(lc) w[u] += w[lc], val[u] ^= val[lc] &lt;&lt; 1; if(rc) w[u] += w[rc], val[u] ^= (val[rc] &lt;&lt; 1) | w[rc]; w[u] &amp;= 1; } void ins(int &amp;u,int x,int dep){ if(!u) u = make(); if(dep &gt; 20) return (void)(w[u] ^= 1); ins(ch[u][x &amp; 1], x &gt;&gt; 1, dep + 1); maintain(u); } void addall(int u) {if(rc) addall(rc); swap(lc, rc); maintain(u);} int merge(int u,int k){ if(!k) return u; if(!u) return k; w[u] = (w[u] + w[k]) &amp; 1; val[u] ^= val[k]; lc = merge(lc, ch[k][0]); rc = merge(rc, ch[k][1]); return u; }}D;int n,v[CN],va[CN];void dfs(int u){ if(!hd[u]){ va[u] = v[u]; D.ins(D.rt[u], v[u], 0); return; } int k = hd[u], s1; for(; k; k = E[k].nxt) dfs(E[k].to); k = hd[u], s1 = E[k].to, k = E[k].nxt, D.rt[u] = D.rt[s1]; for(; k; k = E[k].nxt){ int v = E[k].to; D.merge(D.rt[u], D.rt[v]); } D.addall(D.rt[u]), D.ins(D.rt[u], v[u], 0); va[u] = D.val[ D.rt[u] ];}int main(){ n = read(); for(int i = 1;i &lt;= n;i++) v[i] = read(); for(int i = 2;i &lt;= n;i++) add(read(), i); dfs(1); long long ans = 0; for(int i = 1;i &lt;= n;i++) ans += 1ll * va[i]; printf(\"%lld\", ans); }","link":"/2020/08/18/01-Trie/"},{"title":"KMP学习笔记","text":"众所周知，对于一般的字符串题，存在如下规律：字符串算法 &lt; hash &lt; 暴力，其中 “&lt;” 代表“劣于”。 kmp 被用来解决下面的这样一个问题： 给定两个字符串 $S,T$ ，求 $S$ 在 $T$ 中匹配的数量和位置。$|T|,|S|\\le 10^6$ 直接 hash 和 kmp 都是 $O(|S|+|T|)$ 的复杂度，但是 kmp 的思想还是要理解的。kmp 的思想基于下面这两个东西。 border一个 border 定义为字符串的一段前缀，使其等于本串的一段后缀。用符号表示的话就是找到一个 $k$，使得 $s[1:k]=s[n-k+1:n]$。容易发现我们可以用这个 $k$ 去双射一个 border。众所周知，border 具有一个非常优美的性质，即你的 border 的 border 还是你的 border。 next[] 数组定义 $nxt[i]=md(s[1:i])$ 是串 $s$ 的 $nxt[]$ 数组，其中 $md(x)$ 代表串 $x$ 的最长 border 长度（不能是自身）。容易发现 $nxt[i], nxt[nxt[i]],…$ 构成了串 $s[1:i]$ 的所有 border。 kmp 每次确定一个最大的 $k$，使得 $S[1:k] = T[i - k + 1:i]$，然后尝试扩展 $k\\to k+1$，如果 $k=|S|$ 则发现了匹配位置。容易发现，这个尝试扩展的过程可以通过 border 来加速，即若 $S[k+1]\\neq T[i+1]$，则令 $k=nxt[k]$ 即可。 代码： 12345678910111213141516const int CN = 1e6 + 6;int n, m, nxt[CN]; char s[CN], t[CN];cin &gt;&gt; (t + 1) &gt;&gt; (s + 1); n = strlen(t + 1), m = strlen(s + 1);int k = 0; nxt[1] = 0, nxt[0] = -1; // k : 当前的最长 borderfor(int i = 2; i &lt;= m; i++){ while(k ^ -1 &amp;&amp; s[k + 1] != s[i]) k = nxt[k]; // 去找次长 border nxt[i] = (k += 1); // 往下匹配一位}k = 0;for(int i = 1; i &lt;= n; i++){ while(k ^ -1 &amp;&amp; s[k + 1] != t[i]) k = nxt[k]; // 同理 if((k += 1) == m) printf(\"%d\", i - m + 1), puts(\"\"); // 已经匹配上} 一道栗题 给定字符串 $S$，求 $S$ 的所有前缀的不重叠的 border 数量。$|S|\\le 5\\times 10^7$ 直接在 kmp 上维护即可，注意一下 kmp 想要保证复杂度则必须避免反复横跳。时间复杂度 $O(n)$。 代码： 1234567891011121314151617181920const int CN = 1e7 + 7;const int P = 1e9 + 7;int t, n, nxt[CN], num[CN]; char s[CN];scanf(\"%s\", s + 1); n = strlen(s + 1); int k = 0; nxt[0] = -1, nxt[1] = 0, num[1] = 1;for(int i = 2; i &lt;= n; i++){ while(k ^ -1 &amp;&amp; s[k + 1] != s[i]) k = nxt[k]; k += 1, nxt[i] = k, num[i] = num[k] + 1;} int ans = 1; k = 0;for(int i = 2; i &lt;= n; i++){ while(k ^ -1 &amp;&amp; s[k + 1] != s[i]) k = nxt[k]; while(k &gt; i / 2) k = nxt[k]; // 跑过了就挪回去 ans = 1ll * ans * (num[k] + 1) % P;}printf(\"%d\", ans), puts(\"\"); 在字典树上的扩展考虑这样一个问题： 给定一个字符串 $T$，和一些字符串 $S_1,S_2,…S_n$，对每个 $S_i$ 求其在 $T$ 中匹配的数量。$|T|,\\sum|S_i|\\le 10^6$ 解决方法是对 $S_i$ 建立字典树，然后再在字典树上建立类似于 $nxt[]$ 指针的结构。注意到这种方法具有可扩展性，即广义后缀自动机也通过类似的思想构建。 于是这棵字典树变成了一个确定有限状态自动机（DFA），我们称其为 AC自动机（Aho-Corasick Automaton, ACAM）。 则可以得到这样一份构建代码： 123456789101112131415161718192021222324252627282930const int CN = 1e6 + 6;class ACAM { public: int son[CN][26], fail[CN], e[CN], idx; queue&lt;int&gt; Q; void ins(char *s){ int u = 0; for(int i = 0; s[i]; i++){ if(!son[u][ s[i] - 'a' ]) son[u][ s[i] - 'a' ] = ++idx; u = son[u][ s[i] - 'a' ]; } e[u]++; } void bd(){ for(int i = 0; i &lt; 26; i++) if(son[0][i]) Q.push( son[0][i] ); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int i = 0; i &lt; 26; i++) if(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]); else son[u][i] = son[ fail[u] ][i]; } } int qu(char *s){ int u = 0, r = 0; for(int i = 0; s[i]; i++){ u = son[u][ s[i] - 'a' ]; for(int j = u; j &amp;&amp; e[j] ^ -1; j = fail[j]) r += e[j], e[j] = -1; } return r; }} D; 又一道栗题 给定一个字符串 $T$ 和一些字符串 $S_1,S_2,…S_n$，定义一个字符串是可爱的当且仅当它不包含任何 $S_i$ 作为子串。试删除最少的字符使得 $T$ 变得可爱。$|T|,\\sum|S_i|\\le 5000$ 考虑 DP，设 $f[l,u]$ 为考虑 $S[1:l]$，在AC自动机上走到了节点 $u$ 的最小代价。考虑 $S[l+1]$ 是否删除，则有转移：$$\\begin{aligned} &amp;f[l,u]+1\\to f[l + 1, u]\\newline &amp;f[l,u]\\to f[l+1,v] \\text{ }|\\text{ }son[u, S[l + 1]] = v\\end{aligned}$$ $v$ 点应当满足怎样的限制呢？首先它不应该是接受状态，并且 fail 树上它到根的路径上也不能存在接受状态，因为这些状态是后缀等价的。那么按照 bfs 序更新一下即可，时间复杂度 $O(|T|\\sum |S_i|)$。 代码： 1234567891011121314151617181920212223242526272829303132333435const int CN = 2020;class ACAM { public: int son[CN][26], fail[CN], w[CN], idx; queue&lt;int&gt; Q; void ins(char *s){ int u = 0; for(int i = 0; s[i]; i++){ if(!son[u][ s[i] - 'a' ]) son[u][ s[i] - 'a' ] = ++idx; u = son[u][ s[i] - 'a' ]; } w[u]++; } void bd(){ for(int i = 0; i &lt; 26; i++) if(son[0][i]) Q.push(son[0][i]); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int i = 0; i &lt; 26; i++) if(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]); else son[u][i] = son[ fail[u] ][i]; w[u] += w[ fail[u] ]; // mark } } int f[CN][CN]; int solve(char *s, int n){ memset(f, 0x3f, sizeof(f)), f[0][0] = 0; for(int l = 0; l &lt; n; l++) for(int i = 0; i &lt;= idx; i++){ f[l + 1][i] = min(f[l + 1][i], f[l][i] + 1); int v = son[i][ s[l] - 'a' ]; if(!w[v]) f[l + 1][v] = min(f[l + 1][v], f[l][i]); } int ans = 0x3f3f3f3f; for(int i = 0; i &lt;= idx; i++) ans = min(ans, f[n][i]); return ans; }} D; 双一道栗题 给定一些字符串 $S_1,S_2,…S_n$ 和字符集 $\\Sigma$，每个字符串 $S_i$ 有一个价值 $w_i$。定义一个字符串的价值为其所有子串的价值和（未定义则为 $0$），求一个长度为 $l$ 的串使得其价值最大。$|\\Sigma|\\le 26 ,\\sum|S_i|,l\\le 1000$ 考虑 DP，假设当前的字符串为 $s$，新增了一个字符 $c$ 得到 $sc$，则新增的子串应当是 $sc$ 的所有后缀，新增字符的价值为这些后缀的价值和。对 $S_i$ 建立AC自动机，则“这些后缀的价值和”体现为 fail 树上从根到 $sc$ 所在的节点的权值和，我们记其为 $w[u]$。 于是就可以 DP 了，设 $f[l,u]$ 表示当前拼出的串长度为 $l$，现在在AC自动机上的节点 $u$ 的最大价值，有转移：$$ f[l,u]+w[v]\\to f[l+1,v]\\text{ }|\\text{ }\\exists c, \\text{s.t.} son[u, c]=v$$ 时间复杂度 $O(l\\sum|S_i||\\Sigma|)$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243const int CN = 2020;template &lt; class T &gt;class queue { // 惨痛经历 public: T a[CN], hd, tl; queue() {hd = tl = 0;} bool empty() {return hd ^ tl ? 0 : 1;} T front() {return a[hd];} void pop() {hd++;} void push(int x) {a[tl++] = x;}} ;class ACAM { public: int w[CN], son[CN][26], fail[CN], idx; queue&lt;int&gt; Q; void ins(char *s, int val){ int u = 0; for(int i = 0; s[i]; i++){ if(!son[u][ s[i] - 'a' ]) son[u][ s[i] - 'a' ] = ++idx; u = son[u][ s[i] - 'a' ]; } w[u] += val; } void bd(){ for(int i = 0; i &lt; 26; i++) if(son[0][i]) Q.push(son[0][i]); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int i = 0; i &lt; 26; i++) if(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]); else son[u][i] = son[ fail[u] ][i]; w[u] += w[ fail[u] ]; // mark } } int f[CN][CN]; int solve(int l){ memset(f, -0x3f, sizeof(f)), f[0][0] = 0; for(int i = 0; i &lt; l; i++) for(int u = 0; u &lt;= idx; u++) for(int c = 0; c &lt; 26; c++) f[i + 1][ son[u][c] ] = max(f[i + 1][ son[u][c] ], f[i][u] + w[ son[u][c] ]); int ans = -0x3f3f3f3f; for(int u = 0; u &lt;= idx; u++) ans = max(ans, f[l][u]); return ans; }} D;","link":"/2020/08/31/KMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"A*与IDA*算法","text":"只要启发函数写得好，IDA*能当DP跑…… 注：上面那句话是假的。IDA*再快也跑不过DP的。 一 启发式搜索启发式搜索（Heuristically Search），顾名思义，它不像朴素DFS或BFS那样“盲目地”搜索（或称枚举所有状态），而是“有目的地”进行搜索。它通过启发函数$f(x)$来对每个状态（State）$x$进行估价，进而确定搜索的优先级。这样做的好处是能避免在一些与目的状态毫不相关的状态上浪费过多时间，但是难点也就在于启发函数的设计上。 二 A*算法1 引入A*（A-star）算法是一种启发式搜索算法，也称A*寻路算法。该算法的启发函数定义为$f(x)=g(x)+h(x)$。其中$g(x)$为距离函数，定义为从初始状态转移到当前状态所消耗的代价；$h(x)$为估价函数，定义为从当前状态转移到目标状态的理想代价。 A*算法每次从若干状态$x_1,x_2,…,x_n$中挑选一个$f(x)$值最小的状态进行转移，这也是它“启发式搜索”的根源。设$h’(x)$为从当前状态$x$转移到目标状态的实际代价，若有$\\forall x,h(x)\\leqslant h’(x)$，则A*算法可以找到代价最小的转移方法。当$h()$函数满足三角形不等式时，A*算法不会将重复遍历节点。 2 优势我们看这样一道题： 例 LG-T35414 又梦回如下图，有一个n*m的矩阵。您站在绿色点上，想要去到橙色点。您每次只能上下左右移动一个方格，且不能移动到黑色的方格上。请求出最小移动步数。 此题显然可以用BFS解。但是我们来看一下朴素BFS算法的搜索范围（深蓝色）。 不难发现，从绿色节点向左走的部分都是在做无用功，因为这永远不是最优。而启发式搜索A*就能避免遍历这些节点。 定义$h(x)$为当前节点$x$到目标节点的曼哈顿距离，因为这是理想状态下当前节点到终点所需要走的步数。定义$g(x)$为从起点走到当前节点$x$的步数。设$f(x)=g(x)+h(x)$为节点$x$的启发函数。 该算法的流程如下： 将初始节点加入队列： 1. 在队列中找到f(x)值最小的节点； 2. 遍历该节点四个方向上的节点，判断是(T)否(F)已经访问(最优性剪枝)；若F，则计算它们的启发函数，并将节点放入队列； 3. repeat 1. 直到到达目标节点； 那么答案就是目标节点的$g()$值。看起来是不是非常像BFS？其实可以把它看成改进版的BFS（Improved BFS,IMBFS）。 我们来看一下这种算法的搜索范围： 比BFS高到不知道哪里去了！但是！实际上，A*的应用范围非常有限。与之相比，下面讲的要IDA*更为实用。 3 代码上题的求解代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int CN=3010;const int dx[4]={0,0,1,-1}; //方位数组const int dy[4]={1,-1,0,0};class locat{ //坐标 public: int x,y; bool exm(int n,int m){ return (x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m); }};//v deifneint n,m,p;bool vis[CN][CN]; //标记位int abs(int a) {return a&gt;0 ? a:-a;}//A*int dist(locat a,locat b){ //返回曼哈顿距离 return abs(a.x-b.x)+abs(a.y-b.y);}class state{ //每个状态（节点） public: int g,h; //距离函数和估价函数 locat pos; //坐标 bool operator &lt; (const state &amp;a)const {return g+h &gt; a.g+a.h;} //为了用priority_queue}cur,fin; //当前状态和最终状态priority_queue&lt;state&gt; Q;int A_star(){ cur.h = dist(cur.pos, fin.pos); //计算估价 Q.push(cur); while(!Q.empty()){ cur = Q.top(); //取最小 Q.pop(); if(vis[cur.pos.x][cur.pos.y]) continue; vis[cur.pos.x][cur.pos.y] = true; if(!dist(cur.pos,fin.pos)) break; //到达终点 for(int k=0;k&lt;4;k++){ state nxt; //计算下一个状态 nxt.pos.x = cur.pos.x+dx[k]; nxt.pos.y = cur.pos.y+dy[k]; nxt.g = cur.g+1; //步数+1 nxt.h = dist(nxt.pos,fin.pos); //重新计算估价 if(nxt.pos.exm(n,m) &amp;&amp; !vis[nxt.pos.x][nxt.pos.y]) //最优性剪枝 Q.push(nxt); } } return cur.g;}int main(){ ... //scan A_star(); ... //print return 0;} 该代码的提交记录；朴素BFS的提交记录。 三 IDA*算法1 思想顾名思义，IDA*算法就是用迭代加深搜索（IDDFS）实现的A*算法。该算法更不容易被卡TLE，且空间消耗少，应用范围比A*更广。 实际上，IDDFS与IDA*算法的区别仅在于启发函数的有无。 2 例题 LG-P1389 八数码难题在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局，找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。目标布局如下： 1231 2 38 0 47 6 5 解题思路分析数字的移动：可以看作数字与0调换位置。所以我们找到0的位置并进行搜索即可。 定义估价函数$h(x)$为“当前状态$x$与目标状态相比，不匹配的数字个数”。设当前深度为$d$，则启发函数$f(x) = d + h(x) -1$（有$i$个数字不匹配，最少需要$i-1$步使其全部匹配）。设深度限制为$mxd$，则当$f(x) &gt; mxd$时应剪枝。 最优性剪枝：走过的状态再走一遍肯定不优，故需要判断下一个状态是不是当前状态的上层状态。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* IDA* */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int dx[4] = {1,-1,0,0};const int dy[4] = {0,0,1,-1};class locat{ //坐标 public: int x,y; void init(int xx,int yy) {x=xx; y=yy;} bool exm() {return (x&lt;=3&amp;&amp;x&gt;=1&amp;&amp;y&lt;=3&amp;&amp;y&gt;=1);} //判断是否在棋盘内 bool operator !=(const locat &amp;a)const {return (a.x!=x||a.y!=y);} //判断坐标是否相同};//v defineint cur[4][4],fin[4][4],ans=0; //cur[][]: 当前状态 ; fin[][]: 最终状态locat find_loc(int v){ //找值为v的元素的坐标 for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) if(cur[i][j] == v) return (locat){i,j}; return (locat){0,0};}//IDDFSint mxd=1; //深度限制int h(){ //估价函数 int incor=0; //incorrect for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) if(cur[i][j] != fin[i][j]) incor++; return incor;}bool dfs(int d,locat u,locat prv){ if(d == mxd) return !h(); //到达深度限制，检查是否是最终状态 if(d+h()-1 &gt; mxd) return false; //A*剪枝 for(int k=0;k&lt;4;k++){ locat v; v.init(u.x+dx[k],u.y+dy[k]); //计算下一个0的位置 if(v.exm() &amp;&amp; prv!=v){ //最优性剪枝 swap(cur[v.x][v.y], cur[u.x][u.y]); //调换 if(dfs(d+1,v,u)) return true; //到达最终状态，继续返回true swap(cur[v.x][v.y], cur[u.x][u.y]); //回溯 } } return false; //未到达最终状态}int main(){ fin[1][1] = 1; fin[1][2] = 2; fin[1][3] = 3; fin[2][1] = 8; fin[2][2] = 0; fin[2][3] = 4; fin[3][1] = 7; fin[3][2] = 6; fin[3][3] = 5; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++){ char c; cin&gt;&gt;c; cur[i][j] = c-'0'; } if(h()){ while(!dfs(0,find_loc(0),(locat){0,0})) //迭代加深 mxd++; printf(\"%d\",mxd); //输出深度限制 } else printf(\"0\"); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/26/A-star%E4%B8%8EIDA-star%E7%AE%97%E6%B3%95/"},{"title":"hexo主题Icarus浅度修改教程","text":"此页面最近更新时间：2019.8.14，其中可能存在过时内容。 难得放假两天（还是因为来台风），结果so又没得颓，实在是闲的没事干，随便写写博吧，说不定还能当备忘录使…… Icarus实在是hexo的一款非常优秀的主题。它具有极高的自由度和兼容性，并且功能也很齐全。不过还是有一些美中不足的地方，其中一部分被我摸索（瞎蒙）着解决了（蒙中了）。 文本编辑器推荐：Notepad++ 7.1 x64。 侧边栏侧边栏“最新文章”栏这个东西啊，个人感觉真的没什么实用性。可以把它改成类似于优秀文章推广之类的，就比较好了。 打开\\icarus\\layout\\widget\\recent_posts.ejs，找到： \\icarus\\layout\\widget\\recent_posts.ejs1&lt;% site.posts.sort('date', -1).limit(5).each(post =&gt; { %&gt; 一行，改成： \\icarus\\layout\\widget\\recent_posts.ejs1&lt;% site.posts.sort('priority', -1).limit(5).each(post =&gt; { %&gt; 然后只需要在每篇文章上面的配置里加上priority: xxx，其中xxx是你自由确定的优先级（1,2,3之类的数字），就可以自由更改显示在那里的文章了。当然也可以调整显示在那里的文章数量，像这样： \\icarus\\layout\\widget\\recent_posts.ejs1&lt;% site.posts.sort('priority', -1).limit(10).each(post =&gt; { %&gt; 就是显示10篇文章。10也可以改成其它数字。 然后更改栏目名称。打开\\icarus\\languages\\zh-CN.yml ，找到： \\icarus\\languages\\zh-CN.yml1recents: '最新文章' 一句，把“最新文章”替换成“阅读推荐”就好了。 侧边栏“目录”栏自动编号目录本人一般会手动编号，所以这个自动编号功能对我来说并不友好。所以加个开关好了。 打开\\icarus\\layout\\widget\\toc.ejs，把整个文件复制一遍然后粘贴到最后面。然后会有两行像这样的语句： \\icarus\\layout\\widget\\toc.ejs1&lt;% if (get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post')) { 把第一句改成： \\icarus\\layout\\widget\\toc.ejs1&lt;% if (get_config('toc_auto_num') === false &amp;&amp; get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post')) { 第二句改成： \\icarus\\layout\\widget\\toc.ejs1&lt;% if ((get_config('toc_auto_num') === true || !has_config('toc_auto_num')) &amp;&amp; get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post')) { 然后找到第一个if语段中如下的位置： \\icarus\\layout\\widget\\toc.ejs1&lt;span class=\"has-mr-6\"&gt;${toc.index}&lt;/span&gt; 把它注释掉： \\icarus\\layout\\widget\\toc.ejs1&lt;!--span class=\"has-mr-6\"&gt;${toc.index}&lt;/span--&gt; 然后就可以通过文章前面的toc_auto_num: true/false来控制是不是开启自动编号。 侧边栏“资料”栏关注按钮这个东西对我来说也没什么用处。把它链接到关于页面之后，在\\icarus\\languages\\zh-CN.yml 里，找到： \\icarus\\languages\\zh-CN.yml1follow: '关注' 一句，改成： \\icarus\\languages\\zh-CN.yml1follow: '关于' 然后更改页面打开方式为同一页面跳转，具体做法是打开\\icarus\\layout\\widget\\profile.ejs，找到： \\icarus\\layout\\widget\\profile.ejs123&lt;a class=\"level-item button is-link is-rounded\" href=\"&lt;%= url_for(widget.follow_link) %&gt;\" target=\"_blank\"&gt; &lt;%= __('widget.follow') %&gt;&lt;/a&gt; 把target=&quot;_blank&quot;属性删掉就好了。 站底站底备案号及链接这个Icarus貌似并没有预留接口……只能自己写了。 打开\\icarus\\layout\\common\\footer.ejs，找到： \\icarus\\layout\\common\\footer.ejs12345 &lt;% if (has_config('plugins.busuanzi') ? get_config('plugins.busuanzi') : false) { %&gt; &lt;span id=\"busuanzi_container_site_uv\"&gt; &lt;%- _p('plugin.visitor', '&lt;span id=\"busuanzi_value_site_uv\"&gt;0&lt;/span&gt;') %&gt; &lt;/span&gt;&lt;% } %&gt; 一段，在后面添加： \\icarus\\layout\\common\\footer.ejs12&lt;br&gt; &lt;a class=\"has-link-black-ter-2 -link\" href=\"http://beian.miit.gov.cn/\" target=\"_blank\"&gt;省份ICP备xxx号-x&lt;/a&gt; 然后更改样式文件。打开\\icarus\\source\\css\\style.styl，找到这样的两段： \\icarus\\source\\css\\style.styl1234.has-link-black-ter transition: 0.2s ease &amp;:hover color: hsl(217, 71%, 53%) !important\\icarus\\source\\css\\style.styl12.has-link-black-ter color: hsl(0, 0%, 14%) !important 把这两段分别扩充成： \\icarus\\source\\css\\style.styl12345678.has-link-black-ter transition: 0.2s ease &amp;:hover color: hsl(217, 71%, 53%) !important.has-link-black-ter-2 transition: 0.2s ease &amp;:hover color: hsl(217, 71%, 53%) !important\\icarus\\source\\css\\style.styl1234.has-link-black-ter color: hsl(0, 0%, 14%) !important .has-link-black-ter-2 color: hsl(0, 0%, 30%) !important 就好了。 站底字数统计这个主题是没有集成的，所以首先安插件： 1$ npm i --save hexo-wordcount 然后打开\\icarus\\layout\\common\\footer.ejs，找到： \\icarus\\layout\\common\\footer.ejs12345 &lt;% if (has_config('plugins.busuanzi') ? get_config('plugins.busuanzi') : false) { %&gt; &lt;span id=\"busuanzi_container_site_uv\"&gt; &lt;%- _p('plugin.visitor', '&lt;span id=\"busuanzi_value_site_uv\"&gt;0&lt;/span&gt;') %&gt; &lt;/span&gt;&lt;% } %&gt; 一段，在后面添加： \\icarus\\layout\\common\\footer.ejs12&lt;br&gt;&lt;span class=\"post-count\"&gt;&lt;%= totalcount(site) %&gt;&lt;/span&gt; Words in Total 当然，如果想和备案号放在一块，可以这样添加： \\icarus\\layout\\common\\footer.ejs123&lt;br&gt;&lt;span class=\"post-count\"&gt;&lt;%= totalcount(site) %&gt;&lt;/span&gt; Words in Total | &lt;a class=\"has-link-black-ter-2 -link\" href=\"http://beian.miit.gov.cn/\" target=\"_blank\"&gt;省份ICP备xxx号-x&lt;/a&gt; 站点推送Sitemap生成这个的方法对与所有hexo博客来说都是一样的吧…装个插件就好了： 12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 百度自动推送这个貌似并没有什么用处…但是有总比没有好。 需要从baidu上搞到的推送代码，这个代码可能跟下面这份一样或相似： \\icarus\\layout\\common\\scripts.ejs1234567891011121314&lt;script&gt;(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https'){ bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else{ bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);})();&lt;/script&gt; 然后打开\\icarus\\layout\\common\\scripts.ejs，在顶部添加上面的代码就好了。 其他markdown行间代码样式emm，我还真不知道这个叫什么，其实就是abcde这个东西。这个默认的是红色字体，个人感觉不好看。其实可以改。 打开\\icarus\\source\\css\\style.styl，找到： \\icarus\\source\\css\\style.styl1234code color: hsl(348, 100%, 61%) background: transparent padding: 0一段。这段就是控制行间代码样式的。其中`color`控制字体颜色，`background`控制背景颜色，`padding`控制代码块的边距大小。这里提供一种配色方案： \\icarus\\source\\css\\style.styl1234code color: #5E81AC background: #ECEFF4 padding: 0 其实就是本博客现在呈现的行间代码样式。 Sharthis分享插件emm，这个毕竟是国外的东西，在国内不怎么实用。但是它好看啊…想在站底插入这样一个分享按钮，得先注册一个Sharethis账号，然后获得一个javascript代码的url。这个是免费的。 然后主题里大概集成了这个，但是貌似存在BUG导致hexo无法渲染。于是还得自己加。 打开\\icarus\\layout\\common\\article.ejs，找到： \\icarus\\layout\\common\\article.ejs1234567&lt;div class=\"level is-mobile\"&gt; &lt;div class=\"level-start\"&gt; &lt;div class=\"level-item\"&gt; &lt;a class=\"button is-size-7 is-light\" href=\"&lt;%- url_for(post.path) %&gt;#more\"&gt;&lt;%= __('article.more') %&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 一段，在下面添加： \\icarus\\layout\\common\\article.ejs1234567891011&lt;% if (!index &amp;&amp; post.path !== \"friends.html\" &amp;&amp; post.path !== \"about\\index.html\" &amp;&amp; post.path !== \"(你不想添加代码的页面的路径)\" (......)) { %&gt; &lt;hr&gt; &lt;h3 class=\"menu-label has-text-centered\"&gt;(你想要的标题)&lt;/h3&gt; &lt;div class=\"sharethis-inline-share-buttons\"&gt;&lt;/div&gt; &lt;script type='text/javascript' src='(你的js的url)' async='async'&gt;&lt;/script&gt;&lt;% } %&gt; 隐藏首页文章打开\\icarus\\layout\\index.ejs ，把它改成这样： \\icarus\\layout\\index.ejs12345678&lt;% page.posts.each(function(post){ %&gt; &lt;% if (post.unshown !== true) { %&gt; &lt;%- partial('common/article', { post, index: true }) %&gt; &lt;% } %&gt;&lt;% }); %&gt;&lt;% if (page.total &gt; 1) { %&gt; &lt;%- partial('common/paginator') %&gt;&lt;% } %&gt; 然后通过文章表头的unshown: true/false控制就好了。 在搜索中隐藏文章Icarus的insight搜索基于一个本地生成的content.json。所以只要让页面不出现在这个里面就好了。 打开\\icarus\\includes\\generators\\insight.js，找到这样一段： \\icarus\\includes\\generators\\insight.js1234567function postMapper(post) { return { title: post.title, text: minify(post.content), link: url_for(post.path) }} 在前面加上一段： \\icarus\\includes\\generators\\insight.js12345678910function postMapper(post) { if (url_for(post.path) == \"(你想隐藏的页面的路径)\"){ return {} } return { title: post.title, text: minify(post.content), link: url_for(post.path) }} 附录更改过后的文章头部配置： 1234567891011121314151617181920212223---title: date: categories: 分类priority: 0 # 阅读推荐的优先级tags: - 标签- 标签thumbnail: toc: truetoc_auto_num: false # 是否给目录自动编号mathjax: truedonates:share:widgets: - type: recent_posts position: right - type: toc position: rightunshown: # 是否在主页显示--- 最近更新： 2019.8.14","link":"/2019/08/12/hexo%E4%B8%BB%E9%A2%98Icarus%E6%B5%85%E5%BA%A6%E4%BF%AE%E6%94%B9%E6%95%99%E7%A8%8B/"},{"title":"「题解」Atlantis","text":"矩阵面积并问题：扫描线法+线段覆盖…… 一 题目 Source DescriptionsThere are several ancient Greek texts that contain descriptions of the fabled island Atlantis. Some of these texts even include maps of parts of the island. But unfortunately, these maps describe different regions of Atlantis. Your friend Bill has to know the total area for which maps exist. You (unwisely) volunteered to write a program that calculates this quantity. InputThe input file consists of several test cases. Each test case starts with a line containing a single integer n (1&lt;=n&lt;=100) of available maps. The n following lines describe one map each. Each of these lines contains four numbers x1;y1;x2;y2 (0&lt;=x1&lt;x2&lt;=100000;0&lt;=y1&lt;y2&lt;=100000), not necessarily integers. The values (x1; y1) and (x2;y2) are the coordinates of the top-left resp. bottom-right corner of the mapped area. The input file is terminated by a line containing a single 0. Don’t process it. OutputFor each test case, your program should output one section. The first line of each section must be “Test case #k”, where k is the number of the test case (starting with 1). The second one must be “Total explored area: a”, where a is the total explored area (i.e. the area of the union of all rectangles in this test case), printed exact to two digits to the right of the decimal point. Output a blank line after each test case. 二 题解题目大意二维平面内有n个矩形，有些矩形两两相交。给出矩形主对角线的两个端点的坐标（可能不是整数），试求矩形所覆盖的总面积。 思路扫描线法假设我们有一条平行于y轴的线段，从y轴开始不断向x轴正方向平移。我们可以根据这条线段把这个若干矩形组成的不规则图形划分成若干部分（实际上是根据每个矩形平行于y轴的那些边），如下图： 这样划分，那么每两条相邻的扫描线之间的图形面积就可以快速的求出，因为这部分图形都是矩形，且有相同的宽（即两条扫描线之间的距离）。那么我们只需要求出图形的高之和，也就是若干条线段的并。 线段覆盖如下图，两条扫描线之间的部分是两个不相交的矩形，它们的并的面积可以用下面的式子求出。 $(x_2-x_1)$这个值实际上枚举扫描线就可以确定，关键是求出$h$的值。单看$h$在y轴上的投影（图二），不难发现$h$是若干线段的并。于是我们不妨这样想：把每个矩形看成两条相等的线段（高），那么我们在扫描的过程中会先后遇到这两条线段。第一次遇到时，我们在y轴上投影这条线段（也可以看成把它覆盖在y轴上），第二次遇到时，我们把这条线段从y轴上删除。于是我们只需要求出某一时刻，在y轴上的所有线段之并就好了。 那么实际上我们要维护这样一个东西：维护若干线段的并的长度，支持删除或插入一段线段。 那么就可以引入“线段覆盖”这个概念。实际上就是一棵节点维护的是一条“线段”的线段树，树上的每个节点维护在某个区间$[l,r]$内被覆盖的线段长度。详细定义如下： 123456class node{ public: int l,r; //节点所维护的区间 int cnt; //这个区间被完全覆盖的次数 int len; //这个区间被覆盖的长度} 如下图，每条线段两头的标号代表节点所维护的线段的两个端点（离散化之后）： 不难发现线段是满足“区间加法”的性质的，因为在合并时，父区间若未被完全覆盖，则父区间维护的线段长度一定是子区间维护值的和，否则就是子区间的覆盖长度之和。另外还需要对线段的端点进行离散化，细节参见代码。 细节坐标是可能有小数的，因此需要离散化，详见代码。 其次，因为线段树上的每段区间只能划分成$[l,mid]$和$[mid+1,r]$这两个子区间，否则会无限递归。但是如果把 所维护线段的端点 和 线段树的端点 设定为一个点，实际上$[mid,mid+1]$这个区间是被扔掉了的。因此我们若要修改$[l,r]$区间的值，必须调用递归修改$[l,r-1]$区间，然后在回溯更新区间大小的时候，按照$[l,r]$区间更新就好了，正确性请自行验证。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt; #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define DB doubleint read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CN = 2010;class segment{ //定义一条线段 public: DB l,r,x; int f; //线段的值(1或-1) /*矩形的对边的值分别为1 -1，这样当扫描完这个矩形的时候，这两条线段会抵消掉*/ bool operator &lt; (const segment&amp; a)const {return x &lt; a.x;} //按横坐标排序}s[2*CN];int n,scnt = 0,pcnt = 0; //线段的数量:scnt 离散化后点的数量:pcntDB pos[2*CN],ans; //pos:离散化后每个点对应的原始值 ans:面积和class node{ //定义线段树的一个节点 public: DB len; //被覆盖的长度 int cnt; //是否被整段覆盖 (被整段覆盖的次数)};class st{ //线段树 public: node d[8*CN]; inline void build(int l,int r,int k){ //建树 d[k].cnt = 0; d[k].len = 0; //没有被覆盖 if(l == r) return; int m = (l+r)&gt;&gt;1; build(l,m,k&lt;&lt;1); build(m+1,r,k&lt;&lt;1|1); } DB get_len(int l,int r,int k){ //更新线段长度 if(d[k].cnt) return pos[r+1]-pos[l]; //被整段覆盖，r要+1 if(l == r) return 0; //不是线段 return d[k&lt;&lt;1].len + d[k&lt;&lt;1|1].len; //子区间求和 } inline void modify(int l,int r,int k,int s,int t,int x){ //修改 if(s&lt;=l &amp;&amp; r&lt;=t){ //被包含 d[k].cnt += x; //更新覆盖情况 d[k].len = get_len(l,r,k); //更新 return; } //不被包含 int m = (l+r)&gt;&gt;1; if(s &lt;= m) modify(l,m,k&lt;&lt;1,s,t,x); if(m &lt; t) modify(m+1,r,k&lt;&lt;1|1,s,t,x); d[k].len = get_len(l,r,k); //更新 }}sgt;int main(){ n = read(); int kase = 0; while(n){ ans = 0; scnt = 0; for(int i=1;i&lt;=n;i++){ DB x1,y1,x2,y2; scanf(\"%lf%lf%lf%lf\",&amp;x1,&amp;y1,&amp;x2,&amp;y2); //初始化线段 s[scnt+1].l = s[scnt+2].l = min(y1,y2); s[scnt+1].r = s[scnt+2].r = max(y1,y2); s[scnt+1].x = x1; s[scnt+2].x = x2; s[scnt+1].f = 1; s[scnt+2].f = -1; pos[scnt+1] = y1; pos[scnt+2] = y2; scnt += 2; } //离散化 sort(s+1,s+scnt+1); //把线段排序 sort(pos+1,pos+scnt+1); //把离散化的查询表排序 pcnt = 1; for(int i=2;i&lt;=scnt;i++) if(pos[i] != pos[i-1]) pos[++pcnt] = pos[i]; //建树 sgt.build(1,pcnt,1); for(int i=1;i&lt;=scnt;i++){ int l = lower_bound(pos+1,pos+pcnt+1,s[i].l)-pos; //查找离散化之后的值 int r = lower_bound(pos+1,pos+pcnt+1,s[i].r)-pos-1; //r要-1 sgt.modify(1,pcnt,1,l,r,s[i].f); ans += (s[i+1].x-s[i].x)*sgt.d[1].len; //统计答案 } printf(\"Test case #%d\\nTotal explored area: %.2lf\\n\\n\",++kase,ans); n = read(); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/17/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DAtlantis/"},{"title":"「题解」旧试题","text":"来自神仙 11Dimensions 的神仙做法…… 题目 原题链接 求：$$ \\sum\\limits_{i=1}^A \\sum\\limits_{j=1}^B \\sum\\limits_{k=1}^C d(ijk) $$其中 $A,B,C ⩽ 200005$。 分析记$x⊥y$表示$(x,y)=1$。结论： $$d(ijk)=\\sum\\limits_{x|i}\\sum\\limits_{y|i}\\sum\\limits_{z|i}[x⊥y][x⊥z][y⊥z]$$ 其中[]表示艾弗森括号，当且仅当括号内命题为真时取值为1，否则为0。在本篇题解中，这个括号的意义等价于单位函数，即$\\epsilon((a,b))=[(a,b)=1]=[a⊥b]$。那么： $$\\begin{aligned}&amp; \\sum\\limits_{i=1}^A \\sum\\limits_{j=1}^B \\sum\\limits_{k=1}^C d(xyz) \\newline=&amp; \\sum\\limits_{i=1}^A \\sum\\limits_{j=1}^B\\sum\\limits_{k=1}^C\\sum\\limits_{x|i}\\sum\\limits_{y|i}\\sum\\limits_{z|i}[x⊥y][x⊥z][y⊥z] \\newline=&amp; \\sum\\limits_{x=1}^A \\sum\\limits_{y=1}^B \\sum\\limits_{z=1}^C[x⊥y][x⊥z][y⊥z] \\lfloor\\frac{A}{x}\\rfloor \\lfloor\\frac{B}{y}\\rfloor \\lfloor\\frac{C}{z}\\rfloor \\end{aligned}$$ 从三个单位函数里面任选一个反演，利用$\\epsilon=\\mu*1$： $$\\begin{aligned}&amp; \\sum\\limits_{x=1}^A \\sum\\limits_{y=1}^B \\sum\\limits_{z=1}^C[x⊥y][x⊥z][y⊥z] \\lfloor\\frac{A}{x}\\rfloor \\lfloor\\frac{B}{y}\\rfloor \\lfloor\\frac{C}{z}\\rfloor \\newline=&amp; \\sum\\limits_{x=1}^A \\sum\\limits_{y=1}^B \\sum\\limits_{z=1}^C (\\sum\\limits_{d|x,d|y}\\mu(d)) [x⊥z][y⊥z] \\lfloor\\frac{A}{x}\\rfloor \\lfloor\\frac{B}{y}\\rfloor \\lfloor\\frac{C}{z}\\rfloor \\newline=&amp; \\sum\\limits_{z=1}^C\\lfloor\\frac{C}{z}\\rfloor\\sum\\limits_{d=1}^{\\min(A,B)}\\mu(d)\\sum\\limits_{k_1=1}^{\\lfloor\\frac{A}{d}\\rfloor}\\sum\\limits_{k_2=1}^{\\lfloor\\frac{B}{d}\\rfloor}[k_1d⊥z][k_2d⊥z]\\lfloor\\frac{A}{k_1d}\\rfloor \\lfloor\\frac{B}{k_2d}\\rfloor\\end{aligned}$$ 依据$[ab⊥c]\\iff[a⊥c][b⊥c]$，整理得到： $$\\sum\\limits_{z=1}^C\\lfloor\\frac{C}{z}\\rfloor\\sum\\limits_{d=1}^{\\min(A,B)}\\mu(d)[d⊥z](\\sum\\limits_{x=1}^{\\lfloor\\frac{A}{d}\\rfloor}[x⊥z]\\lfloor\\frac{A}{xd}\\rfloor)(\\sum\\limits_{y=1}^{\\lfloor\\frac{B}{d}\\rfloor}[y⊥z] \\lfloor\\frac{B}{yd}\\rfloor)$$ 记： $$\\begin{aligned} g(n,x) = \\sum\\limits_{i=1}^n\\mu(i)[i⊥x] \\newlinef(n,x) = \\sum\\limits_{i=1}^n\\lfloor\\frac{n}{i}\\rfloor[i⊥x] \\end{aligned}$$ 答案变成： $$\\begin{aligned}&amp; \\sum\\limits_{z=1}^C\\lfloor\\frac{C}{z}\\rfloor\\sum\\limits_{d=1}^{\\min(A,B)}\\mu(d)[d⊥z]f(\\lfloor\\frac{A}{d}\\rfloor, z)f(\\lfloor\\frac{B}{d}\\rfloor, z) \\newline=&amp; \\sum\\lfloor\\frac{C}{z}\\rfloor\\sum(g(r,z) - g(l - 1, z))f(\\lfloor\\frac{A}{d}\\rfloor, z)f(\\lfloor\\frac{B}{d}\\rfloor, z)\\end{aligned}$$ 即对$\\mu()$做前缀和然后对后面的$f()$分段，其中$[l,r]$表示整除分段的一段区间。 假设$O(n)$枚举$z$，那么求出后面的$\\sum$的值是$O(\\sqrt{n})$的。但是发现$z$是变化的，当$z$变化时暴力维护$f(),g()$是$O(n^2)$的，这成为了代码复杂度的瓶颈。如何解决？能不能减少更新$f(),g()$的次数？不难发现$z$在函数中发挥作用的地方是判断一个数与其互质。考虑将$z$质因数分解，容易看出一个数与其互质仅和$z$的质因子的种类有关，而与质因子的幂次无关。记： $$lw(z) = \\prod\\limits_{i=1}^np_i, \\text{where }z = \\prod\\limits_{i=1}^np_i^{\\alpha_i}$$ 那么我们只需要考虑$z\\in [1,C]$的所有$lw(z)$值即可（即所有无平方因子的数），它们共用一套$f(),g()$的函数值。通过dfs暴力生成无平方因子数，我们可以把它们一并更新。 但是这远远不够，考虑通过递推来维护$f(),g()$。这个套路参考NOI2016 循环之美。考虑在$z$中删去其一个质因子$x$，即$f(n,z)\\to f(n,z/x)$，将出现何种变化？应当有一部分多加了，要减去： $$\\begin{aligned}f(n,z) &amp;= \\sum\\limits_{i=1}^n\\lfloor\\frac{n}{i}\\rfloor[i⊥z/x] -\\sum\\limits_{i=1}^n\\lfloor\\frac{n}{i}\\rfloor[i⊥z/x][x|i] \\newline&amp;= f(n, z / x) - \\sum\\limits_{k=1}^{\\lfloor\\frac{n}{x}\\rfloor}[kx⊥z/x]\\lfloor\\frac{n}{kx}\\rfloor \\newline&amp;= f(n, z / x) - [x⊥z/x]\\sum\\limits_{k=1}^{\\lfloor\\frac{n}{x}\\rfloor}[k⊥z/x]\\lfloor\\frac{n}{kx}\\rfloor\\newline&amp;= f(n, z / x) - f(\\lfloor\\frac{n}{x}\\rfloor, z/x)\\end{aligned}$$ 对$g()$的推导也同理，利用$\\mu(ab)=\\mu(a)\\mu(b)[a⊥b]$，可以得出： $$\\begin{aligned}g(n,z) &amp;= \\sum\\limits_{i=1}^n \\mu(i) [i⊥z/x] -\\sum\\limits_{i=1}^n \\mu(i) [i⊥z/x][x|i] \\newline&amp;= g(n, z / x) - \\sum\\limits_{k=1}^{\\lfloor\\frac{n}{x}\\rfloor}[kx⊥z/x] \\mu(kx) \\newline&amp;= g(n, z / x) - \\mu(x)\\sum\\limits_{k=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(k)[k⊥x][k⊥z/x] \\newline&amp;= g(n, z / x) + \\sum\\limits_{k=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(k)[k⊥x(z/x)] \\newline&amp;= g(n, z / x) + g(\\lfloor\\frac{n}{x}\\rfloor, z)\\end{aligned}$$ 即： $$\\begin{aligned} g(n,z) = g(n, z / x) + g(\\lfloor\\frac{n}{x}\\rfloor, z) \\newlinef(n,z) = f(n, z / x) - f(\\lfloor\\frac{n}{x}\\rfloor, z/x) \\end{aligned}$$ 那么就可以递推了，但是直接更新是$O(n)$的。容易发现整除分段并不会用到所用的$f(),g()$值，所以我们边做分段边更新就好了，这是$O(\\sqrt{n})$的。空间复杂度呢？f[2e5][2e5],g[2e5][2e5]看似存不下来，但是容易发现后面一维是不连续使用的，那么将其离散化，考虑在dfs构造无平方因子数的时候，下层状态的转移依赖于上层状态，而dfs树的深度是$O(\\log_2n)$的，所以开f[2e5][10]即可。 总复杂度？粗略估计，爆搜的复杂度是$O(2^{\\log_2n})$即$O(n)$的，后面的求和通过整除分段可以$O(\\sqrt{n})$得出，那么总复杂度是$O(n\\sqrt{n})$的。但实际上复杂度要小很多，也就是说如果常数写得好那么它可以跑的飞快（预处理整除分段的端点、cache-friendly之类的），但是本人代码常数没那么小，最慢一个点大约4s？比三元环是好得多了。 Orz 11Dimensions 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 2e5+5;const LL P = 1e9+7;LL read(){ LL s = 0,ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9'; c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}int p[CN],mu[CN],lw[CN]; LL d[CN]; bool np[CN];void sieve(int n){ np[1] = true; mu[1] = 1, d[1] = 1, lw[1] = 1; for(int i = 2;i &lt;= n; i++){ if(!np[i]) p[ ++p[0] ] = i, d[i] = 2, lw[i] = i, mu[i] = -1; for(int j = 1;j &lt;= p[0] &amp;&amp; i * p[j] &lt;= n; j++){ int x = i * p[j]; np[x] = true; if(i % p[j]) d[x] = d[i] &lt;&lt; 1, lw[x] = lw[i] * p[j], mu[x] = -mu[i]; else {d[x] = (d[i] &lt;&lt; 1) - d[i / p[j]], lw[x] = lw[i]; break;} } } for(int i = 1;i &lt;= n;i++) d[i] += d[i - 1],mu[i] += mu[i - 1];}// int t,A,B,C;LL f[CN][10],g[CN][10],s[CN],ans;void init(){ g[0][1] = f[0][1] = 0; for(int l = 1;l &lt;= A; l++){ int r = min(A / (A / l), B / (B / l)); g[r][1] = mu[r]; f[A / l][1] = d[A / l]; f[B / l][1] = d[B / l]; l = r; } memset(s, 0 , sizeof(s)); for(int z = 1;z &lt;= C; z++) s[ lw[z] ] += 1ll * C / z; ans = 0;}void upd(int x,int k){ for(int l = 1;l &lt;= A; l++){ int r = min(A / (A / l), B / (B / l)); g[r][k] = g[r][k - 1] + g[r / x][k]; f[A / l][k] = f[A / l][k - 1] - f[(A / l) / x][k - 1]; f[B / l][k] = f[B / l][k - 1] - f[(B / l) / x][k - 1]; l = r; }}void dfs(int z0, int u, int k){ LL cur = 0; for(int l = 1;l &lt;= A; l++){ int r = min(A / (A / l), B / (B / l)); cur += (g[r][k] - g[l - 1][k]) * f[A / l][k] * f[B / l][k]; cur = (cur % P + P) % P; l = r; } ans += (s[z0] * cur) % P; ans %= P; for(int v = u; 1ll * p[v] * z0 &lt;= C; v++) upd(p[v], k + 1), dfs(z0 * p[v], v + 1, k + 1);}int main(){ freopen(\"_in.in\", \"r\", stdin); t = read(); sieve(2e5); while(t--){ A = read(), B = read(), C = read(); if(A &gt; B) swap(A, B); init(); dfs(1, 1, 1); printf(\"%lld\\n\", ans); }}","link":"/2020/06/19/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%97%A7%E8%AF%95%E9%A2%98/"},{"title":"「题解」最优贸易","text":"C国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市…… 一 题目 原题链接 描述C国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。 C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城市的标号从 1~ n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设 C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。 假设 1~n 号城市的水晶球价格分别为 4,3,5,6,1。 阿龙可以选择如下一条线路：1-&gt;2-&gt;3-&gt;5，并在 2 号城市以 3 的价格买入水晶球，在 3 号城市以 5的价格卖出水晶球，赚取的旅费数为 2。 阿龙也可以选择如下一条线路 1-&gt;4-&gt;5-&gt;4-&gt;5，并在第 1 次到达 5 号城市时以 1 的价格买入水晶球，在第 2 次到达 4 号城市时以 6 的价格卖出水晶球，赚取的旅费数为 5。 现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。 第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。 接下来 m 行，每行有 3 个正整数x,y,z，每两个整数之间用一个空格隔开。如果 z=1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市y 之间的双向道路。 输出一个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 0。 二 题解本题的缩点做法不好想，缩点之后的DP是个难点，在某位cy巨佬的指点下才悟出正解。 1 思路考虑原图为DAG时的情况。 设$ val_i $为当前节点的物价，$ mn_i $为从$1$节点搜索到$i$节点的最小买入价格，$f_i$为从$1$节点到$i$节点的最大利润（不一定在$i$售出），则转移方程：$$ f_i =\\max { f_j,val_i-mn_i } | (j,i) \\in E$$也就是把状态分解成继承前面的状态（当前点不售出）和当前点售出，两者取较大值。 原图不一定为DAG，考虑使用tarjan缩点。那么转移方程也得变一变。 考虑一个连通分量的贡献。 这个最大利润可能出自同一个连通分量，也可能出自不同。 那么它的贡献分为两类（$mx_i$表示连通分量$i$中的最大售价，$mn_i$表示连通分量$i$中的最小进价，$totmn_i$表示连通分量$1-i$中的最小进价）： 最优解来自同一个连通分量。贡献为$mx_i-mn_i$。 最优解来自不同的连通分量，且在当前连通分量售出物品。贡献为$mx_i-totmn_i$。 最优解根当前联通分量不沾边。没有贡献并继承前面的最优解（因为状态设计的缘故，要满足无后效性） 转移方程$$ f_i=\\max { mx_i-mn_i,mx_i-totmn_i,f_j } | (j,i) \\in E $$ 转移需要按照拓扑序进行，再跑一遍拓扑即可。 2 实现边表 12345678910111213141516171819const int CE=1e6+6;const int CP=1e5+5;const int INF=0x7f7f7f3f;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}void E_init(){ memset(hd,0,sizeof(hd)); ecnt=0;} 缩点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//tarjan主过程int dfn[CP],low[CP],idx=0;int stack[CP],top=0;bool ins[CP];int bel[CP],mn[CP],mx[CP],scnt=0;void tarjan(int cur){ dfn[cur] = low[cur] = ++idx; stack[++top]=cur; ins[cur]=true; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]) { tarjan(to); low[cur] = min(low[cur], low[to]); } else if(ins[to]) low[cur] = min(low[cur], low[to]); } if(dfn[cur] == low[cur]) { int pos; scnt++; mx[scnt]=-INF; mn[scnt]=INF; while(true){ pos=stack[top--]; ins[pos]=false; bel[pos]=scnt; mx[scnt] = max(mx[scnt], val[pos]); mn[scnt] = min(mn[scnt], val[pos]); if(pos == cur) break; } }}void scc(){ for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);}//重新建图int in[CP];void re_build(){ E_init(); for(int i=1;i&lt;=m;i++) { if(bel[_x[i]] == bel[_y[i]]) //这里的_x,_y,_z都是图中边的输入数据 continue; add(bel[_x[i]], bel[_y[i]]); in[bel[_y[i]]]+=1; if(_z[i] == 2){ add(bel[_y[i]], bel[_x[i]]); in[bel[_x[i]]]+=1; //统计节点入度，为了跑拓扑 } }} DP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//topo sortint list[CP];queue&lt;int&gt;Q;void tsort(){ for(int i=1;i&lt;=scnt;i++) if(!in[i]) Q.push(i); while(!Q.empty()){ int cur=Q.front(); Q.pop(); list[++list[0]]=cur; for(int k=hd[cur]; k; k=E[k].nxt){ in[E[k].to]--; if(!in[E[k].to]) Q.push(E[k].to); } }}//dpint dp(){ /*此时_x,_y已经用完，重复利用以节省空间*/ memset(_x,0,sizeof(_x)); //_x[i] : 从scc_1到scc_i的最小买入价格 memset(_y,0,sizeof(_y)); //_y[i] : 从scc_1到scc_i的最大利益 tsort(); /*先递推最小买入价格*/ for(int i=1;i&lt;=scnt;i++) _x[i] = mn[i]; for(int i=1;i&lt;=scnt;i++) { int cur=list[i]; for(int k=hd[cur]; k; k=E[k].nxt) _x[E[k].to] = min(_x[E[k].to], _x[cur]); } for(int i=1;i&lt;=scnt;i++) { int cur=list[i]; for(int k=hd[cur]; k; k=E[k].nxt) _y[E[k].to] = max(max(_y[E[k].to], _y[cur]), //维护最优解 或 继承状态 max(mx[E[k].to]-mn[E[k].to], mx[E[k].to]-_x[E[k].to]) //当前scc中的最大利益 或 当前最大价值减去之前最小差价 ); } return _y[bel[n]]; //返回解。注意这里的下标都是连通分量的编号} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/22/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93/"},{"title":"「题解」观光公交","text":"风景迷人的小城Y市，拥有n个美丽的景点。由于慕名而来的游客越来越多，Y市特意安排了一辆观光公交车，为游客提供更便捷的交通服务…… 一 题目 原题链接 描述风景迷人的小城Y市，拥有n个美丽的景点。由于慕名而来的游客越来越多，Y市特意安排了一辆观光公交车，为游客提供更便捷的交通服务。观光公交车在第 0 分钟出现在 1号景点，随后依次前往 2,3 ,4 ,…,n号景点。从第 i 号景点开到第 i+1 号景点需要 D_i 分钟。任意时刻，公交车只能往前开，或在景点处等待。设共有m 个游客，每位游客需要乘车11次从一个景点到达另一个景点，第i i位游客在T_i 分钟来到景点 A_i ，希望乘车前往景点B_i (A_i&lt;B_i)。为了使所有乘客都能顺利到达目的地，公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。 假设乘客上下车不需要时间。一个乘客的旅行时间，等于他到达目的地的时刻减去他来到出发地的时刻。因为只有一辆观光车，有时候还要停下来等其他乘客，乘客们纷纷抱怨旅行时间太长了。于是聪明的司机ZZ给公交车安装了k个氮气加速器，每使用一个加速器，可以使其中一个 &amp;D_i$-1对于同一个D_i 可以重复使用加速器，但是必须保证使用后D ≥0 。 那么ZZ该如何安排使用加速器，才能使所有乘客的旅行时间总和最小？ 输入第1行是3个整数n, m, k，每两个整数之间用一个空格隔开。分别表示景点数、乘客数和氮气加速器个数。 第2行是n-1个整数，每两个整数之间用一个空格隔开，第i 个数表示从第i 个景点开往第i+1 个景点所需要的时间，即 D_i 。 第3行至m+2行每行3个整数 T_i, A_i, B_i ，每两个整数之间用一个空格隔开。第 i+2 行表示第i 位乘客来到出发景点的时刻，出发的景点编号和到达的景点编号。 输出一个整数，表示最小的总旅行时间。 二 题解不考虑加速器，我们可以预处理出所有乘客的旅行时长，接下来只需减去使用$k$个加速器所节省的时间。 设节点$i$的最晚乘客到达时间为$p_i$，观光车不加速的到达时间为$b_i$。 分析等待时长出现的原因，有二： 乘客来的早$\\Rightarrow$乘客等 乘客来的晚$\\Rightarrow$观光车等 分析使用一个加速所造成的影响：会使某个区间内所有节点的到达时间减少一，之后的节点均无影响。不难发现如果在某一结点观光车要等乘客（$p_i &gt; b_i$），那么当前使用的加速就不会影响到后面节点的到达时间。 网络流分析设$g_i$为节点$i$下车的总人数，设当前使用了$s$个加速器。假设我们处理好了加速器的影响传递（也就是说这$s$个加速器对这些人都有效），对于这一站我们可以节约$s\\times g_i$的时间。对于整条路来讲，就节约了$s\\times\\sum g_i $的时间。 上面这个$s\\times\\sum g_i $是不是很熟悉？这也可以看作费用流问题中一条增广路的费用。若我们用网络流的流量限制来控制使用加速器的个数，把下车人数当作边的费用，节点间顺序连有向边，那么一条增广路的费用恰好是使用这些加速器所节省的时间（前提是解决好了影响传递！）。 拆点下面来谈这个前提。把一个点拆为$i$和$i’$两个点，连边$i\\to i’$，容量$max(p_i-b_i,0)$，费用$0$。若当前有$p_i &gt; b_i$时，这条边的容量一定为$0$，即视为断路，也就是说当前使用的加速器不会再向$i+1$传递。 建图建源点$S’$，汇点$T$。 $i\\to i’$，容量$max(p_i-b_i,0)$，费用$0$ $i’\\to (i+1)$，容量$\\infty$，费用$g_{i+1}$，为节点之间原有的连边 $S’\\to i’$，容量$d_i$，费用$0$，分配每个节点最多使用的加速器（这些加速器一定会造成影响，故不考虑传递，直接连到$i’$点，即出点） $i\\to T$，容量$\\infty$，费用$0$，当加速器不再造成影响时，通过这条路到达汇点，然后算法才能再考虑下面使用的加速器（也就是下一条增广路）。注意加速器还用总数限制，故新增$S$点，连边$S\\to S’$，容量为$k$，费用为$0$。 那么只需要跑$S\\to T$的最大费用最大流，即可求出使用加速所能节省的总时间。这里也可以把$g_i$取相反数，然后跑MCMF，求出来的时节省时间的相反数，与原旅行时长相加即是答案。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=((s&lt;&lt;1)+(s&lt;&lt;3))+c-'0'; return s*ne;}const int CP=1e4;const int CE=1e7;const int INF=0x3f3f3f2f;class fs{ public: int from,to,nxt,cap,cost,flow; void init(int f,int t,int n,int c,int cc,int ff) {from=f; to=t; nxt=n; cap=c; cost=cc; flow=ff;}}E[CE];int hd[CP],ecnt=1;void _add(int s,int t,int cap,int cos){ E[++ecnt].init(s,t,hd[s],cap,cos,0); hd[s] = ecnt;}void add(int s,int t,int cap,int cos){ _add(s,t,cap,cos); _add(t,s,0,-cos);}//v defineint n,m,k;int d[CP],p[CP],b[CP],g[CP]; /*d:时间 p:乘客最晚到站时间 b:巴士预计到达时间 g:该站下车人数*/ int ans=0; //原乘客总旅行时间 class passenger{public: int arr,from,to;}per[CP];//mcmfint mc=0,mf=0;int dist[CP];bool ins[CP];int prv[CP]; //前向弧 int rst[CP];bool augment(int _s,int _t){ memset(dist,0x3f,sizeof(dist)); memset(ins,false,sizeof(ins)); memset(prv,0,sizeof(prv)); memset(rst,0x3f,sizeof(rst)); queue&lt;int&gt;Q; Q.push(_s); dist[_s]=0; ins[_s]=true; while(!Q.empty()){ int u=Q.front(); Q.pop(); ins[u]=false; for(int k=hd[u]; k; k=E[k].nxt){ fs v=E[k]; if(v.cap-v.flow&gt;0 &amp;&amp; dist[v.to]&gt;dist[u]+v.cost){ dist[v.to] = dist[u]+v.cost; prv[v.to] = k; rst[v.to] = min(rst[u], v.cap-v.flow); if(!ins[v.to]){ Q.push(v.to); ins[v.to] = true; } } } } return dist[_t] &lt; INF;}void update(int _s,int _t,int aug){ int pos = _t; while(pos != _s){ E[prv[pos]].flow += aug; E[prv[pos]^1].flow -= aug; pos = E[prv[pos]].from; }}int mcmf(int _s,int _t){ while(augment(_s,_t)){ mf += rst[_t]; mc += dist[_t]*rst[_t]; update(_s,_t,rst[_t]); } return mc;}//mainint main(){ n=read(); m=read(); k=read(); for(int i=1;i&lt;n;i++) d[i]=read(); for(int i=1;i&lt;=m;i++) per[i].arr=read(),per[i].from=read(),per[i].to=read(); for(int i=1;i&lt;=m;i++){ p[per[i].from] = max(p[per[i].from], per[i].arr); g[per[i].to] += 1; } b[1] = 0; for(int i=2;i&lt;=n;i++) b[i] = max(p[i-1],b[i-1])+d[i-1]; for(int i=1;i&lt;=m;i++) ans += b[per[i].to]-per[i].arr; int S=n*2+2,_S=n*2+3,T=n*2+4; add(S,_S,k,0); for(int i=1;i&lt;=n;i++){ add(_S,i+n+1,d[i],0); //S' -&gt; i' add(i,i+n+1, max(b[i]-p[i],0), 0); //i -&gt; i' add(i+n+1,i+1, INF, -g[i+1]); //i' -&gt; i+1 add(i,T,INF,0); //i -&gt; T } printf(\"%d\",ans+mcmf(S,T)); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/20/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%A7%82%E5%85%89%E5%85%AC%E4%BA%A4/"},{"title":"「题解」魔法猪学院","text":"K 短路模板题…… 一 题目 原题链接 描述能量守恒……iPig 今天就在进行一个麻烦的测验。iPig 在之前的学习中已经知道了很多种元素，并学会了可以转化这些元素的魔法，每种魔法需要消耗 iPig 一定的能量。作为 PKU 的顶尖学猪，让 iPig 用最少的能量完成从一种元素转换到另一种元素……等等，iPig 的魔法导猪可没这么笨！这一次，他给 iPig 带来了很多 1 号元素的样本，要求 iPig 使用学习过的魔法将它们一个个转化为 N 号元素，为了增加难度，要求每份样本的转换过程都不相同。这个看似困难的任务实际上对 iPig 并没有挑战性，因为，他有坚实的后盾……现在的你呀！ 注意，两个元素之间的转化可能有多种魔法，转化是单向的。转化的过程中，可以转化到一个元素（包括开始元素）多次，但是一但转化到目标元素，则一份样本的转化过程结束。iPig 的总能量是有限的，所以最多能够转换的样本数一定是一个有限数。具体请参看样例。 输入第一行三个数 N、M、E 表示iPig知道的元素个数（元素从 1 到 N 编号）、iPig已经学会的魔法个数和iPig的总能量。 后跟 M 行每行三个数 si、ti、ei 表示 iPig 知道一种魔法，消耗 ei 的能量将元素 si 变换到元素 ti 。 输出一行一个数，表示最多可以完成的方式数。输入数据保证至少可以完成一种方式。 二 题解简化题意：给定一张有向联通图，设图上$1\\to n$的最短路为长度为$d_1$，次短路长度为$d_2$，……，$k$短路长度为$d_k$。若$k$总满足$\\sum\\limits_{i=1}^k d_i \\leqslant E$，请求出最大的$k$值。 实际上就是让你求第$k$短路的大小。此题可以用A*算法解。 设估价函数$h(x)$表示$x\\to n$的最短距离（也就是反图上$n\\to x$的最短路）设$g(x)$为$1\\to x$已走过的距离。设启发函数$f(x)=g(x)+h(x)$，然后再跑A*。当遍历到一个节点$x$第$k$次时，当前的$g(x)$就是$1\\to x$的$k$短路。 当然你肯定不能这样直接跑。必要性剪枝：因为只需求出前$k$短，所以当遍历一个节点超过$k$次时，直接跳过该节点；可行性剪枝：当估价函数$f()$大于当前剩余的$E$值时，剪枝。然后你就可以写出下面这一份代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;#define DB doubleint read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CP=1e7+7;const int CE=1e7+7;const DB INF=987654321.0;const DB EPS=1e-7;class fs{ // 边表 public: int to,nxt; DB dist; void init(int t,int n,DB d) {to=t; nxt=n; dist=d;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y,DB z){ E[++ecnt].init(y,hd[x],z); hd[x]=ecnt;}void fsinit(){ // 边表重置 memset(hd,0,sizeof(hd)); ecnt=0;}// v defineint n,m,X[CP],Y[CP];DB _E,Z[CP];// dijkstraclass DJ{ public: DB v; int c; bool operator &lt; (const DJ &amp;x)const {return v&gt;x.v;}};priority_queue&lt;DJ&gt;Q;bool vis[CP];DB d[CP];void sp(int s){ // 反图上跑最短路 for(int i=1;i&lt;=n;i++) d[i] = INF; memset(vis,false,sizeof(vis)); d[s] = 0.0; Q.push((DJ){d[s],s}); while(!Q.empty()){ DJ u = Q.top(); Q.pop(); if(vis[u.c]) continue; vis[u.c] = true; for(int k=hd[u.c]; k; k=E[k].nxt){ fs v = E[k]; if(d[v.to] &gt; d[u.c]+v.dist){ d[v.to] = d[u.c]+v.dist; if(!vis[v.to]) Q.push((DJ){d[v.to],v.to}); } } }}// A*class state{ public: int c; DB g; // g:距离函数 d[c]:估价函数 bool operator &lt; (const state&amp; a)const {return g+d[c] &gt; a.g+d[a.c];}};priority_queue&lt;state&gt; _Q;int vistimes[CP];void A_star(int k){ memset(vistimes,0,sizeof(vistimes)); state cur = (state){1,0.0}; _Q.push(cur); while(!_Q.empty()){ cur = _Q.top(); _Q.pop(); if(cur.g+d[cur.c] &gt; _E) return; // 可行性剪枝 vistimes[cur.c]++; if(cur.c == n) {_E -= cur.g; continue;} if(vistimes[cur.c] &gt; k) continue; // 剪枝 for(int k=hd[cur.c];k;k=E[k].nxt){ state nxt = (state){E[k].to,cur.g+E[k].dist}; // 下个节点 _Q.push(nxt); } }}int main(){ n=read(); m=read(); scanf(\"%lf\",&amp;_E); for(int i=1;i&lt;=m;i++){ X[i] = read(); Y[i] = read(); scanf(\"%lf\",&amp;Z[i]); add(Y[i],X[i],Z[i]); // 反图 } sp(n); fsinit(); // 建正图 for(int i=1;i&lt;=m;i++) add(X[i],Y[i],Z[i]); A_star(_E/d[1]); // k &lt;= E/d[1]一定成立 printf(\"%d\",vistimes[n]); return 0;} 然后你提交会发现：最多得92分？一个点被卡MLE？是的，这题专卡A*。您只需在读入之后添加这样一段玄学优化就好了，美之名曰“面向数据编程”。 1234if(_E == 10000000){ printf(\"2002000\\n\"); return 0;} 附 k短路模板需要在class::state中加入标记位进行状态判重。答案储存在kd[]数组中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495const int CP=1e3+3;const int CE=1e6+6;const int INF=0x3f3f3f3f;class fs{ public: int to,nxt; int dist; void init(int t,int n,int d) {to=t;nxt=n;dist=d;}}E[CE];int hd[CP],ecnt=0;// v defineint n,m;// DJclass DJ{ public: int v; /* 权值 */ int c; /* 编号 */ bool operator &lt; (const DJ &amp;a)const {return v &gt; a.v;} };priority_queue&lt;DJ&gt; Q;int d[CP]; // 以n为源的最短路bool vis[CP];void sp(int s){ memset(d,0x3f,sizeof(d)); memset(vis,false,sizeof(vis)); d[s] = 0; Q.push((DJ){d[s],s}); while(!Q.empty()){ DJ u = Q.top(); Q.pop(); if(vis[u.c]) continue; vis[u.c] = true; for(int k=hd[u.c];k;k=E[k].nxt){ fs v = E[k]; if(d[v.to] &gt; d[u.c]+v.dist){ d[v.to] = d[u.c]+v.dist; if(!vis[v.to]) Q.push((DJ){d[v.to], v.to}); } } }} /*A*h(x) : x-&gt;n 的最短路 : d[x] */class state{ public: int g; int x; bool vis[CP]; bool operator &lt; (const state &amp;a)const {return g+d[x] &gt; a.g+d[a.x];}};priority_queue&lt;state&gt; A;int vistimes[CP];int kd[CP]; // kd[i] : 储存起点(s)到节点i的k短路void A_star(int k,int s){ memset(vistimes,0,sizeof(vistimes)); state u = (state){0,s}; // 当前状态 memset(u.vis,false,sizeof(u.vis)); // 初始化标记位 u.vis[s]= true; A.push(u); while(!A.empty()){ u = A.top(); A.pop(); vistimes[u.x]++; if(vistimes[u.x] &gt; k) continue; // 剪枝 if(vistimes[u.x] == k) kd[u.x] = u.g; for(int k=hd[u.x];k;k=E[k].nxt){ if(u.vis[E[k].to]) continue; state v = (state){u.g+E[k].dist,E[k].to}; for(int i=1;i&lt;=n;i++) // 复制标记位 v.vis[i] = u.vis[i]; v.vis[E[k].to] = true; A.push(v); } }}/* k : 阈值 s : 起点 t : 终点 */int ksp(int k,int s,int t){ // 主求解函数 ...(build) // 建反图 sp(t); // 求以t为汇(终点)的最短路 ...(rebuild) // 建正图 A_star(k,s); return kd[t];} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/26/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%AD%94%E6%B3%95%E7%8C%AA%E5%AD%A6%E9%99%A2/"},{"title":"做题记录 2019.8.13","text":"最近把往年NOIPtg的橙色和绿色题目基本上都给刷掉了，还是有一些心得，又因为太水，懒得单篇写题解，搞到一块好了…… NOIP1998 车站 题目 设第二站上车的人数为k，那么你可以列个表： 第一站 第二站 第三站 第四站 第五站 第六站 a k a+k a+2k 2a+3k 3a+5k 然后你会发现系数实际上是斐波拉契数列中相邻的两项。然后打个表瞎搞搞就好了： 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 30;const int f[100] = {0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040};int a,n,m,X;int main(){ scanf(\"%d%d%d%d\",&amp;a,&amp;n,&amp;m,&amp;X); if(X == 1 || X == 2 || n == 1 || n == 2){ printf(\"%d\",a); return 0; } int k1; int x = f[n-3],y = f[n-2],peo; k1 = (m-(x+1)*a)/(y-1); x = f[X-2],y = f[X-1]; peo = (x+1)*a+(y-1)*k1; printf(\"%d\",peo); return 0;} NOIP2012 Vigenère 密码 题目 明文变密文实际上就是偏移若干个字符，然后再取个模。分析一下，把这个过程逆过来就好了： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2002;char M[CN],C[CN],k[CN];int lm,lc,lk;bool isA(char c){ return (c&gt;='A' &amp;&amp; c&lt;='Z');}int size(char *a){ int p = 0; while(a[p]!='\\0') p++; return p;}int main(){ cin&gt;&gt;k&gt;&gt;C; lm = lc = size(C); lk = size(k); for(int i=0;i&lt;lk;i++) if(isA((char)k[i])) k[i] -= ('A'-'a'); for(int i=0;i&lt;lm;i++){ if(isA(C[i])){ int num = C[i]-'A'; int ki = k[i % lk]-'a'; num -= ki; if(num &lt; 0) num += 26; M[i] = num+'A'; } else{ int num = C[i]-'a'; int ki = k[i % lk]-'a'; num -= ki; if(num &lt; 0) num += 26; M[i] = num+'a'; } } cout&lt;&lt;M; return 0;} NOIP2014 生活大爆炸版石头剪刀布 题目 打个表啊… 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1010;int N,Na,Nb;int Oa[CN],Ob[CN];#define paw Player_A_Winint Player_A_Win[10][10] = {{ 0,-1, 1, 1,-1}, { 1, 0,-1, 1,-1}, {-1, 1, 0,-1, 1}, {-1,-1, 1, 0, 1}, { 1, 1,-1,-1, 0}}; void expand(int *a,int pos,int k){ for(int i=pos;i&lt;=pos+k-1;i++) a[i] = a[i-k];}int main(){ scanf(\"%d%d%d\",&amp;N,&amp;Na,&amp;Nb); for(int i=1;i&lt;=Na;i++) scanf(\"%d\",&amp;Oa[i]); for(int i=1;i&lt;=Nb;i++) scanf(\"%d\",&amp;Ob[i]); int t = Na; while(t &lt; N) expand(Oa,t+1,t),t += Na; t = Nb; while(t &lt; N) expand(Ob,t+1,t),t += Nb; int Ansa = 0,Ansb = 0; for(int i=1;i&lt;=N;i++){ int s = paw[Oa[i]][Ob[i]]; if(s == -1) Ansb++; if(s == 1) Ansa++; } printf(\"%d %d\",Ansa,Ansb); return 0;} NOIP2016 玩具谜题 题目 大模拟+取模… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1e5+5;class P{ public: bool tow; string name; //tow = true 朝内 }a[CN];int n,m;int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ int k; scanf(\"%d\",&amp;k); if(!k) a[i].tow = true; cin&gt;&gt;a[i].name; } int p = 1; while(m--){ int t,k; scanf(\"%d%d\",&amp;t,&amp;k); if(a[p].tow){ if(!t){ p -= k; while(p &lt;= 0) p += n; } else{ p += k; while(p &gt; n) p -= n; } } else if(!a[p].tow){ if(!t){ p += k; while(p &gt; n) p -= n; } else{ p -= k; while(p &lt;= 0) p += n; } } } cout&lt;&lt;a[p].name; return 0;} NOIP2014 无线网络发射器选址 题目 枚举一下选在哪里不就好了… 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cstdio&gt;using namespace std;const int CN = 200;int d,n,sum[CN][CN];int main(){ scanf(\"%d%d\",&amp;d,&amp;n); while(n--){ int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); sum[x+1][y+1] = z; } for(int i=1;i&lt;=129;i++) for(int j=1;j&lt;=129;j++) sum[i][j] += sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]; int mx = 0,cnt = 0; for(int x=1;x&lt;=129;x++) for(int y=1;y&lt;=129;y++){ int dx1 = max(1, x-d)-1,dy1 = max(1, y-d)-1; int dx2 = min(129, x+d),dy2 = min(129, y+d); int u = sum[dx2][dy2]-sum[dx1][dy2]-sum[dx2][dy1]+sum[dx1][dy1]; mx = max(mx, u); } for(int x=1;x&lt;=129;x++) for(int y=1;y&lt;=129;y++){ int dx1 = max(1, x-d)-1,dy1 = max(1, y-d)-1; int dx2 = min(129, x+d),dy2 = min(129, y+d); int u = sum[dx2][dy2]-sum[dx1][dy2]-sum[dx2][dy1]+sum[dx1][dy1]; if(u == mx) cnt++; } printf(\"%d %d\",cnt,mx); return 0;} NOIP2011 计算系数 题目 实际上答案就是$C_{n+m}^na^nb^m \\text{ mod } 10007$。一看组合数取模马上想到lucas，然后就AC了。实际上不用lucas的话，打个表也能做。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 1e3+3;const LL R = 10007;LL a,b,k,n,m;LL QuickPow(LL a,LL b,LL r){ LL rec = 1; while(b){ if(b &amp; 1) (rec *= a) %= r; (a *= a) %= r; b &gt;&gt;= 1; } return rec;}LL C(LL n,LL m,LL p){ if(m &gt; n) return 0; LL s1 = 1,s2 = 1; if(m &gt; n-m) m = n-m; for(int i=m+1;i&lt;=n;i++) (s1 *= i) %= p; for(int i=2;i&lt;=n-m;i++) (s2 *= i) %= p; return (s1*QuickPow(s2,p-2,p)) % p;}LL lucas(LL n,LL m,LL p){ if(!m) return 1; return (C(n%p,m%p,p)*lucas(n/p,m/p,p)) % p;}int main(){ scanf(\"%lld%lld%lld%lld%lld\",&amp;a,&amp;b,&amp;k,&amp;n,&amp;m); a = (QuickPow(a,n,R)*QuickPow(b,m,R)) % R; (a *= lucas(k,n,R)) %= R; printf(\"%lld\",a); return 0;} NOIP2015 跳石头 题目 二分答案，然后想想O(n)判断就好了… 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;#define LL long longconst int CN = 1e5+5;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int len,n,m;int pos[CN];bool exm(int dist){ int cnt = 0,p = 0; for(int i=1;i&lt;=n+1;i++) if(pos[i]-pos[p] &lt; dist) cnt++; else p = i; return cnt &lt;= m;}int main(){ scanf(\"%d%d%d\",&amp;len,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) pos[i] = read(); pos[n+1] = len; int l = 0,r = len,mid; while(l &lt; r){ mid = (l+r+1)&gt;&gt;1; if(exm(mid)) l = mid; else r = mid-1; } printf(\"%d\",(l+r)&gt;&gt;1); return 0;} NOIP2013 花匠 题目 DP…推推房方程就好了。 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1e5+5;const int INF = 0x3f3f3f3f;int n,a[CN],ans = INF;int f[CN][2]; int main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); f[1][0] = f[1][1] = 1; for(int i=2;i&lt;=n;i++){ if(a[i] &gt; a[i-1]) f[i][1] = f[i-1][0]+1; else f[i][1] = f[i-1][1]; if(a[i] &lt; a[i-1]) f[i][0] = f[i-1][1]+1; else f[i][0] = f[i-1][0]; } printf(\"%d\",max(f[n][0], f[n][1])); return 0;} NOIP2013 转圈游戏 题目 $10^k$轮后会走到$(x+m\\times 10^k)\\text{ mod } n$的位置，快速幂取模就好了。 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int n,m,k,x;int QuickPow(int a,int b,int R){ int rec = 1; while(b){ if(b &amp; 1) (rec *= a) %= R; (a *= a) %= R; b &gt;&gt;= 1; } return rec;}int main(){ scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;k,&amp;x); (x += ((m%n)*QuickPow(10, k, n)) % n) %= n; printf(\"%d\",x); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/08/13/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%202019.8.13/"},{"title":"主席树","text":"众所周知，主席树即可持久化值域线段树， 用于解决区间 $k$ 小值问题以及动态二维数点问题。 1 静态主席树 静态区间 k 小值 给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。 静态主席树一般指可持久化值域线段树，并不支持修改操作。 容易发现区间信息是满足可减性的，则只需要在每次插入时建立一个船新版本即可，查询也只需要对两个历史版本作差便能得到区间信息。类似的，01-Trie 与 Treap 之类的无法维护区间信息的数据结构也可以通过可持久化来实现区间信息的维护。 容易得出下面的这份代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 2e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SGT{ public: int d[CN * 50], rt[CN * 50], ch[CN * 50][2], idx; #define lc ch[u][0] #define rc ch[u][1] SGT() {idx = 0;} int make() {return ++idx;} void md(int &amp;u, int v, int l, int r, int p){ if(!u) u = make(); if(l == r) return (void)(d[u] = d[v] + 1); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) md(lc, ch[v][0], l, m, p), rc = ch[v][1]; else md(rc, ch[v][1], m + 1, r, p), lc = ch[v][0]; d[u] = d[lc] + d[rc]; } int qu(int u, int v, int l, int r, int k){ if(l == r) return l; int m = (l + r) &gt;&gt; 1, s = d[lc] - d[ ch[v][0] ]; if(s &gt;= k) return qu(lc, ch[v][0], l, m, k); else return qu(rc, ch[v][1], m + 1, r, k - s); }} D;int n, m, a[CN], val[CN];int id(int x) {return lower_bound(val + 1, val + val[0] + 1, x) - val;}int main(){ freopen(\"_in.in\", \"r\", stdin); n = read(), m = read(); for(int i = 1; i &lt;= n; i++) val[i] = a[i] = read(); sort(val + 1, val + n + 1); val[0] = 1; for(int i = 2; i &lt;= n; i++) if(val[i] ^ val[i - 1]) val[ ++val[0] ] = val[i]; for(int i = 1; i &lt;= n; i++) D.md(D.rt[i], D.rt[i - 1], 1, val[0], id( a[i] )); while(m--){ int l = read(), r = read(), k = read(); printf(\"%d\", val[ D.qu( D.rt[r], D.rt[l - 1], 1, val[0], k ) ]), puts(\"\"); }} 2 带修主席树 动态区间 k 小值 给定一个含有 $n$ 个数的序列 $a_1, a_2, …, a_n$ ，需要支持两种操作： Q l r k 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数 C x y 表示将 $a_x$ 改为 $y$ 带修主席树一般指树状数组套可持久化值域线段树。 容易发现主席树的每个版本是对区间信息做一个前缀和，这样如果在某个版本上修改是 $O(n)$ 的。既然是前缀和，套用树状数组的方式写主席树就好了，复杂度 $O(n\\log^2n)$ 。 于是容易得到下面的这份代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 4e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SGT{ public: int d[CN * 50], ch[CN * 50][2], rt[CN], idx, n; #define lc ch[u][0] #define rc ch[u][1] SGT() {idx = 0;} int make() {return ++idx;} int lb(int x) {return x &amp; (-x);} void md(int &amp;u, int l, int r, int p, int x){ // 修改不新建版本 if(!u) u = make(); if(l == r) return (void)(d[u] += x); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) md(lc, l, m, p, x); else md(rc, m + 1, r, p, x); d[u] = d[lc] + d[rc]; } void cg(int u, int p, int x){ // 修改 BIT 中所有的树 while(u &lt;= rt[0]) md(rt[u], 1, n, p, x), u += lb(u); } int t1[101], t2[101]; // 把 O(log) 棵主席树的根搞下来 void qu_pre(int l, int r){ // (l, r] t1[0] = t2[0] = 0; int u = l; while(u) t1[ ++t1[0] ] = rt[u], u -= lb(u); u = r; while(u) t2[ ++t2[0] ] = rt[u], u -= lb(u); } int qu(int l, int r, int k){ if(l == r) return l; int m = (l + r) &gt;&gt; 1, s = 0; for(int i = 1; i &lt;= t1[0]; i++) s -= d[ ch[ t1[i] ][0] ]; for(int i = 1; i &lt;= t2[0]; i++) s += d[ ch[ t2[i] ][0] ]; if(s &gt;= k){ for(int i = 1; i &lt;= t1[0]; i++) t1[i] = ch[ t1[i] ][0]; for(int i = 1; i &lt;= t2[0]; i++) t2[i] = ch[ t2[i] ][0]; return qu(l, m, k); } else{ for(int i = 1; i &lt;= t1[0]; i++) t1[i] = ch[ t1[i] ][1]; for(int i = 1; i &lt;= t2[0]; i++) t2[i] = ch[ t2[i] ][1]; return qu(m + 1, r, k - s); } }} D;class QUERY { public: int tp, a, b, c;} Q[CN];int n, m, a[CN], val[CN];int id(int x) {return lower_bound(val + 1, val + val[0] + 1, x) - val;}int main(){ freopen(\"_in.in\", \"r\", stdin); D.rt[0] = n = read(), m = read(); for(int i = 1; i &lt;= n; i++) val[ ++val[0] ] = a[i] = read(); for(int i = 1; i &lt;= m; i++) { char c; cin &gt;&gt; c; if(c == 'Q') Q[i].tp = 0, Q[i].a = read(), Q[i].b = read(), Q[i].c = read(); else Q[i].tp = 1, Q[i].a = read(), val[ ++val[0] ] = Q[i].b = read(); } sort(val + 1, val + val[0] + 1); int cnt = 1; for(int i = 2; i &lt;= val[0]; i++) if(val[i] ^ val[i - 1]) val[ ++cnt ] = val[i]; D.n = val[0] = cnt; for(int i = 1; i &lt;= n; i++) D.cg(i, id( a[i] ), 1); for(int i = 1; i &lt;= m; i++){ if(!Q[i].tp){ D.qu_pre(Q[i].a - 1, Q[i].b); printf(\"%d\", val[ D.qu(1, val[0], Q[i].c) ]), puts(\"\"); } else D.cg(Q[i].a, id( a[ Q[i].a ] ), -1), a[ Q[i].a ] = Q[i].b, D.cg(Q[i].a, id( a[ Q[i].a ] ), 1); }} 由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，导致其常数巨大，不过它依然能在 1s 左右的时间内通过此题。 3 一道栗题 「CQOI2011」动态逆序对 给出 $1\\sim n$ 的一个排列，按照某种顺序依次删除 $m$ 个元素，在每次删除一个元素之前统计整个序列的逆序对数。 如果是静态问题，那么只需要用权值树状数组就可以简单维护。 由于只有删除操作，考虑计算删除一个元素对答案的贡献（实际上是减少量而不是增加量），容易发现这样的查询同时存在下标和权值两个维度；下标即通过版本来区分，因此用主席树。考虑到修改和影响传递的过程，仿照上题套一个树状数组即可。 于是容易得到如下代码。同样的，由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，其常数巨大，不过它依然能在 1.2s 左右的时间内通过此题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define LL long longconst int CN = 2e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SGT{ public: int d[CN * 50], rt[CN], ch[CN * 50][2], idx, n; #define lc ch[u][0] #define rc ch[u][1] SGT() {idx = 0;} int make() {return ++idx;} int lb(int x) {return x &amp; (-x);} void md(int &amp;u, int l, int r, int p, int x){ if(!u) u = make(); if(l == r) return (void)(d[u] += x); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) md(lc, l, m, p, x); else md(rc, m + 1, r, p, x); d[u] = d[lc] + d[rc]; } void cg(int u, int p, int x){ while(u &lt;= rt[0]) md(rt[u], 1, n, p, x), u += lb(u); } int t[CN]; void pqu(int r){ t[0] = 0; int u = r; while(u) t[ ++t[0] ] = rt[u], u -= lb(u); } int qu(int l, int r, int p){ if(l == r){ int s = 0; for(int i = 1; i &lt;= t[0]; i++) s += d[ t[i] ]; return s; } int m = (l + r) &gt;&gt; 1; if(p &lt;= m){ for(int i = 1; i &lt;= t[0]; i++) t[i] = ch[ t[i] ][0]; return qu(l, m, p); } else{ int s = 0; for(int i = 1; i &lt;= t[0]; i++) s += d[ ch[ t[i] ][0] ]; for(int i = 1; i &lt;= t[0]; i++) t[i] = ch[ t[i] ][1]; return s + qu(m + 1, r, p); } }} D;int n, m, a[CN], val[CN], rk[CN];int main(){ freopen(\"_in.in\", \"r\", stdin); n = read(), m = read(); for(int i = 1; i &lt;= n; i++) val[i] = a[i] = read(), rk[ a[i] ] = i; D.rt[0] = D.n = n; LL ans = 0; for(int i = 1; i &lt;= n; i++) D.cg(i, a[i], 1), D.pqu(i - 1), ans -= D.qu(1, n, a[i]), D.pqu(i - 1), ans += D.qu(1, n, n); m -= 1; while(m--){ printf(\"%lld\", ans), puts(\"\"); int x = read(), p = rk[x], s1, s2; D.cg(p, x, -1); D.pqu(p - 1), s2 = D.qu(1, n, x); D.pqu(p - 1), s1 = D.qu(1, n, n) - s2; D.pqu(n), s2 = D.qu(1, n, x) - s2; ans -= s1 + s2; } printf(\"%lld\", ans);} 4 二维数点 「SHOI2007」园丁的烦恼 维护二维坐标系上的 $n$ 个点，$q$ 次查询矩形 $(a,b):(c,d)$ 内的点的个数。 二维数点是一类宽泛的 RMQ 问题，甚至于许多树上问题都能通过 dfs 序转化成二维数点问题。 众所周知，带修主席树可以用来解决动态二维数点问题，其本质与上面的题目类似。对于静态的二维数点，带修主席树 $O(n\\log^2n)$ 的复杂度要比 $O(n\\log n)$ 的树状数组解法要劣，可通过实现一个版本修改函数来避免带修。具体实现也较为简单，因此不再赘述。 这里给出一份带修主席树解决静态二维数点的代码，使用时需注意常数因子对程序效率带来的影响。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e6 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SGT { public: int d[CN * 50], ch[CN * 50][2], rt[CN], idx, n, m; #define lc ch[u][0] #define rc ch[u][1] int make() {return ++idx;} int lb(int x) {return x &amp; (-x);} void pmd(int &amp;u, int l, int r, int p, int x){ if(!u) u = make(); if(l == r) return (void)(d[u] += x); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) pmd(lc, l, m, p, x); else pmd(rc, m + 1, r, p, x); d[u] = d[lc] + d[rc]; } void md(int u, int p, int x) {while(u &lt;= m) pmd(rt[u], 1, n, p, x), u += lb(u);} int t1[25], t2[25]; void pqu(int s, int t){ int u = s; t1[0] = 0; while(u) t1[ ++t1[0] ] = rt[u], u -= lb(u); u = t; t2[0] = 0; while(u) t2[ ++t2[0] ] = rt[u], u -= lb(u); } int qu(int l, int r, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t){ int ans = 0; for(int i = 1; i &lt;= t2[0]; i++) ans += d[ t2[i] ]; for(int i = 1; i &lt;= t1[0]; i++) ans -= d[ t1[i] ]; return ans; } int m = (l + r) &gt;&gt; 1, ans = 0, tmp1[25], tmp2[25]; if(s &lt;= m){ if(m &lt; t) memcpy(tmp1, t1, sizeof(t1)), memcpy(tmp2, t2, sizeof(t2)); for(int i = 1; i &lt;= t1[0]; i++) t1[i] = ch[ t1[i] ][0]; for(int i = 1; i &lt;= t2[0]; i++) t2[i] = ch[ t2[i] ][0]; ans += qu(l, m, s, t); if(m &lt; t) memcpy(t1, tmp1, sizeof(tmp1)), memcpy(t2, tmp2, sizeof(tmp2)); } if(m &lt; t){ for(int i = 1; i &lt;= t1[0]; i++) t1[i] = ch[ t1[i] ][1]; for(int i = 1; i &lt;= t2[0]; i++) t2[i] = ch[ t2[i] ][1]; ans += qu(m + 1, r, s, t); } return ans; }} D;int n, m, vX[CN], vY[CN], X[CN], Y[CN];int idx(int x) {return lower_bound(vX + 1, vX + vX[0] + 1, x) - vX;}int idy(int x) {return lower_bound(vY + 1, vY + vY[0] + 1, x) - vY;}class QU {public: int a, b, c, d;} q[CN];int main(){ freopen(\"_in.in\", \"r\", stdin); n = read(), m = read(); for(int i = 1; i &lt;= n; i++) vX[i] = X[i] = read() + 1, vY[i] = Y[i] = read() + 1; vX[0] = vY[0] = n; for(int i = 1; i &lt;= m; i++) vX[ ++vX[0] ] = q[i].a = read() + 1, vY[ ++vY[0] ] = q[i].b = read() + 1, vX[ ++vX[0] ] = q[i].c = read() + 1, vY[ ++vY[0] ] = q[i].d = read() + 1; sort(vX + 1, vX + vX[0] + 1), sort(vY + 1, vY + vY[0] + 1); int tmp = 1; for(int i = 2; i &lt;= vX[0]; i++) if(vX[i] ^ vX[i - 1]) vX[++tmp] = vX[i]; vX[0] = tmp; tmp = 1; for(int i = 2; i &lt;= vY[0]; i++) if(vY[i] ^ vY[i - 1]) vY[++tmp] = vY[i]; vY[0] = tmp; D.n = vY[0], D.m = vX[0]; for(int i = 1; i &lt;= n; i++) D.md( idx( X[i] ), idy( Y[i] ), 1); for(int i = 1; i &lt;= m; i++){ int a = q[i].a, b = q[i].b, c = q[i].c, d = q[i].d; D.pqu(idx(a) - 1, idx(c)), printf(\"%d\", D.qu(1, D.n, idy(b), idy(d))), puts(\"\"); }} 最近更新：2020-8-26 添加了二维数点的内容。","link":"/2020/08/17/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"title":"分块-区间排名","text":"维护一段长为$n$的数列，支持区间加法，查询区间内小于某个值的元素个数（该值在区间内的排名）…… 分块基础 一 排名问题1 模型维护一段长为$n$的数列，支持区间加法，查询区间内小于某个值的元素个数（该值在区间内的排名）。 修改操作很好解决，可以用类似于区间加法问题的思路。 关键是这个查询。想要知道“区间内小于某个值的元素个数”，首先要知道这个值在区间内的排名。如果区间是有序的，那么就可以用二分的方法在$\\log_2\\sqrt{n}$的时间内求出元素排名。那么我们就需要让每个块内的元素有序。 首先，在构造分块的时候，就要使得每块内的元素都有序（从小到大）。 当暴力修改时，直接更改元素的值，并对该块整体进行重新排序（因为排名可能会变）。当整块修改时，此时块内排名一定不改变，故只打上tag。当整块查询时，此时需要把块内元素都加上tag之后再二分，实际上等同于把查询值主动减掉tag，于是做到$O(1)$完成tag的释放。加上二分或排序的复杂度，总单次修改（查询）的最高复杂度为$O(\\sqrt{n}log_2\\sqrt{n})$ 用vector维护每个块，排序用stl里的sort()实现，二分使用stl里的lower_bound()。 lower_bound() 返回一个 iterator，它指向在 $ [first,last) $ 标记的有序序列中可以插入 $ value $，而不会破坏容器顺序的第一个位置，而这个位置标记了一个不小于$ value $的值。 关于iterator（迭代器）：vector等stl数据结构的指针类型为iterator，每个iterator都指向一个地址。它的声明方法如下： 123456class_name&lt;template&gt;::iterator iterator_name;/*例如:vector&lt;int&gt;::iterator it;set&lt;long long&gt;::iterator _it;*/ 2 代码模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const int CN=5e4+4;int n,v[CN];//hzwer tqlint bel[CN],bcnt;int tag[CN];vector&lt;int&gt;lib[CN]; //用vector实现块内排序void updata(int pos){ //对编号为pos的块重新排序 lib[pos].clear(); for(int i=(pos-1)*bcnt+1; i&lt;=min(pos*bcnt, n); i++) //注意边界 lib[pos].push_back(v[i]); sort(lib[pos].begin(), lib[pos].end());}void build(){ //构建 bcnt=sqrt(n); for(int i=1;i&lt;=n;i++){ bel[i]=(i-1)/bcnt+1; //上取整 lib[bel[i]].push_back(v[i]); } for(int i=i;i&lt;=bel[n];i++) //预先排序 sort(lib[i].begin(), lib[i].end());}void modify(int l,int r,int c){ for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) v[i] += c; updata(bel[l]); //重新排序 if(bel[l] != bel[r]){ for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) v[i] += c; updata(bel[r]); //重新排序 } for(int i=bel[l]+1; i&lt;bel[r]; i++) tag[i] += c; //只打标记}int query(int l,int r,int c){ int ans=0; for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) if(v[i]+tag[bel[i]] &lt; c) ans++; if(bel[l] != bel[r]) for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) if(v[i]+tag[bel[i]] &lt; c) ans++; for(int i=bel[l]+1; i&lt;bel[r]; i++){ int x=c-tag[i]; //c主动减掉tag，相当于块内元素一起加上tag ans += lower_bound(lib[i].begin(), lib[i].end(), x)-lib[i].begin(); //要减去首地址 } return ans;} 二 前驱元素问题1 模型维护一段长为$n$的数列，支持区间加法，查询区间内某个值的前驱（在区间内比该值小的最大值）。 和上一题的处理方法相似。块外依然暴力修改与查找。块内，维护元素有序，依然可以用二分的方法找出一个值的区间排名。因为这个值不在区间内，那么排在它后面的那个元素就是要找的元素。只需要把lower_bound()返回的地址往前推一个就是答案的地址。 2 代码模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const int CN=1e5+4;int n,v[CN];//hzwer tqlint bel[CN],bcnt;int tag[CN];vector&lt;int&gt;lib[CN];void updata(int pos){ lib[pos].clear(); for(int i=(pos-1)*bcnt+1; i&lt;=min(pos*bcnt, n); i++) lib[pos].push_back(v[i]); sort(lib[pos].begin(), lib[pos].end());}void build(){ bcnt=sqrt(n); for(int i=1;i&lt;=n;i++){ bel[i]=(i-1)/bcnt+1; lib[bel[i]].push_back(v[i]); } for(int i=i;i&lt;=bel[n];i++) sort(lib[i].begin(), lib[i].end());}void modify(int l,int r,int c){ for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) v[i] += c; updata(bel[l]); if(bel[l] != bel[r]){ for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) v[i] += c; updata(bel[r]); } for(int i=bel[l]+1; i&lt;bel[r]; i++) tag[i] += c;}int query(int l,int r,int c){ int ans=-1; //找不到返回-1 for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) if(v[i]+tag[bel[i]] &lt; c) ans = max(v[i]+tag[bel[i]], ans); if(bel[l] != bel[r]) for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) if(v[i]+tag[bel[i]] &lt; c) ans = max(v[i]+tag[bel[i]], ans); for(int i=bel[l]+1; i&lt;bel[r]; i++){ int x=c-tag[i]; //c主动减掉tag vector&lt;int&gt;::iterator it=lower_bound(lib[i].begin(), lib[i].end(), x); //用迭代器储存 if(it != lib[i].begin()) //若返回的是表头，表示找不到这个元素 ans = max(*(it-1)+tag[i], ans); //上一个地址 } return ans;} 三 分块的可扩展性1 上述代码的优化先从2-2中的代码的改进讲起。 我们使用了stl里的vector来维护一个块内的元素，并使用lower_bound()和sort()对其进行查找和维护。有没有什么数据结构可以同时支持这三种操作呢？ 如果有，代码的可读性和可调试性都会大大提高。 stl中还有一个很强大的数据结构：set。它完全是数学意义上的一个集合——元素自动去重，并始终保持有序，支持插入元素，删除元素甚至是二分查找（lower_bound()）。我们完全可以接入这个数据结构来代替上面的vector。 改进得到的代码如下，注意set内封装的成员函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int CN=1e5+4;int n,v[CN];//hzwer tqlint bel[CN],bcnt;int tag[CN];set&lt;int&gt;s[CN];void build(){ bcnt=sqrt(n); for(int i=1;i&lt;=n;i++){ bel[i]=(i-1)/bcnt+1; //上取整 s[bel[i]].insert(v[i]); //insert() : 插入元素 }}void modify(int l,int r,int c){ for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++){ s[bel[i]].erase(v[i]); //erase() : 删除元素 v[i] += c; s[bel[i]].insert(v[i]); //insert() : 插入元素 } if(bel[l] != bel[r]) for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++){ s[bel[i]].erase(v[i]); v[i] += c; s[bel[i]].insert(v[i]); } for(int i=bel[l]+1; i&lt;bel[r]; i++) tag[i] += c;}int query(int l,int r,int c){ int ans=-1; for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) if(v[i]+tag[bel[i]] &lt; c) ans = max(v[i]+tag[bel[i]], ans); if(bel[l] != bel[r]) for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) if(v[i]+tag[bel[i]] &lt; c) ans = max(v[i]+tag[bel[i]], ans); for(int i=bel[l]+1; i&lt;bel[r]; i++){ int x=c-tag[i]; //c主动减掉tag set&lt;int&gt;::iterator it=s[i].lower_bound(x); //lower_bound() : 二分查找 if(it != s[i].begin()) ans = max(*(--it)+tag[i], ans); } return ans;} 不过有个缺点：set的常数太大！时间涨了一倍还多，可以看评测记录：朴素写法，set 2 可扩展性如上面所讲，我们在分块的同时，在单个块内还使用了vector和set来维护达到求解的目的，也就是说在块内还使用了其他数据结构。 那么可以总结出这样一条：在单个块内还可以继续使用数据结构来维护一些东西，以快速的达到整块求解的目的。这就是分块的可扩展性，也是为什么要讲一个负优化的写法的原因。 与其把分块理解成一种数据结构，不如把它看作是一种处理思路。不要被分块的模板所局限。深刻的去理解分块，它实际上就是一种“把区间分成若干块”的处理思路。 $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/13/%E5%88%86%E5%9D%97-%E5%8C%BA%E9%97%B4%E6%8E%92%E5%90%8D/"},{"title":"初中政治答题整理","text":"蒟蒻的瞎整理…… 封面图来自radiokafka/Adobe Stock。 七上 学习（与八上“受教育”联系）：教育/学习丰富知识，增长才干。受教育是法律规定公民应尽的义务。我们应珍惜受教育权利，自觉履行受教育义务，努力学习。 正确认识自我：我们要全面客观的看待自己，学会欣赏自己，努力追求美。 冲动：是正常的，但若调控不好，就可能做出违背道德和法律的事，伤害他人，危害自己。应增强自制力，学会用理性控制自己的情感和行为。 自尊自爱：自尊自爱才能感受生活的快乐，是促使人不断向上的动力。我们要肯定自我，尊重他人，不做有损人格的事，做到自尊自爱。 自信：自信是成功的基石。我们要克服自卑自负心理，走向自信。 自立自强：是做人的基本要求。要克服依赖思想，树立正确人生目标，走向自立自强。 挫折/坚强：人生难免有挫折。我们要有挫折并不可怕的态度，树立信心，挫而不折。意志坚强才能实现人生目标。我们应磨砺坚强意志。 法律：特征（七上，P105）。作用（七上，P107）。（原则）公民在法律面前一律平等。违法危害（七上，P116）。 七下 友谊：每个人的成长和发展都离不开友谊的滋润。应学会与他人交往，做到善交益友，乐交诤友，不交损友。（闭锁心理）是正常的心理反应，但如果不及时调试，则会有碍身心健康，影响学习生活。我们应正确认识自己，主动与他人交往，积极调试闭锁心理。 师生沟通：沟通产生理解，理解产生信任，我们应学会与老师沟通。（批评）应正确对待老师的批评，虚心接受，有错即改。 情绪：生活中难免产生消极情绪，若调控不好，会影响身心健康发展。我们要学会及时的调节和控制情绪。（宣泄）情绪的宣泄不能违背道德和法律，不能妨碍他人，不能损害他人或集体利益。 焦虑：考试焦虑不利于水平的正常发挥。应树立适合的目标，缓解考试焦虑。 情趣：高雅情趣有利于身心健康发展（庸俗情趣反之）。我们要追求高雅情趣，摒弃庸俗情趣。 好奇心：好奇是兴趣的开始，是我们探索未知的动力。但如果把握不好，会影响正常的学习生活。我们应正确把握好奇心，培养高雅情趣。 生命：生命是最可宝贵的，生命只有一次。（总体）应珍爱生命。（自身）应提高自救自护本领，永不放弃生的希望。（他人）当他人生命遭遇困境时，我们应尽己所能伸出援助之手。 奉献：人生的价值在于奉献。我们应自觉承担社会责任，在奉献中实现人生价值。 敬业：爱岗敬业是社会主义核心价值观的价值追求。应热爱劳动，爱岗敬业。 未成年人保护：为什么（七下，P89）。自我保护（七下，P98）。不良行为（七下，P106）。 八上 孝敬父母：孝敬父母是做人的本分，是中华民族的传统美德，是法律规定的义务。我们应在精神上尊重父母，在生活上关心照顾父母。（沟通）尊敬父母，主动与父母沟通交流。 台湾（与九上“国家统一”联系）：台湾是中国不可分割的一部分。实现国完全统一是包括台湾同胞在内的全体中华儿女的共同心愿。 爱国：爱国是中华民族的光荣传统，是对祖国的深厚情感（是民族精神的核心）。应热爱祖国。 民族团结：民族团结关系着国家的统一与安全，关系着社会的稳定与和谐，关系着各族人民的共同利益和幸福生活。 文明交往：积极与他人交往时我们的心理需要。学会交往是我们必备的能力。应学会交往，（礼貌）做到语言文明，态度亲和，举止端庄。（交往艺术）应用心倾听，学会表达，善于赞美。 平等待人：平等待人是友好交往的基础。我们应尊重他人，反对凌弱欺生，不歧视他人。 理解：理解是一种可贵的美德。我们要学会多方面理解他人，为他人着想。 宽容：宽容是一种美德。我们要以豁达的胸襟原谅他人的无心之过，学会宽容。 助人：乐于助人的人能赢得别人尊重。我们应积极帮助他人，养成助人为乐的品质。 诚信：诚信是中华民族的传统美德，是立身之本。（自身）我们应做到对自己诚实，不自欺。（承诺）信守承诺，言而有信。（勇气/智慧）具有诚信的勇气，学会诚信的智慧。 集体个人：个人与集体密不可分。集体是个人成长的乐园，个人离不开集体。个人是组成集体的细胞，集体的发展靠个人努力。我们应积极参加集体活动，维护集体荣誉利益，为集体添光彩。 团结：团结就是力量。要树立集体观念，增强团队意识。团队精神（八上，P63） 竞争合作：竞争无时不在，合作无时不有。竞争能激发进取心，发掘自身潜能，弥补不足。合作有助于事业的成功，是时代的要求。竞争合作相互依存，相互促进。我们要学会在竞争中合作，在合作中竞争，相互促进，共同提高。 人身权/财产权：生命健康权（八上，P78）。人身自由权（P82）。人格尊严权（P84）。受教育权（P89）。财产权（P105）。知识产权（P109）。消费者权益（P115）。 八下 宪法地位：是公民权利的保障书，是治国安邦的总章程，是一切组织和个人的根本活动准则，具有最高的法律权威和法律效力。 国家性质：我国是人民民主专政的社会主义国家，国家的一切权力属于人民。 宪法意识：学习宪法，认同宪法，践行宪法。坚持宪法至上，践行宪法精神，推动宪法实施。 权利行使：权利的行使是有范围的，不能滥用权利。不得损害国家、社会、集体利益和他人的合法自由和权利。 权利义务：公民的权利义务相互依存，相互促进。要增强权利意识，依法行使权利，增强义务观念，自觉履行法定义务。 自由：自由是有限制的、相对的。必要的限制是对自由的保障，无限制的自由只会导致混乱与伤害。我们要珍视自由，珍惜宪法和法律赋予的权利，依法行使权利。 平等：平等是人类的崇高理想，是社会发展的永恒主题。我们要反对特权，平等对待他人合法权利，抵制不平等的行为。 公平：公平是个人生存发展的重要保障，是社会稳定进步的重要基础。个人维护公平（八下，P107），制度保障公平（八下，P108）。 正义：正义是社会文明的尺度，是法制追求的核心价值目标之一，是社会制度的重要价值，是社会和谐的基本条件。正义感是公民的基本德性，要做有正义感的人（见义智为，八下，P108）。 实现公平正义，是国家、社会和全体公民的共同责任。 九上 国家统一：是国家的最高利益，是我国社会主义现代化建设顺利进行的基本保证。 改革开放：改革开放是一场新的伟大革命，是决定当代中国命运的关键抉择，是强国富民必由之路。应全面深化改革，进一步扩大开放。对外开放也是改革，是我国长期坚持的一项基本国策。 五位一体（答题角度）：经济，政治，文化，社会，生态。 共同富裕：共同富裕是中国特色社会主义的基本要求。应坚持走共同富裕道路。 中华文化：中华文化源远流长，博大精深，具有强大的生命力和创造力。我们应继承中华优秀传统文化，努力传播和弘扬中华民族优秀文化。 文明/秩序（与九下“规则”联系）：文明参与公共生活是现代社会对每个社会成员的要求，不文明行为败坏社会风气，影响公共生活质量。遵守秩序是保障公民自身安全权益的重要条件。我们应提高个人修养，遵守公共秩序，文明参与公共生活。 社会责任：每个人的成长和发展都离不开他人和社会。我们要增强社会责任感，（责任）积极承担社会责任，（活动）积极参加社会公益/实践活动，服务他人，奉献社会，养成亲社会行为。 生态环境（九下“可持续发展”）：生态环境是人类赖以生存和发展的根基。我们应树立尊重自然，顺应自然，保护自然的生态文明理念，学会与大自然和谐共生。 环保法律：（国情）我国生态环境状况依然严峻。（危害）直接危害人们的健康乃至生命，制约社会经济的可持续发展。（立法）加强环境保护立法和执法工作，把环保纳入法制化轨道，是解决环境问题的根本之策。（执法）严格执法是依法保护环境的关键。 环境政策：绿色发展理念，可持续发展战略，科学发展观，节约资源和保护环境的基本国策。 依法解决纠纷：要树立依法解决纠纷的意识，依法理性维护自己的合法权益。 民法：（地位）是民事权利的宣言书。（原则）平等、自愿、公平、诚信、公序良俗、保护环境。物权（九上，P114）。合同（九上，P118）。 九下 科教：科学技术是第一生产力，是推动经济社会发展的最重要因素。百年大计，教育为本。应坚持科教兴国和人才强国战略，把科技和教育放在优先发展的战略地位。 创新：创新是引领发展的第一动力。应坚持创新驱动发展战略，把创新发展摆在国家发展全局的核心位置。 新发展理念：创新、协调、绿色、开放、共享。 可持续发展：我国面临严峻的人口、资源、环境形势。坚持绿色发展理念，坚持全面、协调、可持续的科学发展观，走生产发展、生活富裕、生态良好的文明发展之路，实现人与自然和谐共生。 城乡/区域：统筹城乡协调发展，推动城乡一体化建设，实施乡村振兴战略。实施区域协调发展战略，西部大开发战略。 依法治国：依法治国是党领导人民治理国家的基本方略。依法治国首先要依宪治国，党的领导是依法治国的根本保证，依法行政是依法治国的必然要求。严格执法有利于全面推进依法治国。 法律监督：法律的生命力在于实施。监督和制约是法律有效实施和司法公正的保障。要建立严密的法律监督体系和科学严密的制约机制。 公民政治权利：知情权、参与权、表达权、监督权。有助于建立健全监督和制约机制，促进严格执法和公正司法（九下，P47）。 负责任：承担责任是做人的基本要求。应积极承担责任，做一个负责任的人。 发展 ：发展是硬道理，发展是解决我国所有问题和矛盾的关键。必须毫不动摇的坚持以经济建设为中心，全面推进依法治国。 规则（与九上“文明/秩序”联系）：尊重和遵守规则，是一个公民应有的品格和素养，是社会文明的重要标志。应树立规则意识，自觉遵守社会规则。 文化（九下，P83）：文化多样性和丰富性是人类社会的基本特征。文化既是民族的，又是世界的。文化因交流而精彩，因互鉴而丰富。（做法）在文化交流中增进友谊，弘扬和发展中华文化，并学习、借鉴各国优秀文明成果。 时代背景：经济全球化，政治多极化，和平与发展是主题，和平、发展、合作、共赢是潮流。 国际地位：是世界最大的发展中国家，是经济发展速度最快的国家之一，经济总量跃升全球第二位。是联合国安理会常任理事国，在国际的大国地位不断提高，已成为多极化格局的重要一极。 经济作用：中国经济已成为世界经济持续增长的重要引擎，为全球经济稳定和增长提供了持续强大的推动。 政治作用：我国始终奉行独立自主的和平外交政策，在当今世界树立起了负责任的大国形象，在国际事务中发挥日益重要的作用。 理想：理想是人生的奋斗目标。我们要树立远大理想，并为之努力奋斗。（青年中国梦）我们要把个人梦和中国梦结合起来，将个人梦融入中国梦，在实现中国梦的奋斗中奉献青春。 艰苦奋斗：艰苦奋斗是我们的优良传统，是中华民族传统美德，是通往理想的必经之路。我们要发扬艰苦奋斗精神，努力学习，不断进步。 实干：把理想变成现实，关键靠实干。要发扬实干精神，求真务实、改革创新、真抓实干。 劳动：劳动是财富的源泉，也是幸福的源泉。我们要热爱劳动，让劳动之花美丽绽放。 职业：应树立职业平等的观念，扬长避短，敢于竞争，勇于创业（创业是最大的就业）。 幸福：把帮助他人、服务社会、为国家做贡献当作幸福，是高尚的追求，是最高的人生境界。 后记2019-5-2，终于整理完了！ 仅供参考，本页面的源码。 $$ - - - - \\mathcal{End} - - - - $$ 最近更新： 2019.6.17 考前修订。","link":"/2019/04/29/%E5%88%9D%E4%B8%AD%E6%94%BF%E6%B2%BB%E7%AD%94%E9%A2%98%E6%95%B4%E7%90%86/"},{"title":"双连通分量","text":"两只$\\mathbf{Tarjan}$，两只$\\mathbf{Tarjan}$，跑得快，跑得快…… 此页面存在相关页面。关于强连通分量，请参见「强连通分量」。 封面图来自unsplash.com。 一 概念1 基本定义无向图的双连通有两种情况：点-双连通 与 边-双连通。 点-双连通：若一个无向图中的去掉任意一个节点，都不会改变此图的连通性，即不存在割顶，则称作点-双连通图。 —— Baidu 边-双连通：若一个无向图中的去掉任意一条边，都不会改变此图的连通性，即不存在桥，则称作边-双连通图。 —— Baidu 类似与有向图的强连通分量，无向图的 点-双连通 的极大子图被称作该图的双连通分量（BiConnected Component,BCC）。而无向图的 边-双连通 的极大子图被称作该图的边-双连通分量（Edge-BiConnected Component,EBCC）。 上述还涉及到了两个概念，割顶与桥，定义如下： 对于一张无向图，若删去一个端点后，产生了新的连通块，则称这个端点为割顶（也称割点）。 对于一张无向图，若删去一条边后，产生了新的连通块，则称这条边为桥（也称割边）。 不难发现：割顶决定了点-双连通，而桥决定了边-双连通。 对于一张无向图，割顶（桥）可能不存在，也可能不仅一个。 2 图示 如上图，节点$4$是割顶，边$(4,6)$是桥。图中点-双连通子图有${1,2,4}$，${1,3,4,5}$等，但BCC只有${1,2,3,4,5}$和${6}$。类似的，边-双连通子图有${1,2,4}$等，但EBCC只有${1,2,3,4,5}$和${6}$。 二 割顶在求解BCC之前，先来学习割顶的必备知识。 注：因为 桥和边-双连通 与 点-双连通 有许多相似之处，故不重点说明。以下所有 “双连通/双连通子图/双连通分量/BCC” 等均指 “点-双连通”。 1 dfs树dfs树的基本内容在SCC算法分析中已经讲过，这里不再过多重复，只对部分概念做必要说明。 树边：dfs所经过的边 返祖边：连接子节点与它的祖先节点的边，本质上与树边无异 注意：无向图的dfs树上不存在横叉边。 可以绘制出上图的dfs树： 2 定理我们先来推导一下割顶的基本判定方法。 猜想： 在一个无向图中，若$u$是割顶，当且仅当$u$存在一个子节点$v$，使得子树$v$内没有边返回$u$的祖先。 画出图来就长这样： 看上去很对，但是有疏漏。 根节点很特殊。一定没有返祖边指向根的祖先，因为根没有祖先。但是仅当根由两棵及以上的子树时，根才是割点，否则删去它并不影响图的连通。所以需要特判根。 2-1 割顶的判定定理 根节点是割顶，当且仅当在dfs树上它有两个及以上的子节点。 非根节点$u$是割顶，当且仅当在dfs树上$u$存在一个子节点$v$，使得子树$v$内没有返祖边返回$u$的祖先。 简单证明： 此时删去根节点会让它的各个子树互不连通，因为不存在横叉边。 此时删去$u$，会使得子树$v$中的节点“独立”出来，形成新的连通块。 2-2 桥的判定定理与上面的类似。 对于任意节点$u$，若$u$存在一个子节点$v$，使得子树$v$内没有返祖边返回**$u$及$u$的祖先**，则边$(u,v)$是桥。 图示如下： 证明其实挺好想：删掉这条边会孤立子树$v$。 3 算法 该算法由Robert Tarjan提出（又是他）。 3-1 思路设节点$u$被dfs到的次序号是$dfn[u]$，从它能到达的祖先的最小次序号是$low[u]$，那么定理中的第二条就变成了： 找一个节点$u$，使得$low[v] \\geqslant dfn[u] | (u,v)\\in E$，则判定$u$是割顶。 同理，桥的判定定理可以表示为： 找一个节点$u$，使得$low[v] &gt; dfn[u] | (u,v)\\in E$，则判定无向边$(u,v)$是桥。 于是可以在dfs一张无向图的时候求解。 3-2 流程该算法主要有以下四步： dfs整个图。 对于每个非根节点，使用子节点的$low$值更新当前节点的$low$值。 访问该节点出发的所有返祖边，并用这条边指向的祖先的$dfn$值更新当前节点的$low$值。注意一定是$dfn$值，下面会讲。 判定是否是割顶（用到上面的不等式）。 对于1-2中的图，可以得到如下的一张dfs树（桥和割顶都已经标出）。发现存在$low[6]\\geqslant dfn[4]$，故判定$4$是割顶。 小问题：为什么一定是dfn值？看下面的图。 此时使用$low[u]$更新$low[v]$，实际上走了两条返祖边。则会判定$u$不是割顶，但实际上它是。 3-3 代码割顶的求解如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int CP=1e3+3;const int CE=CP*CP;//边表class fs{ public: int to,nxt;}E[CE];int hd[CP],cnt=0;void add(int x,int y){ E[++cnt].to=y; E[cnt].nxt=hd[x]; hd[x]=cnt;}//cutint dfn[CP],low[CP];int idx=0;bool iscut[CP]; //是否是割顶void tarjan(int cur,int prv){ int child = 0; //孩子数，用于根的特判 dfn[cur] = low[cur] = ++idx; //设置初始值 for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]) //是树边 { child++; tarjan(to,cur); //向下搜索 low[cur] = min(low[cur], low[to]); //更新 if(low[to] &gt;= dfn[cur]) //用儿子来判定 iscut[cur]=true; } else if(to != prv) //是返祖边 low[cur] = min(low[cur], dfn[to]); //更新 } if(!prv &amp;&amp; child==1) //处理根 iscut[cur]=false; }void bcc() //主求解函数{ for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i,0);} 桥的求解如下： 因为边表没法有效地一次性保存双向边。所以边的下标从$1$开始，使得$k \\text{ xor } 1$就是$k$的反向边。（$k$与$k \\text{ xor } 1$共同组成一条无向边）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int CP=1e3+3;const int CE=CP*CP;//边表class fs{ public: int to,nxt;}E[CE];int hd[CP],cnt=1; //从1开始void add(int x,int y){ E[++cnt].to=y; E[cnt].nxt=hd[x]; hd[x]=cnt;}//bridgeint dfn[CP],low[CP];int idx=0;bool isbri[CE]; //是否是桥void tarjan(int cur,int prv){ dfn[cur] = low[cur] = ++idx; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]) { tarjan(to,cur); //向下搜索 low[cur] = min(low[cur], low[to]); if(low[to] &gt; dfn[cur]) //判定 isbri[k] = isbri[k^1] = true; } else if(to != prv) low[cur] = min(low[cur], dfn[to]); }}void ebcc() //主求解函数{ for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i,0);} 三 算法实现1 BCC学会了求解割顶，求出BCC就再容易不过了。 维护一个栈，栈内保存每一次走过的边（一定保存边，因为两个不同的双连通子图可能有交点，但一定没有交边）。每当发现割顶时，出栈，直到发现当前出栈的边恰好是连接割顶与判定它的子节点的边。则出栈的所有边同属一个双连通子图，这些边的端点也同属一个双连通子图。 代码如下：因为回溯到根的时候，剩余栈内元素一定是一个双连通子图，故先出栈再特判根。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const int CP=1e3+3;const int CE=CP*CP;//边表class fs{ public: int from,to,nxt;}E[CE];int hd[CP],cnt=0;void add(int x,int y){ E[++cnt].from=x; E[cnt].to=y; E[cnt].nxt=hd[x]; hd[x]=cnt;}//bccint dfn[CP],low[CP];int idx=0;int bel[CP],bcnt=0; //每个点所属的bcc编号，为-1则表示该点是割顶（割顶同时属于两个bcc，所以它的bel无意义）int stack[CE],top=0;void tarjan(int cur,int prv){ int child = 0; dfn[cur] = low[cur] = ++idx; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]) { child++; stack[++top]=k; //入栈 tarjan(to,cur); //向下搜索 low[cur] = min(low[cur], low[to]); if(low[to] &gt;= dfn[cur]) //是割顶 { int pos; ++bcnt; while(true) { pos=stack[top--]; //出栈 bel[E[pos].from] = bel[E[pos].to] = bcnt; if(E[pos].from==cur &amp;&amp; E[pos].to==to) //发现当前的树边 break; } bel[cur] = -1; //标记割顶 } } else if(to != prv) low[cur] = min(low[cur], dfn[to]); } if(!prv &amp;&amp; child==1) //处理根 bel[cur] = bcnt;}void bcc() //主求解函数{ for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i,0);} 2 EBCCEBCC可以用更简单的两遍dfs求出： 第一遍dfs在图上删去所有的桥。第二遍dfs求出这之后所有的连通块。那么每个连通块都是一个边-双连通子图。 四 BCC可以解决什么样的问题？噫，好了，我中了，我们已经学会了BCC。但是BCC可以用来求解什么样的问题呢？ 在这里梳理一下BCC的主要性质： 一个BCC一定是若干个简单环（环上的边数等于点数）的并。求出BCC的主要目的就是求出图上的若干环。 根据双连通（也是环的性质）可知：同一双连通子图中的点一定有至少两条路径可达。 两个不同的双连通子图的交点一定是该图的割顶，或这个点不存在。 $$ - - - - \\mathcal{End} - - - - $$ 最近更新： 2019.4.10","link":"/2019/03/08/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"title":"最小斯坦纳树","text":"众所周知，斯坦纳树问题是一类特殊的生成树问题…… 给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G=(V,E)$，使得： $S\\subseteq V$； $G$ 为连通图； $E$ 中所有边的权值和最小。 你只需要求出 $E$ 中所有边的权值和。$n\\le 100, m\\le 500, k\\le 10$ 上述问题被称作「最小斯坦纳树」问题。 设 $f[i,S]$ 表示当前在 $i$ ，$S$ 中的点已经连通的最小代价，则有转移： $$ \\begin{aligned} f[i,S] &amp;=\\min f[i,S_0]+f[i,S\\oplus S_0]\\newline f[i,S] &amp;=\\min f[j,S]+\\text{sp}(i,j) \\end{aligned} $$ 容易发现后一个转移是最短路的形式，考虑到不存在负权边，使用 Dijkstra 转移，复杂度 $O(2^k n\\log n)$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int CN = 101;const int INF = 0x3f3f3f3f;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt,w; void init(int t,int n,int d) {to = t, nxt = n, w = d;} } E[CN * CN];int hd[CN], ecnt = 0; void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}int n, m, k, key[CN], f[CN][1 &lt;&lt; 10];class DJ {public: int id, v; bool operator &lt; (const DJ &amp; a) const {return v &gt; a.v;}};DJ make(int a, int b) {DJ c; c.id = a, c.v = b; return c;}priority_queue&lt;DJ&gt; Q; bool vis[CN];void sp(int S){ memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i++) if(f[i][S] &lt; INF) Q.push( make(i, f[i][S]) ); while(!Q.empty()){ int u = Q.top().id; Q.pop(); vis[u] = true; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(vis[v]) continue; if(f[v][S] &gt; f[u][S] + E[k].w){ f[v][S] = f[u][S] + E[k].w; Q.push( make(v, f[v][S]) ); } } }}int main(){ freopen(\"_in.in\", \"r\", stdin); n = read(), m = read(), k = read(); while(m--){ int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w); } for(int i = 1; i &lt;= k; i++) key[i] = read(); memset(f, 0x3f, sizeof(f)); for(int i = 1; i &lt;= k; i++) f[ key[i] ][ 1 &lt;&lt; (i - 1) ] = 0; for(int i = 1; i &lt;= n; i++) f[i][0] = 0; for(int S = 1; S &lt; (1 &lt;&lt; k); S++){ for(int i = 1; i &lt;= n; i++) for(int V = S; V; V = (V - 1) &amp; S) f[i][S] = min(f[i][S], f[i][V] + f[i][S ^ V]); sp(S); } int ans = INF; for(int i = 1; i &lt;= n; i++) ans = min(ans, f[i][(1 &lt;&lt; k) - 1]); printf(\"%d\", ans);}","link":"/2020/08/23/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"},{"title":"树状数组","text":"关于树状数组：请移步隔壁《线段树》…… 一 原理 树状数组图示，其中 t 维护整棵树 1 对于每个$ t_i $，有如下规律$ t_1=a_1 $ $ t_2=t_1+a_2=a_1+a_2 $ $ t_3=a_3 $ $ t_4=t_2+t_3+a_4 =t_1+a_2+t_3+a_4=a_1+a_2+a_3+a_4 $ $ t_5=a_5 $ $ t_6=t_5+a_6=a_5+a_6 $ $ t_7=a_7 $ $ … $ 2 则前六个元素的前缀和：$ 6=110 $ (二进制)，从末尾开始第一个 ‘1’ 在第一位。截取该 ‘1’ 之后的部分，为$ 10=2 $。所以和$ t_6 $有关联的是$ t_{6-2} $($ t_4 $)。 $ 4=100 $(二进制)，从末尾开始第一个 ‘1’ 在第二位。截取该 ‘1’ 之后的部分，为$ 100=4 $。所以和$ t_4 $有关联的是$ t_{4-4} $。 此时结束。累加经过的$ t_i $，发现正好是前六个元素的前缀和。 3 怎么实现截取最低位的 ‘1’ 之后的部分？观察： $ 6=110 $ $ -6=(1)010 $ (最高位的 ‘1’ 为负数标记) 则 $$ 6 &amp; (-6)= 110 &amp; 010=10 $$ 二 实现读入/更新/查询:$ O(log_2N) $ 123456789101112131415161718192021222324int lowbit(int x) {return x &amp; (-x);}class tree_set{ public: int value[500001];//t为树 void modify(int p,int v)//将元素p+v { while(p&lt;=n)//受 p (p&lt;=n)影响的只有 p+lowbit[p] ,受 p+lb[p] 影响的亦然 value[p]+=v,p+=lowbit(p); } int query(int p)//返回区间[1,p]的和 { int ret=0; while(p)//sum[1,p]可拆分成sum[1,lb(p)],sum[lb(p),p];即sum[1,lb(lb(p))],sum[lb(lb(p)),lb(p)]...一直到p=0 ret+=value[p],p-=lowbit(p); return ret; } void print_sum(int l,int r) { int vl=query(l-1),vr=query(r); printf(\"%d\\n\",vr-vl); }}; $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/01/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"title":"数列差分","text":"差分是一种对于数列区间修改问题的很优秀的 idea ，对于每个独立的查询操作，它可以做到在线性时间内完成任务…… 一 一阶差分1 模型 维护一段数列，支持将区间 $ [l,r] $ 内的每个元素加或减某个值，并查询所有操作后的数列。要求在线性时间内完成任务。 以上为数列差分问题的基本模型。 对于数列$a_1,a_2,a_3,…,a_n$，我们定义它的差分数列为$b_1,b_2,b_3,…b_n$，满足$b_i = a_i-a_{i-1}$。不难发现，有 $a_i=\\sum_{j=1}^i b_j$。 我们发现在对区间 $[l,r]$ 进行某次操作之后，该区间内元素的相对大小是不变的，也就是任意两数的差值固定。利用这个性质，我们发现在对一段区间 $[l,r]$ 操作之后，数列 $\\begin{Bmatrix} b \\end{Bmatrix}$ 中仅有两个元素 $b_l$ 和 $b_{r+1}$ 发生了变化；我们想要记录这次操作的影响，只需要对 $b_l$ 和 $b_{r+1}$ 做一些加加减减就好了。 于是我们做到了在 $O(1)$ 的时间内“传递影响”，那么也就是说我们可以在 $O(q)$ 的时间内处理完所有操作，最后再 $O(n)$ 推一遍前缀和，我们就得到了修改后的 $\\begin{Bmatrix} a \\end{Bmatrix}$ 数列。 2 代码代码，实际上差分数组和原序列可以共用一个数组，此处是为了便于理解： 123456789101112131415161718const int CN = 1e6+6;int n,q,a[CN],b[CN]; // b[] : 差分数组/* 推 b[] */a[0] = 0; for(int i=1;i&lt;=n;i++) b[i] = a[i] - a[i-1]; scanf(\"%d\",&amp;q);while(q--){ int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); /* 更新 b[] 数组 我们发现 [l,r] + v 会使得 b[r + 1] - v 和 b[l] + v */ b[y + 1] -= z; b[x] += z; }/* 前缀和推出操作后的 a[] 数组 */for(int i=1;i&lt;=n;i++) a[i] = a[i-1] + b[i]; 更简化的版本： 123456789101112const int CN = 1e6+6;int n,q,a[CN];for(int i=1;i&lt;=n;i++) a[i] = a[i] - a[i-1]; scanf(\"%d\",&amp;q);while(q--){ int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); a[y + 1] -= z; a[x] += z; }for(int i=1;i&lt;=n;i++) a[i] += a[i-1]; 二 二阶差分1 模型 维护一段数列，支持将区间 $ [l,r] $ 加一个等差数列 $s:e$ （ $[l,r]$ 内每个元素分别加等差数列的第 $1,2,3,...$ 项，其中等差数列的第一项为 $s$ ，最后一项为 $e$ ），并查询所有操作后的数列。要求在线性时间内完成任务。 不难发现，某段区间整体加上一个等差数列，相当于该区间上的差分数列整体加了这个等差数列的公差。当然，在差分数列的两个端点还会有一些小的细节。 对于“差分数列整体加公差”这个操作，我们直接对差分数列进差分即可维护。注意，差分数列中加上公差的区间是 $[l+1,r]$ 。 剩下的是一点小细节：区间 $[l,r]$ 加一个等差数列 $s:e$ 后，还会使得 $b_l + s$ 和 $b_{r+1} - e$ 。这两个特例均是对差分数列 $\\begin{Bmatrix} b \\end{Bmatrix}$ 进行的单点操作，我们在二次差分推出数列 $\\begin{Bmatrix} b \\end{Bmatrix}$ 后，暴力修改就好了。 2 代码代码，实际上三个计算数组可以合成一个，此处是为了便于理解： 12345678910111213141516171819202122232425262728293031#define LL long longconst int CN = 1e6+6;LL read(){ /* 省略 */ }int n,q;int l[CN],r[CN]; LL s[CN],e[CN]; // 记录操作LL a[CN],b[CN],c[CN]; // b[] : 原序列的差分 // c[] : 差分序列的差分/* 推 b[] */for(int i=1;i&lt;=n;i++) b[i] = a[i] - a[i - 1]; /* 推 c[] */for(int i=1;i&lt;=n;i++) c[i] = b[i] - b[i - 1]; q = read();for(int i=1;i&lt;=q;i++){ l[i] = read(); r[i] = read(); s[i] = read(); e[i] = read(); LL k = (e[i] - s[i]) / (r[i] - l[i]); // 公比 /* 更新 c[] 数组 */ c[ r[i] + 1 ] -= k; c[ l[i] + 1 ] += k; }/* 推出操作后的 b[] 数组 */b[0] = 0; for(int i=1;i&lt;=n;i++) b[i] = b[i - 1] + c[i]; /* 对 b[] 进行单点修改 */for(int i=1;i&lt;=q;i++) b[ r[i] + 1 ] -= e[i], b[ l[i] ] += s[i]; /* 前缀和推出处理后的 a[] 数组 */a[0] = 0; for(int i=1;i&lt;=n;i++) a[i] = a[i - 1] + b[i]; 更简化的版本： 12345678910111213141516171819202122#define LL long longconst int CN = 1e6+6;LL read(){ /* 省略 */ }int n,q;int l[CN],r[CN]; LL s[CN],e[CN],a[CN]; for(int i=1;i&lt;=n;i++) a[i] = a[i] - a[i - 1]; for(int i=1;i&lt;=n;i++) a[i] = a[i] - a[i - 1]; q = read();for(int i=1;i&lt;=q;i++){ l[i] = read(); r[i] = read(); s[i] = read(); e[i] = read(); LL k = (e[i] - s[i]) / (r[i] - l[i]); a[ r[i] + 1 ] -= k; a[ l[i] + 1 ] += k; }for(int i=1;i&lt;=n;i++) a[i] += a[i - 1]; for(int i=1;i&lt;=q;i++) a[ r[i] + 1 ] -= e[i], a[ l[i] ] += s[i]; for(int i=1;i&lt;=n;i++) a[i] += a[i - 1]; $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/11/06/%E6%95%B0%E5%88%97%E5%B7%AE%E5%88%86/"},{"title":"最近公共祖先","text":"最近公共祖先，是指有根树上任意两个节点$x,y$的祖先中，深度最大的那一个…… 一 概念 祖先：在有根树中，对于树上的节点$x$，若存在节点$k$，使得$x$在以$k$为根的子树中，则称$k$是节点$x$的祖先。 公共祖先：在有根树中，对于树上的节点$x$和$y$，若存在节点$k$，使得$x,y$都在以$k$为根的子树中，则称**$k$是节点$x,y$的公共祖先**。 最近公共祖先（Least Common Ancestors，LCA），是指有根树上任意两个节点$x,y$的祖先中，深度最大的那一个（离$x,y$最近）。 如图，$4,6$节点的祖先有节点$1$和$2$，但$4,6$节点的LCA为节点$2$。 树上倍增求LCA1 思路朴素的暴力想法是：两个节点先“跳”（向父节点走）到同一深度（树上的同一层），然后再一起往上挑，直到两个点重合，那么这个点就是他们的LCA。但是不用说我们也知道它的复杂度太高了。 不难发现：在跳到LCA之前，如果一次能跳一大步会大大降低算法的复杂度。 根据xkq巨佬定理可知：任何一个正整数都可以分解成2的若干次幂之和。用公式写出来就是这样：$$ n = 2^{e_1} + 2^{e_2} + … + 2^{e_k} | n \\in Z $$ 回到问题。在跳到同一深度之后，对于“跳到LCA要跳的步数”这个数，假设我们设它为$m$，显然$m$是一个正整数，那么$m$也满足上述等式。那么我们可以把$m$拆分成$2^{e_1} + 2^{e_2} + … + 2^{e_k}$，然后每次跳$2^{e_i} ( e_i \\in e)$步，直到跳满$m$步，于是就能找到LCA。 但是我们并不知道$m$的具体值。不难发现再节点$x,y$到达LCA之后，再继续往上跳，无论跳多远这两个点总重合。又因为$ \\sum\\limits_{0 \\leqslant e \\leqslant 20} 2^e = 2097151$，这个数已经很大了，所以我们只需要从$2^{20}$到$2^0$挨个去试，并判断能不能跳（一定从大的开始试，否则不该跳的也会跳）。如果跳$2^i(0 \\leqslant i \\leqslant 20)$步之后，这两个点重合，说明当前已经过了LCA。这时我们不应该向上跳，反之则应该向上跳$2^i$步。最后，这两个点就会停在他们的LCA的下一层（LCA的儿子）。 还有一个细节：我们需要预处理出节点$i$的$2^j$级祖先$f_{i,j}$，否则这个算法的复杂度也不是理想的$O(log_2 m)$。$f_{i,j}$的值可以由递推得到：因为$2^{i-1} + 2^{i-1} = 2^i$，故有：$$ f_{i,j} = f_{f_{i,j-1} , j-1} $$ 好吧这时候用LaTeX写递推式会不太容易认，其实放到代码里就是这样： 1f[i][j] = f[ f[i][j-1] ][j-1]; 边界条件是:$$f_{i,0}=j|(j,i) \\in E$$特别地，$f_{r,0}=r$（$r$是树根）。 2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CP=5e5+5;const int CE=CP*2;//边表class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}//v defineint n,m,s;//lcaint anc[CP][21],dep[CP];void init(int cur){ for(int k=hd[cur]; k; k=E[k].nxt) { if(dep[E[k].to]) continue; int to=E[k].to; dep[to] = dep[cur]+1; //记录深度 anc[to][0] = cur; //记录父节点 init(to); }}int lca(int x,int y){ if(dep[x] &lt; dep[y]) //保证a的深度大 swap(x,y); for(int i=20; i&gt;=0; i--) //跳到同一深度 if(dep[anc[x][i]] &gt;= dep[y]) x=anc[x][i]; if(x==y) return x; //两个点重合了 for(int i=20; i&gt;=0; i--) //一起往上跳 if(anc[x][i] != anc[y][i]){ x=anc[x][i]; y=anc[y][i]; } return anc[x][0]; //返回父节点，就是LCA}int main(){ scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;n;i++){ int s,e; scanf(\"%d%d\",&amp;s,&amp;e); add(s,e); add(e,s); } //solve for(int i=1;i&lt;=n;i++) if(!dep[i]) //找到树根（这里是无根树转有根树写法） { dep[i]=1; init(i); //初始化 anc[i][0]=i; } for(int i=1;i&lt;=20;i++) //递推 for(int pos=1;pos&lt;=n;pos++) anc[pos][i] = anc[ anc[pos][i-1]][i-1]; while(m--){ //回答询问 int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",lca(a,b)); } return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/03/10/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"title":"树的直径","text":"边数恰好比点数少一的无向联通图被称为树（无根树）。在无根树上选出两个节点$v,u$，使得$v\\to u$的路径上经过的边数最多，那么这条路径被称为树的直径…… 一 概念1 树图论中所指的树，一般指边数恰好比点数少一的无向联通图。若选中一个节点作为dfs的起点，那么一次dfs恰好可以遍历整棵树。我们把选出的这个节点叫做树根，没有固定树根的树称为无根树，反之成为有根树。 树上的相关定义： 根（root）： 选出的dfs起点。 父节点（parent）：dfs树上进入当前节点的节点。 祖先（ancestor）：从根到当前节点的路径上所有的节点。 兄弟（sibling）：具有相同父节点的节点。 子节点（child）：dfs树上当前节点的下一个遍历节点，不止一个。 子树（subtree）：搜索树的一部分，包括以当前节点作为起点的所有递归分支。 后代（descendant）：当前节点为根的子树上所有的节点。 图解如下： 2 直径因为树的特殊性，所以树上任意两个互异的节点间有且只有一条路径。找到一条经过边数最多的路径，这条路径就被称作树的直径。当边存在边权时，直径定义为边权和最大的一条路径。 图例如下，直径用红线标出。 注意同一棵树可能存在多条直径！ 二 实现1 dfs求直径的长树的直径可以简单的用两边dfs求出。该思想的核心是下面的这个定理： 树上距离任意一点最远的节点一定是直径的端点。 对于这个定理，可以不严谨的这样理解一下：如果这个“最远的节点”不是直径的端点，那么走直径可以比它走得更远。 那么任选一个节点，找到和它相距最远的节点，那么直径的一端就已经固定了。对于直径的端点而言，上述定理也依然适用，那么再找出据这个点最远的一个点，即直径的另一个端点，直径就可以被求出。 对于求最远的过程，类似于单源最短路。在树上可以更简单地递推求得。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const int CP=1e3+3;const int CE=CP*10;const int INF=0x3f3f3f3f;//快读 int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;} //边表 class fs{ public: int to,nxt,dist; void init(int x,int y,int z) {to=x; nxt=y; dist=z;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y,int z){ E[++ecnt].init(y,hd[x],z); hd[x]=ecnt;}//v defineint n,m;//dfsbool vis[CP];int d[CP];void dfs(int u){ vis[u] = true; for(int k=hd[u]; k; k=E[k].nxt) if(!vis[E[k].to]){ d[E[k].to] = d[u]+E[k].dist; dfs(E[k].to); }}int diameter(){ //主求解函数 int st=1,mx=-INF; memset(d,0,sizeof(d)); memset(vis,false,sizeof(vis)); dfs(st); for(int i=1;i&lt;=n;i++) if(mx &lt; d[i]) mx = d[st=i]; memset(d,0,sizeof(d)); memset(vis,false,sizeof(vis)); dfs(st); mx=-INF; for(int i=1;i&lt;=n;i++) mx = max(mx, d[i]); return mx;} 2 求直径的具体路径上述代码可以很方便的求出直径的长度，调用主求解函数diameter()即可。但是它无法保存路径。对于某些要求求出直径的具体路径的题目，上述代码就不胜任了。 其实记录路径只需要简单地更改一下上述代码：在搜索的时候记录进入每一个节点的边的编号（即在边表中的下标）。因为两点间仅存在一条路径，这样就可以很快速的通过一个while()遍历，求出任意两点间的路径。这种思路与费用流问题中bfs模拟回溯更新有点相像。 具体代码如下，仅能求出任意一条直径： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const int CP=1e3+3;const int CE=CP*10;const int INF=0x3f3f3f3f;//快读 int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;} //边表 class fs{ public: int from,to,nxt,dist; void init(int f,int t,int n,int d) {from=f; to=t; nxt=n; dist=d;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y,int z){ E[++ecnt].init(x,y,hd[x],z); hd[x]=ecnt;}//v defineint n,m;//dfsbool vis[CP];int d[CP];int prv[CP]; //prv[i] : 进入节点 i 的边 void init(){ memset(d,0,sizeof(d)); memset(vis,false,sizeof(vis)); memset(prv,0,sizeof(prv));}void dfs(int u){ vis[u] = true; for(int k=hd[u]; k; k=E[k].nxt) { int v = E[k].to; if(!vis[v]){ d[v] = d[u]+E[k].dist; prv[v] = k; dfs(v); } }}void print_path(int s,int t){ //打印路径 int pos = t; while(pos != s){ fs e = E[prv[pos]]; printf(\"edge: %d &lt;-&gt; %d\\n\",e.from,e.to); pos = e.from; }} int diameter(){ //主求解函数 int s=1,t; init(); dfs(s); int mx=-INF; for(int i=1;i&lt;=n;i++) if(mx &lt; d[i]) mx = d[s=i]; init(); dfs(s); mx=-INF; for(int i=1;i&lt;=n;i++) if(mx &lt; d[i]) mx = d[t=i]; print_path(s,t); return mx; } $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/04/11/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"title":"树上的动态规划","text":"对于树上的动态规划问题，一般可以分为两类：树型结构的DP问题和树形背包。两种模型都存在树型的依赖关系，前者侧重相邻节点间的制约条件，后者则更像是一个有依赖关系的背包问题…… 一 树型结构的DP问题1 模型给定$ n $个物品，且这些物品构成一个树形结构。树上的父节点与子节点间存在一些制约，通常表现为父子节点无法同时被选择。同时，每件物品还有一个权值（点权）。 这就是树形结构的DP问题的基本模型。 树形结构的DP问题通常用来求解上述模型的 最大/最小 点权和。 例题：Luogu P1352 没有上司的晚会 某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 很明显，上司与职员的关系构成一棵树，树上的子节点与父节点无法同时被选择。 2 状态设计定义$ f_{i,k} $为考虑以$ i $为根的子树，且节点$ i $的选择状态为$ k $时求的的解（$ k=1 $表示选择节点$ i $，$ k=0 $表示不选择节点$ i $）。 因为当前节点一旦选中，子节点则全部无法选择，故转移方程一：$$ f_{i,1} = \\sum_{i,j \\in E}f_{j,0} $$（$ E $为边集） 若当前节点不被选中，子节点则可选可不选，故转移方程二：$$ f_{i,0} = \\sum_{i,j \\in E}\\max f_{j,0},f_{j,1}$$（$ E $为边集） 答案为$ \\max f_{1,0},f_{1,1} $。 3 实现因为状态的转移需要由叶向根转移，我们可以借助dfs实现状态的转移。 123456789101112131415int dp(int cur){ f[cur][1]=v[cur]; //预处理 for(int k=hd[cur]; k; k=E[k].nxt) //遍历边表 { int to=E[k].to; dp(to);//求出子节点的两个状态 f[cur][0]+=max(f[to][0], f[to][1]);//判断子节点选和不选哪个更优 f[cur][1]+=f[to][0];//sigema } return max(f[cur][0], f[cur][1]);} 二 树形背包问题1 模型给定$ n $个物品，子物品和主物品存在依赖关系，且这些关系满足树的性质，即所有物品构成一个树形结构。每个节点有点权。令在其中选出$ m $个，且对于任意一棵子树，必须先选中父节点，才可以在该子树的所有节点中选择。 这就是树形背包问题的基本模型。 树形背包通常用来求解上述模型的 最大/最小 点权和。 例题：Luogu P2014 选课 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？ 显然，先修课与后修课的关系满足树状结构。 2 状态设计定义$ f_{i,s_i} $为选中节点 $ i $，且当前节点为根的树中选择$ s_i $个节点（不含根）的解。 设$sum_i$为子树$i$的总结点数。对于节点$ i $，当固定了$s_i$的值时，它的$f$值可以分成两个部分：它的一棵子树的解（$f_{j,s_j}$）和其他子树的解之和（$ f_{i,s_i-s_j-1}$ )。因为$s_j$里面实际不包含节点$j$，所以最后还要$-1$。 那么转移方程： $ f_{i,s_i} = \\max f_{j,s_j}+f_{i,s_i-s_j-1} +c[j] | s_i\\leqslant sum_i,s_j\\leqslant sum_j,(i,j)\\in E$（$c[j]$为节点权值，$E$为边集） 2-1 小问题：为什么一棵子树不会被重复累加？我们考虑以背包的方式更新当前节点的解，则一棵子树在被累加之前不会累加在$ f_{i,s_i-s_j-1}$ 中。 3 实现因为状态转移需要知道当前的$ s_i $，且需要从叶向根转移状态，所以我们依然用dfs来实现。 统计子树节点需要一遍dfs。但是考虑任意节点，我们都可以分段的转移状态。即我们可以边统计它的节点个数，边转移状态，因为状态的转移是不存在后效性的。 1234567891011121314151617void dfs(int cur,int prv) //cur当前，prv父节点{ sum[cur]=1; for(int k=hd[cur]; k; k=E[k].nxt) //遍历边表 { int to=E[k].to; dfs(to, cur); //递归处理 sum[cur] += sum[to]; //累加节点数 for(int j=min(m, sum[cur]); j; j--) //分配给当前树的节点数 for(int k=min(j-1, sum[to]); k&gt;=0; k--) //分配给子树的节点数 f[cur][j] = max(f[cur][j], f[to][k]+f[cur][j-k-1]+c[to]); //这里要加上子节点的权值，因为f[to][k]不包含节点to的权值 }} 题中树形结构可能构成森林，故我们假设森林有一个总根$0$，调用dfs(0,0)即可解决。 因为状态定义中每个$f$不包含根，故新增总根对答案状态无影响。 答案为$f_{0,m} $ $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/01/%E6%A0%91%E4%B8%8A%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"树的重心","text":"在树上找一个点，使在其所有的子树中，最大的那棵尽量小。满足这样条件的点叫做树的重心…… 一 概念在树上找一个点，使在其所有的子树中，最大的那棵尽量小。满足这样条件的点叫做树的重心。树的重心至少有一个，至多有两个。在树上删去树的重心之后，生成的多棵树会尽可能平衡。 二 性质 以树的重心为根时，它的所有子树的大小不超过树的大小的一半 在树上找一个点，使得所有点到该点的距离和最小，则这个点是树的重心 将两棵树连一条边形成一棵新的树，则新树的重心在原来两棵树的重心间的路径上 在一棵树上添加或减少一个节点，树的重心至多移动一条边的距离 三 求法DFS求出以每个节点为根的子树的大小，然后求出每个节点$i$的最大的子树大小$mx_i$。求出$\\min mx_i$，则求得的$mx_i$所对应的$i$即是树的重心。 代码 1234567891011121314151617181920212223242526272829303132333435363738const int CP=2e4+4;const int CE=CP*100;const int INF=0x3f3f3f3f;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;int n;int sz[CP],g,mn=INF; //g为重心 mn为min(mx_i)void dfs(int u,int prv){ //u当前节点 prv父节点 sz[u] = 1; //初始只有自己一个节点 int mx = -INF; //初始化 for(int k=hd[u];k;k=E[k].nxt){ int v=E[k].to; if(v != prv){ //是子节点 dfs(v,u); //搜索 sz[u] += sz[v]; //累加 mx = max(mx, sz[v]); //更新 } } mx = max(mx, n-sz[u]); //注意：u的祖先节点也是它的子树（即上方子树） if(mx &lt; mn){ //找最小 mn = mx; g = u; //记录重心 }}int main(){ ... //scan dfs(1,0); ... //print return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/26/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"title":"欧几里得与扩展欧几里得定理","text":"$$ \\gcd(a,b) = \\gcd (b,a \\text{ mod } b) $$ $$ \\begin{cases} ax_1 + by_1 = \\gcd(a,b) \\newline bx_2 + (a\\text{ mod }b)y_2 = \\gcd(b,a\\text{ mod }b) \\end{cases} \\Rightarrow \\begin{cases} x_1 = y_2 \\newline y_1 = x_2- \\lfloor\\dfrac{a}{b}\\rfloor \\times y_2 \\end{cases}$$ 一 欧几里得定理1 最大公约数最大公约数（Greatest Common Divisor，GCD），是指对于两个整数$a,b$，找到一个最大的整数$k$，使得$k|a$且$k|b$（“$|$”表示整除）。 2 欧几里得定理对于任意整数对$(a,b)$，它们的最大公约数都等于整数对$(b,a\\text{ mod }b)$的最大公约数。用公式表达就是这样：$$\\forall a,b\\in Z , \\gcd(a,b) = \\gcd(b, a\\text{ mod }b)$$ 证明请参照OI Wiki - gcd。 3 代码实现当$b=0$时，可知$\\gcd(a,b) = \\gcd(a,0) = a$。故递推$\\gcd(a,b) = \\gcd(b,a\\text{ mod }b)$直到$b=0$。 实现如下： 1234int gcd(int a,int b){ if(!b) return a; return gcd(b, a%b);} 甚至可以压行： 1int gcd(int a,int b) {return b ? gcd(b,a%b) : a;} 二 扩展欧几里得定理1 模型扩展欧几里得定理（EX-GCD）用于求解关于$x,y$的，形如$ax+by = \\gcd(a,b)$方程的一组可行解。该定理的基本内容如下： 设$ax_1 + bx_2 = \\gcd(a,b)$，$bx_2 + (a\\text{ mod }b)y_2 = \\gcd(b,a\\text{ mod }b)$，则有$x_1= y_2, y_1 = x_2- \\lfloor\\dfrac{a}{b}\\rfloor \\times y_2$。即为引言中的公式： $$ \\begin{cases} ax_1 + by_1 = \\gcd(a,b) \\newline bx_2 + (a\\text{ mod }b)y_2 = \\gcd(b,a\\text{ mod }b) \\end{cases} \\Rightarrow \\begin{cases} x_1 = y_2 \\newline y_1 = x_2- \\lfloor\\dfrac{a}{b}\\rfloor \\times y_2 \\end{cases}$$ 证明也请参见OI Wiki - exgcd。 2 代码实现当$b=0$时，$\\gcd(a,b) = \\gcd(a,0) = a$。此时$ax + by = \\gcd(a,b) = a$的一组可行解是$\\begin{cases} x = 1 \\ y = 0 \\end{cases}$。把这个作为边界条件带入gcd函数，不断向上面一样递推至$b=0$，再在回溯过程中计算答案即可。 1234567891011void exgcd(int a,int b,int &amp;x,int &amp;y){ if(!b){ x = 1; y = 0; return; } exgcd(b,a%b,x,y); int t = x; //保存x2 x = y; //计算x1 y = t-(a/b)*y; //计算y1 } 3 解的关系设$k$为任意整数，则当$x_1,y_1$是方程$ax+by = \\gcd(a,b)$的一组解时，$x_1+kb,y_1-ka$也是该方程的一组解。 证明如下：因$ax_1 + by_1= \\gcd(a,b)$①，得$ax_1 + by_1 + k·a·b - k·a·b= \\gcd(a,b)$。变换得$ax_1 + a·kb + by_1 - b·ka = \\gcd(a,b) , a(x_1 + kb) + b(y_1 - ka) = \\gcd(a,b)$②。因①式成立，故​②​式成立。即$x_1+kb,y_1-ka$是方程的可行解。 三 变形 NOIP2012 TG 同余方程 求关于 x的同余方程$ a x \\equiv 1 \\pmod {b}$的最小正整数解。 设$y·b + 1 = ax$，即$ax - by = 1$，则题目要求为找出满足上面等式的最小的正整数$x$。设$y_0 = - y$，变形为$ax + by_0 = 1$，似乎可以用exgcd处理。 考虑$\\gcd(a,b)$的定义，$ax + by_0$一定是$\\gcd(a,b)$的倍数。因$ax + by_0 = 1$，故$\\gcd(a,b)|1$。因$\\gcd(a,b) \\geqslant 1$，故$\\gcd(a,b) = 1$。那么上面的$ax + by_0 = 1$再变形为$ax + by_0 = \\gcd(a,b)$。直接用exgcd求解就好了。 答案的处理因exgcd可以求出上述方程的一组任意解，而题目要求是求出“最小正整数解”。根据解的关系，可知当$x_1$是解时，$x_1 \\pm b$也是解。那么当$x \\leqslant 0$时，另$x + b$直到$x &gt; 0$；反之同理，即可求出最小正整数解。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longLL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}LL a0,b0,x,y;void exgcd(LL a,LL b){ if(!b) return (void)(x=1,y=0); exgcd(b, a%b); int t = x; x = y; y = t-(a/b)*y;}int main(){ a0=read(); b0=read(); exgcd(a0,b0); while(x &lt; 0) x += b0; x %= b0; //大于，直接取模 printf(\"%d\",x); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/05/19/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/"},{"title":"欧拉路","text":"欧拉跑过的七桥古塘，让你，心驰神往…… 一 引入1 欧拉路问题 数学家欧拉在研究著名的德国哥尼斯堡(Koenigsberg)七桥问题时，发现欧拉路。流经哥尼斯堡的普雷格尔河中有两个岛，两个岛与两岸共4处陆地通过7座桥彼此相联。七桥问题就是如何能从任一处陆地出发，经过且经过每个桥一次后回到原出发点。 欧拉由此提出了著名的欧拉定理。 欧拉路问题，也称“一笔画问题”。即给定一张图（有向或无向），求出图上的一条路径，使得这条路径经过图上的所有边恰好一次。 若存在满足上述条件的道路，则这条道路被称为欧拉道路。若一条欧拉道路的起点与终点相重合，则这条道路被称为欧拉回路。若图中已判定存在欧拉回路，则从任意一点出发，均可以回到该点。 2 解的存在性存在一条欧拉道路，首先需要保证图是联通的。 对于一个联通图，定义$d_i$为节点$i$所连接的边数（也就是度）。对于图上$d_i$的值为奇数的节点，称之为奇点。定理：（蒟蒻并不会证明） 若图上没有奇点，则一定存在欧拉回路。 若图上存在两个奇点，则一定存在欧拉道路，且该道路以这两个奇点为端点。 若图上存在多于两个奇点，则不存在欧拉道路。 二 实现算法的思路很简单：先判断解的有无，然后从奇点（若不存在就从任意一点）出发，搜索整张图，并把每次走过的边删除。那么我们访问节点的先后顺序就是欧拉道路。 有一点需要注意，当使用边表存图时，删边需要把正反两条边同时删除。故边从$1$开始标号，使得$i \\text{xor} 1$总是$i$的反向边。 给出代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int CP=1e3+3;const int CE=CP*CP;const int INF=0x3f3f3f3f;//边表class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=1; //边的标号从1开始void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}//variable defineint n,m;int d[CP]; //度//判断解的存在bool examine(){ int sum=0; for(int i=1;i&lt;=n;i++) if(d[i]%2) sum++; return (!sum) || (sum==2);}//求解bool vis[CE]; //每条边是否访问过int list[CP]; //保存答案void dfs(int u){ for(int k=hd[u]; k; k=E[k].nxt) if(!vis[k]) { vis[k]=vis[k^1]=true; //正反边同时标记 dfs(E[k].to); } list[++list[0]]=u; //记录，注意要倒序输出，因为是在回溯时记录}bool solve(){ if(!examine()) return false; int st=1; //起点默认为1 for(int i=1;i&lt;=n;i++) if(d[i]%2) //为奇点 st=i; //从奇点出发 dfs(st); return list[0]==n; //当list[0]!=n时，可以判定图不联通} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/26/%E6%AC%A7%E6%8B%89%E8%B7%AF/"},{"title":"状态压缩的动态规划","text":"状态压缩的动态规划，实际上也是一种“暴力出奇迹”的做法。 一 模型 例：SCOI2005 互不侵犯在$N \\times N$的棋盘里面放$K$个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共$8$个格子。$（1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N \\times N）$ 1 暴力思路先考虑暴力解法。爆搜第一行的状态，在合法的情况下，再爆搜下一行状态，得到这两行的所有可行方案。然后递归向下一行求解。直到得到前$N$行的可行方案，且当前方案放置了$K$个国王，此时累加答案。 2 从暴力到动态规划一个国王攻击距离只有一个格子。这就是说，如果仅考虑前$i$行，那么当前求解第$i$行时，受其影响的只有第$i-1$行（下面的格子越界了不去考虑，左右的个子同在第$i$行，剩下的只在第$i-1$行）。 也就是说，第$i$行的状态可以由第$i-1$行转移过来。 然后我们灵稽一动，是不是设$f_{i,j}$表示考虑前$i$行放$j$个国王的解数，就能切了这题吗？然而并不是。当前行和上一行之间，怎么保证满足限制且能快速的计算出满足限制的解数？ 爆搜当前行和上一行的排列方案？还是不行。存在后效性：当当前行的排列方案改变的时候，$f$的值也会发生变化，不能用$f_{i,j}$一个状态一概而过。 那么就得加一维状态，也就是把爆搜放到数组的维度里。 3 把爆搜变成数组的维度不要听题目瞎扯。爆搜怎么可能变成数组的维度？！实际上，是把排列方案变成数组的维度。这个排列方案也可称作“状态”，于是就有了“状态压缩的动态规划”。 我们考虑每一行，有$N$个位置，放置国王用$1$表示，不放国王用$0$表示，那么我们会得到一个01串，如下：$$ 01101 $$这是当$N=5$时的随机一行的一种状态。虽然它不合法，但是这没有关系。它表示当前行，第一个位置没有国王，第二、三个位置有国王，第四个位置没有国王，第五个位置有国王。 那什么是“压缩”？我们把上面的01串看作二进制。 $ (01101)2 = (13)10 $ 所以我们把这个状态编号为$13$，这就是状态压缩。 有了状态压缩，我们就可以定义$f_{i,j,cur}$表示考虑前$i$行放$j$个国王，且放置状态为$cur$时的解数。解决了后效性的问题。转移方程：$ f_{i,j,cur}=1|i=1,j=sumbit(cur),j \\leqslant K,exmslf(cur) $$ f_{i,j,cur}=f_{i,j,cur}+f_{i-1,j-sumbit(cur),prv}|1&lt;i \\leqslant N,j \\leqslant K,exmslf(cur,prv),exmcpl(cur,prv) $其中，$cur$为当前行状态，$prv$为上一行状态，$sumbit$函数实现统一任意一个状态里国王放置的数量，$exmslf$函数实现检查任意一个状态是否合法（一行中是否有国王可以互相攻击），$exmcpl$函数实现检查任意两个状态是否可以相邻（上下两行是否有国王可以互相攻击）。 4 枚举状态考虑怎么枚举状态。当$N=5$时，状态最大为$(11111)_2$，最小为$(00000)_2$。$(11111)_2=(100000)_2-(1)_2$$ (100000)_2=1&lt;&lt;5=1&lt;&lt;N(=2^N) $故状态在$0$到$1&lt;&lt;N$之间（不包括$1&lt;&lt;N$）。（注：“$&lt;&lt;$”是位运算中的左移运算符） 所以只需要 for(int cur=0; cur&lt;(1&lt;&lt;N); cur++) 就好了。 二 代码实现1 sumbit函数暴力分解二进制。 1234567891011int sumbit(int s){ int sum=0; while(s) { if(s&amp;1) //如果二进制的最后一位是1 sum++; //累加 s&gt;&gt;=1; } return sum;} 2 exmslf函数原理：$a &amp; b=1$表示$a,b$二进制上的某一位同时为$1$。 则当$cur$不满足单行要求时，$cur &amp; (cur&lt;&lt;1)$与$cur &amp; (cur&gt;&gt;1)$里面至少有一者运算结果为$1$。 123bool exmslf(int s){ return !(s&amp;(s&lt;&lt;1)) &amp;&amp; !(s&amp;(s&gt;&gt;1));} 3 exmcpl函数原理同上。 123bool exmcpl(int s1,int s2){ return !(s1&amp;s2) &amp;&amp; !(s1&amp;(s2&lt;&lt;1)) &amp;&amp; !(s1&amp;(s2&gt;&gt;1));} 4 递推123456789101112131415for(int fst=0; fst&lt;(1&lt;&lt;n); fst++) if(exmslf(fst) &amp;&amp; sumbit(fst)&lt;=k) f[1][sumbit(fst)][fst]=1; for(int i=2;i&lt;=n;i++) for(int cur=0; cur&lt;(1&lt;&lt;n); cur++) for(int sum=sumbit(cur);sum&lt;=k;sum++) for(int prv=0; prv&lt;(1&lt;&lt;n); prv++) if(exmslf(cur) &amp;&amp; exmslf(prv) &amp;&amp; exmcpl(cur,prv)) f[i][sum][cur]+=f[i-1][sum-sumbit(cur)][prv];int ans=0; for(int lst=0; lst &lt; (1&lt;&lt;n); lst++) if(exmslf(lst)) ans+=f[n][k][ans]; $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/18/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"线段树","text":"维护一段数列，支持 区间/单点 修改以及 区间查询…… 一 功能维护一段数列，支持 区间/单点 修改以及 区间查询（求和等）。 二 原理线段树（segment tree）形似二叉堆（heap）。 一棵长得很清新的线段树 将大区间分成左右两个子区间，子区间继续细分，构成一棵二叉树。二叉树中每个节点都会有一个待查询值，即此区间进行区间查询的返回值。 当 区间/单点 修改时，利用懒标记（tag）系统降低复杂度。 1 tag系统这是一个类似于差分的数组。$ tag_k $即对应着$ k $号节点的区间修改值（加减乘除等的运算因数）。 当一个区间被修改区间包含时，这个区间会被优先修改，然后打上$ tag $。这意味着区间被做了标记，即当前区间的子区间需要进行以该区间$ tag $为因数的运算，但此时优先忽略。 当某一区间进行多次修改时，$ tag $系统（不优先遍历子区间）会大大降低时间复杂度。 当该区间的子区间被查询时，则需要数据下传（pushdown）操作。 2 pushdown子区间优先按照父区间的$ tag $修改区间查询值。 同时子区间$ tag $继承父区间$ tag $，父区间$ tag $归零。 三 代码实现1 定义部分1234567const int CON=1e5+5;int d[CON*4],tag[CON*4];//d[]维护节点值，tag[]维护懒标记 d[]与tag[]维护整棵树，需要四倍空间 int org[CON];//原始序列d[1]=0;memset(tag,0,sizeof(tag)); 2 建树（build）12345678910111213141516171819#define MID(a,b) (a+b)&gt;&gt;1#define LS(k) k&lt;&lt;1#define RS(k) (k&lt;&lt;1)|1void build(int l,int r,int k){ if(l==r) { d[k]=org[l];//叶节点的值为原始值 return; } int tom=MID(l,r);//中点处断开 build(l,tom,LS(k));//递归建树 build(tom+1,r,RS(k)); d[k]=d[LS(k)]+d[RS(k)];//处理父节点的值} 3 区间操作3-1 数据下传（pushdown）12345678void pushdown(int l,int r,int k,int tom){ d[LS(k)]+=tag[k] * (tom-l+1);//优先子区间修改 d[RS(k)]+=tag[k] * (r-tom); tag[LS(k)]=tag[RS(k)]=tag[k];//tag下传 tag[k]=0;} 3-2 区间修改（modify）123456789101112131415161718192021#define MID(a,b) (a+b)&gt;&gt;1#define LS(k) k&lt;&lt;1#define RS(k) (k&lt;&lt;1)|1void modify(int l,int r,int k/*当前区间*/ int s,int e,/*查询区间*/ int v,/*修改值*/ ){ if(s&lt;=l &amp;&amp; r&lt;=e)//当前区间被包含 { tag[k]+=v;//打标记 d[k]+=(l-r+1) * tag[k]; return; } int tom=MID(l,r);//中点 if(tag[k] &amp;&amp; l!=r)//处理tag（非叶节点） pushdown(l,r,k,tom); if(l&lt;=tom) modify(l,tom,LS(k), s,e,v);//子区间包含查询区间，递归修改 if((tom+1)&lt;=r) modify(tom+1,r,RS(k), s,e,v);} 3-3 区间查询（query）1234567891011121314151617181920#define MID(a,b) (a+b)&gt;&gt;1#define LS(k) k&lt;&lt;1#define RS(k) (k&lt;&lt;1)|1int query(int l,int r,int k/*当前区间*/ int s,int e,/*查询区间*/){ if(s&lt;=l &amp;&amp; r&lt;=e)//当前区间被包含 return d[k]; int ret=0;//查询结果 int tom=MID(l,r); if(tag[k] &amp;&amp; l!=r)//处理tag pushdown(l,r,k,tom); if(l&lt;=tom) ret+=query(l,tom,LS(k), s,e);//子区间包含查询区间，递归查询，累加返回值 if((tom+1)&lt;=r) ret+=query(tom+1,r,RS(k) ,s,e); return ret;//返回结果} 四 其他1 时间复杂度单次 修改/查询：$ O(log_n) $。 （$ n $为区间长度） $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/01/30/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"title":"组合数学基础","text":"此页面存在相关页面。关于反演与组合恒等式，请参见「组合数学再基础」。 排列组合 + 二项式定理 + 卢卡斯（lucas）定理…… 一 排列组合1 概念从$n$个不同元素中取$m(m\\leqslant n)$个形成一个排列，所得到的排列的总数被称作排列数，记作$A_n^m$。从$n$个不同元素中取$m(m\\leqslant n)$个形成一个集合，所得到的集合的个数被称作组合数，记作$C_n^m$。 2 公式通项公式$$ A_n^m = \\dfrac{n!}{(n-m)!} $$$$ C_n^m = \\dfrac{n!}{m!(n-m)!} $$ 推导式$$C_n^m = \\dfrac{A_n^m}{m!}$$ 递推式$$ C_n^m = C_{n-1}^m+C_{n-1}^{m-1} $$ 对称性$$ C_n^m = C_n^{n-m} $$组合数具有对称性。假设你现在有一张$C_1^1\\text{~} C_n^m$的组合数表，那么这张表的第$i$横行应该是以$i/2$为轴呈左右对称的。 二 二项式定理其实组合数、杨辉三角、二项式定理都可以看成一个东西…… 二项式定理用于求$(x+y)^n$的展开式。定理的内容如下（公式表示）：$$ (x+y)^n = \\sum\\limits_{k=0}^n C_n^kx^ky^{n-k} $$ 有一个比较有意思的地方：当$p$是素数时，$ (x+y)^p \\equiv x^p+y^p (\\text{mod }p)$。 因为$ \\sum\\limits_{k=0}^p C_p^kx^ky^{p-k} $可以拆成$x^p+y^p + \\sum\\limits_{k=1}^{p-1} C_p^kx^ky^{p-k}$，后面的$\\sum\\limits_{k=1}^{p-1} C_p^kx^ky^{p-k}$中，每一项都有一个$C_p^k(k\\in [1,p-1] )$。用通项公式，那么$C_p^k$可以变成$\\dfrac{p!}{k!(p-k)!}$，分子部分的$p!$含有$p$这一项，故$p!\\equiv 0 (\\text{mod }p)$；同时$p$这一项不会被约分掉（因为$p$是质数），故$\\dfrac{p!}{k!(p-k)!}\\equiv 0 (\\text{mod }p)$，故$C_p^k\\equiv 0 (\\text{mod }p,k\\in [1,p-1])$，故$\\sum\\limits_{k=1}^{p-1} C_p^kx^ky^{p-k}\\equiv 0 (\\text{mod }p)$，故得证。 三 卢卡斯定理1 理论卢卡斯（lucas）定理用来求$ C_n^m \\text{ mod } p$的值，其中$p$为素数。题外话：当$p$不是素数的时候要用扩展卢卡斯（ex-lucas），貌似还要用CRT，真是吓死我了…… 定理的内容：$$ C_n^m \\text{ mod } p = (C_{n \\text{ mod } p}^{m \\text{ mod } p}\\times C_{\\lfloor n/p\\rfloor}^{\\lfloor m/p\\rfloor}) \\text{ mod } p $$ 根据乘法取余的运算原则，可以拆出$C_{\\lfloor n/p\\rfloor}^{\\lfloor m/p\\rfloor} \\text{ mod } p$这一项。这个可以继续用lucas递归求。 剩下部分是$C_{n \\text{ mod } p}^{m \\text{ mod } p}\\text{ mod } p$，可知$n,m$都不会超过或等于$p$，那么尝试暴力求。 当$p$一定时，显然可以打一个阶乘取余的表，不再多说。如果不打表，用通项公式求的极限复杂度大约是$O(p)$（忽略了常数），实际上可以再优化一下常数。当组合数有意义（即$m\\leqslant n$）时，$n!$中实际上包含了$m!$。于是通项公式可以变形为：$$C_{n}^{m} \\text{ mod } p = \\dfrac{n(n-1)(n-2)…(m+1)}{(n-m)!} \\text{ mod } p $$这个式子涉及到除法的取余，所以需要引入$(n-m)!$在模$p$意义下的逆元$\\text{inv}[(n-m)!]$。$p$是个质数，用费马小定理就好了。最终变形为：$$C_{n}^{m} \\text{ mod } p =n(n-1)(n-2)…(m+1)·\\text{inv}[(n-m)!] \\text{ mod } p $$ 然后根据组合数的对称性，$ C_n^m = C_n^{n-m} $，那么我们在$m,n-m$挑一个小的代入式子求组合数就好了。极限复杂度大概是严格的$O(p)$。 考虑到多组数据的话，该算法适用数据范围大约是$p\\leqslant 10^5$。 2 代码模板 12345678910111213141516171819202122232425262728#define LL long longLL QuickPow(LL a,LL b,LL r){ //快速幂取余 LL base = a%r,rec = 1; while(b){ if(b &amp; 1) (rec *= base) %= r; (base *= base) %= r; b &gt;&gt;= 1; } return rec % r;}int C(int n,int m,int p){ //计算组合数 if(m &gt; n) return 0; if(m &gt; n-m) m = n-m; //这里用到对称性 LL s1 = 1,s2 = 1; for(int k=m+1;k&lt;=n;k++) (s1 *= k) %= p; for(int k=2;k&lt;=n-m;k++) (s2 *= k) %= p; LL inv = QuickPow(s2,p-2,p); //求逆元 return (s1*inv) % p;}int lucas(int n,int m,int p){ //主求解函数，返回C(n,m) mod p的值 if(!m) return 1; //边界 return (C(n%p,m%p,p)*lucas(n/p,m/p,p)) % p;} 时间复杂度大概是$O(t·p\\log_pn)$，$t$是数据组数。 $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/26/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"title":"种类并查集","text":"类并查集，也称带权并查集，是并查集的强化版。 一 引入1 为什么需要种类并查集我们知道，凭借其优秀的树形结构，并查集可以在较短时间内实现判断某一元素$x$与$y$之间的关系。但是一般的并查集仅限于维护一重关系，当元素间的关系变得错综复杂时，普通并查集也难免无能为力。 于是，当并查集维护的关系很复杂时，需要用到种类并查集。 2 什么是种类并查集种类并查集相当于若干个普通并查集的并。 例：NOI2001食物链动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B吃 C，C 吃 A。现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 N 个动物所构成的食物链关系进行描述：第一种说法是“1 X Y”，表示 X 和 Y 是同类。第二种说法是“2 X Y”，表示 X 吃 Y 。 此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。• 当前的话与前面的某些真的话冲突，就是假话• 当前的话中 X 或 Y 比 N 大，就是假话• 当前的话表示 X 吃 X，就是假话你的任务是根据给定的 N 和 K 句话，输出假话的总数。 在本题中，任意两个元素$x,y$间的关系有三种：$x$吃$y$，$y$吃$x$，或同类。传统的并查集显然没办法维护这么多关系。考虑一个并查集能维护一种关系，所以我们使用三个并查集（其实是三倍大小），来维护这三种关系。 我们设存在三个集合$A,B,C$，并且满足题目中“$A$ 吃 $B$，$B$吃 $C$，$C$ 吃$A$”的要求。因为不知道具体有哪些动物，所以不妨设全体动物共同属于这三个集合，然后通过动物间的关系，就可以得到集合间的相对关系。具体地，就是使用一个三倍空间的并查（$3N$大小）。其中$[1,N]$表示集合$A$，$(N,2N]$表示集合$B$，$(2N,3N]$表示集合$C$。同时，相同集合中的并查集表示同类，跨越集合的并查集表示敌对。 这就是种类并查集。 当出现表述“$x,y$是同类”时，在三个区间内分别将$x,y$合并（注意是区间内合并，表示同类）。当出现表述“$x$吃$y$”时，分别合并集合$A$中的$x$与集合$B$中的$y$，集合$B$中的$x$与集合$C$中的$y$，集合$C$中的$x$与集合$A$中的$y$。这表示他们所在的并查集为敌对（注意其实这里元素$i$的下标其实是发生了变化的，所以不会和表示同类的并查集冲突）。 二 实现给出模板： 1234567891011121314151617181920212223242526272829303132333435const int CP=1e4+4;#define A(x) x //A集合#define B(x) x+n //B集合#define C(x) x+2*n //C集合class ufs{ public: int fa[CP*3]; ufs() {for(int i=1;i&lt;CP*3-10;i++) fa[i]=i;} //构造函数 int find(int u) {return fa[u]==u ? u : fa[u]=find(fa[u]);} //find函数 void merge(int x,int y) {fa[find(x)]=find(y);} //合并 bool exm(int x,int y) {return !find(x)==find(y);} //检查是否在同一并查集中}s;bool rela(int x,int y) //同类{ if(s.exm(A(x),B(y)) || s.exm(B(x),A(y))) return false; s.merge(A(x),A(y)); //合并 s.merge(B(x),B(y)); s.merge(C(x),C(y)); return true;}bool emen() //敌对{ if(s.exm(A(x),A(y)) || s.exm(B(x),A(y))) return false; s.merge(A(x),B(y)); //合并 s.merge(B(x),C(y)); s.merge(C(x),A(y)); return true;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/27/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"组合数学再基础","text":"之前好像写过「组合数学基础」，在这里再来堆点柿子。 此页面存在相关页面。关于组合数学基础，请参见「组合数学基础」。 1 Stirling 数1.1 定义众所周知，Stirling 数有两类，分别是： $$ \\begin{align} \\begin{bmatrix}n\\newline m \\end{bmatrix} = \\begin{bmatrix}n-1\\newline m-1 \\end{bmatrix}+(n-1)\\begin{bmatrix}n-1\\newline m \\end{bmatrix} \\newline \\begin{Bmatrix}n\\newline m \\end{Bmatrix}=\\begin{Bmatrix}n-1\\newline m-1\\end{Bmatrix}+m \\begin{Bmatrix}n-1\\newline m \\end{Bmatrix} \\end{align} \\tag1 $$ 接下来介绍 Stirling 数的性质。 1.2 常幂展开一个组合意义显然的柿子： $$ \\begin{align} n^m &amp;= \\sum\\limits_{k=0}^m \\begin{Bmatrix}m\\newline k \\end{Bmatrix}k! \\dbinom{n}{k} \\tag2 \\newline &amp;= \\sum\\limits_{k=0}^m \\begin{Bmatrix}m\\newline k\\end{Bmatrix} n^{\\underline{k}} \\tag{3} \\end{align} $$ $(3)$ 式通常被称为 常幂展开。 1.3 Stirling 反演$$ f(n) = \\sum\\limits_{k=0}^n \\begin{Bmatrix}n\\newline k\\end{Bmatrix} g(k) \\Leftrightarrow g(n) = \\sum\\limits_{k=0}^n (-1)^{n - k} \\begin{bmatrix}n\\newline k\\end{bmatrix} f(k) \\tag{4} $$ $(4)$ 式通常被称为 Stirling 反演公式。 1.4 阶乘幂展开对 $(3)$ 应用 $(4)$ 式得： $$ n^{\\underline{m}}= \\sum\\limits_{k=0}^m (-1)^{m-k} \\begin{bmatrix}m\\newline k\\end{bmatrix} n^k \\tag{5} $$ 可以证明有： $$ n^{\\overline{m}}= \\sum\\limits_{k=0}^m \\begin{bmatrix}m\\newline k\\end{bmatrix} n^k \\tag{6} $$ $(5),(6)$ 两式被称作 阶乘幂展开。 2 组合数2.1 定义 众所周知，小葱同学擅长计算，尤其擅长计算组合数，但是这跟本文的主题并没有什么关系。 小葱同学擅长计算的组合数定义为： $$\\dbinom{n}{m} = \\dbinom{n-1}{m} + \\dbinom{n-1}{m-1}$$ 2.2 二项式定理$$(x+y)^k = \\sum\\limits_{i=0}^k \\dbinom{k}{i} x^i y^{k-i} \\tag{7}$$ $(7)$ 式被称作 二项式定理。 2.3 组合恒等式 组合恒等式 I 在 $(7)$ 式中令 $x=y=1$ ，得： $$\\sum\\limits_{i=0}^k \\dbinom{k}{i} = 2^k \\tag{8}$$ 组合恒等式 II $$\\sum\\limits_{i=0}^k \\dbinom{k}{i}[2|i] =\\sum\\limits_{i=0}^k \\dbinom{k}{i}[2\\nmid i] = 2^{k-1} \\tag9$$ 证明显然。 组合恒等式 III $$\\dbinom{n}{k}\\dbinom{k}{j} = \\dbinom{n}{j} \\dbinom{n-j}{k-j} \\tag{10}$$ 证明显然。 组合恒等式 IV $$\\begin{align} \\sum\\limits_{i=m}^n \\dbinom{i}{m} &amp;= \\dbinom{n+1}{m+1} \\tag{11} \\newline\\sum\\limits_{i=0}^n \\dbinom{m+i}{m} &amp;= \\dbinom{n+m+1}{n} \\tag{12} \\end{align}$$ 证明显然。 组合恒等式 V $$ \\dbinom{n+m}{k}= \\sum\\limits_{i=0}^k \\dbinom{n}{i}\\dbinom{m}{k-i} \\tag{13}$$ 证明显然。 $(8),(9),(10),(11),(12),(13)$ 式通常被称作 组合恒等式。 2.4 二项式反演 形式 I $$ f(n) = \\sum\\limits_{k=0}^n (-1)^k\\dbinom{n}{k} g(k) \\Leftrightarrow g(n) = \\sum\\limits_{k=0}^n (-1)^k \\dbinom{n}{k} f(k) \\tag{14} $$ 形式 II $$ f(n) = \\sum\\limits_{k=0}^n\\dbinom{n}{k} g(k) \\Leftrightarrow g(n) = \\sum\\limits_{k=0}^n (-1)^{n-k} \\dbinom{n}{k} f(k) \\tag{15} $$ 形式 III $$ f(n) = \\sum\\limits_{k=n}^m\\dbinom{k}{n} g(k) \\Leftrightarrow g(n) = \\sum\\limits_{k=n}^m (-1)^{k-n} \\dbinom{k}{n} f(k) \\tag{16} $$ $(14),(15),(16)$ 式被称作 二项式反演公式。 2.5 第二类 Stirling 数通项对 $(2)$ 式应用 $(15)$ 式得： $$ \\begin{Bmatrix}n\\newline m \\end{Bmatrix}m! = \\sum\\limits_{k=0}^m (-1)^k \\dbinom{m}{k} (m-k)^n \\tag{17} $$ 其中 $(17)$ 式被称为 第二类 Stirling 数通项公式。 3 应用「bzoj2839」集合计数「bzoj3622」已经没有什么好害怕的了「CF932E」 Team Work「2018 雅礼集训」方阵「TJOI / HEOI2016」求和「LOJ #6716.」 自然数幂之和「2020联考A卷」组合数问题「各种数数题」… 最近更新： 2020.8.9","link":"/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/"},{"title":"背包","text":"DP经典模型。 一 01背包$ d_{i,j} $表示将 i 个物品放在容量为 j 的背包中，所得到的最大价值。 动归方程:$$ d_{i,j} =\\max d_{i-1,j} , d_{i-1,j-v_i} + c_i $$ DP实现 123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int V,N,d[101][1001],v[101],c[101];//V为背包容积，N为物品数量，v_i为物品i的体积，c_i为物品i的价值int main(){ scanf(\"%d%d\",&amp;V,&amp;N); for(int i=1;i&lt;=N;i++) scanf(\"%d%d\",&amp;v[i],&amp;c[i]); for(int i=1;i&lt;=N;i++) for(int j=V;j&gt;=1;j--)//从V倒推，保证一件物品不会被装多次(例:两次分别为:d[i][V-v[i]]一次，d[i][V-v[i]-1]一次) if(v[i]&lt;=j) d[i][j]=max(d[i-1][j],d[i-1][j-v[i]]+c[i]);//若装得下物品i，判断是否装它 else d[i][j]=d[i-1][j];//若装不下，直接按体积为j的箱子装i-1件物品算 printf(\"%d\",d[N][V]); return 0;} 还可以进行的剪枝 1234for(int i=1;i&lt;=N;i++) for(int j=V;j&gt;=v[i];j--)//保证装得下物品i d[i][j]=max(d[i-1][j],d[i-1][j-v[i]]+c[i]);//判断是否装它printf(\"%d\",d[N][V]); 二 完全背包1 何为完全背包完全背包即为在 $V$ 的空间内，已知 $N$ 件物品的价值 $c_i$ 和重量 $v_i$ ,求此空间能装下的最大价值。但是与0-1背包不同的是，完全背包问题中的物品是取之不尽的，那么，问题来了： 2 完全背包和0-1背包代码区别在哪里看转移方程： 12f[i][j]=max(f[i][j], f[i-1][j-v[i]]+c[i]) //0-1背包f[i][j]=max(f[i][j], f[i][j-v[i]]+c[i] //完全背包 因为完全背包中一个物品可能会被装很多次，所以即使在状态$ i , j $也要把第$ i $件物品考虑进去 而0-1背包则不需要，也就是说在状态$ i , j $只考虑前$ i-1 $件物品 也正是因为完全背包的这个特性，你**只能正序遍历 $j$ **(因为状态是从前面向后面转移) 3 DP实现动规方程:$$ d_{i,j}=\\max d_{i,j-v_i}+c_i $$ 其中， $ d_{i,j} $表示将 $i$ 个物品放在容量为 $j$ 的背包中，所得到的最大价值 。 123456789101112131415#include&lt;cstdio&gt;#include&lt;iostream&gt;#define max(a,b) a&gt;b?a:busing namespace std;int V,N,d[10001][10001],c[10001],v[10001];int main(){ scanf(\"%d%d\",&amp;V,&amp;N); for(int i=1;i&lt;=N;i++) scanf(\"%d%d\",&amp;c[i],&amp;v[i]); for(int i=1;i&lt;=N;i++) for(int j=v[i];j&lt;=V;j++)//从v[i]开始，保证装得下 d[i][j]=max(d[i-1][j],d[i][j-v[i]]+c[i]); printf(\"%d\",d[N][V]);//最优解为,d[N][V] return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/01/29/%E8%83%8C%E5%8C%85/"},{"title":"迭代加深搜索","text":"迭代加深搜索（Iterative Deepening Depth First Search,IDDFS），是朴素深度优先搜索（Depth First Search,DFS）的一种改进。它的核心思想是：控制当前搜索的深度上限$mxd$，初始化为$1$并令其不断递增，在这个深度限制上进行DFS…… 一 引入1 概念迭代加深搜索（Iterative Deepening Depth First Search,IDDFS），是朴素深度优先搜索（Depth First Search,DFS）的一种改进。它的核心思想是：控制当前搜索的深度上限$mxd$，初始化为$1$并令其不断递增，在这个深度限制上进行DFS。 2 优势迭代加深搜索是状态空间搜索（即隐式图的搜素）中比较常用的搜索方式之一，适用于解决搜索树（即状态树）的深度的广度看似都没有明显上限的状态空间搜索问题。与其类似的算法还有IDA*（Iterative Deepening A-Star）算法，在状态空间搜索问题中也比较常用。 最常见的两种搜索方式（或称搜索顺序）即是深度优先搜索和广度优先搜索（Breadth First Search），前者优先遍历当前节点的一棵子树，后者优先遍历当前节点的所有子节点。但是如果有一棵看似非常庞大的搜索树，如下图（请把它想得再庞大一点），这两种搜索方式劣势明显。如图，无论使用DFS还是BFS，从初始状态到达目标状态都要消耗不少的时间，因为该搜索树无论在深度上还是在广度上都是看似无限大的（请人为脑补）。 但是目标状态只有一个且是确定的。这时不妨先控制每次DFS的深度，并且通过最大深度对当前所有子状态进行可行性剪枝，也就是限制广度，那么我们只需要花费一定的时间就可以到达目标状态。如下图，即是IDDFS的搜索方法。注意在DFS的深度扩大的同时，广度也是在不断扩大的。 二 应用 例 UVa12558埃及分数在古埃及，人们用若干单位分数（形如1/a，a是有理数）的和表示一切有理数。例如，2/3=1/2+1/6，但不允许2/3=1/3+1/3，因为加数不允许相同。对于一个分数a/b，有多种表示方法，其中加数少的比加数多的好，若加数个数相同，则最小的分数越大越好。例如，19/45=1/5+1/6+1/18是最优方案。输入整数a/b，计算最佳表达式，加数从大到小排列。 1 分析此题显然可以用搜索来解决，但是它的解答树是及其庞大的。你既无法预估它的深度（加数个数），也无法预估当前深度下解答树的广度（加数大小）。此时只能通过IDDFS来求解。 2 思路设当前最大深度限制为$mxd$，定义DFS函数为$\\text{dfs}(d,c,a,b)$，其中$d$为当前深度，$a/b$为当前剩余的分数，$c$为满足$1/c \\leqslant a/b$的最小$c$。DFS的流程如下： 123456789检查是否到达深度限制T -&gt; 检查剩余分数(a/b)是否为埃及分数，并返回true/falseF -&gt; 1. 确定c的值，并循环i : from c to INFTY 2. 检查1/i*(mxd-d+1)&lt;=a/b（可行性剪枝），若否，跳出循环 3. 计算新的剩余分数(a/b-1/i)，向下一层递归 4. 检查递归结果，若为ture，跳出循环并返回ture 5. repeat 1. fin. 循环结束，返回false 3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;#define LL long longconst int CN = 1e5+5;int t;LL gcd(LL a,LL b){ //最大公约数 return b ? gcd(b,a%b):a;}//IDDFSint mxd;LL ans[CN],cur[CN];/*返回getfirst(a,b)=c,使得1/c&lt;=a/b且c的值最大*/LL getfirst(LL a,LL b){ if(b % a) return (b/a)+1; return b/a;}/*检查当前的到的答案和之前得到的答案那个更优*/bool better(int pos){ for(int i=pos;i;i--) if(cur[i] != ans[i]) return ans[i]==-1 || cur[i]&lt;ans[i]; return false;}/*把f数组赋值到t中，长度为sz*/inline void copy(LL* f,LL* t,int sz){ for(int i=1;i&lt;=sz;i++) t[i] = f[i];}/*当前深度d 当前分数1/c 剩余分数a/b*/bool dfs(int d,LL c,LL a,LL b){ if(d == mxd){ //最后一个分数是1/(a/b)，即b/a if(b%a) return false; //检查它是不是埃及分数 cur[d] = b/a; //记录答案 if(better(d)) copy(cur,ans,d); //维护答案 return true; } bool flag = false; c = max(c, getfirst(a,b)); //找到c值 for(LL i=c;;i++){ //枚举 if((mxd-d+1)*b &lt;= a*i) break; //可行性剪枝 cur[d] = i; //记录答案 /*计算a/b - 1/i = a1/b1*/ LL a1 = a*i-b,b1 = b*i； LL g = gcd(a1,b1); //便于约分 if(dfs(d+1,i+1, a1/g, b1/g)) flag = true; } return flag;}int main(){ ... //scan bool found = false; for(mxd=1; !found; mxd++){ //主求解代码 memset(ans,-1,sizeof(ans)); found = dfs(0,getfirst(fa,fb),fa,fb); } ... //print return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/06/25/%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2/"},{"title":"逆元","text":"若有$a\\times b \\equiv 1(\\text{mod } m)$，则称$b$是$a$在模$m$意义下的逆元…… 一 引入1 定义若有$a\\times b \\equiv 1(\\text{mod } m)$，则称$b$是$a$在模$m$意义下的逆元（inv）。逆元只在取模意义下是有意义的，因此逆元应该小于模数（虽然大于模数对上面的同余方程成立并没有影响）。 2 应用若要求$(a\\div b) \\text{ mod } m$，直接计算会遇到精度问题。 设$c$是$b$的逆元，因为存在$cb\\equiv 1(\\text{mod }m)$，故$\\dfrac{a}{b} \\equiv \\dfrac{a}{b}\\times 1 \\equiv \\dfrac{a·b·c}{b}( \\text{mod } m)$。故可知$a\\div b\\equiv ac( \\text{mod } m)$。 这样计算就避免了精度问题。 二 逆元的求法1 费马小定理 费马小定理：对于整数$a$和质数$p$，若$a,p$互质，则总存在$a^{p-1} \\equiv 1(\\text{mod }p)$ 于是不难发现：若要求$a$在模$p$意义下的逆元，且$p$是质数时，一定有 $a^{p-1} \\equiv a\\times a^{p-2} \\equiv 1 (\\text{mod m})$。故当$p$是质数且$a,p$互质时，$a$在模$p$意义下的逆元为$a^{p-2}$。 用快速幂取模运算$a^{p-2}$就好了。 代码： 1234567891011121314#define LL long longLL QuickPow(LL a,LL b,int m){ //快速幂取模 (a^b)%m LL base = a%m,rec = 1; while(b){ if(b &amp; 1) (rec *= base) %= m; (base *= base) %= m; b &gt;&gt;= 1; } return rec;}LL QueryInv(LL x,int m){ //求x在mod m意义下的逆元 return QuickPow(x,m-2,m);} 2 扩展欧几里得当$a,m$不互质时呢。此时需要解一个单变元模线性方程$ab\\equiv 1(\\text{mod } m)$，具体解法在后面的博文里面会提到，这里只给出代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344LL a,m;LL gcd(LL a,LL b){ return b ? gcd(b,a%b):a;}//用ExGcd求不定方程 ax+by = c的一组特解(x0,y0)//通解: x=x0+i*kx,y=y0-i*ky (i = 0,±1, ±2, ...)void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(!b){ x = 1; y = 0; return; } _exgcd(b,a%b,x,y); int t = x; x = y; y = t-(a/b)*y;}bool ExGcd(LL a,LL b,LL c,LL &amp;x,LL &amp;y,LL &amp;kx,LL &amp;ky){ LL g = gcd(a,b); if(c % g) return false; //无解 _exgcd(a,b,x,y); LL kc = c/g; x *= kc; y *= kc; kx = b/g; ky = a/g; return true;} //求模线性方程 ax ≡ b(mod m)的最小非负整数解x0//化成ax-my = b //通解x = x0+i*k bool LineModEqu(LL a,LL b,LL m,LL &amp;x,LL&amp; k){ LL y,kx,ky; if(!ExGcd(a,m,b,x,y,kx,ky)) return false; k = kx; x %= k; x = (x+k)%k; //取非负整数 return true;}//求a的逆元b ab ≡ 1(mod m)LL inv(LL a,LL m){ LL b,k; if(!LineModEqu(a,1,m,b,k)) return -1; return b;} 3 线性递推求逆元若要求$[1,n]$内所有的数在模$m$意义下的逆元，显然可以求$n$次快速幂取模，复杂度$O(nlog_2 n)$。那么有没有办法可以在$O(n)$的时间内求出所有的逆元呢？ 首先一定有$\\text{inv}[1]=1$恒成立，那么就可以用到下面这个递推式：$$\\text{inv}[i] = (m-\\lfloor\\dfrac{m}{i}\\rfloor)\\times \\text{inv}[m\\text{ mod }i]\\text{ }\\text{ }(\\text{mod }m)$$ 推导：设$a = \\lfloor\\dfrac{m}{i}\\rfloor,b= m\\text{ mod }i$，则有$m = a\\times i +b$由$m = a\\times i +b \\Rightarrow ai+b \\equiv 0(\\text{mod }m)\\Rightarrow b\\equiv -ai(\\text{mod }m)$同余号两边同除以$i\\times b$，得$-a\\div b \\equiv 1\\div i (\\text{mod }m)$ 引入$b$的逆元$\\text{inv}[b]$和$i$的逆元$\\text{inv}[i]$，得 $-a\\times\\text{inv}[b] \\equiv \\text{inv}[i]$ $(\\text{mod }m)$代入$a = \\lfloor\\dfrac{m}{i}\\rfloor,b= m\\text{ mod }i$，得 $-\\lfloor\\dfrac{m}{i}\\rfloor·\\text{inv}[m\\text{ mod }i] \\equiv \\text{inv}[i]$ $(\\text{mod }m)$ 又因$m\\equiv 0(\\text{mod }m)$，故$m-\\lfloor\\dfrac{m}{i}\\rfloor\\equiv -\\lfloor\\dfrac{m}{i}\\rfloor (\\text{mod }m)$。所以有$\\text{inv}[i] = (m-\\lfloor\\dfrac{m}{i}\\rfloor)\\times \\text{inv}[m\\text{ mod }i] \\text{ }\\text{ }(\\text{mod }m)$。 为什么不用$-\\lfloor\\dfrac{m}{i}\\rfloor$ ，而用$(m-\\lfloor\\dfrac{m}{i}\\rfloor)$ 呢？因为$-\\lfloor\\dfrac{m}{i}\\rfloor &lt; 0$，那么求出来的逆元也可能是个负数，而我们规定逆元总为正数。 代码： 12345678int n,p;int inv[CN];n = read(); p = read(); inv[1] = 1; for(int i=2;i&lt;=n;i++) inv[i] = (LL)(p-p/i)*inv[p%i]%p; $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/18/%E9%80%86%E5%85%83/"},{"title":"随机博文封面","text":"最近找博文封面难找，于是从unsplash.com上搞到一堆图片。unsplash在天朝的访问速度真是不敢恭维，于是搞到了自己的图床上，留着做封面使…… 每次刷新页面图片自动更新。 长方形封面信息尺寸：700x400张数：共20张来源：unsplash.com调用地址：https://www.big-news.cn/thumbnail/pic.php 源码markdown 1![](https://www.big-news.cn/thumbnail/pic.php) html 1&lt;img src=\"https://www.big-news.cn/thumbnail/pic.php\"&gt; 图片一览 正方形封面信息尺寸：700x700张数：共6张来源：unsplash.com调用地址：https://www.big-news.cn/sthumbnail/pic.php 源码markdown 1![](https://www.big-news.cn/sthumbnail/pic.php) html 1&lt;img src=\"https://www.big-news.cn/sthumbnail/pic.php\"&gt; 图片一览","link":"/2019/08/10/%E9%9A%8F%E6%9C%BA%E5%8D%9A%E6%96%87%E5%B0%81%E9%9D%A2/"},{"title":"强连通分量","text":"Tarjan陪伴强连通分量，生成树完成后思路才闪光。Euler跑过的七桥古塘，让你，心驰神往…… 此页面存在相关页面。关于双连通分量，请参见「双连通分量」。 封面图来自unsplash.com。 一 定义1 强连通在有向图 $ G $ 中，选出 $ n $ 个点，使得这些点两两可达，则称这些点强连通。 有向图 $ G $ 上强连通的的顶点，被称为 $ G $ 的强连通子图。显然，一个有向环上的点一定是强连通的（或说强连通子图中一定存在一个环）。 若 $ G $ 整体强连通，则称 $ G $ 为一个强连通图。 2 强连通分量在非强连通图 $ G’ $ 中，极大强连通子图称为 $ G’ $ 的强连通分量（Strongly Connected Components，SCC）。注意极大的概念，它强调相对于自身无法继续扩大。 如下图，SCC有 $ \\begin{Bmatrix}1,2,3,4\\end{Bmatrix} $ ， $ \\begin{Bmatrix}5\\end{Bmatrix} $ 和 $ \\begin{Bmatrix}6\\end{Bmatrix} $ 。其中强连通子图还有 $ \\begin{Bmatrix}1,3,4\\end{Bmatrix} $ ，但是它不“极大”（因为它还可以扩大为 $ \\begin{Bmatrix}1,2,3,4\\end{Bmatrix} $ ），所以不是SCC。 二 Tarjan算法 Robert Tarjan（1984~），美帝人，计算机科学家，以LCA、强连通分量等算法闻名。 1 dfs树学习tarjan的玄学算法，我们首先要了解dfs树，即把一张有向连通图转化为一棵搜索树。 树上的一些定义： $ \\text{dfn} $ （dfs number）：结点第一次被访问的时间（起点为 $ 1 $ ，每次搜索 $ +1 $ ） $ \\text{low} $ ：结点所能到达的最小 $ \\text{dfn} $ 值 树边：dfs树上应有的边，又父节点指向子节点 返祖边：dfs树上不应有的边，且该边由子辈节点指向父辈节点（注意这里不一定是父子节点） 横叉边：dfs树上不应有的边，且该边连接的两个点无父子辈关系（注意横叉边一定由 $ \\text{dfn} $ 值大的节点指向 $ \\text{dfn} $ 值小的节点，否则它是树边） 上图的dfs树，以 $ 1 $ 为起点。图中 $ 5 $ 节点的 $ \\text{low} $ 值为 $ 5 $ 而不是 $ 4 $ ，是因为横插边 $ (5,6) $ 会被忽略，下面会讲。 2 处理思路SCC中一定存在若干个环，那么我们可以通过找环来判断是否找到了SCC。 2-1 怎么判断环的有无当存在一个节点 $ u $ ，使得 $ \\text{dfn}[u] = \\text{low}[u] $ 时，那么就发现了一个环。从定义看，这代表从当前节点出发能到达的最早的祖先是当前节点，也就是说递归“绕回来了”，那么就一定存在环。这个环也包括自环，这需要默认每个节点初始状态下都存在自环，即初始化 $ \\text{low}[u] = \\text{dfn}[u] $ 。 那么剩下的问题就是怎么计算 $ \\text{low}[u] $ 。假设存在边 $ (u,v) $ ，那么这条边有以下三种可能。 边 $ (u,v) $ 为树边。那么向下dfs节点 $ v $ ， $ \\text{low}[u] $ 可由 $ \\text{low}[v] $ 推得，即 $ \\text{low}[u] = \\text{low}[v] $ 。 边 $ (u,v) $ 为返祖边。根据 $ \\text{low} $ 的定义，直接更新 $ \\text{low}[u] $ ，即 $ \\text{low}[u] = \\text{dfn}[v] $ 。此处也可以直接令 $ \\text{low}[u] = \\text{low}[v] $ ，因为 $ v $ 能到达的的祖先也可以被 $ u $ 到达，通过多条返祖边即可。 边 $ (u,v) $ 为横叉边。此时分情况处理，详见二.2-3。 2-2 怎么维护SCC判环只能发现SCC，我们还需要维护SCC中的节点。 考虑用一个栈（stack）来实现。每次深搜时，把节点的编号入栈。回溯时，仅当某节点处出现环，且子树都检索完毕（也就是说子树中所有不在环上的点都已经 入/出栈 完成），此时出栈至该节点为止。那么此时该节点以上的所有栈内元素均可以互达，均在一个环上，均属同一个SCC。 2-3 怎么处理横叉边假设当前节点为 $ u $ ，有一条到 $ v $ 的横叉边 $ (u,v) $ 。如果从 $ v $ 处出发，能直接或间接地到达 $ u,v $ 的公共祖先（不一定最近），那么这条横叉边应该被重视，因为这样就会出现环。反之，这条横叉边就应该被忽略。 假设存在一条返祖边 $ (v,a) $ ， $ a $ 为 $ v $ 能回到的最远祖先。那么当 $ u $ 在以 $ a $ 为根的子树中时，横叉边被重视，反之被忽略。 再看上述维护方法：当 $ u $ 不在以 $ a $ 为根的子树中，当检索到 $ u $ 时，因为横叉边一定从后访问的节点指向先访问的节点，那么 $ v $ 一定被检索过。 $ a $ 是 $ v $ 的祖先，那么子树 $ a $ 一定已经检索完成。因为存在返祖边 $ (v,a) $ ，所以此时存在从 $ a $ 出发的环，那么子树 $ a $ 必然已经出栈，此时 $ v $ 不在栈内。 同理可知，若 $ u $ 在以 $ a $ 为根的子树中，则此时 $ v $ 一定在栈内。于是我们可以知道，当且仅当 $ v $ 在栈内时，横叉边 $ (u,v) $ 应被重视，需要更新 $ \\text{low}[u] = \\text{low}[v] $ ，回答了上文二.2-1中留下的问题。 3 流程手推对于上图的 tarjan 算法。代码见二.4。 Step 1扫描到节点 $ 1 $ ，节点入栈。 cde 1 2 3 4 5 6 dfn 1 n/a n/a n/a n/a n/a low 1 n/a n/a n/a n/a n/a stack 1 Step 2访问边 $ (1,2) $ ，扫描到节点 $ 2 $ ，节点入栈。 cde 1 2 3 4 5 6 dfn 1 2 n/a n/a n/a n/a low 1 2 n/a n/a n/a n/a stack 1 2 Step 3访问边 $ (2,4) $ ，扫描到节点 $ 4 $ ，节点入栈。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 n/a n/a low 1 2 n/a 3 n/a n/a stack 1 2 4 Step 4访问边 $ (4,6) $ ，扫描到节点 $ 6 $ ，节点入栈。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 n/a 4 low 1 2 n/a 3 n/a 4 stack 1 2 4 6 Step 5节点 $ 6 $ 无出度，且存在自环（ $ dfn[6]=low[6] $ ），出栈至节点 $ 6 $ ，回溯至节点 $ 4 $ 。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 n/a 4 low 1 2 n/a 3 n/a 4 stack 1 2 4 发现强连通分量 $ {6} $ Step 6发现返祖边 $ (4,1) $ ，更新 $ 4 $ 的 $ \\text{low} $ 值，不出栈并回溯至节点 $ 2 $ 。 $ 2 $ 的 $ \\text{low} $ 值更新。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 n/a 4 low 1 1 n/a 1 n/a 4 stack 1 2 4 Step 7发现边 $ (2,5) $ ，扫描至节点 $ 5 $ ，入栈。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 5 4 low 1 1 n/a 1 5 4 stack 1 2 4 5 Step 8发现横叉边 $ (5,6) $ ，此时 $ 6 $ 不在栈内，忽略该横叉边。出栈至节点 $ 5 $ ，回溯至节点 $ 2 $ 。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 5 4 low 1 1 n/a 1 5 4 stack 1 2 4 发现强连通分量 $ {5} $ Step 9回溯至节点 $ 1 $ ，扫描边 $ (1,3) $ ，节点 $ 3 $ 入栈。 cde 1 2 3 4 5 6 dfn 1 2 6 3 5 4 low 1 1 6 1 5 4 stack 1 2 4 3 Step 10发现横叉边 $ (3,4) $ ，此时 $ 4 $ 在栈内，用 $ 4 $ 的 $ \\text{low} $ 值更新 $ 3 $ 的 $ \\text{low} $ 值。 cde 1 2 3 4 5 6 dfn 1 2 6 3 5 4 low 1 1 1 1 5 4 stack 1 2 4 3 Final回溯至节点 $ 1 $ ，出栈至栈空，算法结束。 cde 1 2 3 4 5 6 dfn 1 2 6 3 5 4 low 1 1 1 1 5 4 stack 发现强连通分量 $ {1,2,3,4} $ 4 代码实现1234567891011121314151617181920212223242526272829303132const int CP=1e3+3;int dfn[CP],low[CP],idx=0,stk[CP],top=0;bool ins[CP]; // 是否在栈中int ans=0;void tarjan(int cur){ dfn[cur] = low[cur] = ++idx; //设置初始值 stk[++top] = cur; ins[cur] = true; //节点入栈 for(int k=hd[cur]; k; k=E[k].nxt){ //遍历边表 int to=E[k].to; //边的终点 if(!dfn[to]){ //未被访问，说明这是树边 tarjan(to); //深搜 low[cur] = min(low[cur], low[to]); } else if(ins[to]) //已经访问且在栈内，说明这是返祖边或需要重视的横叉边 low[cur] = min(low[cur], low[to]); //此处写成low[cur] = min(low[cur], dfn[to])也没有问题 } if(dfn[cur] == low[cur]){ //发现环 ans++; //计数 while(true){ int pos=stk[top--]; ins[pos] = false; //标记去除 if(pos == cur) break; //出栈至当前节点 } }}void scc(){ //主求解函数 for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);} 三 缩点1 模型给定一张有向图 $ G_0 $ ，不保证无环，图上的节点有点权（正权，注意无法处理负环），要求找一条从起点到终点的路径，使得经过节点的点权和存在最大值。对于每条边，可以走多次。对于每个节点，点权仅计算一次。 怎么解决呢？ 先考虑无环时的情况，那么只需要一遍DP（记忆化搜索）就可以解决问题。再考虑环。对于任意一个环，如果走这个环，那么一定要全走才能获得最大价值，也就是一条环的价值可以被看作一个点的价值。一条环一定是强连通的，那么我们只需要求出 $ G_0 $ 的所有的强连通子图，分别统计它们的点权（累加环上点权和），并重新建图连边。于是我们会得到一个有向无环图（Directed Acyclic Graph，DAG）。借用无环时的解决方案即可解决问题。 2 代码实现边表 123456789101112131415class fs{ public: int to,nxt;}E[CON];int hd[CON],cnt=0;void E_add(int x,int y){ E[++cnt].to=y; E[cnt].nxt=hd[x]; hd[x]=cnt;}void E_init(){ memset(hd,0,sizeof(hd)); memset(E,0,sizeof(E)); cnt=0;} 算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int dfn[CON],low[CON],idx=0,stk[CON],top=0,belong[CON];bool ins[CON];void tarjan(int cur){ dfn[cur] = low[cur] = ++idx; stk[++top] = cur; ins[cur] = true; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]){ tarjan(to); low[cur] = min(low[cur], low[to]); } else if(ins[to]) low[cur] = min(low[cur], low[to]); } if(dfn[cur] == low[cur]){ //出现环，则定义cur为当前环的根（因为它先被扫描到） int sum=0; while(true){ int pos = stk[top--]; ins[pos] = false; sum += c[pos]; c[pos] = 0; //这样不是根的节点c值一定为0 belong[pos] = cur; //染色，即记录环的根 if(pos==cur) break; } c[cur] = sum; //将环上点的权值累加入根的权值 }}void scc(){ //主求解函数 for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);}//dpint f[CON]; //f[i]为从i出发的最优解 int dp(int cur){ //记忆化搜索 if(f[cur]) return f[cur]; f[cur] = c[cur]; //初始化 for(int k=hd[cur]; k; k=E[k].nxt) f[cur] = max(f[cur], dp(E[k].to)+c[cur]); //转移方程 return f[cur];//返回解}int solve(){ E_init(); //边表初始化 for(int i=1;i&lt;=m;i++) if(belong[x[i]] != belong[y[i]]) //不在一个环上，避免连出自环边 E_add(belong[x[i]], belong[y[i]]); //将两个强连通子图的根连边。原图中x[i]-&gt;y[i]存在边 int ans=0; for(int i=1;i&lt;=n;i++) //枚举起点 if(c[i]) ans=max(ans, dp(i)); //是根，更新答案 return ans;} 3 推论 设一有向联通图缩点后得到图 $ G’ $ ，且在 $ G’ $ 中，入度为 $ 0 $ 的点（DAG的起点）有 $ x $ 个，出度为 $ 0 $ 的点（DAG的终点）有 $ y $ 个。 图 $ G’ $ 必为一个DAG。 选出最少的点，使得从这些点出发，可以到达整个图。则这个最小值一定为 $ x $ 。（必要性：不从起点出发那么起点永远无法到达。 最优性：考虑任意一个非起点的点，从它出发一定比从它的起点出发覆盖的节点少。） 选出最少的点，使得从任意点出发，可以到达这些点。则这个最小值一定为 $ y $ 。（必要性：终点本身无法到达任何点，那么不选中终点显然是不合法的。 最优性：终点既然必定选中，且选中所有终点一定合法，那么不需要再选中其它点。） 添加最少的边，使得 $ G’ $ 成为一个强连通图，则这个最小值一定为 $ \\max x,y $ 。（考虑终点向起点对应连边。） $$ - - - - \\mathcal{End} - - - - $$ 最近更新： 2019.4.9 梳理了部分不清楚的描述","link":"/2019/02/07/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"title":"OI模板梳理","text":"明天自招考试!花点时间把一些老博客上的一些板子转移过来，顺便也复习一下。不要问我为什么有封面…… 此页面存在相关页面。关于本站的目录，请参见「除夕闲扯」。 图片来自unsplash.com。 一 图论1 最短路1-1 Dijkstra Dijkstra 的贪心策略正确当且仅当图上不存在负权环。 Dijkstra 认为：一个点只会被某些特定的点“松弛”，因为如果从其它点转移，最短路径要么变长，要么不变，而绝不可能变短；Dijkstra 每次在做的是就是找到这样的一个“特定的点”，即当前最短路径长度最小的那个点。 这是一个很贪心的策略，因此其成立是有条件的，即图上没有负权环。注意，一条无向的负权边也是负权环。 堆优化 Dijkstra ： 1234567891011121314151617181920212223242526272829#define LL long longconst int CN = 1e5+5;const LL INF = 0x3f3f3f3f3f3f3f2f;class fs {public: int to,nxt; LL di;} E[CN * 51];int hd[CN];class DJ{ public: int id; LL v; bool operator &lt; (const DJ&amp; a)const {return v &gt; a.v;}};priority_queue&lt;DJ&gt; Q; LL d[CN]; bool vis[CN];LL SP(int s,int t){ memset(vis, 0, sizeof(vis)); memset(d, 0x3f, sizeof(d)); Q.push((DJ){s, d[s] = 0}); while(!Q.empty()){ int u = Q.top().id; Q.pop(); if(vis[u]) continue; vis[u] = true; // 必须在此处标记访问 for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(d[v] &gt; d[u] + E[k].di){ d[v] = d[u] + E[k].di; if(!vis[v]) Q.push((DJ){v, d[v]}); // 不能在此处标记访问，因为先入队时该点不一定达到最优 } } } return d[t] &lt; INF ? d[t] : -1;} 1-2 Floyd12345int f[][];for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) f[i][j] = min(f[i][j], f[i][k]+f[k][j]); 1-3 Bellman-Ford / SPFA Has it dead? 出题人造数据当然要卡 SPFA ，但这也要考虑到历史的行程。众所周知，历史的行程可以被抽象成一串01串…… 123456789101112131415161718192021222324bool ins[CP]; // 是否在队列中int times[CP]; // times[i] : 节点i被松弛的次数int d[CP]; // 保存单源最短路bool spfa(int s){ // 返回有解（true）或无解（false） memset(d,0x3f,sizeof(d)); memset(ins,false,sizeof(ins)); memset(times,0,sizeof(times)); queue&lt;int&gt;Q; Q.push(s); d[s]=0; while(!Q.empty()){ int u=Q.front(); Q.pop(); ins[u]=false; for(int k=hd[u]; k; k=E[k].nxt){ fs e=E[k]; if(d[u]+e.dist &lt; d[e.to]){ // 松弛 d[e.to]=d[u]+e.dist; if(!ins[e.to]){ // 不在队列中就入队 Q.push(e.to); ins[e.to]=true; if(++times[e.to] == n) // 松弛了超过n次，存在负环 return false; } } } } return true;} 2 最小生成树2-1 Kruskal1234567891011121314class edge{...}; class ufs{...}; // 并查集edge E[];ufs s;int mst(){ int cnt=0,cst=0; sort(E+1,E+m+1); for(int k=1; cnt!=n-1 &amp;&amp; k&lt;=m; k++){ // 枚举所有边 if(s.find(E[k].from) == s.find(E[k].to)) continue; s.fa[find(E[k].from)] = s.find(E[k].to); cnt+=1; cst+=E[k].c; } return cst;} 2-2 Prim有点像DJ。 12345678910111213141516171819202122class fs{...}; // 边表fs E[];int dis[]; // dis[i] : 1~i的所有边中边权最小的那一个bool vis[];int prim(){ memset(dis,0x3f,sizeof(dis)); for(re int i=hd[1];i;i=E[i].nxt) dis[E[i].to] = min(dis[E[i].to], E[i].c); int cur=1,cst=0; for(int i=1; i&lt;n; i++){ int mn=INF; vis[cur]=1; for(int i=1;i&lt;=n;++i) // 挑出最小的一个 if(!vis[i] &amp;&amp; mn&gt;dis[i]) mn=dis[cur=i]; cst+=mn; for(re int i=hd[cur]; i ;i=E[i].nxt) // update if(!vis[E[i].to] &amp;&amp; dis[E[i].to]&gt;E[i].c) dis[E[i].to] = E[i].c; } return cst;} 3 并查集123456789const int CN=1e3;class dsu{ public: int fa[CN]; ufs() {for(int i=1;i&lt;CN;i++) fa[i]=i;} int find(int x) {return fa[x]==x ? x : fa[x]=find(fa[x]);} // 找元素所在的树根 bool examine(int x,int y) {return find(x) != find(y);} // 检查x,y可不可以合并 void merge(int x,int y) {fa[find(x)] = find(y);} // 合并x,y两棵树} 其它 以下内容请在本站搜索相应文章。 树链剖分 \\ LCA 树的重心 \\ 树的直径 最大流 \\ 最小费用最大流（二分图相关） 强连通分量（缩点） \\ 双连通分量 倍增LCA 二分图匹配（匈牙利） k 短路问题（A* 寻路，请参阅这篇文章） 二 数论1 素数筛Eratosthenes 筛法，此筛法非严格的线性。有关线性筛，请见另一篇博文。 12345678910111213141516#define LL long longconst int CN = 1e7+7;bool isp[CN]; // 判断素数LL prime[CN]; // 保存素数void GetPrime(LL n){ memset(isp,true,sizeof(isp)); for(LL i=2;i&lt;=n;i++){ if(isp[i]){ prime[++prime[0]] = i; for(int k=2;i*k&lt;=n;k++) isp[i*k] = false; } }} 2 分解质因数试除法，复杂度$O(\\sqrt{x})$。注：一个数的质因数数量是$\\log$级别。 12345678910111213#define LL long longconst int CN = 101;int cnt = 0; long long p[CN],a[CN]; void Div(LL x){ for(LL i = 2; i * i &lt;= x; i++){ if(x % i) continue; p[++cnt] = i; while(!(x % i)) {a[cnt]++; x /= i;} } if(x &gt; 1) p[++cnt] = x,a[cnt] = 1;} 3 高斯-约旦消元1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*解方程组：a1x1 + a2x2 +...+ anxn = s1b1x1 + b2x2 +...+ bnxn = s2...*/#define DB doubleconst int CN = 110;int n;DB a[CN][CN]; /*a[][] : 增广矩阵 a[][n+1] : 储存常数项 */DB dabs(DB x) {return x&lt;0 ? x : -x;} // 绝对值/*高斯 - 约旦消元 :通过加减消元，把原方程组化成k1x1 = v1k2x2 = v2...knxn = vn的形式，再计算 */DB x[CN]; // 保存答案 bool gauss(){ for(int i=1;i&lt;=n;i++){ // 枚举未知数 DB mx = a[i][i]; int p = i; for(int j=i+1;j&lt;=n;j++){ // 挑选未知数x[i]的最大系数 if(dabs(mx) &lt; dabs(a[j][i])) mx = a[p = j][i]; } if(!mx) return false; // 无解 for(int j=1;j&lt;=n+1;j++) // 行、行交换 swap(a[i][j], a[p][j]); /*加减消元*/ for(int j=1;j&lt;=n;j++){ // 枚举方程 if(j == i) continue; for(int k=i+1;k&lt;=n+1;k++){ // 枚举系数 a[j][k] -= a[i][k]*(a[j][i]/a[i][i]); } } } for(int i=1;i&lt;=n;i++) x[i] = a[i][n+1]/a[i][i]; // 保存解 return true; } 4 扩展欧几里得算法扩展欧几里得算法用于求解形如 $ax+by=c$ 的二元不定方程的整数解。根据裴蜀定理，该不定方程有解当且仅当 $(a,b)|c$。容易发现，若 $(x,y)$ 是解，则 $(x+kb, y-ka), k\\in \\mathbb{Z}$ 也是解。 代码： 123456789int gcd(int a, int b) {return b ? gcd(b, a % b) : a;}void exgcd(int a, int &amp;x, int b, int &amp;y){ if(!b) return (void)(x = 1, y = 0); exgcd(b, x, a % b, y); int t = x; x = y, y = t - (a / b) * y;}bool solve(int a, int &amp;x, int b, int &amp;y, int c){ int g = gcd(a, b); if(c % g) return false; return exgcd(a, x, b, y), c /= g, x *= c, y *= c, true;} 5 类欧几里得算法 类欧几里得算法仅适用于处理斜率和截距非负的线段。当斜率为负时，需要通过对称变换使得斜率为正；当截距为负时，需要通过平移坐标轴使截距为正。 求解： $$f(n,A,B,C)=\\sum_{i=0}^n\\left\\lfloor \\frac{Ai+B}{C} \\right\\rfloor$$ 其中满足 $A,B,C \\ge 0$。它的几何意义是：在第一象限内，一条斜率和截距非负的线段下方的整点的数量。 实数版： 12345678#define LL long longLL s2(LL n) {return n * (n + 1) / 2;}LL f(LL n, LL a, LL b, LL c){ if(!a) return (b / c) * (n + 1); if(a &gt;= c || b &gt;= c) return s2(n) * (a / c) + (n + 1) * (b / c) + f(n, a % c, b % c, c); LL m = (a * n + b) / c; return n * m - f(m - 1, c, c - b - 1, a);} 取模版： 123456789#define LL long longconst int P = 998244353;int s2(LL n) {return (n * (n + 1) / 2) % P;}int f(LL n, LL a, LL b, LL c){ if(!a) return (b / c) * (n + 1) % P; if(a &gt;= c || b &gt;= c) return (s2(n) * (a / c) % P + (n + 1) * (b / c) % P + f(n, a % c, b % c, c)) % P; LL m = (a * n + b) / c; return (n * m % P - f(m - 1, c, c - b - 1, a) + P) % P;} 其它 以下内容请在本站搜索相应文章。 矩阵快速幂（矩阵加速递推） lucas（组合数取模） gcd（最大公约数） \\ exgcd（关于其求解不定方程的模板，请参阅CRT&amp;exCRT） 逆元 CRT &amp; exCRT（同余方程组） 三 多项式1 FFT / 快速傅里叶变换12345678910111213141516171819202122232425262728293031const int CN = 1e5+5;const double PI = 3.14159265358;class Comp{ public: double x,y; void init(double xx,double yy){x = xx, y = yy;} Comp operator + (const Comp &amp;a)const {Comp b; b.x = x + a.x; b.y = y + a.y; return b;} Comp operator - (const Comp &amp;a)const {Comp b; b.x = x - a.x; b.y = y - a.y; return b;} Comp operator * (const Comp &amp;a)const {Comp b; b.x = x * a.x - y * a.y; b.y = x * a.y + y * a.x; return b;}};int rev[CN &lt;&lt; 2];void change(Comp *t,int n){ for(int i = 0;i &lt; n;i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (n &gt;&gt; 1); for(int i = 0;i &lt; n;i++) if(i &lt; rev[i]) swap(t[i], t[ rev[i] ]);} void fft(Comp* t,int n,int tp){ change(t, n); for(int l = 2;l &lt;= n;l &lt;&lt;= 1){ // 长度 Comp wn; wn.init(cos(2 * PI / l), sin(2 * tp * PI / l)); for(int i = 0;i &lt; n; i += l){ // 起点 Comp w; w.init(1, 0); for(int j = i;j &lt; i + l / 2;j++){ Comp u = t[j], v = w * t[j + l / 2]; t[j] = u + v; t[j + l / 2] = u - v; w = w * wn; } } } if(tp == -1) for(int i = 0;i &lt; n; i++) t[i].x /= n;} 2 NTT / 快速数论变换1234567891011121314151617181920212223int rev[CN &lt;&lt; 2];void change(int *t,int n){ for(int i = 0;i &lt; n;i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (n &gt;&gt; 1); for(int i = 0;i &lt; n;i++) if(i &lt; rev[i]) swap(t[i], t[ rev[i] ]);} void ntt(int *t,int n,int tp){ int gi = qp(3, P - 2); change(t, n); for(int l = 2;l &lt;= n;l &lt;&lt;= 1){ int gn = qp(tp ? 3 : gi, (P - 1) / l), k = l &gt;&gt; 1; for(int i = 0;i &lt; n;i += l){ int g = 1; for(int j = i;j &lt; i + k;j++){ int u = t[j], v = (1ll * g * t[j + k]) % P; t[j] = (u + v) % P, t[j + k] = (u - v + P) % P; g = (1ll * g * gn) % P; } } } if(!tp){ gi = qp(n, P - 2); for(int i = 0;i &lt; n;i++) t[i] = (1ll * t[i] * gi) % P; }} 3 求逆 / 指对运算123456789101112131415161718192021222324252627282930313233343536373839int c[CN &lt;&lt; 2],lnb[CN &lt;&lt; 2];void inv(int *a,int *b,int n){ for(int i = 0;i &lt; (n &lt;&lt; 1);i++) b[i] = 0; memset(c, 0, sizeof(c)); b[0] = qp(a[0], P - 2); for(int l = 2;l &lt; (n &lt;&lt; 1);l &lt;&lt;= 1){ for(int i = 0;i &lt; l;i++) c[i] = a[i]; ntt(b, l &lt;&lt; 1, 1); ntt(c, l &lt;&lt; 1, 1); for(int i = 0;i &lt; (l &lt;&lt; 1);i++) b[i] = (1ll * b[i] * (2 - 1ll * c[i] * b[i] % P) % P + P) % P; ntt(b, l &lt;&lt; 1, 0); for(int i = l;i &lt; (l &lt;&lt; 1);i++) b[i] = 0; }}void ln(int *a,int *b,int n){ inv(a, b, n); memset(c, 0, sizeof(c)); for(int i = 0;i &lt; n - 1;i++) c[i] = 1ll * (i + 1) * a[i + 1] % P; int l = 1; while(l &lt; (n &lt;&lt; 1)) l &lt;&lt;= 1; ntt(c, l, 1); ntt(b, l, 1); for(int i = 0;i &lt; l;i++) b[i] = 1ll * b[i] * c[i] % P; ntt(b, l, 0); for(int i = n - 1;i;i--){ int in = qp(i, P - 2); b[i] = 1ll * in * b[i - 1] % P; } b[0] = 0; for(int i = n;i &lt; l;i++) b[i] = 0;}void exp(int *a,int *b,int n){ for(int i = 1;i &lt; (n &lt;&lt; 1);i++) b[i] = 0; b[0] = 1; for(int l = 2;l &lt; (n &lt;&lt; 1);l &lt;&lt;= 1){ ln(b, lnb, l); for(int i = 0;i &lt; l;i++) lnb[i] = (a[i] - lnb[i] + P) % P; lnb[0]++; ntt(lnb, l &lt;&lt; 1, 1); ntt(b, l &lt;&lt; 1, 1); for(int i = 0;i &lt; (l &lt;&lt; 1);i++) b[i] = 1ll * b[i] * lnb[i] % P; ntt(b, l &lt;&lt; 1, 0); for(int i = l;i &lt; (l &lt;&lt; 1);i++) b[i] = 0; } for(int i = n;i &lt; (n &lt;&lt; 1);i++) b[i] = 0;} 4 任意模数卷积拆系数fft，细节参考毛啸（myy）的论文。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#define LDB long double#define LL long longconst LDB PI = acos(-1.0); class comp{ public: LDB x, y; void init(LDB xx,LDB yy) {x = xx, y = yy;} comp operator + (comp a) {comp c; c.init(x + a.x, y + a.y); return c;} comp operator - (comp a) {comp c; c.init(x - a.x, y - a.y); return c;} comp operator * (comp a) {comp c; c.init(x * a.x - y * a.y, x * a.y + y * a.x); return c;}};comp conj(comp a) {comp c; c.init(a.x, -a.y); return c;}comp cm(LDB i,LDB j) {comp c; c.init(i, j); return c;}int rev[CN &lt;&lt; 2];void change(comp *t, int n){ for(int i = 0;i &lt; n;i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) * (n &gt;&gt; 1)); for(int i = 0;i &lt; n;i++) if(i &lt; rev[i]) swap(t[i], t[ rev[i] ]);}void fft(comp *t, int n, int tp){ change(t, n); for(int l = 2;l &lt;= n;l &lt;&lt;= 1){ comp wn; wn.init(cos(2 * PI / l), sin(2 * tp * PI / l)); int k = l &gt;&gt; 1; for(int i = 0;i &lt; n;i += l){ comp w; w.init(1, 0); for(int j = i;j &lt; i + k;j++){ comp u = t[j], v = w * t[j + k]; t[j] = u + v; t[j + k] = u - v; w = w * wn; } } } if(tp == -1) for(int i = 0;i &lt; n;i++) t[i].x /= n, t[i].y /= n;}int n,m; LL a[CN],b[CN];comp fa[CN &lt;&lt; 2],fb[CN &lt;&lt; 2],d1[CN &lt;&lt; 2],d2[CN &lt;&lt; 2],d3[CN &lt;&lt; 2],d4[CN &lt;&lt; 2];void conv(){ int l = 1; while(l &lt; (n &lt;&lt; 1) || l &lt; (m &lt;&lt; 1)) l &lt;&lt;= 1; int bit = (1 &lt;&lt; 15) - 1; for(int i = 0;i &lt; n;i++) fa[i].init(a[i] &amp; bit, a[i] &gt;&gt; 15); // r k for(int i = 0;i &lt; m;i++) fb[i].init(b[i] &amp; bit, b[i] &gt;&gt; 15); // _r _k fft(fa, l, 1); fft(fb, l, 1); for(int i = 0;i &lt; l;i++){ int j = (l - 1) &amp; (l - i); comp r,k,_r,_k; r = (fa[i] + conj(fa[j])) * cm(0.5, 0); k = (fa[i] - conj(fa[j])) * cm(0, -0.5); _r = (fb[i] + conj(fb[j])) * cm(0.5, 0); _k = (fb[i] - conj(fb[j])) * cm(0, -0.5); d1[i] = k * _k; d2[i] = _k * r; d3[i] = k * _r; d4[i] = r * _r; } for(int i = 0;i &lt; l;i++) fa[i] = d1[i] + d2[i] * cm(0, 1); for(int i = 0;i &lt; l;i++) fb[i] = d3[i] + d4[i] * cm(0, 1); fft(fa, l, -1); fft(fb, l, -1); for(int i = 0;i &lt; l;i++){ LL A = 1ll * (fa[i].x + 0.5), B = 1ll * (fa[i].y + 0.5), C = 1ll * (fb[i].x + 0.5), D = 1ll * (fb[i].y + 0.5); A = ((A % p) &lt;&lt; 30) % p; B = (((B + C) % p) &lt;&lt; 15) % p; D %= p; a[i] = (A + B + D) % p; }} 四 字符串1 KMP有关 KMP 的总结请参见KMP学习笔记。 12345678910int k = 0; nxt[1] = 0, nxt[0] = -1;for(int i = 2; i &lt;= m; i++){ while(k ^ -1 &amp;&amp; t[k + 1] != t[i]) k = nxt[k]; nxt[i] = (k += 1);}k = 0;for(int i = 1; i &lt;= n; i++){ while(k ^ -1 &amp;&amp; t[k + 1] != s[i]) k = nxt[k]; if((k += 1) == m) printf(\"%d\", i - m + 1), puts(\"\");} 2 ACAM / AC 自动机有关AC自动机的总结请参见KMP学习笔记。 123456789101112131415161718192021const int CN = 1e6 + 6;class ACAM { public: int son[CN][26], fail[CN], e[CN], idx; queue&lt;int&gt; Q; void ins(char *s){ // 建立 tire 结构 int u = 0; for(int i = 0; s[i]; i++){ if(!son[u][ s[i] - 'a' ]) son[u][ s[i] - 'a' ] = ++idx; u = son[u][ s[i] - 'a' ]; } e[u]++; } void bd(){ // 建立 fail 指针 for(int i = 0; i &lt; 26; i++) if(son[0][i]) Q.push( son[0][i] ); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int i = 0; i &lt; 26; i++) if(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]); else son[u][i] = son[ fail[u] ][i]; } }} D; 3 SA / 后缀数组后缀数组通过将后缀按字典序排序来获得一些优美的性质。 123456789101112131415161718192021222324252627int rk[CN &lt;&lt; 1], prk[CN &lt;&lt; 1], px[CN], id[CN], sa[CN], cnt[CN];/* rk[ ] 是某种重标号，从旧下标映射到某个新的标号，类似于离散化 */void SufSort(){ int m = max(n, 300); for(int i = 1;i &lt;= n;i++) rk[i] = s[i - 1]; for(int i = 1;i &lt;= n;i++) cnt[ rk[i] ]++; for(int i = 1;i &lt;= m;i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ rk[i] ]-- ] = i; for(int w = 1; w &lt; n; w &lt;&lt;= 1){ memset(cnt, 0, sizeof(cnt)); for(int i = 1;i &lt;= n;i++) id[i] = sa[i]; for(int i = 1;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] + w ] ]++; for(int i = 1;i &lt;= m;i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i]; memset(cnt, 0, sizeof(cnt)); for(int i = 1;i &lt;= n;i++) id[i] = sa[i]; for(int i = 1;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] ] ]++; for(int i = 1;i &lt;= m;i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i]; memcpy(prk, rk, sizeof(rk)); m = 0; for(int i = 1;i &lt;= n;i++) rk[ sa[i] ] = prk[ sa[i] ] == prk[ sa[i - 1] ] &amp;&amp; prk[ sa[i] + w ] == prk[ sa[i - 1] + w ] ? m : ++m; if(n == m) break; // menci tql }} 4 SAM / 后缀自动机后缀自动机可以将字符串的每一个子串双射在有向单词无环图（DAWG）上，从而获得一系列优美的性质。 1234567891011121314151617const int CN = 1e6 + 6;class SAM{ public: int len[CN &lt;&lt; 1], nxt[CN &lt;&lt; 1], last, sz; int son[CN &lt;&lt; 1][26]; SAM() {memset(son, 0, sizeof(son)), len[0] = 0, nxt[0] = -1, sz = 1, last = 0;} void extend(int c){ int u = sz++, p = last; last = u, len[u] = len[p] + 1; while(p != -1 &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p]; if(p == -1) return (void)(nxt[u] = 0); int d = son[p][c]; if(len[d] == len[p] + 1) return (void)(nxt[u] = d); int v = sz++; len[v] = len[p] + 1, nxt[v] = nxt[d], nxt[u] = nxt[d] = v; memcpy(son[v], son[d], sizeof(son[d])); while(p != -1 &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p]; }}; 5 Manacher众所周知，Manacher 是一种优雅的暴力。 123456789101112cin &gt;&gt; (s + 1); n = strlen(s + 1); c[0] = '$', c[1] = '#';for(int i = 1; i &lt;= n; i++) c[i &lt;&lt; 1] = s[i], c[i &lt;&lt; 1 | 1] = '#';n = n &lt;&lt; 1 | 1, c[n + 1] = '.';int k, i0 = 1; r[1] = 1;for(int i = 2; i &lt;= n; i++){ k = min(i0 + r[i0] - i, r[(i0 &lt;&lt; 1) - i]); while(c[i + k] == c[i - k]) k++; r[i] = k; if(i + r[i] &gt; i0 + r[i0]) i0 = i;} 最近更新： 2020.9.1 添加了字符串算法。","link":"/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/"},{"title":"「杂题选做」八月口胡合集","text":"众所周知，做题的关键在于口胡出解法，而我还是什么都不会…… 本篇 Blog 多以口胡为主，杂题居多。 1 Hunger Game 有 $N$ 个箱子，每个箱子有 $a[i]$ 个石头，一开始所有箱子都是关着的。Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。不能操作的输，求先手必胜还是后手必胜。$1\\le N\\le 1e5, 0\\le a[i]&lt;10^9$ Nim 博弈的经典结论：对于每个状态有 $SG_i=a_i$ ，则终态是 P 态的充要条件是 $a_1\\oplus a_2\\oplus … \\oplus a_n = 0$。 回到本题，如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。 因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。 2 Minimum Value of Equation 给定 $k[i],b[i]$，有 $n$ 个函数，第 $j$ 个函数为 $f_j(x)=\\sum |k[i]x+b[i]|$，其中$1\\le i\\le j$。对于每个 $j=1…n$，求出 $f_j(x)$ 的最小值。$1\\le n\\le 10^5 , |k[i]|\\le 1000$ 提一下公因式变成 $\\sum k_i|x+(b_i/k_i)|$ ，即 $x$ 到数轴上的一堆点 $b_i/k_i$ 的距离和，那么 $x$ 取这些点的中位数就好了。 3 DFS Count 给定一个 $n$ 个点的有向图，求合法的 DFS 序的个数。$n \\le 13$ 直接搜？？？（雾设 $f[u,S]$ 表示当前在 $u$ ，没走过的点集为 $S$ 的方案数。$|S|$ 是递减的，可通过其来划分子问题，得到转移：$$ f[v,T_v \\And S]·f[u,S-(T_v \\And S)] \\to f[u, S] | (u,v)\\in E$$其中 $T_v$ 是 $v$ 能到达的点集。容易发现这次从小集合往大集合转移，则其是可操作的。 4 XOR Product 给定序列 $a_1,…,a_n$ ，求：$$ \\sum\\limits_{i&lt;j&lt;k}(a_i\\oplus a_j)·(a_j \\oplus a_k) $$ 把 $j$ 提出来，拆一下柿子：$$ \\sum\\limits_j(\\sum\\limits_{i&lt;j}a_i\\oplus a_j)(\\sum\\limits_{j&lt;k}a_j \\oplus a_k) $$考虑求 $\\sum\\limits_{i&lt;j}a_i\\oplus a_j$ ，把每一位拆开算贡献，则应当统计 $a_1,…,a_{j-1}$ 中这一位上有多少个 1 ，预处理即可。预处理是 $O(n\\log)$ 的，枚举 $j$ 处理前后两个 sigma 是 $O(n\\log)$ 的，最后统计答案也是 $O(n)$ 的。 5 SUMXOR 给定序列 $a[1…n]$ 和 $b[1…n]$ ，求：$$ \\bigoplus\\limits_{i,j}a_i+b_j $$ 依然拆开每一位算，考虑第 $w$ 位的贡献应当是 $2^w\\sum[(a_i+b_j)\\text{ mod } 2^{w+1} \\ge 2^w] \\text{ mod }2$。令 $a_i\\gets a_i\\text{ mod }2^{w+1},b_i\\gets b_i\\text{ mod }2^{w+1} $，有两种情况： $a_i + b_j \\ge 2^{w+1}$，则应当有 $a_i+b_j-2^{w+1}\\ge 2^w$，移项得 $a_i+b_j\\ge 2^w+2^{w+1}$ $a_i+b_j&lt; 2^{w+1}$，则应当有 $2^w\\le a_i+b_j&lt; 2^{w+1}$ 于是转化成序列上的查询问题，Two-Pointers 扫即可。 6 The Hanged Man 有一个 $n$ 个点的树，每个点有一个体积 $v[i]$ 和收益 $w[i]$，现在你能选一个独立集，对于每个 $i$ 输出体积和为 $i$ 的收益和最大的独立集的值。$n\\le 50, m\\le 5000$ $O(nm^2)$ 的 DP 显然啊，但是重链剖分 DP 看不懂啊，这个先咕着。 资料：乱搞，重链剖分 附一个 $O(nm^2)$ 的 DP： 12345678910111213141516int n, m, vi[CN], wi[CN], f[CN][5005][2];void dfs(int u, int p){ for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p) dfs(v, u); } f[u][ vi[u] ][1] = wi[u]; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v == p) continue; for(int V = m; V; V--) for(int Vp = 0; Vp &lt;= V; Vp++){ if(V - Vp &gt;= vi[u]) f[u][V][1] = max(f[u][V][1], f[v][Vp][0] + f[u][V - Vp][1]); f[u][V][0] = max(f[u][V][0], max(f[v][Vp][0], f[v][Vp][1]) + f[u][V - Vp][0]); } }} 7 Anton and Ira 给定两个排列 $s$ 和 $p$ ，每次可以交换 $p$ 中的两个数，代价为它们间的距离，问最小代价使 $p$ 变为 $s$ ，输出方案。$n\\le 1000$ 设 $to[u]$ 是 $u$ 想要去到的位置，可以将其看作一条有向边。根据抽屉原理，某一时刻必然存在一个点使 $to[u]$ 与 $to[to[u]]$ 反向，于是贪心就好了。设这样得到的答案为 $s$，容易发现对于一种操作方案，必然存在另一种与之互为补集的操作方案，其答案也为 $s$。两者可以组成全集，即有 $2s=\\sum|i-to[i]|$，从而 $s=\\sum|i-to[i]|/2$。 8 Increasing Shortest Path 有个 $n$ 个点 $m$ 条边的有向图，有 $q$ 个询问：从 $ai$ 到 $bi$，边权递增，经过不超过 $ci$ 条边，权值和最小是多少？$T$组数据（$T\\le 100$）。$n ≤ 150, m, q ≤ 5000.$ $n$ 比较小，那么考虑 DP。边权看上去没办法放进状态里面，有一个技巧是把边升序排序，然后按照边来转移状态，即可满足要求。 设 $f[u,v,m]$ 表示 $u\\to v$ 经过不超过 $m$ 条边的答案，$O(n)$ 固定起点 $s$，$O(m)$ 枚举一条边 $(u,v,w)$，则有转移：$$ f[s,u,k]+w\\to f[s,v,k+1] $$这样看上去是 $O(nm^2)$ 的，但是考虑到限制是“至多经过”，而要求最小路径，则一个环不应在路径中出现，即一个点不会被访问超过一次。考虑到一个点之多有一条出边被选中，因此状态第三维的数量实际上是 $O(n)$ 的。对于 $ci&gt; n$ 的询问，其答案一定等于 $ci=n$ 的询问。 复杂度 $O(T(m\\log m+n^2m+q))$，瓶颈在于 $O(Tn^2m)$；考虑到时限是 60s， 因此可以通过。 代码： 12345678sort(G + 1, G + m + 1), memset(f, 0x3f, sizeof(f));for(int i = 1; i &lt;= n; i++) for(int k = 0; k &lt;= n; k++) f[i][i][k] = 0; for(int s = 1; s &lt;= n; s++) for(int i = 1; i &lt;= m; i++){ int u = G[i].u, v = G[i].v, w = G[i].w; for(int k = 0; k &lt; n; k++) f[s][v][k + 1] = min(f[s][u][k] + w, f[s][v][k + 1]); } 9 Increasing Number 一个数是Increasing当且仅当它的十进制表示是不降的，求 $n$ 位不降十进制数中被 $m$ 整除的有多少个。$n ≤ 10^{18}, m ≤ 500.$ 显然有状态 $f[n,p,k]$ 表示考虑第 $n$ 位数字，当前位填 $p$，模 $m$ 等于 $k$ 的方案数，转移可以枚举当前位数字和上一位数字，有关系 $f[n,p,(p\\times 10^n+k)\\text{ mod }m]\\gets f[n-1,p’,k]$，复杂度 $O(100nm)$，不太可行。对于这种转移关系比较固定的 DP，可以考虑矩乘加速，但是这是 $O((10m)^3\\log n)$ 的，看上去也不太行。 一个重要的性质：一个合法数字必然是至多 9 个仅由 1 组成的数的和。则可以按 $111…111$ 模 $m$ 的值将其分类，这样有 $m$ 类，然后对类做 DP 即可。这也令我们可以得出一个结论：位数小于 $n$ 的不降数的总个数是 $\\sum\\limits_{i=1}^9\\dbinom{i+n-1}{n-1}=\\dbinom{n+9}{n}-1$。 10 Little Elephant and Colored Coins 给定 $n$ 个物品，每个物品可以取无限次，每个物品有两种属性：价值 $v$ 和颜色 $c$。现在有 $q$ 个询问，询问最多能用多少种颜色组成 $S$。$n ≤ 30, v_i ≤ 2\\times 10^5,s\\le 10^{18}$ 对于这种题目，一般来说技巧是取 $w=\\min v_i$ ，把问题转化到模 $w$ 的剩余系下做。这样做的正确性在于：$\\mathbb{F}_P$ 中的所有数与 $P$ 的倍数组合能够填满整个整数域。然后可以设状态 $f[u,k]$ 或 $f[k]$ 表示模 $w$ 为 $k$ 的答案，对于物品的价值 $v$ 可以抽象成一条边的边权，然后套用最短路模型，于是做到 $O(w\\log w)$ 转移状态。 对于本题，考虑到硬币种类可能在统计过程中重复，因此设 $f[i,k]$ 表示选至少 $i$ 种，模 $w$ 为 $k$ 的路径的最小长度；用最短路模型来转移看上去也不太行，考虑换成背包模型，即有 $f[i,k]\\gets f[i+1,(k+v_i)\\text{ mod }w]$，然后按 $i$ 分组 DP 更新即可，复杂度 $O(n^2w)$。 给出大致的代码： 12345678910111213141516171819202122n = read();for(int i = 1; i &lt;= n; i++) v[i] = read(), w = w ? min(w, v[i]) : v[i];memset(f, 0x3f, sizeof(f)), f[0][0] = 0;for(int i = 1; i &lt;= n; i++) for(int j = n - 1; j + 1; j--) for(int k = 0; k &lt; w; k++) f[j + 1][(k + v[i]) % w] = min(f[j][k] + v[i], f[j + 1][(k + v[i]) % w]);for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) for(int k = 0; k &lt; w; k++) f[i][(k + v[j]) % w] = min(f[i][k] + v[j], f[i][(k + v[j]) % w]); q = read();while(q--){ int s = read(), sw = s % w; bool flag = false; for(int i = n; i &amp;&amp; !flag; i--) if(f[i][sw] &lt; INF &amp;&amp; f[i][sw] &lt;= s) printf(\"%d\", i), puts(\"\"), flag = true; if(!flag) puts(\"-1\");} 11 Balance 一个杠杆，半长为 $n$，$2n+1$ 个整数坐标各有一个质量相同的砝码，取走 $k$ 个，问最终杠杆仍然平衡的方案数。$n\\le 10^4, k\\le 10$ 整数划分问题。容易发现两边是完全对称的，那么只需要考虑一边。考虑枚举取的数字和是多少，设 $f[i,k]$ 表示把数字 $i$ 拆分成 $k$ 个小于 $n$ 的不同数字的方案数，有转移：$$ \\begin{aligned}f[i,k]&amp;=f[i-k,k]+f[i-k,k-1]\\newline f[i,k]&amp;=f[i,k]-f[i-n-1,k-1] \\text{ }\\text{ }| \\text{ }\\text{ }i\\ge n + 1 \\end{aligned}$$复杂度 $O(nk^2)$。 代码： 12345678910memset(f, 0, sizeof(f)), N = 0;for(int i = n - K + 1; i &lt;= n; i++) N += i;for(int i = 1; i &lt;= n; i++) f[i][1] = 1;for(int k = 2; k &lt;= K; k++) for(int i = 1; i &lt;= N; i++) f[i][k] = i &gt;= k ? (f[i - k][k] + f[i - k][k - 1]) % p : 0, f[i][k] = i &gt; n ? (f[i][k] - f[i - n - 1][k - 1] + p) % p : f[i][k];int ans = 0;for(int w = 1; w &lt;= N; w++) for(int j = 1; j &lt; K; j++) ans = (1ll * f[w][j] * f[w][K - j] % p + ans) % p;for(int w = 1; w &lt;= N; w++) for(int j = 1; j &lt; K - 1; j++) ans = (1ll * f[w][j] * f[w][K - j - 1] % p + ans) % p; 12 Arrangement Count 求有多少个排列 $A\\subseteq [n]$，使得 $A$ 中每个位置与相邻位置的数的差不为 1。$n\\le 1000$ 设 $f[i,j,0/1]$ 表示考虑 $A\\subseteq [i]$，有 $j$ 对相邻位置相差为 1 ，$i$ 是否与 $i+1$ 相邻的方案数，有转移： $f[i,j,0]·j\\to f[i+1,j-1,0]$ $f[i,j,0]·2\\to f[i+1, j + 1, 1], f[i,j,1]·2\\to f[i+1, j, 1]$ $f[i,j,0/1]·(i-j-1)\\to f[i+1,j,0]$ 复杂度 $O(n^2)$。 13 Cut Tree $n$ 个节点的树，点有点权，要切两条边和加一个点使得形成的三个子树点权和相等，最小化新加节点点权的绝对值。$n \\le 10^5$ 考虑固定一整棵树的根，对所有 $n$ 棵子树的大小统计其出现次数 $cnt[]$。不妨设当前的根处需要割断一条边，那么枚举其的枚举一个子树 $v$，设其大小为 $sz[v]$ ，则当 $cnt[sz[v]]&gt;1$ 时，可将整棵树切成三个部分：两个 $sz[v]$ 和一个 $n-sz[v]$ ，于是可以更新答案。 但是当前根处不一定会割断边，那么考虑换根。容易发现当根向某个儿子移动时，至多有两个节点的 $sz[]$ 值会发生变化，则简单维护即可。 于是可以做到不漏算答案，时间复杂度 $O(n)$。 14 Number Game Alice 和 Bob 又双叒叕在玩游戏。Bob 每次会想一个 $0\\text{~}n$ 的数，Alice 每次猜 $k$，Bob 告诉 Alice 大了还是小了。Alice 猜 $k$ 会付出 $a_k$ 的代价，Alice 要最小化代价，Bob 要最大化代价（并在不违反前面询问的情况下改数）。假设二人都绝顶聪明，求 Alice 最后付出多少代价。$n \\le 10^5, a_i\\le 9$ 本人只会 $O(n^3)$ 的辣鸡 DP…… 设 $f[l,r]$ 为考虑区间 $[l,r]$ 的答案，应当有转移：$$ f[l,r]=\\min\\limits_k a_k+ \\max(f[l,k-1],f[k+1,r]) $$ 边界是 $f[i,i]=a_i$，直接大力 DP 即可做到 $O(n^3)$。 15 Distributs 小 A 带来了 $m$ 种特产，第 $i$ 种特产的数量为 $a_i$。小 A 要把它们全部分给 $n$ 个同学，要求每个同学至少拿到一个特产，问有多少种分法，对 $10^9+7$ 取模。$n,m \\le 1000$ 容斥简单题，钦点 $k$ 个人一定分不到，剩下的随便分，在总方案数中减去就好了，则答案是：$$ \\sum\\limits_{k=0}^n (-1)^k \\dbinom{n}{k}\\sum\\limits_j \\dbinom{a_j+n-k-1}{n-k-1}$$ 复杂度 $O(n^2)$。 16 Solutions of the Equation 有 $n$ 个变量 $x_1…x_n$，每个变量 $0&lt;x\\le R$，给定 $S$，求方程 $x_1+x_2+…+x_n=S$有多少组正整数解。$n \\le 1000$ 容斥简单题，如果不考虑限制答案是 $\\dbinom{S-1}{n-1}$，然后钦点有 $k$ 个变量不合法然后去加加减减，答案是：$$ \\sum\\limits_{k=0}^n (-1)^k \\dbinom{n}{k}\\dbinom{S-kR-1}{n-1} $$ 复杂度 $O(n^2)$。 17 Bohater 在一款电脑游戏中，你需要打败$n$只怪物（从 $1$ 到 $n$ 编号），初始生命值为 $z$。为了打败第 $i$ 只怪物，你需要消耗 $d_i$ 点生命值，但怪物死后会掉落血药，使你恢复 $a_i$ 点生命值。任何时候你的生命值都不能降到 0（或 0 以下）。请问是否存在一种打怪顺序，使得你可以打完这 $n$ 只怪物而不死掉。如果存在请输出方案，不存在输出NO。$1≤n,z≤10^5，0≤d_i,a_i≤10^5$ 考虑把怪分成两类，先打加血怪，再打减血怪；考虑打加血怪的过程：应当按 $d_i$ 升序去打。减血怪呢？考虑打怪的反过程：不打一个怪，血量增加 $d_i$ 而减少 $a_i$。则反过程应当按 $a_i$ 升序排，正过来就是按 $a_i$ 降序排。 复杂度 $O(n\\log n)$。 18 Swap Space 你有许多电脑，它们的硬盘用不同的文件系统储存数据。你想要通过格式化来统一文件系统。格式化硬盘可能使它的容量从 $a_i$ 变成 $b_i$。为了格式化，你需要买额外的硬盘。当然，你想要买容量最小的额外储存设备以便省钱。你可以按任意顺序格式化硬盘。格式化之前，你要把该硬盘上所有数据移到一个或更多的其他硬盘上，数据可以分割。格式化后，该硬盘可以立刻开始使用。你没有必要把数据放到它原来所在的硬盘上。数据也可以被放到你额外买的硬盘上。求最小的额外储存设备容量。$1≤n≤10^6,1≤a_i,b_i≤10^9$ 考虑二分最终的答案 $M$ ，表示一开始购买的硬盘大小，则模型变为： 给定一些元素 $(a,b)$ ，选择某个元素会付出代价 $a$ 得到收益 $b$ ，求能否选择所有元素。 这就是上题模型，复杂度 $O(n\\log^2n)$，看上去有点卡。 实际上二分大可不必，依然按照上题的思路去做，当代价和多于当前的承受限度时，把多出来的那一部分加到答案里即可，复杂度 $O(n\\log n)$。 19 Maximum Value of Linear Function 现在有 $n$ 个一次函数，$f_i(x)=a_ix+b_i$。给定 $x$，并且对于所有的 $f_i(x)$ 可以任意改变顺序嵌套函数，求 $f(f(f(…f(x))…)$ 的最大值。$n\\le 10^6$ 容易发现 $x$ 的系数一定，那么只需要考虑常数项最大。考虑交换，对二元组 $(a_1,b_1)$ 和 $(a_2,b_2)$ ，前者放在外层当且仅当 $a_1(a_2x+b_2)+b_1&gt;a_2(a_1x+b_1)+b_2$，移项得 $(a_1-1)/b_1&gt;(a_2-1)/b_2$，则按照 $(a_i-1)/b_i$ 降序排序，把靠前的放在外层即可。 这个题也可以类比一下「国王游戏」那道题。考虑何时应该交换相邻的两个元素 $i,j$：当且仅当 $\\Pi/b_i+(a_i·\\Pi)/b_j &gt; \\Pi/b_j+(a_j·\\Pi)/b_i$，化简得 $(a_j-1)·b_j&lt;(a_i-1)·b_i$，因此按 $(a_i-1)·b_i$ 为关键字排序即可。 20 Kuglarz $n$ 个杯子排成一排，每个杯子中可能放有也可能没有一个小球。你每次可以花费 $C(i,j)$ 的代价得知区间 $[i,j]$ 的杯子中球的总数的奇偶性。问最少花费多少代价才能求出每个杯子中是否有小球。$n\\le 1000$ 看上去很像 DP，但我的做法假掉了……建一张图，边 $(u,v)$ 的边权为 $C(u,v)$，则问题等价于求出图上的最小生成树。时间复杂度 $O(n^2)$。 21 OSU! 一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。求该 01 串的价值的期望。$n\\le 10^5$ 考察期望的定义，和应用用贡献法计算每一位的价值期望。设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：$$ \\begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \\newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \\end{aligned}$$ 于是可以做到 $O(n)$。注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。 代码： 123for(int i = 1; i &lt;= n; i++) l[i] = a[i] * (l[i - 1] + 1);for(int i = 1; i &lt;= n; i++) l2[i] = a[i] * (l2[i - 1] + 2 * l[i - 1] + 1);for(int i = 1; i &lt;= n; i++) f[i] = f[i - 1] + a[i] * (3 * l2[i - 1] + 3 * l[i - 1] + 1);","link":"/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/"},{"title":"拓扑排序","text":"对一个DAG$G=(V,E)$（$V$为点集，$E$为边集）进行拓扑排序，是将$G$中所有顶点排成一个线性序列，使得图中任意一边$(u,v)∈E$，$u$在线性序列中出现在$v$之前…… 一 概念 对一个DAG $G=(V,E)$（$V$为点集，$E$为边集）进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一边$(u,v)∈E$，$u$在线性序列中出现在$v$之前。通常，这样的线性序列称为满足拓扑次(Topological Order)的序列，简称拓扑序列。 简单来说，就是找一种排序方案，使得每条边的起点总排在终点之前。注意：一个DAG的拓扑序列不一定是唯一的。 如图，合法的拓扑序列有$4,3,6,1,2,5$或$4,3,6,5,1,2$。 二 实现1 怎么求拓扑序要使得起点排在终点之前，那么我们首先要找到起点，即入度为$0$的节点。然后我们删去这些点，即在图中删除以它们为起点的边。因为DAG的特性，那么这样操作以后，新得到的图也一定是一个DAG。于是我们可以继续找起点，删边，那么我们得到起点的顺序就是一个拓扑序。 因为DAG的性质，所以一个点不会被重复访问。 2 算法求出一有向图的一个拓扑序。 边表 12345678910111213const int CP=1e3+3;const int CE=CP*CP;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;} 排序算法 123456789101112131415161718192021222324252627282930313233343536const int CP=1e3+3;const int CE=CP*CP;int in[CP]; //记录节点入度int ans[CP]; //得到的拓扑序queue&lt;int&gt;Q; //存放入度为0的节点void tsort(){ int pos=0; for(int i=1;i&lt;=n;i++) for(int k=hd[i]; k; k=E[k].nxt) in[E[k].to]++; //统计入度 for(int i=1;i&lt;=n;i++) if(!in[i]) Q.push(i); //将起点入队 while(!Q.empty()) { int cur=Q.front(); Q.pop(); ans[++pos]=cur; //记录答案 for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; in[to]--; //拆边，并减少终点的入度 if(!in[to]) //得到的是一个新起点，就把它入队 Q.push(to); } }} 三 建图拓扑排序的题目中，难点一般在建图，因为建图之后求拓扑序是一件极其容易的事情。讨论建图之前，我们先讨论一些基础的东西。 1 字典序字符在某一标准（一般是ASCII）中出现的先后顺序叫做字典序。类似于数字比大小，某一字符串$A$相对于字符串$B$，$A$的高位上的字符在标准中比$B$出现得早，则称$A$的字典序（相对于$B$）小。反之，则称$A$的字典序（相对于$B$）大。 若以ASCII为标准，则串$abc$比串$acb$字典序小。 设定拓扑序列中第一个元素为最高位，最后一个元素为最低位。那么字典序小的拓扑序则是高位元素的编号尽量小，字典序大的拓扑序则是高位元素的编号尽量大。 对于第一章节中的图，拓扑序列$4,3,6,1,2,5$的字典序小，拓扑序列$4,3,6,5,1,2$的字典序大。 2 怎么求一个字典序大或小的拓扑序列前文中给出的算法是以入队顺序确定拓扑序列。那么怎么求一个指定字典序大小的拓扑序列呢？只需要把上文算法中的普通队列改成优先队列即可。因为在队列中的元素总是起点，在拓扑序列中的相对位置可以调换。 具体实现（重载运算符） 123456789101112131415161718192021222324const int CP=1e3+3;const int CE=CP*CP;class node{ public: int cde; void init(int c){cde=c;} //大字典序 bool operator &lt; (const node a)const { return cde&lt;a.cde; } /* 小字典序 bool operator &lt; (const node a)const { return cde&gt;a.cde; } */};priority_queue&lt;node&gt;Q; 然后照常跑拓扑排序即可。 1234567891011121314151617181920212223242526272829303132333435363738int in[CP];void tsort(){ int pos=0; for(int i=1;i&lt;=n;i++) for(int k=hd[i]; k; k=E[k].nxt) in[E[k].to]++; for(int i=1;i&lt;=n;i++) if(!in[i]) { node temp; temp.init(i); Q.push(temp); } while(!Q.empty()) { node cur=Q.top(); Q.pop(); ans[++pos]=cur.cde; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; in[to]--; if(!in[to]) { node temp; temp.init(to); Q.push(temp); } } }} 3 例题1-建图求拓扑序 Luogu P1983 车站分级一条单向的铁路线上，依次有编号为$ 1, 2, …, n $的$ n $个火车站。每个火车站都有一个级别，最低为 $1$ 级。现有若干趟车次在这条线路上行驶，每一趟都满足如下要求：如果这趟车次停靠了火车站 $x$，则始发站、终点站之间所有级别大于等于火车站 $x$ 的都必须停靠。（注意：起始站和终点站自然也算作事先已知需要停靠的站点）现有 $m$ 趟车次的运行情况（全部满足要求），试推算这 $n$ 个火车站至少分为几个不同的级别。 数据输入 第一行包含 $2$ 个正整数 $n,m$，用一个空格隔开。第 $i+1$ 行$(1 ≤ i ≤ m)$中，首先是一个正整数 $s_i(2 ≤ s_i ≤ n)$，表示第 $i$ 趟车次有 $s_i$ 个停靠站；接下来有 $s_i$个正整数，表示所有停靠站的编号，从小到大排列。每两个数之间用一个空格隔开。输入保证所有的车次都满足要求。 数据输出 $n$ 个火车站最少划分的级别数。 对于任意一趟列车，经过的站点总比没有经过的级别高，我们把级别高的站点向级别低的站点依次连边。 这样处理完$m$趟列车后，我们就会得到一个DAG。接下来我们只需要对这个DAG进行拓扑排序。但还有一个问题，怎么求出最小级别数？很明显，若定义排序起点的深度为$1$，那么这个最小级别数就是图中节点的最大深度。我们只需要在广搜的时候递推记录一下节点深度就可以了。 递推式：$$\\begin{aligned}f_i&amp;=1 | i \\in S \\newline f_i&amp;=\\max f_i,f_j+1 | (j,i)\\in E \\end{aligned}$$ $S$为起点集，$E$为边集。 具体实现（仅核心算法）： 123456789101112131415161718192021222324252627const int CP=1e3+3;int f[CP];for(int i=1;i&lt;=n;i++) if(!in[i]) { f[i]=1; Q.push(i); }while(!Q.empty()){ int cur=Q.front(); Q.pop(); for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; f[to]=max(f[to], f[cur]+1); //here in[to]--; if(!in[to]) Q.push(to); }} 4 反图4-1 什么是反图？对一个有向图$G={V,E}$，若存在一个图$G_r={V,E_r}$，其中两个图的点集相同，边集相反（定义为每一条边的方向均相反），那么称$G_r$为$G$的反图。 建立反图其实是一件非常简单的事情，只需要在节点连边的时候连反向边即可。 4-2为什么要建反图? 若令求一个拓扑序列，使得最小的编号尽早出现。 先考虑能否用字典序解决：字典序小使得居高位的数字尽可能小；字典序大使得居高位的数字尽可能大。 于是我们发现，最小的字典序并不能保证最小数字尽可能靠前。 继续分析：最小数字尽可能靠前，那么其它数字（都比它大）要尽可能靠后。看不出什么来，那我们反过来看：最小数字尽可能靠后，那么其它数字要尽可能前。这恰好是原图中的最大字典序（无论高位怎样排布，最大字典序会使低位尽可能小，也就是最小数字尽可能靠后）。 于是我们求一个最大字典序的拓扑序列，反过来读，就是答案吗？不是。就像sort一样，一段排好序的数列，反过来读（相对于排序条件）一定是无序的。 那么怎么解决这个问题？考虑反向建图。在原图的反图中跑最大字典序的拓扑序列。这个序列看起来是不合法的，但是反过来看就exciting了。我们不难发现，反图中的每个拓扑序列，都是正图中的一个合法拓扑序列反转而形成的。继续考虑，求出反图中最大字典序的拓扑序列$K$，会使得最小数字在$K$中出现的尽量晚。然后我们把$K$反转形成$K_r$，那么最小数字在$K_r$中就会出现的尽可能早。然后$K_r$依然是正图的合法拓扑序列，完美解决。 4-3 算法实现代码依然是上面的代码改了改。 边表 12345678910111213const int CP=1e3+3;const int CE=CP*CP;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=x; //反向加边 E[ecnt].nxt=hd[y]; hd[y]=ecnt;} 排序算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int CP=1e3+3;const int CE=CP*CP;class node{ public: int cde; void init(int c){cde=c;} bool operator &lt; (const node a)const { return cde&lt;a.cde; //大字典序 }};int in[CP];int ans[CP];prioirty_queue&lt;node&gt;Q;void tsort(){ int pos=n; //倒着记录答案，正好是正图中的拓扑序列 for(int i=1;i&lt;=n;i++) for(int k=hd[i]; k; k=E[k].nxt) in[E[k].to]++; for(int i=1;i&lt;=n;i++) if(!in[i]) { node temp; temp.init(i); Q.push(temp); } while(!Q.empty()) { node cur=Q.top(); Q.pop(); ans[pos--]=cur.cde; //记录 for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; in[to]--; if(!in[to]) { node temp; temp.init(to); Q.push(temp); } } }} 5 例题2-建立反图解决拓扑问题 HNOI2015 菜肴制作知名美食家小A被邀请至ATM 大酒店，为其品评菜肴。 ATM 酒店为小A准备了 N 道菜肴，酒店按照为菜肴预估的质量从高到低给予1到N的顺序编号，预估质量最高的菜肴编号为1。由于菜肴之间口味搭配的问题，某些菜肴必须在另一些菜肴之前制作，具体的，一共有 M 条形如”i 号菜肴’必须’先于 j 号菜肴制作“的限制，我们将这样的限制简写为&lt;i,j&gt;。现在，给出若干组形如&lt;i,j&gt;的限制，酒店希望能求出一个最优的菜肴的制作顺序，使得小A能尽量先吃到质量高的菜肴 最小编号最靠前，明显是一个反图拓扑序问题。对于每组限制&lt;i,j&gt;，从j向i连边，然后求最大字典序，反着输出即可。 $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"最大子段和问题","text":"最近刷到一道三段最大子段和的问题，发现自己连一段最大子段和都写不出来。于是怒刷四道题，特此记录…… 一 单段最大子段和问题来源 给出一段长为$N$的序列$s$，选出其中连续且非空的一段使得这段和最大。$N⩽200000$ 设$f_i$为以$i$结尾（$i$必须要选）时的最大子段和大小。则有$f_i = \\max f_{i-1}+s_i, s_i$，也就是与前面的合并成一段或者新开另一段。最后一个元素不一定要选，那么答案就是$\\max\\limits_{i=1}^n f_i$。 代码 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e5+5;int n,f[CN],g[CN];/*f[i] 的意义是在必须选 i 的前提下，得到的最大字段和g[i] 的意义是考虑前 i 个元素，得到的最大子段和 */int main(){ memset(g,-0x3f,sizeof(g)); f[0] = -0x3f3f3f3f3f; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++){ int s; scanf(\"%d\",&amp;s); f[i] = max(f[i-1]+s,s); //另开一段，或继承前面 g[i] = max(g[i-1], f[i]); } printf(\"%d\",g[n]); return 0;} 二 多段最大子段和问题 给定一个长为$n$的数列$s$，从中找到$m$个无交集的连续子数列使其和最大。 有一个很优秀的DP状态设计：设$f_{i,j,0/1}$表示考虑前$ i $个位置，划分$ j $段，且第$ i $个位置的数 选(最后一维为$1$) 或 不选(最后一维为$0$) 时，得到的答案。初始状态总是$f_{1,0,0} = 0,f_{1,1,1} = s_1$，其余$f$值全清成$-\\infty$。 时空复杂度都是$O(nm)$，在$m$比较小时适用。 实际上还有一种能应对$n,m$都很大的情况的贪心通解，典型题是BZOJ2288（貌似已经找不到了）。但是我太菜，理解不了，请参阅hzwer神犇的题解。 1 两段最大不相邻子段和来源 给定一个长度为$n$的整数序列$s$，要求从中选出两个连续子序列，使得这两个连续子序列的序列和之和最大，最终只需输出最大和。一个连续子序列的和为该子序列中所有数之和。每个连续子序列的最小长度为1，并且两个连续子序列之间至少间隔一个数。 转移方程是$f_{i,j,0} = \\max\\begin{Bmatrix} f_{i-1,j,0},f_{i-1,j,1} \\end{Bmatrix}, f_{i,j,1} = \\max \\begin{Bmatrix} f_{i-1,j,1}+s_i, f_{i-1,j-1,0}+s_i \\end{Bmatrix}$。后面的方程必须满足$j&gt;0$才可以转移，因为状态$f_{i,0,1}$没有意义。 第一个方程不用解释，第二个的意思是和前面的一块组成$j$个或者自己组成第$j$个。因为两个子段不能相邻，故后面的那个不能从$f_{i-1,j-1,1}$转移（请与后面的问题对比）。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 1e6+6;const LL INF = 0x7f7f7f7f7f7f7f7f;LL read(){/*略*/}int n;/*设 f[i][j][0/1] 表示考虑前 i 个数, 划分 j 段, 数 i 选1 /不选0 的答案 f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0])f[i][j][1] = max(f[i-1][j-1][0], f[i-1][j][1]) + s[i]*/LL f[CN][3][2],s[CN];int main(){ n = read(); for(int i=1;i&lt;=n;i++) s[i] = read(); memset(f,-0x7f,sizeof(f)); f[1][0][0] = 0; f[1][1][1] = s[1]; for(int i=2;i&lt;=n;i++){ for(int j=0;j&lt;=2;j++){ f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0]); if(j &gt; 0) f[i][j][1] = max(f[i-1][j][1]+s[i], f[i-1][j-1][0]+s[i]); } } printf(\"%lld\",max(f[n][2][0], f[n][2][1])); return 0;} 2 三段最大子段和来源 （实际上是从hzwer神犇的博客上搞来的套题，一部分题目放在了这个题组里。） 给定一个长为$n$的数列$s$，从中找到三个无交集的连续子数列使其和最大。 转移方程是$f_{i,j,0} = \\max\\begin{Bmatrix} f_{i-1,j,0},f_{i-1,j,1} \\end{Bmatrix}, f_{i,j,1} = \\max \\begin{Bmatrix} f_{i-1,j,1}+s_i,f_{i-1,j-1,1}, f_{i-1,j-1,0}+s_i \\end{Bmatrix}$。同样，后面的方程必须满足$j&gt;0$才可以转移，因为状态$f_{i,0,1}$没有意义。 第二个方程的意思是：和前面的一块组成$j$个，或者从$i-1\\to i$这个位置断成两个数列，或者自己组成第$j$个。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 1e6+6;const LL INF = 0x7f7f7f7f7f7f7f7f;LL read(){/*略*/}int n;/*设 f[i][j][0/1] 表示考虑前 i 个数, 划分 j 段, 数 i 选1 /不选0 的答案 f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0])f[i][j][1] = max(f[i-1][j-1][1], f[i-1][j][1], f[i-1][j-1][0]) + s[i] */LL f[CN][4][2],s[CN];int main(){ n = read(); for(int i=1;i&lt;=n;i++) s[i] = read(); memset(f,-0x7f,sizeof(f)); f[1][0][0] = 0; f[1][1][1] = s[1]; for(int i=2;i&lt;=n;i++){ for(int j=0;j&lt;=3;j++){ f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0]); if(j &gt; 0) f[i][j][1] = max(f[i-1][j][1], max(f[i-1][j-1][0], f[i-1][j-1][1])) + s[i]; } } printf(\"%lld\",max(f[n][3][0], f[n][3][1])); return 0;} 三 环形双段最大子段和问题来源 给出一段长为$n$的环状序列$s$，即认为 $s_1$ 和 $s_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。 实际上就是两种情况：选两段最大子段和（类似于这样：xxx√√xx√√√x）或选三段首尾都需要选的最大子段和（类似于这样：√√√xx√√xxx√）。 第一种情况直接跑两段最大子段和就好了，第二种情况可以看成区间总和减掉一个两段最小不相邻子段和，并且这两段中不能包括$s_1$和$s_n$。其实改一改DP边界就解决了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 1e6+6;const LL INF = 0x7f7f7f7f7f7f7f7f;LL read(){/*略*/}int n;/*设 f[i][j][0/1] 表示考虑前 i 个数, 划分 j 段, 数 i 选1 /不选0 的答案 */LL f[CN][3][2],s[CN],ans = -INF,sigma = 0;int main(){ n = read(); for(int i=1;i&lt;=n;i++) s[i] = read(),sigma += s[i]; /* 双段的情况 做最大子段和 f[1][0][0] = 0 f[1][1][1] = s[1] f[else][else][else] = -INF f[i][j][0] = max(f[i-1][j][1] , f[i-1][j][0]) f[i][j][1] = max(f[i-1][j][0] , f[i-1][j][1] , f[i-1][j-1][1]) + s[i] */ memset(f,-0x7f,sizeof(f)); f[1][0][0] = 0; f[1][1][1] = s[1]; for(int i=2;i&lt;=n;i++){ for(int j=0;j&lt;=2;j++){ f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0]); if(j &gt; 0) f[i][j][1] = max(f[i-1][j][1], max(f[i-1][j-1][1], f[i-1][j-1][0])) + s[i]; } } ans = max(ans, max(f[n][2][0], f[n][2][1])); /* 三段的情况 做最小子段和，用前缀和相减 f[2][0][0] = 0 f[2][1][1] = s[2] f[else][else][else] = INF f[i][j][0] = min(f[i-1][j][1] , f[i-1][j][1]) f[i][j][1] = min(f[i-1][j-1][0] , f[i-1][j][1]) + s[i] 选中的两个相邻的子段不能连续 且1,n都不能被选中 */ memset(f,0x7f,sizeof(f)); f[2][0][0] = 0; f[2][1][1] = s[2]; for(int i=3;i&lt;n;i++){ for(int j=0;j&lt;=2;j++){ f[i][j][0] = min(f[i-1][j][1], f[i-1][j][0]); if(j &gt; 0) f[i][j][1] = min(f[i-1][j][1],f[i-1][j-1][0]) + s[i]; } } ans = max(ans, sigma-min(f[n-1][2][0], f[n-1][2][1])); printf(\"%lld\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/08/04/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98/"},{"title":"最小费用最大流","text":"此页面存在相关页面。关于网络流基础，请参见「网络最大流」。 最小费用最大流（Min Cost Max Flow，MCMF，也称费用流）问题，是指在网络流图中，对于每条边在原有的基础上再增加一个限制——单位流量的费用…… 一 概念最小费用最大流（Min Cost Max Flow，MCMF，也称费用流）问题，是指在网络流图中，对于每条边在原有的基础上再增加一个限制——单位流量的费用，并且在保证流最大的情况下使得产生的费用最小。 那么在费用流问题中，一条边就可以被描述成$e=(u,v,cap,cost,flow)$，$(u,v)$是边的起点和终点，$cap$是容量限制，$cost$是单位流量所产生的费用，$flow$是当前流量。之所以强调“单位流量“，是因为这条边总产生的费用为$flow\\times cost$。 网络的最大流显然是一定的，但是最小割可能会有多个。每个割的单位流量费用不同，于是才有了费用流问题。注意：费用流是在保证流最大的前提下，使得总产生的费用最小。 二 解决1 思路网络的最大流可能是由多条增广路径共同组成。如下图，增广路$s \\to 1 \\to 4 \\to t$和$s \\to 2 \\to 3 \\to t$共同组成了网络的最大流。 那么先分析一条增广路的费用。设该费用为$p$，该增广路经过边$e_1,e_2,…,e_m$，每条边的单位流量费用分别是$c_1,c_2,…,c_m$，且该路上当前流量为$a$，那么可以得出下面的式子： $$ p = ac_1 + ac_2 + … + ac_m = a(c_1+c_2+…+c_m) $$也就是：$$ p = a \\times \\sum\\limits_{i=1}^m c_i $$ 如果能保证$p$最小且该增广路在最大流中，那么$a$一定是个定值，且等于路上的最小割。要保证$p$最小，就是要让后面的$\\sum$最小，它表示该增广路上各条边的单位费用之和。 那么我们能想到什么？最短路把$cost$这一元看作边的边权，那么这个$\\sum\\limits_{i=1}^m c_i$就表示路上的边权之和。我们要求出最小的$\\sum$，就是在求图上的最短路。 那么就有了贪心的思路：每次找出图上$s\\to t$的最短路并把它增广，那么这条路就“断”了，然后再找最短路，直到无法增广，此时网络达到最大流，且产生的费用最小。 2 代码利用spfa找最短路，每次进行单路增广，并模拟dinic中dfs增广的退栈过程来实现数据的更新（这需要记录搜索时进入每个节点的边时哪一条边）。 注意，因为反向边是反悔机制，用来抵消正向边的影响，所以反向边的单位流量费用应该是对应正向边的相反数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const int CP=5e3+3;const int CE=1e5+1e2;const int INF=0x3f3f3f2f;//快读int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=((s&lt;&lt;1)+(s&lt;&lt;3))+c-'0'; return s*ne;}//边表class fs{ public: int from,to,nxt,cap,cost,flow; void init(int r,int t,int n,int c,int s,int f) {from=r; to=t; nxt=n; cap=c; cost=s; flow=f;}}E[CE];int hd[CP],ecnt=1;void _add(int x,int y,int c,int s){ E[++ecnt].init(x,y,hd[x],c,s,0); hd[x]=ecnt;}void add(int x,int y,int c,int s){ _add(x,y,c,s); _add(y,x,0,-s); //反向边}//v defineint n,m,s,t;//mcmfint mincost=0,maxflow=0;int dist[CP]; //dist : 单源最短路bool ins[CP]; //ins[i] : i 是否在队列内int prv[CP]; //prv[i] : 当前最短路中进入点 i 的边 int rst[CP]; //rst[i] : s-&gt;i路上的最小割bool Augment(int _s,int _t) //spfa{ memset(ins,false,sizeof(ins)); memset(dist,0x3f,sizeof(dist)); memset(rst,0x3f,sizeof(rst)); queue&lt;int&gt;Q; Q.push(_s); dist[_s]=0; ins[_s]=true; while(!Q.empty()) { int u=Q.front(); Q.pop(); ins[u] = false; for(int k=hd[u]; k; k=E[k].nxt){ fs e=E[k]; if(e.cap-e.flow &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u]+e.cost) { dist[e.to] = dist[u]+e.cost; //松弛，边权为cost prv[e.to] = k; //记录入边 rst[e.to] = min(rst[u], e.cap-e.flow); //递推 if(!ins[e.to]){ Q.push(e.to); ins[e.to] = true; } } } } return dist[_t]&lt;INF; //没到达 _t ，则dist[_t]=INF}void update(int _s,int _t){ //更新（模拟退栈） int pos=_t; //从终点开始 while(pos != _s){ //直到起点 E[prv[pos]].flow += rst[_t]; //正向 E[prv[pos]^1].flow -= rst[_t]; //反向 pos = E[prv[pos]].from; //前往上一个节点 }}void mcmf(int _s,int _t){ //主调用函数 while(Augment(_s,_t)){ maxflow += rst[_t]; mincost += dist[_t]*rst[_t]; //单位费用 * 流量 update(_s,_t); //更新 }} 三 网络流建模1 点容量问题拆点建模一般应用在点存在容量限制的网络流问题中，因此也可以用来求解图上的最小割点集（此时点的容量均为$1$，详见「题解」奶牛的电信）。 把图上的每个非源非汇点$i$拆成$i,i+n$两个点（$n$是总点数），其中点$i$连接原图中该点的入边，点$i+n$连接原图中该点的出边，这样$i\\to i+n$这条边就能代表原图中的点$i$，对这条边设置容量限制，实际就是对该点设置容量限制。 如下图： 2 点权均衡问题原题：负载平衡问题 给定一张由$n$个点组成的环，每个点$i$有一个点权$x_i$，点权可以在相邻节点间转移。记$ \\overline x = \\sum\\limits_{i=1}^n x_i \\div n$，求最少的转移量，使得每个$x_i$都等于$\\overline x$。 可以把仓库分成两类： $x_i &gt; \\overline x$ 的仓库$i$，记为图$L$。 $x_i &lt; \\overline x$ 的仓库$i$，记为图$R$。 $x_i = \\overline x$的仓库不会影响答案，所以放在哪一类里面都行。 很明显，$L$中节点的点权需要转移到$R$中节点去。把这个点权变成边权，那么新建总源$s$和总汇$t$，连边$s\\to L$，$L \\rightleftarrows R$与$R\\to t$。具体方法如下： $s\\to L$边上的流量限制为$L$中节点点权超出$\\overline x$的部分，即$x_i - \\overline x$，转移费用为$0$。 $R\\to t$边上的流量限制为$R$中节点点权不足$\\overline x$的部分，即$\\overline x- x_i$，转移费用为$0$。 图上所有相邻节点互相连双向边，边上没有流量限制，因为可以无限转移。不过转移的费用就是$1$。 这样，当增广一条路时，$s\\to L$的边流量增大，使得$L$中节点点权变小；$R\\to t$的边流量也增大，使得$R$中节点点权变大。其实上意味着$L,R$中点的点权会更接近于平均值$\\overline x$。当网络流达到最大时，也就是说所有不等于平均值的点权都已经被增广到平均值大小，也就达到了负载平衡。 那么跑费用流，输出最小费用。 四 二分图匹配问题1 最大基数匹配二分图的不带权最大匹配问题也称最大基数匹配问题。基础部分详见：二分图基础。 新建总源$s$，总汇$t$。设二分图的左图为$L$，右图为$R$，则将$s$向$L$中的所有节点连边，$R$中的所有节点向$t$连边，并将二分图中原有的无向边转化成$L\\to R$的有向边。所有边的容量均为$1$。于是我们可以得到一张网络流图，如下： 边的容量为$1$保证了同一条边不会同时在多条增广路中，那么任意两条增广路的交点只会是$s$和$t$。此时若求出最大流，那么最大流就是该图的最大匹配，$L\\to R$中流量为$1$的边就是最大匹配中的匹配边。 代码参见飞行员配对问题。 2 最大带权匹配 若存在一种匹配方案，使得图上所有点都被匹配，则称这个匹配为二分图的完美匹配。 先考虑存在完美匹配时的情况。 依然是上面的建图思路，并把边权看作费用，$s\\to L$和$R\\to t$的边费用为$0$。那么显然可以求出最小费用最大流。 把最大边权和转化成最小费用？两种思路：每次延着最长路增广 和 使费用为边权的相反数。 但是此时最小费用其实受最大流的限制，也就是说仅当流最大时才保证费用最小，那么这样求出来的最小费用实际上是完美匹配的最小边权和。为什么呢？当存在完美匹配时，最大流一定是这个完美匹配，那么这时候最小费用才对应着图上的最小边权和，那么也就是完美匹配的最小边权和。 那么怎样求不受边数限制的最大带权匹配？ 也就是说要摆脱这个“最大流”的限制。怎么做呢？每次增广后都记录一下当前的总费用，直到当前流最大，那么所有可能的匹配的边权和我们都已经求出来了，只要把最小（如果费用是边权的相反数）的那个挑出来就好了。 建图的图解如下： 3 最大带权独立集 选出一些节点，使得这些节点都没有边相连，称其为原图的一个独立集。 那么最大带权独立集就是在点有点权的基础上，求出一个点权和最大的独立集。 还是上面的思路。新建总源$s$，总汇$t$。设二分图的左图为$L$，右图为$R$。将$s$向$L$中的所有节点连边，容量为$L$中节点的点权；$R$中的所有节点向$t$连边，容量为$R$中节点的点权。并将二分图中原有的无向边转化成$L\\to R$的有向边，容量无限。 那么有： 最大独立集 = 总点权-最小割（最大流） 割中的边一定是$s\\to L$或$R\\to t$的边。增广它们等于删掉这些边，相当于删掉$L,R$中的结点。删掉最小割一定会导致图不连通。而在原二分图中，删掉割中的节点及所连接的边，就会导致图上一条边也没有！那么剩下的节点肯定是独立集。又保证了割最小，所以求得了最大独立集。 图解： $$ - - - - \\mathcal{End} - - - - $$ 最近更新： 2020.8.9 优化页面结构","link":"/2019/03/19/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"title":"模线性方程组与中国剩余定理","text":"这篇文章会比较杂乱，因为好多内容都被我搞到一块来了…先写一个内容摘要可供参考： 利用扩展欧几里得算法（exgcd）求解二元一次不定方程 利用exgcd求解单变元模线性方程 利用中国剩余定理（CRT）与扩展中国剩余定理（exCRT）求解单变元模线性方程组…… 一 求解二元一次不定方程1 理论关于$x,y$的，形如$ax+by = c$的方程被称作二元一次不定方程。在实数域中，不定方程有无限组解，因为它可以被看作一条二维平面内的直线，直线上每一个点都对应方程的一组实数解。 但是不定方程却不一定有$x,y$都为整数的解（以下通称“整数解”）。根据扩展欧几里得定理我们知道：不定方程$ax+by=\\text{gcd}(a,b)$一定存在整数解。但是推广到一般形式呢？我们不妨将$ax+by=c$两边同时除以$\\text{gcd}(a,b)$，得$a/\\text{gcd}(a,b)\\times x+b/\\text{gcd}(a,b) \\times b = c/\\text{gcd}(a,b)$。假设$x,y$均为整数，则等式左边的部分$a/\\text{gcd}(a,b)\\times x+b/\\text{gcd}(a,b) \\times b$一定是整数，故等式右边的部分$c/\\text{gcd}(a,b)$也一定是整数，可知$ax+by=c$存在整数解的条件是$\\text{gcd}(a,b)|c$（$\\text{gcd}(a,b)$是$c$的因子）。 于是我们知道了二元一次不定方程整数解存在性的判定方法，然后我们需要解这个不定方程。 将方程两边同时除以$c/\\text{gcd}(a,b)$，化为$\\dfrac{a·\\text{gcd}(a,b)}{c}\\times x+\\dfrac{b·\\text{gcd}(a,b)}{c}\\times y =\\text{gcd}(a,b)$。然后我们再建立一方程使得$ax’+by’ = \\text{gcd}(a,b)$，使得可以用exgcd求出该方程的特解$x’,y’$。于是我们获得了$\\dfrac{a·\\text{gcd}(a,b)}{c}\\times x+\\dfrac{b·\\text{gcd}(a,b)}{c}\\times y =ax’+by’$，因为一定存在$x’|x,y’|y$，于是推出$x = x’\\times\\dfrac{c}{\\text{gcd}(a,b)},y = y’\\times\\dfrac{c}{\\text{gcd}(a,b)}$。 然后我们就求出了二元一次不定方程的一组特解，通解：令$kx = b/\\text{gcd}(a,b),ky = a/\\text{gcd}(a,b)$，则$x+i\\times kx,y-i\\times ky\\text{ }(i\\in Z)$是方程的通解。 2 代码12345678910111213141516171819202122LL gcd(LL a,LL b){ return b ? gcd(b,a%b):a;}//用ExGcd求不定方程 ax+by = c的一组特解(x0,y0)//通解: x=x0+i*kx,y=y0-i*ky (i = 0,±1, ±2, ...)void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ //普通的exgcd if(!b){ x = 1; y = 0; return; } _exgcd(b,a%b,x,y); int t = x; x = y; y = t-(a/b)*y;}bool ExGcd(LL a,LL b,LL c,LL &amp;x0,LL &amp;y0,LL &amp;kx,LL &amp;ky){ LL g = gcd(a,b); if(c % g) return false; //无解 _exgcd(a,b,x0,y0); LL kc = c/g; x0 *= kc; y0 *= kc; kx = b/g; ky = a/g; return true;} 二 求解单变元模线性方程1 理论关于$x$的，形如$ax+k\\equiv b (\\text{mod }m)$的方程被称作单变元模线性方程。该方程可以被化为一般形式$ax\\equiv b(\\text{mod }m)$（注意这里的等式和上面的等式中，$b$并不表示同一个数）。 解方程$ax\\equiv b(\\text{mod }m)$需要先把它去除同余。不妨把$ax$与$b$相差的那一部分（$|ax-b|$）补齐，于是得到等式$ax=b+km$，可化为$ax-mk=b$，实际上是一个关于$x,k$的二元一次不定方程。然后就可以exgcd求解。注意，我们只关注$x$的取值，而对$k$不作要求。并且$x$应该在模$m$的情况下才有意义，所以我们关注的是$x$的最小非负整数解。 2 代码12345678910111213141516171819202122232425262728293031323334LL gcd(LL a,LL b){ return b ? gcd(b,a%b):a;}//用ExGcd求不定方程 ax+by = c的一组特解(x0,y0)//通解: x=x0+i*kx,y=y0-i*ky (i = 0,±1, ±2, ...)void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(!b){ x = 1; y = 0; return; } _exgcd(b,a%b,x,y); int t = x; x = y; y = t-(a/b)*y;}bool ExGcd(LL a,LL b,LL c,LL &amp;x,LL &amp;y,LL &amp;kx,LL &amp;ky){ LL g = gcd(a,b); if(c % g) return false; //无解 _exgcd(a,b,x,y); LL kc = c/g; x *= kc; y *= kc; kx = b/g; ky = a/g; return true;} //求模线性方程 ax ≡ b(mod m)的最小非负整数解x0//化成ax-my = b //通解x = x0+i*k bool LineModEqu(LL a,LL b,LL m,LL &amp;x0,LL&amp; k){ LL y0,kx,ky; if(!ExGcd(a,m,b,x0,y0,kx,ky)) return false; k = kx; x0 %= k; x0 = (x0+k)%k; //取非负整数 return true;} 然后你不觉得这个东西可以来求逆元吗？？？ 三 中国剩余定理经过了前面的铺垫，终于可以步入正题了。 1 单变元模线性方程组把$n$个$x$系数为$1$的单变元模线性方程搞到一起，就得到了一个单变元模线性方程组。它是类似于这样的：$$ \\begin{cases} x \\equiv b_1(\\text{mod }m_1) \\newline x \\equiv b_2(\\text{mod }m_2) \\newline x \\equiv b_3(\\text{mod }m_3) \\newline …\\newline x \\equiv b_n(\\text{mod }m_n) \\end{cases} $$ 2 中国剩余定理若单变元模线性方程组的模数$m_1,m_2,m_3,…,m_n$两两互质，那么这个同余方程组可以用中国剩余定理（CRT）来求解。否则用扩展中国剩余定理（exCRT）求解，下面讲。 我们设$M = \\prod\\limits_{i=1}^n m_i,M_i = M/m_i$。对于每一个$M_i$，求出它在模$m_i$意义下的逆元$t_i$，则$x = \\sum\\limits_{i=1}^n M_i·t_i·b_i$。然后这个$x$是在模$M$情况下有意义，所以将它模$M$就求出了最小非负整数解。 3 代码1234567891011121314151617181920212223242526272829303132333435363738/*解单变元模线性方程ax ≡ b*/LL gcd(LL a,LL b){return b ? gcd(b,a%b) : a;}void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(!b){ x = 1; y = 0; return; } _exgcd(b,a%b,x,y); LL tx = x; x = y; y = tx-(a/b)*y;}bool ExGcd(LL a,LL b,LL c,LL &amp;x,LL &amp;y,LL &amp;kx,LL &amp;ky){ LL g = gcd(a,b); if(c % g) return false; _exgcd(a,b,x,y); LL kc = c/g; x *= kc; y *= kc; kx = b/g; ky = a/g; return true;}bool LineModEqu(LL a,LL b,LL m,LL &amp;x,LL &amp;k){ LL y,kx,ky; if(!ExGcd(a,m,b,x,y,kx,ky)) return -1; k = kx; x %= k; x = (x+k)%k; return true; }/*CRT*/void CRT(int n,LL &amp;x,LL *b,LL *m){ LL M=1; for(int i=1;i&lt;=n;i++) M *= m[i]; x = 0; for(int i=1;i&lt;=n;i++){ LL Mi = M/m[i],Ti,k; LineModEqu(Mi,1,m[i],Ti,k); //求逆元 (x += b[i]*Mi*Ti) %= M; } x = (x+M)%M; //搞成非负数 } 四 扩展中国剩余定理1 理论单变元模线性方程组的模数不满足两两互质，就要使用扩展中国剩余定理合并方程。 先考虑$n=2$（仅有两个方程）的情况。类似于这样：$$ \\begin{cases} x \\equiv b_1(\\text{mod }m_1) \\newline x \\equiv b_2(\\text{mod }m_2) \\end{cases} $$ 去掉同余，我们推出$x = k_1m_1+b_1 = k_2m_2+b_2$。然后后面的部分可以变型成$k_1m_1 -k_2m_2 = b_2-b_1$，然后你发现这坨东西又可以exgcd……于是我们求出了上面那个二元一次不定方程的一组最小非负整数解$k_1,k_2$。设$x’ = k_1m_1+b_1,m’ = \\text{lcm}(m_1,m_2)$。 我们假设$k_1m_1+b_1 \\equiv k_2m_2+b_2 (\\text{mod }k)$成立，则条件是$m_1|k$且$m_2|k$。故可知最小的$k = m’$。故推出$x\\equiv x’ (\\text{mod }m’)$，也就是把两个方程合并成了一个。 最后只会剩下一个单变元模线性方程，你再exgcd一遍就解出来了。 然后你未免会发现上面的说法存在一些逻辑上的缺漏。没办法，水平有限，没法搞得太严谨，将就着理解，还是背代码更重要。 2 代码1234567891011121314151617181920212223242526272829303132333435/*解单变元模线性方程ax ≡ b*/LL gcd(LL a,LL b){return b ? gcd(b,a%b) : a;}void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(!b){ x = 1; y = 0; return; } _exgcd(b,a%b,x,y); LL tx = x; x = y; y = tx-(a/b)*y;}bool ExGcd(LL a,LL b,LL c,LL &amp;x,LL &amp;y,LL &amp;kx,LL &amp;ky){ LL g = gcd(a,b); if(c % g) return false; _exgcd(a,b,x,y); LL kc = c/g; x *= kc; y *= kc; kx = b/g; ky = a/g; return true;}/*ExCRT*/bool ExCRT(int n,LL &amp;x,LL *b,LL *m){ b[0] = 0; m[0] = 1; //x ≡ 0(mod 1) LL k0,ki,kk0,kki; for(int i=1;i&lt;=n;i++){ //合并方程 if(!ExGcd(m[0],m[i],b[i]-b[0],k0,ki,kk0,kki)) return false; //解不定方程 k0 %= kk0; b[0] += k0*m[0]; //x' = b0*k0*m0 m[0] = (m[i]*m[0])/gcd(m[i],m[0]); //m' = lcm(m0,mi) b[0] %= m[0]; //在取模意义下 b[0] = (b[0]+m[0])%m[0]; //搞成非负数 } x = b[0]; //x ≡ b0(mod 1) =&gt; x = b0 return true;} 参考资料：初等数论(1) - CDC $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/22/%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"title":"概率与期望","text":"x乙己是站着学数学而学会的唯一的人。他对人说话，总是满口四点共圆，叫人半懂不懂的。因为他姓x，别人便从描红纸上的“上巨佬x乙己”这半懂不懂的话里，替他取下一个绰号，叫作x乙己……接着便是难懂的话，什么“梅涅劳斯”，什么“斯特瓦尔特”之类，引得众人都哄笑起来：店内外充满了快活的空气…… 友情提示：引言与内容并不占边… 一 概率1 概念1-1 单位事件和事件空间倘若我们掷一枚硬币，记正面为$1$，反面为$0$，则可能的情况有$(1,0),(1,1),(0,1),(0,0)$。令$A=(x,y)|x,y\\in \\begin{Bmatrix} 0,1\\end{Bmatrix}$，$S=\\begin{Bmatrix} (1,0),(1,1),(0,1),(0,0) \\end{Bmatrix}$，则$A$可以表示任意一种可能发生的情况，$S$可以表示所有可能性。我们称$A$为单位事件，$S$为事件空间。 1-2 独立事件若存在单位事件$A_1,A_2,…,A_n$，其中两两不同事件均没有交集，且满足$A_1\\cup A_2\\cup … \\cup A_n = S$，则称$A_1,A_2,…,A_n$为独立事件。 1-3 概率在事件空间内的某一事件发生的可能性大小被叫做该事件发生的概率。概率总是一个在$0\\text{~}1$之间的实数。 2 全概率公式设$S=\\begin{Bmatrix} A_1,A_2,…,A_n \\end{Bmatrix}$，其中$A_1,A_2,…,A_n$为独立事件，那么任意事件$B$发生的概率$P(B)$为“各独立事件发生的前提下，$B$发生的概率乘以各独立事件的概率，所得到的积之和”。用$P(B|A)$表示“各独立事件发生的前提下，$B$发生的概率”，那么公式即：$$ P(B) = P(B|A_1)\\times P(A_1) + P(B|A_2)\\times P(A_2) +…+ P(B|A_n)\\times P(A_n)$$ 二 期望1 概念对于一个事件$A$，它可能存在许多种可能性。把这些可能性的概率乘以它们分别的权值再求和，就成为这个事件的数学期望，也称期望。 举一个紫书上的例子：一个随机变量有1/2的机率等于1，有1/3的机率等于2，1/6的机率等于3，那么该随机变量的期望是$ (1/2)\\times 1 + (1/3)\\times 2 + (1/6)\\times 3 = 5/3 $。 2 线性性期望具有线性性（即可加性），而概率没有。因此对于若干个事件发生的期望，可以分开考虑每个事件发生的期望，最后再求和，即：$$E(A_1|A_2|…|A_n)=E(A_1)+E(A_2)+…+E(A_n)$$ 三 期望DP NOIP2016(TG) 换教室 对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。在可以选择的课程中，有2n节课程安排在 n 个时间段上。在第 i（1≤i≤n）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室c_i上课，而另一节课程在教室 &gt; d_i进行。在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 n 节安排好的课程。如果学生想更换第 i 节课程的教室，则需要提出申请。若申请通过，学生就可以在第 i 个时间段去教室 d_i上课，否则仍然在教室 c_i上课。由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 i 节课程的教室时，申请被通过的概率是一个已知的实数 k_i，并且对于不同课程的申请，被通过的概率是互相独立的。学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 m 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请自己最希望更换教室的 m 门课程，也可以不用完这 m 个申请的机会，甚至可以一门课程都不申请。因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。牛牛所在的大学有 v 个教室，有 e 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。 当第 i（1≤i≤n−1节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 1 状态设计设$f_{k,i,j}$为考虑前$i$节课，换$j$次教室，第$i$节课换$(k=0)$或不换$(k=1)$教室时，获得的最小期望。 转移1$f_{0,i,j}$可以由$f_{0,i-1,j}$①或$f_{1,i-1,j}$②转移过来。由①转移时，最近两节课（$i$和$i-1$）都在原先教室上的概率为$1$，期望为$\\text{dist}(c_{i-1},c_i) \\times 1$。由②转移时，上节课可能在教室$c_{i-1}$上，也就是没换成功；也可能在教室$d_{i-1}$上。期望为$\\text{dist}(d_{i-1},c_i) \\times k_{i-1} + \\text{dist}(c_{i-1},c_i) \\times (i-k_{i-1})$。方程：$$ f_{0,i,j} = \\min \\begin{cases} f_{0,i-1,j}+ \\text{dist}(c_{i-1},c_i) \\newline f_{1,i-1,j}+\\text{dist}(d_{i-1},c_i) \\times k_{i-1} + \\text{dist}(c_{i-1},c_i) \\times (i-k_{i-1}) \\end{cases} $$ 转移2同理$f_{1,i,j}$可以由$f_{0,i-1,j-1}$①或$f_{1,i-1,j-1}$②转移过来。①时，当前换教室申请可能被/不被通过，期望为$\\text{dist}(c_{i-1},d_i)\\times k_i + \\text{dist}(c_{i-1},c_i)\\times (1-k_i)$。②时，在上次换教室申请被/不被通过的前提下，当前换教室申请又可能被/不被通过，故一共四种情况，期望$E(2)$可由如下等式计算：$ \\begin{aligned} E(2) = &amp;\\text{dist}(c_{i-1},c_i)\\times (1-k_{i-1})\\times (1-k_i) \\newline &amp;+ \\text{dist}(c_{i-1},d_i)\\times (1-k_{i-1})\\times k_i \\newline &amp;+ \\text{dist}(d_{i-1},c_i)\\times k_{i-1}\\times (1-k_i) \\newline &amp;+ \\text{dist}(d_{i-1},d_i)\\times k_{i-1}\\times k_i\\end{aligned}$方程：$$ f_{1,i,j} = \\min \\begin{cases} f_{0,i-1,j-1} + \\text{dist}(c_{i-1},d_i)\\times k_i + \\text{dist}(c_{i-1},c_i)\\times (1-k_i) \\newline f_{1,i-1,j-1} + E(2) \\end{cases} $$ 2 细节处理dist()的处理使用Floyd求最短路，即可预处理出所有的$dist(i,j)$。 边界边界条件是$f_{0,1,0} = f_{1,1,1} = 0$，其余$f$值均为$\\infty$。 答案因为$m$次机会不一定全用完，故答案为$\\min\\limits_{1\\leqslant i \\leqslant m} f_{0,n,i},f_{1,n,i}$。转移的时候别忘了继承一下$j=0$的状态。 3 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN=310;const int CT=2010;const double INF=9876543.0;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n,m,v,e,c[CT],d[CT];double p[CT]; //p[]表示题目中的k[]int dist[CN][CN];double f[2][CT][CT];int main(){ memset(dist,0x01,sizeof(dist)); n=read(); m=read(); v=read(); e=read(); for(int i=1;i&lt;=n;i++) c[i]=read(); for(int i=1;i&lt;=n;i++) d[i]=read(); for(int i=1;i&lt;=n;i++) scanf(\"%lf\",&amp;p[i]); while(e--){ int x=read(),y=read(),z=read(); dist[x][y] = dist[y][x] = min(dist[x][y], z); //处理重边 } //floyd for(int i=1;i&lt;=v;i++) dist[i][i] = 0; for(int k=1;k&lt;=v;k++) for(int i=1;i&lt;=v;i++) for(int j=1;j&lt;=v;j++) dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]); //dp for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=m;j++) f[0][i][j] = f[1][i][j] = INF; f[0][1][0] = f[1][1][1] = 0.0; for(int i=2;i&lt;=n;i++){ f[0][i][0] = f[0][i-1][0] + dist[c[i-1]][c[i]]; //j=0的情况 for(int j=1;j&lt;=min(i,m);j++){ int&amp; cp=c[i-1],cc=c[i],dp=d[i-1],dc=d[i]; //声明引用 f[0][i][j] = min(f[0][i-1][j] + dist[cp][cc], f[1][i-1][j] + dist[cp][cc]*(1-p[i-1]) + dist[dp][cc]*p[i-1] ); f[1][i][j] = min(f[0][i-1][j-1] + dist[cp][cc]*(1-p[i]) + dist[cp][dc]*p[i], f[1][i-1][j-1] + dist[cp][cc]*(1-p[i-1])*(1-p[i]) + dist[cp][dc]*(1-p[i-1])*p[i] + dist[dp][cc]*p[i-1]*(1-p[i]) + dist[dp][dc]*p[i-1]*p[i] ); } } double ans=INF; for(int i=0;i&lt;=m;i++) //取min ans = min(ans, min(f[0][n][i], f[1][n][i])); printf(\"%.2lf\",ans); return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/05/26/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"},{"title":"概率期望学习笔记","text":"众所周知，一个随机变量 $x$ 的数学期望定义为 $E(x)$，即是 $E(x)traodinary$ 的缩写形式，代表 $x$ 是一个非凡的数字…… 概念随机变量 $x$ 的数学期望 $E(x)$ 定义为 $x$ 的每种取值的概率加权和，可以理解为 $x$ 在平均情况下的取值，我们一般称其为「期望取值」。举个例子，若 $x$ 有 $1/3$ 的概率为 $1$，有 $2/3$ 的概率为 $2$，则 $E(x)=1/3+2\\times (2/3)=5/3$。 线性性根据乘法结合律以及分配律，可以发现期望具有线性性，可以将其理解为「元素和的期望等于元素期望的和」，亦即：$$ E(\\Sigma x_i)=\\sum E(x_i) $$ 设 $c$ 为常量，也容易验证：$$E(x+c)=E(x)+c$$ 一道简单题 有一个长度为 $n$ 的数列，一开始所有位置都未被访问。每次随机一个未被访问过的位置，将它和它之前的位置都标记为访问过，问期望操作次数。$n\\le 10^{18}$ 考虑期望的线性性，答案就等于每个位置能被访问到的概率。一个位置 $i$ 能被访问到当且仅当它在所有它后面的数之前被访问，这个概率是 $\\frac{1}{n-i+1}$，因此容易发现答案是调和级数 $H_n$，使用近似公式计算即可。 又一道简单题 有一个 $n$ 个节点的有根树，一开始所有节点都未被访问。每次随机一个未被访问过的节点，将它到根的路径上所有点都标记为访问过，问期望操作次数，对 $998244353$ 取模。$n\\le 10^7$ 仿照上题，容易发现答案是 $\\sum\\limits_{i=1}^n\\frac{1}{sz[i]}$，其中 $sz[i]$ 表示子树 $i$ 的大小，线性求逆即可。 双一道简单题 $n$ 堆石子，每堆有 $a_i$ 个，每次随机选一个石子，并取光它所在的那堆石子。问第一堆石子被取到的时间的期望。$n\\le 10^5$ 根据期望的线性性，答案等于每堆石子在 $1$ 之前取到的期望之和，即 $1+\\sum\\limits_{i=2}^n\\frac{a_i}{a_1+a_i}$，线性计算即可。 叒一道简单题 一个 $n$ 面的骰子，问每一面都被掷到的期望投掷次数。$n\\le 10^{18}$ 此类问题被称作「赠券收集问题」。设 $f[n]$ 为 $n$ 面掷出后还需投掷的次数的期望，易得 $f[i]=\\frac{i}{n}f[i]+\\frac{n-i}{n}f[i+1]+1$，整理得 $f[i]=f[i+1]+\\frac{n}{n-i}$，从而有 $f[0]=nH_n$，利用公式计算即可。 一道栗题 一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。求该 01 串的价值的期望。$n\\le 10^5$ 设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：$$ \\begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \\newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \\end{aligned}$$ 于是可以做到 $O(n)$ 求出答案。注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。 又一道栗题 给定一颗 $n$ 个节点的有根树，$1$ 号节点为根，树上的每个节点 $u$ 都有一个权值 $c_u$。你需要随机一个节点的排列 $P\\in [n]$， 并且按这个排列的顺序依次访问所有树上的节点。每当访问到树上的一个节点 $u$ 时，你需要将子树 $u$ 内所有节点的权值加上 $c_u$（包括点 $u$）。问在一切的操作结束之后所有节点权值之和的期望。由于期望可能不是一个整数，请将它乘上 $n!$，并对 $10^9+7$ 取模。$n\\le 10^5$, 且保证树的形态随机 根据期望的线性性，我们只需要求出每个节点最后的期望权值即可。设这个东西是 $a_u$ ，容易发现 $a_u$ 的取值只与从根到 $u$ 的这一条祖孙链上的节点有关。因为树的形态随机，所以树高是期望 $O(\\sqrt{n})$ 的。设祖孙链长为 $d$，那么只需考虑 $O(d)$ 地求出 $a_u$ 即可。运用贡献法考虑：期望权值 = $Σ$权值$×$期望累加次数，那么考虑预处理一个 $t[]$，使得 $a_u=\\sum c_v·t_v$ 即可。 容易发现 $t_v$ 的取值只与 $u,v$ 的相对距离有关，则可以设 $f_i$ 表示考虑随机访问一个有 $n$ 位的序列 $a_1,a_2,…,a_n$，$a_1$ 在 $i$ 上的期望累加次数。考虑一次累加应当是什么样子： $1\\to p_1\\to p_2\\to …\\to i$，且满足 $1&lt;p_1&lt;p_2&lt;…&lt;i$。这显然双射了一个上升子序列（IS）。则 $f_i$ 即代表考虑所有 $P\\in [i]$，$P$ 中以 $1$ 起始的 IS 的期望数量。这样我们可以直接拿组合数选出来，即有：$$ f_i=\\sum\\limits_d \\dbinom{i-1}{d-1}\\dbinom{i}{d}(i-d)! $$ 于是就可以计算了，时间复杂度 $O(n\\sqrt{n})$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e5 + 6;const int P = 1e9 + 7;class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int qp(int a,int b) {int r = 1; while(b) {if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P; b &gt;&gt;= 1;} return r;}int n, a[CN], fac[CN], ifac[CN], f[CN];int C(int n, int m) {return 1ll * (1ll * fac[n] * ifac[m] % P) * ifac[n - m] % P;}int stk[CN], ans = 0;void dfs(int u, int p, int dep){ stk[dep] = a[u]; for(int i = dep, j = 1; i; i--, j++) ans = (1ll * stk[i] * f[j] % P + ans) % P; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p) dfs(v, u, dep + 1); }}int main(){ n = read(); for(int i = 1; i &lt; n; i++) {int u = read(), v = read(); add(u, v), add(v, u);} for(int i = 1; i &lt;= n; i++) a[i] = read(); fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = 1ll * fac[i - 1] * i % P; ifac[n] = qp(fac[n], P - 2); for(int i = n - 1; i; i--) ifac[i] = 1ll * (i + 1) * ifac[i + 1] % P; for(int i = 1; i &lt;= 5000; i++){ for(int d = 1; d &lt;= i; d++){ int prd = 1ll * C(i - 1, d - 1) * C(i, d) % P; prd = 1ll * prd * fac[i - d] % P, f[i] = (f[i] + prd) % P; } f[i] = 1ll * f[i] * ifac[i] % P; } for(int i = 1; i &lt;= n; i++) ans = (ans + a[i]) % P; dfs(1, 0, 1), ans = 1ll * ans * fac[n] % P; printf(\"%d\", ans);} 双一道栗题 有 $n$ 种方法，每种方法需要 $k_i$ 条途径，第 $j$ 条途径有 $p[i,j]$ 的概率无法使用。每次可以查询任意一条途径可否使用，直到查询到一种能使用的方法，求最小的“最少查询次数的期望”。$n,k_i \\le 500$ 容易发现对于任意一种方法，如果不将其全部查询完，那么这次查询是无意义的。对于任意一种方法，我们应当按照 $p[i,j]$ 降序排序的顺序去查询。假定 $\\forall i$，$p[i,j]$ 已经降序排序为 $p_1,p_2,…p_{k_i}$，那么考虑对所有方法进行排列，设 $E_i$ 为考虑 $[1:i]$ 中的方法时的答案，则有：$$\\begin{aligned} E_i&amp;=p_1(1+E_{i-1}) + p_2(1-p_1)(2+E_{i-1})+…\\newline &amp;=k_iE_{i-1}+b_i \\end{aligned} $$ 注意到还有 $\\prod\\limits_j (1-p_j)$ 的概率本次查询不会停止，把这部分加到常数项即可。于是变成了一次函数嵌套的最小值问题，按 $(k_i-1)/b_i$ 升序排序即可，时间复杂度 $O(\\sum k_i + n\\log n)$。 代码： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define DB doubleconst int CN = 550;const DB EPS = 1e-9;int n, m, id[CN]; DB k[CN], b[CN], p[CN];bool cmp(DB x, DB y) {return x &gt; y;}bool comp(int i, int j) {return k[i] * b[j] + b[i] &lt; k[j] * b[i] + b[j];}int main(){ n = read(); for(int i = 1; i &lt;= n; i++){ m = read(); for(int j = 1; j &lt;= m; j++) scanf(\"%lf\", &amp;p[j]); sort(p + 1, p + m + 1, cmp); DB prd = 1.0; if(p[1] &gt; 1.0 - EPS) {i--, n--; continue;} while(m &amp;&amp; p[m] &lt;= EPS) m--; for(int j = 1; j &lt;= m; j++) k[i] += p[j] * prd, b[i] += p[j] * prd * j, prd *= (1.0 - p[j]); b[i] += m * prd, id[i] = i; } sort(id + 1, id + n + 1, comp); DB ans = 0; for(int i, p = n; p; p--) i = id[p], ans = k[i] * ans + b[i]; printf(\"%.9lf\", ans);}","link":"/2020/09/13/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"矩阵基础","text":"又是一个乱堆一气的文章…索引：矩阵的加减乘运算，矩阵快速幂，矩阵加速线性递推…… 一 基础知识1 概念一个$n\\times m$的数阵被称作矩阵（matrix）。举个栗子，就像下面这样：$$ \\begin{bmatrix} 1&amp;2&amp;3 \\newline 4&amp;5&amp;6 \\newline 7&amp;8&amp;9 \\newline 10&amp;11&amp;12 \\end{bmatrix} $$矩阵可以用大写字母表示，像这样：$$ A = \\begin{bmatrix} 1&amp;2&amp;3 \\newline 4&amp;5&amp;6 \\newline 7&amp;8&amp;9 \\newline 10&amp;11&amp;12 \\end{bmatrix} $$$A_{i,j}$表示矩阵第$i$行第$j$列的元素，如$A_{3,2} = 8$。 主对角线形如$A_{i,i}$的元素所组成的一条矩阵的对角线被称为矩阵的主对角线。 矩阵的阶$n$行$m$列的矩阵被称为$n\\times m$阶矩阵。如上面的$A$矩阵是$4\\times 3$阶矩阵，注意这里的$\\times$符号不表示相乘，就是说$3\\times 4$和$4\\times 3$不是同一个阶数。 2 加减运算两个阶数相同的矩阵可以进行加减法，就像这样：若$ A = \\begin{bmatrix} 1&amp;2&amp;3 \\newline 4&amp;5&amp;6 \\end{bmatrix} $，$ B = \\begin{bmatrix} 7&amp;8&amp;9 \\newline 10&amp;11&amp;12 \\end{bmatrix} $则$A+B = \\begin{bmatrix} 1+7 &amp; 2+8 &amp; 3+9 \\newline 4+10 &amp; 5+11 &amp; 6+12 \\end{bmatrix} = \\begin{bmatrix} 8 &amp; 10 &amp; 12 \\newline 14 &amp; 16 &amp; 18 \\end{bmatrix}$$A-B = \\begin{bmatrix} 1-7 &amp; 2-8 &amp; 3-9 \\newline 4-10 &amp; 5-11 &amp; 6-12 \\end{bmatrix} = \\begin{bmatrix} -6 &amp; -6 &amp; -6 \\newline -6 &amp; -6 &amp; -6 \\end{bmatrix}$ 由上也可知，矩阵的加法是满足交换律的。 3 矩阵相乘仅有形如这样的两个矩阵可以进行乘法：$n\\times k$阶矩阵$A$和$k\\times m$阶矩阵$B$。它们的乘积会是一个$n\\times m$阶矩阵。 满足相乘条件的矩阵的乘法原则是：若$C = A\\times B$，则有$C_{i,j} = \\sum\\limits_{u = 1}^k A_{i,u}·B_{u,j}$。一个例子：$$ \\begin{bmatrix} 1&amp;2&amp;3 \\newline 4&amp;5&amp;6 \\end{bmatrix} \\times \\begin{bmatrix} 1&amp;2 \\newline 3&amp;4 \\newline 5&amp;6 \\end{bmatrix} = \\begin{bmatrix} 22 &amp;28 \\newline 49&amp;64 \\end{bmatrix}$$具体的运算细节如下图： 注意：矩阵乘法是不满足交换律的！ 二 矩阵快速幂1 理论快速幂能在较短的时间内求出$a^b$的值，是因为巧妙的把$b$进行了二进制分解并划分了求$a^b$的子问题。 那么对于矩阵而言，可不可以用类似于快速幂的办法快速的求出$n\\times n$阶矩阵$A$的幂次$A^b$的值呢？注意：因为矩阵乘法的限制，只有阶数形如$n\\times n$的矩阵有幂运算。 显然是可以的，这里有一份快速幂代码： 123456789LL QuickPow(LL a,LL b){ LL base = a,rec = 1; while(b){ if(b &amp; 1) rec *= base; base *= base; b &gt;&gt;= 1; } return rec;} 我们把里面的a、base、rec假想成一个矩阵，那么rec *= base、base *= base我们都可以实现。唯一的问题是rec = 1应该怎么定义？ 抛开矩阵，”1”应该满足的条件是：对于任意非零实数$a$，有$a\\times 1 = a$。回到矩阵上来，”1”矩阵$base$应该满足的条件是：对于任意非零矩阵$A$，有$A\\times base = A$。 假如$A$为$n\\times m$阶，那么显然$base$应该是$m\\times m$阶，否则得到的积矩阵不会是$n\\times m$阶的。进一步研究发现：$base$应该是一个主对角线为$1$，其余元素都为$0$的矩阵，像这样：$\\begin{bmatrix} 1&amp;0&amp;0 \\newline 0&amp;1&amp;0 \\newline 0&amp;0&amp;1 \\end{bmatrix}$（当$m = 3$时）。 2 代码于是我们得到矩阵快速幂的代码：模板 1234567891011121314151617181920212223242526272829303132333435#define LL long longconst int CN = 101;const int R = 1e9+7; //结果对 R 取模class matrix{ //定义一个矩阵 public: LL a[CN][CN]; int n,m; //n*m阶 //matrix() {memset(a,0,sizeof(a)); n=m=0;} //matrix(int nn,int mm) {memset(a,0,sizeof(a));n = nn; m = mm;} void MakeOne(){ //构造 \"1\" 矩阵 for(int i=1;i&lt;=m;i++) a[i][i] = 1; } matrix operator *(const matrix&amp; b)const{ //重定义乘法 // n*m x b.n*b.m =&gt; n*b.m // k = m = b.n matrix rec = (matrix){{{0}},n,b.m}; //乘法运算的答案 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int k=1;k&lt;=b.m;k++) (rec.a[i][k] += (a[i][j]*b.a[j][k])%R) %= R; return rec; } void operator *=(const matrix&amp; b) {*this = (*this)*b;} //重定义乘法};//矩阵快速幂matrix MatrixQuickPow(matrix &amp;mr,LL k){ matrix rec = (matrix){{{0}},mr.m,mr.m}; //构造 '1' 矩阵 rec.MakeOne(); //构造 '1' 矩阵 while(k){ //类似于普通的快速幂 if(k &amp; 1) rec *= mr; mr *= mr; k &gt;&gt;= 1; } return mr = rec;} 时间复杂度大概是$O(k \\log_2 b)$，其中$k$是一次矩阵乘法的复杂度，大概是$n^3$级别（$n$是阶数）。 三 矩阵加速线性递推矩阵快速幂可以被用来优化递推。实际上并不是只能优化线性递推，一个非线性递推的例子：请在本站搜索“摆花”。 1 斐波那契数列问题众所周知的斐波那契数列（Fibonacci Sequence），它的递推式是这样的：$f_1 = f_2 = 1,f_i = f_{i-1} + f_{i-2}(i&gt;2)$。 若求$f_i$项的值，朴素的想法是$O(i)$递推。有没有什么$\\log$级别的算法呢？ 我们不妨定义一些矩阵：设矩阵$F(i) = \\begin{bmatrix} f_i&amp;f_{i-1} \\end{bmatrix}$，有没有可能从$F(i-1)$推出$F(i)$呢？ 假设存在矩阵$base$，使$F(i-1)\\times base = F(i)$。不难发现$F(i-1)\\times base^2 = F(i+1)$，于是有一般规律$F(i)\\times base^k= F(i+k)$，即可得$F(2)\\times base^{i-2}= F(i)$。 我们知道$F(2) = \\begin{bmatrix} 1&amp;1 \\end{bmatrix}$，而在式子$F(2)\\times base^{i-2}= F(i)$中，后面的$base^{i-2}$是可以利用矩阵快速幂快速求得的。于是我们有了一种想法：假如知道$base$，我可以在$\\log$级别的时间复杂度里推出$F(i)$，进而推出$f_i$。 $base$所满足的条件是$F(i-1)\\times base = F(i)$，即$\\begin{bmatrix} f_{i-1}&amp;f_{i-2} \\end{bmatrix} \\times base=\\begin{bmatrix} f_i&amp;f_{i-1} \\end{bmatrix}$。至少$base$应该是一个$2\\times 2$阶的（请注意推广到一般形式，如果$F(i)$是$1\\times n$阶的呢？），否则两矩阵相乘得不到一个$2\\times 2$阶矩阵。 我们知道：$f_{i-1}\\times 1+f_{i-2}\\times 1 = f_i,f_{i-1}\\times 1+f_{i-2}\\times 0 =f_{i-1}$。即：$$F(i-1)\\times \\begin{bmatrix} 1\\newline 1 \\end{bmatrix} = f_i $$ $$ F(i-1)\\times \\begin{bmatrix} 1\\newline 0 \\end{bmatrix} = f_{i-1} $$故有：$F(i-1)\\times \\begin{bmatrix} 1&amp;1\\newline 1&amp;0 \\end{bmatrix} = F(i)$，即$base = \\begin{bmatrix} 1&amp;1\\newline 1&amp;0 \\end{bmatrix}$。 于是利用式子$F(2)\\times base^{i-2}= F(i)$，我们就求出$F(i) = \\begin{bmatrix} f_i&amp;f_{i-1} \\end{bmatrix}$。再求$f_i$就简单不过了。 注意：当递推式不同时，$base$的值是会变的。 代码模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define LL long longconst int CN = 101;const LL R = 1e9+7;class matrix{ //定义矩阵 public: LL a[CN][CN]; int n,m; //matrix() {memset(a,0,sizeof(a)); n=m=0;} //matrix(int nn,int mm) {memset(a,0,sizeof(a));n = nn; m = mm;} void MakeOne(){ for(int i=1;i&lt;=m;i++) a[i][i] = 1; } matrix operator *(const matrix&amp; b)const{ // n*m x b.n*b.m =&gt; n*b.m // k = m = b.n matrix rec = (matrix){{{0}},n,b.m}; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int k=1;k&lt;=b.m;k++) (rec.a[i][k] += (a[i][j]*b.a[j][k])%R) %= R; return rec; } void operator *=(const matrix&amp; b) {*this = (*this)*b;}}F,base;matrix MatrixQuickPow(matrix mr,LL k){ //矩阵快速幂 matrix rec = (matrix){{{0}},mr.m,mr.m}; //构造 '1' 矩阵 rec.MakeOne(); //构造 '1' 矩阵 while(k){ if(k &amp; 1) rec *= mr; mr *= mr; k &gt;&gt;= 1; } return rec;}//主求解函数LL f(LL i){ if(i &lt;= 2) return 1; //构造初始矩阵 F = (matrix){{{0}},1,2}; //F(2) F.a[1][1] = 1; F.a[1][2] = 1; //[f2 f1] //构造base base = (matrix){{{0}},2,2}; base.a[1][1] = base.a[1][2] = base.a[2][1] = 1; F *= MatrixQuickPow(base,i-2); return F.a[1][1]; //答案是矩阵第一行(一共只有一行...)第一个元素} 一个很有趣的结论：$ \\text{gcd}(f_a,f_b) = f_{\\text{gcd}(a,b)} $例题：LG P1306 2 推广假如现在不是斐波那契数列，而要求这么一个递推式在第$i$项的值：$f_1=f_2=f_3=1,f_x=f_{x-3}+f_{x-1} (x&gt;3)$，该怎么用矩阵加速呢？ 设矩阵$F(i) = \\begin{bmatrix} f_{i}&amp;f_{i-1}&amp;f_{i-2} \\end{bmatrix}$，则有$F(3) = \\begin{bmatrix} f_1&amp;f_2&amp;f_3 \\end{bmatrix}$。设$F(i)\\times base^k = F(i+k)$，则有$F(i) = F(3)\\times base^{i-3}$。通过上面的方法推导出$base = \\begin{bmatrix} 1&amp;1&amp;0 \\newline 0&amp;0&amp;1 \\newline 1&amp;0&amp;0 \\end{bmatrix}$（请自己手推一遍，按照上面的分别构造$f_i,f_{i-1},f_{i-2}$的方法！）。 然后求出第$i$项的值就是一个矩阵快速幂+矩阵乘法的事了。 代码模板 123456789101112131415161718192021222324#define LL long longconst int CN = 101;const LL R = 1e9+7;class matrix{ //定义矩阵 /*同上省略*/}F,base;matrix MatrixQuickPow(matrix mr,LL k){ //矩阵快速幂 /*同上省略*/}//主求解函数LL f(int i){ if(i &lt;= 3) return 1;//防止快速幂出锅(负数) //构造初始矩阵 F = (matrix){{{0}},1,3}; F.a[1][1] = F.a[1][2] = F.a[1][3] = 1; //构造base base = (matrix){{{0}},3,3}; base.a[1][1] = base.a[1][2] = base.a[2][3] = base.a[3][1] = 1; F *= MatrixQuickPow(base,i-3); return F.a[1][1]; } 3 再推广广义斐波那契数列问题： 广义的斐波那契数列是指形如$f_n=p\\times f_{n-1}+q\\times f_{n-2}$的数列。今给定数列的两系数$p$和$q$，以及数列的最前两项$f_1$和$f_2$，另给出两个整数$n$和$m$，试求数列的第$n$项$f_n$除以$m$的余数。 这个问题其实依然可以矩阵加速。设矩阵$F(i) = \\begin{bmatrix} f_i&amp;f_{i-1} \\end{bmatrix}$，有：$$ F(i-1) \\times \\begin{bmatrix} p\\newline q \\end{bmatrix} = f_i$$ $$ F(i-1) \\times \\begin{bmatrix} 1\\newline 0 \\end{bmatrix} = f_{i-1}$$ 所以就是$ F(i-1) \\times \\begin{bmatrix} p&amp;1\\newline q&amp;0 \\end{bmatrix} = F(i)$。 再套矩阵加速就跟板子一样了。 代码模板 1234567891011121314151617181920212223242526#define LL long longconst int CN = 3;LL R; //对 R 取余class matrix{ //定义矩阵 /*同上省略*/}F,base;matrix MatrixQuickPow(matrix mr,LL k){ //矩阵快速幂 /*同上省略*/}//主求解函数LL f(LL i,LL f1,LL f2,LL p,LL q){ //f_n = p·f_n-1 + q·f_n-2 if(i == 1) return f1; //特判 1 if(i == 2) return f2; //特判 2 //构造初始矩阵 F = (matrix){{{0}},1,2}; //F(2) F.a[1][1] = f2; F.a[1][2] = f1; //[f2 f1] //构造base base = (matrix){{{0}},2,2}; base.a[1][1] = p; base.a[1][2] = 1; base.a[2][1] = q; F *= MatrixQuickPow(base,i-2); return F.a[1][1]; } $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/30/%E7%9F%A9%E9%98%B5%E5%9F%BA%E7%A1%80/"},{"title":"线性筛","text":"貌似今天CCF倒闭了，不过还是要把学完的东西写完。感觉数论的好多东西都被我胡乱堆……索引：唯一分解定理与积性函数 + 线性筛素数 + 线性筛因子个数 + 线性筛因子和…… 一 引入1 唯一分解定理唯一分解定理就是说这么一个东西：任意一个自然数都可以被写成若干质数的幂次之积，就像下面这样： $$\\forall n\\in N, n = p_1^{a_1}\\times p_2^{a_2}\\times …\\times p_k^{a_k} $$ 其中$p$是质数，$a_k\\in N$。 根据唯一分解定理将一个整数拆分成若干质数的次幂之积的过程，被称作分解质因数。 2 积性函数对于一个函数$f(x)$，若对任意互质的两数$a,b$，有$f(a\\times b) = f(a)\\times f(b)$，则称$f(x)$为积性函数。例如：欧拉函数$\\varphi(x)$（定义为小于$x$的与$x$互质的数的个数），莫比乌斯函数等都是积性函数。积性函数总是可以通过线性的筛法求得的。 二 线性筛素数1 理论实际上也叫欧拉筛。其实在OI模板中有一份关于筛素数的代码，实际上那个是Eratosthenes筛，这个是$O(n\\log\\log n)$，并不是严格的线性筛法。 欧拉筛的想法是：对于每个合数，只用它的一个质因数（实际上它的是最小质因子）把它筛掉。因此一个合数只会被筛一次，也就保证了严格的线性。 实际的做法是：用一个数$i$和小于$i$的且与$i$互质的所有质数（已经筛出）$\\text{prime}[j]$去筛$i\\times \\text{prime}[j]$。为什么这样做呢？前面说一个数只被它的最小质因子筛掉，而当$i$与$ \\text{prime}[j]$不互质时，假设存在一个比$\\text{prime}[j]$小的质数$\\text{prime}[k]$，那么$i\\times \\text{prime}[k]$一定是$\\text{prime}[j]$的倍数。换言之此时$\\text{prime}[j]$并不一定是$i\\times \\text{prime}[j]$的最小质因子。实际上这个这个结论是总成立的，即此时$\\text{prime}[j]$不是$i\\times \\text{prime}[j]$的最小质因子。因此只需枚举到$\\text{prime}[j]$与$i$不互质就好了。 具体的做法请见代码。 2 代码123456789101112131415161718const int CN = 1e7+7;int n,m;int prime[CN]; bool not_prime[CN]; //标记一个数字不是素数//线性筛素数not_prime[1] = true;for(int i=2;i&lt;=n;i++){ if(!not_prime[i]) prime[++prime[0]] = i; //记录素数 for(int j=1;j&lt;=prime[0] &amp;&amp; i*prime[j]&lt;=n;j++){ not_prime[i*prime[j]] = true; //筛，prime[j] 总是 i 的最小质因子 if(!(i % prime[j])) break; //欧拉筛之所以线性之处 /* i mod prime[i] = 0, 即 prime[j] 是 i 的质因子 也就说明对于其它的质数 prime[k], i*prime[k] 总会是 prime[j] 的倍数 那么就不需要继续用 prime[j] 继续往下筛了 */ }} 三 线性筛因子个数1 理论我们用$d(x)$表示$x$的因子个数。$d()$函数也是积性函数，因此可以线性筛。 若将$x$分解质因子，得$x = p_1^{a_1}\\times p_2^{a_2}\\times …\\times p_k^{a_k} $。每个质因子$p_i$可以产生$a_i+1$种不同的因子，即$p_i^0,p_i^1,…,p_i^{a_i}$。而任意若干上述“不同的因子”相乘又会得到新的因子，因此$x$共有$(a_1+1)·(a_2+1)·…·(a_k+1)$个因子，即$d(x) = (a_1+1)(a_2+1)…(a_k+1)$。 实际上可以表示成$d(x) = \\prod\\limits_{i=1}^k a_i+1$。 然后考虑如何线性筛。对于上面的欧拉筛代码，考虑在筛$i\\times \\text{prime}[j]$时求出$d(i\\times \\text{prime}[j])$。可以分类讨论： 若$i$与$\\text{prime}[j]$互质，则根据积性函数的定义可得$d(i\\times \\text{prime}[j]) = d(i)\\times d(\\text{prime}[j])$。 若$i$与$\\text{prime}[j]$不互质，首先$\\text{prime}[j]$一定是$i$的最小质因子，则根据$i = p_1^{a_1}\\times p_2^{a_2}\\times …\\times p_k^{a_k} $，可知$\\text{prime}[j]$会是质因数分解里面最小的那个质因子，也就是$p_1$。于是得$i\\times \\text{prime}[j] = i·p_1 = p_1^{a_1+1}\\times p_2^{a_2}\\times …\\times p_k^{a_k}$。原来的$d(i) = (a_1+1)(a_2+1)…(a_k+1)$，现在变成了$d(i) \\times \\text{prime}[j] = (a_1+2)(a_2+1)…(a_k+1)$，于是可知$d(i\\times \\text{prime}[j]) = d(i)/(a_1+1) \\times(a_1+2) $。这个最小质因子的指数$a_1$可以记录下来，设它是$m_i$，则有$d(i\\times \\text{prime}[j]) = d(i)/(m_i+1) \\times (m_i+2) $。 这个$m_i$也是可以线性推广到$m_{i\\times \\text{prime}[j]}$的。对于情况一，既然$\\text{prime}[j]$是$i\\times \\text{prime}[j]$的最小质因子，且又只乘了一个$\\text{prime}[j]$，显然有$m_{i\\times \\text{prime}[j]} = 1$；而对于情况二，从$i$变成$i\\times \\text{prime}[j]$，实际上是最小质因子又被乘了一遍，即它的指数又被加上了$1$，所以有$m_{i\\times \\text{prime}[j]} = m_i+1$。 于是我们就找到了一种线性筛因子个数的方法。 2 代码123456789101112131415161718192021222324252627const int CN = 1e7+7;int n,m;int prime[CN]; bool not_prime[CN];int d[CN],mi[CN]; //mi[x] 记录 x 的质因数分解中最小的质因子的指数//线性筛因子个数d()not_prime[1] = true;d[1] = 1; mi[1] = 0; // 1 仅有 1 个因子，质因数分解为任意负数的零次方for(int i=2;i&lt;=n;i++){ if(!not_prime[i]){ //记录素数 prime[++prime[0]] = i; d[i] = 2; mi[i] = 1; //素数仅有两个因子，质因数分解为自身的一次方 } for(int j=1;j&lt;=prime[0] &amp;&amp; i*prime[j]&lt;=n;j++){ /*prime[j] 一定是 i*prime[j] 的最小质因子*/ not_prime[i*prime[j]] = true; if(i % prime[j]){ //互质时，根据积性函数的特性推出 d[i*prime[j]] = d[i]*d[prime[j]]; mi[i*prime[j]] = 1; } else{ //不互质 d[i*prime[j]] = d[i]/(mi[i]+1) * (mi[i]+2); mi[i*prime[j]] = mi[i]+1; break; } }} 四 线性筛因子和1 理论设$D(x)$表示$x$的所有因子之和。$D()$函数同样是积性函数，可以进行线性筛。 同样，先推通项公式（貌似也可以叫它解析式…）。把$x$分解质因数，得$x = p_1^{a_1}\\times p_2^{a_2}\\times …\\times p_k^{a_k}$。$x$的所有因子应该是什么呢？同上所述，所有的形如$p_i^j (j\\in [0,a_i],i\\in [1,k])$的数都可以作为$x$的因子，但是这并不是全部。实际上，在其中任取若干个数$p_{i1}^{j1},p_{i2}^{j2},…$相乘，所得的积也会是$x$的一个因子。因此把所有可能的因子分组并根据乘法原理相乘，就得到$D(x) = (1+p_1^1+p_1^2+…+p_1^{a_1})(1+p_2^1+p_2^2+…+p_2^{a_2})…(1+p_k^1+p_k^2+…+p_k^{a_k})$。 也就是$D(x) = \\prod\\limits_{i=1}^k \\sum\\limits_{j=0}^{a_i} p_i^j$。 然后再考虑线性筛。设$\\text{prime}[j]$是$i$的最小质因子，枚举$i$，考虑$O(1)$推出$D(i\\times \\text{prime}[j])$。首先$\\text{prime}[j]$与$i$互质时显然可以直接相乘得到，不再多说。 不互质呢？观察$D(i)$和$D(i\\times \\text{prime}[j])$的通项表达式有什么区别？实际上是$D(i\\times \\text{prime}[j]) = D(i)/(1+p_1^1+p_1^2+…+p_1^{a_1}) \\times (1+p_1^1+p_1^2+…+p_1^{a_1+1})$。同样把后面的那个东西设作$w_i$，得到$D(i\\times \\text{prime}[j]) = D(i)/w_i \\times w_{i\\times \\text{prime}[j]}$。 此时实际上$w_{i\\times \\text{prime}[j]} = w_{i}\\times \\text{prime}[j] +1$；而对于互质的情况，有$w_{i\\times \\text{prime}[j]} = \\text{prime}[j] +1$。 因此我们找到了一种线性筛因子和的方法。 2 代码123456789101112131415161718192021222324252627const int CN = 1e7+7;int n,m;int prime[CN]; bool not_prime[CN];int D[CN],w[CN];//线性筛因子和D()not_prime[1] = true;D[1] = 1; w[1] = 1; for(int i=2;i&lt;=n;i++){ if(!not_prime[i]){ //记录素数 prime[++prime[0]] = i; D[i] = i+1; w[i] = i+1; //两个因子: 自身(i) + 1 } for(int j=1;j&lt;=prime[0] &amp;&amp; i*prime[j]&lt;=n;j++){ /*prime[j] 一定是 i*prime[j] 的最小质因子*/ not_prime[i*prime[j]] = true; if(i % prime[j]){ //互质时，根据积性函数的特性推出 D[i*prime[j]] = D[i]*D[prime[j]]; w[i*prime[j]] = prime[j]+1; //即最小质因子的零次方和一次方 } else{ //不互质 D[i*prime[j]] = D[i]/w[i] * (w[i]*prime[j]+1); w[i*prime[j]] = w[i]*prime[j]+1; break; } }} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/08/16/%E7%BA%BF%E6%80%A7%E7%AD%9B/"},{"title":"网络最大流","text":"此页面存在相关页面。关于费用流，请参见「最小费用最大流」。 任意一条网络流边可以描述为$x=(u,v,cap,flow)$。其中$u$为边的起点，$v$为边的终点，$cap$为流量限制，$flow$为当前流量…… 网络流简介 （来自OI Wiki） 一 基础内容任意一条网络流边可以描述为$x=(u,v,cap,flow)$。其中$u$为边的起点，$v$为边的终点，$cap$为流量限制，$flow$为当前流量。 反向边：对于任意一条有向边$e=(i,j,cap,flow)$，定义$e’=(j,i,0,-flow)$ 为它的反向边。注意，反向边在网络流图中是不真实存在的，它其实是一个反悔机制，因此它的流量限制为$0$。定义反向边的当前流量与其对应的正向边的当前流量互为相反数。 反向边图解，图片来自网络：图中，选择$u\\to v$和$p\\to v\\to u\\to q$两条增广路径，实际上等同于选择$u\\to q$和$p\\to v$两条增广路径。因为路径$u\\to v$和它的反向边$v\\to u$的流量之和总为$0$，同时被选中，则意味着这条边对实际流量其实是没有贡献的（这两条边的贡献等于流量之和，等于$0$）。实际上就变成了这两条边同时不被选中。 残量网络：对于图上的任意一条边（包括反向边），定义它们的流量限制与当前流量之差为其残量。一张网络流图上所有边的残量构成残量网络。 增广路：一条从原点（$s$）到汇点（$t$）的路径，并且这条路径上每条边（包括反向边）的残量均大于$0$。设$f_i$为这条路上最小的残量，那么这条增广路可以使得当前流量增加$f_i$。 增广路定理：一张网络流图的流量达到最大流当且仅当残量网络中不存在增广路。 最大流最小割定理：一张网络流图的最大流永远等于该图的最小割的总容量（蒟蒻的我不会证明）。对于割的定义，可以参考割点。 二 Edmond Karp算法1 流程于是我们可以得出最朴素的最大流算法（Edmond Karp，EK算法）。 从原点开始，每次找一条到汇点的增广路径，并进行一次增广。 从原点出发向汇点搜索，设$m_i$为$s\\to i$这条路上的最小残量$i$，$cap_e$为当前入边（$e$）的流量限制，$flow_e$为当前入边的当前流量，可以得到递推式如下：$$ m_i = \\min m_j,cap_e-flow_e | e=(j,i),e \\in E $$ 每次到达汇点，将答案增广$m_t$，一直到残量网络中不存在增广路。于是就可以达到最大流。 注意反向边的储存。边表存图时，定义正向边编号为偶数，它的下一条边就是它的反向边。编号从$0$开始，则$i \\text{xor} 1$总为$i$的对应边（正向边对应到反向，反向边对应到正向）。 2 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int CP=1e4+4;const int CE=2e5+5;const int INF=0x7f7f7f3f;//边表class fs{ public: int from,to; //起点，终点 int cap,flow; //cap容量上限，flow当前流量量 void init(int f,int t,int c,int fl){ from=f; to=t; cap=c; flow=fl; }}E[CE];vector&lt;int&gt; cde[CP]; //节点i的第j条边在E中的序号int ecnt=0;void add(int f,int t,int c){ E[ecnt].init(f,t,c,0); E[++ecnt].init(t,f,0,0); //反向边 ++ecnt; cde[f].push_back(ecnt-2); cde[t].push_back(ecnt-1); //反向边}int n,m,s,t;//edmonds karp int imp[CP]; //从起点出发的最小残量int p[CP]; //搜索树上进入节点的边的编号 int Augment(int s,int t){ memset(imp,0,sizeof(imp)); queue&lt;int&gt;Q; Q.push(s); imp[s]=INF; while(!Q.empty()) { int cur=Q.front(); Q.pop(); for(int k=0; k&lt;cde[cur].size(); k++) //遍历边表 { fs e=E[ cde[cur][k] ]; if(!imp[e.to] &amp;&amp; e.cap &gt; e.flow) { p[e.to]=cde[cur][k]; imp[e.to] = min(imp[cur], e.cap-e.flow); //满足比起点的残量小 Q.push(e.to); } } } return imp[t];}int ek(int s,int t){ int maxf=0; int aug=0; while(aug=Augment(s,t)) //增广到无法增广为止 { for(int cur=t; cur!=s; cur=E[p[cur]].from) //倒着搜索图 { E[p[cur]].flow += aug; E[p[cur]^1].flow -= aug; //反向边 } maxf+=aug; } return maxf;}int main(){ scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;s,&amp;t); while(m--) { int x,y,c; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;c); add(x,y,c); } printf(\"%d\",ek(s,t)); return 0;} 三 Dinic算法在稠密图中，dinic算法的复杂度要比EK高到不知道哪里去了。 1 思想dinic的主要思想是把一张网络流图分层，每次只往更深一层寻找增广路，以避免在同一层中绕圈子（这多半是无意义的）。每当分层图中找不到增广路，这意味着当前图中至少有一条边的流量已经达到限制。也就是说这条边“断了”。而一条断了的边会改变图的分层情况，所以这时重新分层，并继续寻找增广路。直到图上找不到一条$s\\to t$的可行路径。也就是说所有道路都断了。此时会在图上会表现为找不到汇点的所在层级，因为根本没有到达汇点。说的更透彻一点，此时实际上是最小割被完全切断（最大流最小割定理）。 使用bfs完成图的分层，利用dfs寻找增广路径。 2 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CP=1e4+4;const int CE=2e5+5;const int INF=0x7f7f7f3f;//边表class fs{ public: int to,nxt; //终点和下一条边的编号 int cap,flow; //cap限制，flow当前流 fs() {cap=flow=to=0; nxt=-1;} //初始化为-1，因为边的下标从0开始 void init(int t,int n,int c,int f){ to=t; nxt=n; cap=c; flow=f; }}E[CE];int hd[CP],ecnt;void E_init(){ memset(hd,-1,sizeof(hd)); ecnt=0;}void _add(int x,int y,int z){ E[ecnt].init(y,hd[x],z,0); hd[x]=ecnt++;}void add(int x,int y,int z){ _add(x,y,z); _add(y,x,0); //反向建边}//variable defineint n,m,s,t;//dinicint dep[CP]; //节点深度bool build(int s,int t) //bfs{ memset(dep,0,sizeof(dep)); //首先清零 dep[s]=1; //原点深度为1 queue&lt;int&gt;Q; Q.push(s); while(!Q.empty()) //广搜 { int u=Q.front(); Q.pop(); for(int k=hd[u]; k!=-1; k=E[k].nxt) //遍历边表 { fs e=E[k]; if(e.cap-e.flow&gt;0 &amp;&amp; !dep[e.to]) //当前边没有断，且终点没被分层 { Q.push(e.to); dep[e.to]=dep[u]+1; //那么就给终点分层 } } } return dep[t]&gt;0; //判断汇点的深度是不是初始值}int Augment(int u,int t,int rst) //dfs :u 节点编号，rst 找到的最小残量{ if(u == t) //已经到了汇点 return rst; //直接返回找到的最小残量 for(int k=hd[u]; k!=-1; k=E[k].nxt) //遍历边表 { fs e=E[k]; if(e.cap-e.flow&gt;0 &amp;&amp; dep[u]==dep[e.to]-1) //还有残量，并且在下一层 { int f=Augment(e.to,t, min(rst, e.cap-e.flow)/*从两个残量里面选一个小的*/); if(f) //能增广则增广，因为反向边保留了退路 { E[k].flow+=f; E[k^1].flow-=f; //反向边 return f; //继续向上层递归返回增广量 } } } return 0; //增广失败}int dinic(){ int max_flow=0,f; while(build(s,t)) //直到所有路径被切断 while(f=Augment(s,t,INF)) //直到不能增广（此处赋值语句兼用作判断真值），注意这里最小残量的初始值 max_flow+=f; //加上增广得到的解 return max_flow;}int main(){ E_init(); scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;s,&amp;t); while(m--) { int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); add(x,y,z); } printf(\"%d\",dinic()); return 0;} 3 优化3-1 多路增广上文中的代码一次搜索仅找出一条增广路，这样可能会在搜索时走很多重复的道路，造成一些常数负担。 所以每次在一条路上增广时，同时寻找多条增广路，直到干路的最小残量被用完或到达汇点时为止。这样可以避免重复走一条干路。也就是说，一次dfs搜索所有的增广路。 3-2 当前弧优化多路增广后，一条仍有残量却已经被增广的边是不可能继续被增广的，因为它所有的增广可能性已经被全部枚举了。所以继续dfs时，不需要再考虑这些边。所以设$cur_i$为新的边表表头，即以$i$为起点且没有被增广过的第一条边的编号，每次增广后更新$cur_i$即可。注意，每次重新构造分层图后，$cur_i$需复原，因为此时对于 任意一条边 的 任意一种增广可能性 都没有考虑。 3-3 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CP=1e4+4;const int CE=2e5+5;const int INF=0x7f7f7f3f;//边表class fs{ public: int to,nxt,cap,flow; fs() {to=cap=flow=0; nxt=-1;} void init(int t,int n,int c,int f){ to=t; nxt=n; cap=c; flow=f; }}E[CE];int hd[CP],ecnt=0;int cur[CP]; //当前弧优化，用来保存从i出发未增广的第一条边在边表中的下标void E_init(){ memset(hd,-1,sizeof(hd)); ecnt=0;}void _add(int x,int y,int z){ E[ecnt].init(y,hd[x],z,0); hd[x]=ecnt++;}void add(int x,int y,int z){ _add(x,y,z); _add(y,x,0); //反向边}//variable defineint n,m,s,t;void copy(int* a,int* b,int lenth){ //复制a[]到b[]中 for(int i=0;i&lt;=lenth;i++) b[i]=a[i];}//dinicint dep[CP];bool build(int s,int t) //构造分层图{ memset(dep,0,sizeof(dep)); dep[s]=1; queue&lt;int&gt;Q; Q.push(s); while(!Q.empty()) { int u=Q.front(); Q.pop(); for(int k=hd[u]; k!=-1; k=E[k].nxt) { fs e=E[k]; if(!dep[e.to] &amp;&amp; e.cap-e.flow&gt;0) { dep[e.to]=dep[u]+1; Q.push(e.to); } } } return dep[t]&gt;0;}int Augment(int u,int t,int rst) //多路增广{ if(u == t) //到达汇点 return rst; //返回最小残量 int used=0; //已经得到的增广量 for(int k=cur[u]; k!=-1; k=E[k].nxt) //当前弧优化 { cur[u]=k; //重新记录第一条边，赋值为k是因为这条边目前为止还未增广 fs e=E[k]; if(dep[e.to]==dep[u]+1 &amp;&amp; e.cap-e.flow&gt;0) { int f=Augment(e.to,t, min(rst-used, e.cap-e.flow)); if(f) { used+=f; //累加增广量 E[k].flow+=f; E[k^1].flow-=f; if(used == rst) //增广路的残量用完了 return used; //返回增广量 } } } return used; //搜索完毕，返回增广量}int dinic(){ int max_flow=0; while(build(s,t)) { copy(hd,cur,n); //复制cur的初始边 max_flow += Augment(s,t,INF); //一次完成所有增广 } return max_flow; }int main(){ E_init(); scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;s,&amp;t); while(m--) { int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); add(x,y,z); } printf(\"%d\",dinic()); return 0;} $$ - - - - \\mathcal{End} - - - - $$ 最近更新： 2020.8.9 优化页面结构","link":"/2019/02/23/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"title":"虚树","text":"众所周知，虚树是一类重构树，用于处理点数较多而关键点（有效点）数较少的树上问题。举个栗子，我们所熟知的后缀树就是一种虚树…… 定义给定点集 $V_k$ 代表有效点，我们定义一颗树 $T=(V,E)$ 是建立在 $V_k$ 上的虚树，当且仅当： $V_k\\subseteq V$ $\\forall x\\in V, x\\in V_k \\text{ or } \\exists u,v\\in V, \\text{s.t. } \\text{LCA}(u,v)=x$ $\\forall (u,v)\\in E, \\text{LCA}(u,v)=u\\text{ or }v$ 一句话来讲：虚数是关键点以及关键点的 LCA 构成的，保证原树的祖孙关系不变的重构树。 构建模仿笛卡尔树的构建，虚树的构建可以使用单调栈在 $O(|V_k|\\log |V|)$ 的时间内完成，其中 $\\log V$ 的复杂度是倍增 LCA 的复杂度。如果使用 $O(n)-O(1)$ 的 RMQ-LCA，则可以降至 $O(|V_k|\\log |V_k|)$，基本可以视作线性。这种方法一般被称为「单调栈维护右链」。 顾名思义，这种构建方法的本质就在于使用单调栈去维护虚数最靠右边的树链。容易得出这份代码： 1234567891011121314151617181920212223242526#include&lt;algorithm&gt;using std :: sort;const int CN = 1e5 + 5;class fs{} E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x, int y, int z) {}int lca(int u, int v) {}int a[CN], stk[CN], top = 0, dfn[CN];bool cmp(int i, int j) {return dfn[i] &lt; dfn[j];} // 按 dfs 序排序void bd(){ sort(a + 1, a + a[0] + 1, cmp); stk[top = 1] = 1, hd[1] = 0, ecnt = 0; for(int i = 1; i &lt;= a[0]; i++){ if(a[i] == 1) continue; int l = lca(a[i], stk[top]); if(l ^ stk[top]){ while(dfn[ stk[top - 1] ] &gt; dfn[l]) add(stk[top - 1], stk[top], 0), top--; if(l ^ stk[top - 1]) hd[l] = 0, add(l, stk[top], 0), stk[top] = l; else add(l, stk[top], 0), top--; } hd[ a[i] ] = 0, stk[++top] = a[i]; } for(int i = 1; i &lt; top; i++) add(stk[i], stk[i + 1], 0);} 一道栗题 $n$ 个点的树，边有边权。$q$ 次询问，每次给出 $k_i$ 个关键点，问切断多少边能使得关键点都不与 $1$ 号节点联通，最小化切断的边的边权。$n,q,\\sum k_i\\le 10^5$ 如果只有一次询问，则可以通过树上 DP 简单求出。注意到 DP 的过程中有效的点只有关键点和它们的 LCA，因此直接建出虚树 DP 即可，时间复杂度 $O(\\sum k_i\\log n)$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define int long longconst int CN = 3e5 + 5;const int INF = 0x3f3f3f3f3f3f3f3f;class fs {public: int to,nxt,w; void init(int t,int n,int d) {to = t, nxt = n, w = d;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}int n, m, mn[CN], dep[CN], fa[CN][21], dfn[CN], idx = 0;void dfs(int u, int p){ // 预处理 fa[u][0] = p, dep[u] = dep[p] + 1, dfn[u] = ++idx; for(int k = hd[u]; k; k = E[k].nxt) {int v = E[k].to; if(v ^ p) mn[v] = min(mn[u], E[k].w), dfs(v, u);}}int lca(int x, int y){ // 倍增 LCA if(dep[x] &lt; dep[y]) swap(x, y); for(int k = 20; k + 1; k--) if(dep[ fa[x][k] ] &gt;= dep[y]) x = fa[x][k]; if(x ^ y){ for(int k = 20; k + 1; k--) if(fa[x][k] ^ fa[y][k]) x = fa[x][k], y = fa[y][k]; x = fa[x][0]; } return x;}int a[CN], stk[CN], top = 0;bool cmp(int i, int j) {return dfn[i] &lt; dfn[j];}void bd(){ // 建立虚树 sort(a + 1, a + a[0] + 1, cmp); stk[top = 1] = 1, hd[1] = 0, ecnt = 0; // 小心翼翼的初始化 for(int i = 1; i &lt;= a[0]; i++){ if(a[i] == 1) continue; int l = lca(stk[top], a[i]); if(l ^ stk[top]){ while(dfn[ stk[top - 1] ] &gt; dfn[l]) add(stk[top - 1], stk[top], 0), top--; if(l ^ stk[top - 1]) hd[l] = 0, add(l, stk[top], 0), stk[top] = l; else add(l, stk[top], 0), top--; } hd[ a[i] ] = 0, stk[++top] = a[i]; // 小心翼翼的初始化 } for(int i = 1; i &lt; top; i++) add(stk[i], stk[i + 1], 0);}int f[CN]; bool is[CN];void dp(int u, int p){ // DP f[u] = mn[u]; int sum = 0; // 小心翼翼的初始化 for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p) dp(v, u), sum += f[v]; } if(!is[u]) f[u] = min(f[u], sum);}signed main(){ n = read(); for(int i = 1; i &lt; n; i++) {int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w);} mn[1] = INF, dfs(1, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; memset(hd, 0, sizeof(hd)), ecnt = 0; m = read(); while(m--){ a[0] = read(); for(int i = 1; i &lt;= a[0]; i++) a[i] = read(), is[ a[i] ] = true; bd(), dp(1, 0), printf(\"%lld\", f[1]), puts(\"\"); for(int i = 1; i &lt;= a[0]; i++) is[ a[i] ] = false; // 小心翼翼的清空标记 }} 又一道栗题 $n$ 个点的树，$q$ 次询问，每次给出 $k_i$ 个关键点，问切断多少点能使得关键点互不相连，无解输出 -1。$n,q,\\sum k_i\\le 10^5$ 依然沿用上题的思路，只不过在树上 DP 的时候细节较多。可以维护一个 $g[u]$ 表示子树 $u$ 中是否还存在与 $u$ 相连的关键点，在转移时分类讨论即可，时间复杂度 $O(\\sum k_i\\log n)$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e5 + 5;class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int n, q;int dep[CN], fa[CN][21], dfn[CN], idx = 0;void dfs(int u, int p){ fa[u][0] = p, dep[u] = dep[p] + 1, dfn[u] = ++idx; for(int k = hd[u]; k; k = E[k].nxt) {int v = E[k].to; if(v ^ p) dfs(v, u);}}int lca(int u, int v){ if(dep[u] &lt; dep[v]) swap(u, v); for(int k = 20; k + 1; k--) if(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k]; if(u ^ v){ for(int k = 20; k + 1; k--) if(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][0]; } return u;}int stk[CN], top = 0, a[CN];bool cmp(int i, int j) {return dfn[i] &lt; dfn[j];}void bd(){ sort(a + 1, a + a[0] + 1, cmp); stk[top = 1] = 1, hd[1] = 0, ecnt = 0; for(int i = 1; i &lt;= a[0]; i++){ if(a[i] == 1) continue; int l = lca(stk[top], a[i]); if(l ^ stk[top]){ while(dfn[ stk[top - 1] ] &gt; dfn[l]) add(stk[top - 1], stk[top]), top--; if(l ^ stk[top - 1]) hd[l] = 0, add(l, stk[top]), stk[top] = l; else add(l, stk[top]), top--; } hd[ a[i] ] = 0, stk[++top] = a[i]; } for(int i = 1; i &lt; top; i++) add(stk[i], stk[i + 1]);}int f[CN], g[CN]; bool is[CN];bool dp(int u, int p){ f[u] = g[u] = 0; int cnt = 0; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v == p) continue; if(!dp(v, u)) return false; f[u] += f[v], cnt += g[v]; if(is[u] &amp;&amp; is[v] &amp;&amp; dep[v] - dep[u] &lt;= 1) return false; // 无解 } if(is[u]) f[u] += cnt, g[u] = 1; // 讨论 u 的决策 else if(cnt &gt; 1) f[u]++; else if(cnt == 1) g[u] = 1; return true; // 有解}int main(){ n = read(); for(int i = 1; i &lt; n; i++) {int u = read(), v = read(); add(u, v), add(v, u);} dfs(1, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; q = read(); while(q--){ a[0] = read(); for(int i = 1; i &lt;= a[0]; i++) a[i] = read(), is[ a[i] ] = true; bd(); if(dp(1, 0)) printf(\"%d\", f[1]), puts(\"\"); else puts(\"-1\"); for(int i = 1; i &lt;= a[0]; i++) is[ a[i] ] = false; }} 双一道栗题 $n$ 个点的树，$q$ 次询问，每次给出 $k_i$ 个关键点，问关键点之间的两两距离和，距离最小值和距离最大值。$n,q,\\sum k_i\\le 10^5$ 距离最大 / 最小都可以简单维护，对于“距离和”这个问题，有一个常用方法是考虑每条边对答案的贡献。这就跟边有关系了，因此在建立虚树时不能再固定以 $1$ 号节点为根，简单维护一下树根即可，时间复杂度 $O(\\sum k_i\\log n)$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define int long longconst int CN = 1e6 + 6;const int INF = 0x3f3f3f3f3f3f3f3f;class fs {public: int to,nxt,w; void init(int t,int n,int d) {to = t, nxt = n, w = d;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}int n, q;int fa[CN][21], dep[CN], dis[CN], dfn[CN], idx = 0;void dfs(int u, int p){ fa[u][0] = p, dep[u] = dep[p] + 1, dfn[u] = ++idx; for(int k = hd[u]; k; k = E[k].nxt) {int v = E[k].to; if(v ^ p) dis[v] = dis[u] + E[k].w, dfs(v, u);}}int lca(int u, int v){ if(dep[u] &lt; dep[v]) swap(u, v); for(int k = 20; k + 1; k--) if(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k]; if(u ^ v){ for(int k = 20; k + 1; k--) if(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][0]; } return u;}bool cmp(int i, int j) {return dfn[i] &lt; dfn[j];}int stk[CN], top = 0, a[CN], rt; // rt 维护树根void bd(){ sort(a + 1, a + a[0] + 1, cmp); stk[top = 1] = a[1], hd[ a[1] ] = 0, ecnt = 0; for(int i = 2; i &lt;= a[0]; i++){ int l = lca(stk[top], a[i]); if(l ^ stk[top]){ while(dfn[ stk[top - 1] ] &gt; dfn[l]) add(stk[top - 1], stk[top], 0), top--; if(l ^ stk[top - 1]) hd[l] = 0, add(l, stk[top], 0), stk[top] = l; else add(l, stk[top], 0), top--; } hd[ a[i] ] = 0, stk[++top] = a[i]; } rt = stk[1]; for(int i = 1; i &lt; top; i++) add(stk[i], stk[i + 1], 0);}int mn[CN], mx[CN], sz[CN], amn, amx, ans, tmp1[4], tmp2[4]; bool is[CN];void dp(int u, int p){ if(!hd[u]) return (void)(mn[u] = mx[u] = 0, sz[u] = 1); mn[u] = INF, mx[u] = sz[u] = 0; int Mn = INF, pMn = INF, Mx = 0, pMx = 0; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to, d = dis[v] - dis[u]; if(v == p) continue; dp(v, u); mn[u] = min(mn[u], mn[v] + d), tmp1[0] = mn[v] + d, mx[u] = max(mx[u], mx[v] + d), tmp2[0] = mx[v] + d; sz[u] += sz[v]; ans += d * (a[0] - sz[v]) * sz[v]; // 计算距离和 tmp1[1] = Mn, tmp1[2] = pMn, tmp2[1] = Mx, tmp2[2] = pMx; sort(tmp1, tmp1 + 3), sort(tmp2, tmp2 + 3, greater&lt;int&gt;()); Mn = tmp1[0], pMn = tmp1[1], Mx = tmp2[0], pMx = tmp2[1]; } amn = min(amn, Mn + pMn), amx = max(amx, Mx + pMx); // 计算距离最大 最小 if(is[u]) sz[u]++, amn = min(amn, Mn), mn[u] = 0;}signed main(){ n = read(); for(int i = 1; i &lt; n; i++) {int u = read(), v = read(); add(u, v, 1), add(v, u, 1);} dfs(1, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; q = read(); while(q--){ a[0] = read(); for(int i = 1; i &lt;= a[0]; i++) a[i] = read(), is[ a[i] ] = true; bd(), amn = INF, amx = ans = 0; if(a[0] == 1) ans = amn = amx = 0; dp(rt, 0), printf(\"%lld %lld %lld\", ans, amn, amx), puts(\"\"); for(int i = 1; i &lt;= a[0]; i++) is[ a[i] ] = false; }}","link":"/2020/09/11/%E8%99%9A%E6%A0%91/"},{"title":"除夕闲扯","text":"请人为忽略与主题有关的内容，这其实是一个目录。 文化课真好系列为了证明 bn 还没入坟，他决定闲的没事瞎bb几句起名做：A Simple Proof of BN’s Aliving A Simple Proof of BN’s AlivingP1 Analyse the Problem该命题显然不成立。 P2 Conclusionbn 已经入坟，故证伪。 因 bn 已经入坟，所以他对之前的 post 们搞了一个整理，以备 后人之用 自己欣赏。 此页面存在相关页面。关于另一个集合贴，请参见「OI模板梳理」。 图论最短路 Dijkstra：OI模板梳理 2.1.1 SPFA: OI模板梳理 2.1.3 Floyd: Floyd本质探究-「题解」灾后重建 树 最小生成树(MST)：OI模板梳理 2.2，变形-CFR599D 0-1 MST 树的重心，树的直径 LCA: 倍增法-最近公共祖先，树链剖分法-树链剖分 3.1 树上类RMQ问题：树链剖分 连通性 强连通分量/SCC 双连通分量/BCC 割点和桥：双连通分量 2 2-SAT：2019.10 JN 总结.pdf 网络 最大流-最小割：网络最大流 最小费用最大流 二分图 最大匹配：匈牙利算法-二分图匹配，费用流法-最小费用最大流 4.1 最大点全覆盖集：最小费用最大流 4.2 最大独立集：最小费用最大流 4.3 欧拉图：欧拉路 拓扑：拓扑排序 数论线性筛 高斯消元：OI模板梳理 4.3 乘法逆元 费马小定理法-逆元 exgcd法-模线性方程组与中国剩余定理 2 线性求逆元-逆元 2.3 欧几里得系列：欧几里得与扩展欧几里得定理 中国剩余定理系列：模线性方程组与中国剩余定理 矩阵系列：矩阵基础 概论系列：概率与期望 组合学系列：组合数学基础 数据结构单调栈：音乐会的等待 单调队列，对DP的优化-「题解」Watching Fireworks is Fun 堆：OI模板梳理 1.3，或pq一行完成 并查集：OI模板梳理 1.4 树状数组 线段树，线段覆盖-「题解」Atlantis 数列差分 DP背包，变式-「题解」硬币购物 树形DP，变式-「题解」重建道路 状压DP 优化：单调队列优化-「题解」Watching Fireworks is Fun，矩阵乘法优化-「题解」摆花 其他DP内容，请参见标签：DP 其它字符串：KMP-KMP算法 关于本博客的内容，顺便还有之前的Icarus魔改教程，教你一步步走向深渊。 顺便一说，bn 的 luogu 还没有掉蓝（珂怕）。 以上 祝各位新春快乐qwq. $$ - - - - \\mathcal{End} - - - - $$","link":"/2020/01/24/%E9%99%A4%E5%A4%95%E9%97%B2%E6%89%AF/"},{"title":"树链剖分","text":"树链剖分是一种针对树上问题的很优秀的处理想法。准确的说，它就是一种把“树”映射成“链”的想法。而对于“链”，我们能进行很多处理，诸如挂上线段树，维护前缀和之类。通过这些优秀的数据结构，我们就可以很好的解决有关树上路径的诸多问题…… 封面来自unsplash.com。 一 引入1 模型对于区间求和、区间最值问题，我们有一个很好的数据结构模型——线段树来解决。但是如果我们把区间换成在一棵树上呢？ 维护一棵树，树上的每个点都有一个权值，支持修改树上任意一个点对的路径上，所有点的权值和以任意一个节点为根的子树上所有点的权值，查询任意一个点对的路径上的权值和和以任意一个节点为根的子树上的权值和 怎样解决？这时就需要引入“树链剖分”这一概念，即破树为链，再在链上维护线段树。 还有一类问题，是维护树上的边权。不难发现树上除根以外的所有节点 和 它的父节点的边总是唯一的，那么我们可以把边权看作点权，也就是让$v$的点权等于$u\\to v$的边权（$u$是$v$的父节点），再修改一下细节就好了。 2 概念学习树链剖分需要先引入几个概念： 重儿子（$\\text{prv}[i]$）：节点$i$的子节点中，子树大小最大的那一个。 重链：一个节点的重儿子，重儿子的重儿子，……，组成的链。 $\\text{sz}[i]$：以节点$i$为根的子树的大小（节点数量）。 $\\text{prv}[i]$：节点$i$的父节点。 $\\text{dep}[i]$：节点$i$在树上的深度（定义根的深度为$1$）。 $\\text{pos}[i]$：节点$i$映射在线段树上的节点编号，编号按照dfs的先后顺序从小到大编排。 $\\text{tid}[i]$：线段树上的节点$i$映射在原树上的节点编号，与$\\text{pos}[i]$互为反函数。 $\\text{top}[i]$：节点$i$所在的重链上，深度最低的那个节点（也可以看作重链的根）。 如下图，标记出了一棵树上的所有重链（注意，每个节点都必定在一条重链上）与重链的根，每个节点的重儿子，节点的深度、子树大小和编号（$\\text{pos}[i]$）。 注意：我们对节点进行编号的时候，优先dfs遍历当前节点的重儿子，这样就可以保证一条重链上的编号总是连续的。 二 实现1 思想那么怎么实现上面的问题呢？ 在处理出节点的dfs编号之后，我们不妨把这$n$个编号当作区间，把每条重链映射在这个区间上，如下图： 显然我们可以用线段树去维护这个区间，然后我们就可以快速的求出一条重链上任意一个点对间所有点的权值和。 跳链操作不在一条重链上呢？不妨这样想：我们不断让所在重链的深度（定义为链的根的深度）大的那个点每次跳到它所在重链的根的父节点，也就是另一条重链上。这样，最后总能让这两个点位于一条重链上。那么我们只需要在节点每条过一条重链时，记录这条重链上所有点的权值和，然后再加上最后在同一重链上是两点间的点权和，就是两点的路径上所有点的权值之和。关于权值和修改的问题也同理。 子树查询再看修改子树上的所有点权和这个操作。不难发现以$i$为根的子树，点编号的范围是$[i,i+\\text{sz}[i]-1]$。那么只需要在线段树上直接区间修改就好了。 这样，我们就可以在最高$O((log_2)^2n)$的时间里，完成一次 修改/查询 操作。 2 代码预处理：两遍dfs，分别处理出$\\text{prv}[i],\\text{sz}[i],\\text{prv}[i],\\text{dep}[i]$和$\\text{pos}[i],\\text{tid}[i],\\text{top}[i]$。 然后建立线段树，并写好跳链操作就好了。 代码：模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116const int CN = 2e6+10;class fs{ //边表 public: int to,nxt; void init(int t,int n) {to=t; nxt=n;}}E[CN&lt;&lt;2];int hd[CN],ecnt = 0;void add(int x,int y){ E[++ecnt].init(y,hd[x]); hd[x] = ecnt;}//v defineint n,m,r,R; //题目要求答案对R取余int v[CN]; //点权/*SGT*//*Segment Tree 线段树 习惯简写SGT*/int dep[CN]; //节点深度 int sz[CN]; //以节点为根的子树的大小 int imp[CN]; //节点的重儿子 int pos[CN]; //节点编号映射在线段树上的编号int tid[CN]; //线段树上节点编号映射到节点实际编号 int top[CN]; //节点所在重链的根 int prv[CN]; //节点的父亲节点 //初始化函数 void init1(int u){ dep[u] = dep[prv[u]]+1; //深度 sz[u] = 1; //子树大小 int mx = 0; //记录最大的子树大小 for(int k=hd[u]; k; k=E[k].nxt){ int v = E[k].to; if(!dep[v]){ prv[v] = u; init1(v); sz[u] += sz[v]; if(sz[v] &gt; mx) mx = sz[imp[u] = v]; //更新重儿子 } }}int idx = 0; //编号 void init2(int u,int t){ pos[u] = ++idx; //更新编号 tid[idx] = u; top[u] = t; //维护链的根 if(!imp[u]) return; //叶节点 init2(imp[u], t); //优先访问重链 for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v!=imp[u] &amp;&amp; dep[v]&gt;dep[u]) init2(v, v); //新开一条重链 }}//线段树 class SegmentTree{ public: int d[CN&lt;&lt;2],tag[CN&lt;&lt;2]; void build(int l,int r,int k){ //构造 if(l == r) return (void)(d[k] = v[tid[l]]%R); int m = (l+r)&gt;&gt;1; build(l,m,k&lt;&lt;1); build(m+1,r,k&lt;&lt;1|1); d[k] = (d[k&lt;&lt;1]+d[k&lt;&lt;1|1])%R; } void PushDown(int l,int r,int m,int k,int s,int t){ //标记下传 (d[k&lt;&lt;1] += tag[k]*(m-l+1)) %= R; (tag[k&lt;&lt;1] += tag[k]) %= R; (d[k&lt;&lt;1|1] += tag[k]*(r-m)) %= R; (tag[k&lt;&lt;1|1] += tag[k]) %= R; tag[k] = 0; } void modify(int l,int r,int k,int s,int t,int x){ //修改 if(s&lt;=l &amp;&amp; r&lt;=t){ (d[k] += x*(r-l+1)) %= R; (tag[k] += x) %= R; return; } int m = (l+r)&gt;&gt;1; if(tag[k]) PushDown(l,r,m,k,s,t); if(s &lt;= m) modify(l,m,k&lt;&lt;1,s,t,x); if(m &lt; t) modify(m+1,r,k&lt;&lt;1|1,s,t,x); d[k] = (d[k&lt;&lt;1]+d[k&lt;&lt;1|1])%R; } int query(int l,int r,int k,int s,int t){ //查询 if(s&lt;=l &amp;&amp; r&lt;=t) return d[k]; int m = (l+r)&gt;&gt;1,rec = 0; if(tag[k]) PushDown(l,r,m,k,s,t); if(s &lt;= m) rec += query(l,m,k&lt;&lt;1,s,t); if(m &lt; t) rec += query(m+1,r,k&lt;&lt;1|1,s,t); return rec%R; }}sgt;//跳链函数 void PathModify(int u,int v,int x){ //路径修改 x %= R; while(top[u] != top[v]){ //跳至同一条链 if(dep[top[u]] &gt; dep[top[v]]) swap(u,v); sgt.modify(1,n,1,pos[top[v]],pos[v],x); //修改 v = prv[top[v]]; //让深度大的向上跳 } sgt.modify(1,n,1,min(pos[u],pos[v]),max(pos[u],pos[v]),x);}void SubTreeModify(int u,int x){ //子树修改 x %= R; sgt.modify(1,n,1,pos[u],pos[u]+sz[u]-1,x); //直接修改}int PathQuery(int u,int v){ //路径查询 int ans = 0; while(top[u] != top[v]){ if(dep[top[u]] &gt; dep[top[v]]) swap(u,v); ans += sgt.query(1,n,1,pos[top[v]],pos[v]); //累加 ans %= R; v = prv[top[v]]; //往上跳 } ans += sgt.query(1,n,1,min(pos[u],pos[v]),max(pos[u],pos[v])); return ans%R;}int SubTreeQuery(int x){ //子树查询 return sgt.query(1,n,1,pos[x],pos[x]+sz[x]-1); //直接返回} 三 图论应用树链剖分是一种针对树上问题的很优秀的处理想法。正是因为它太优秀了，所以他并不仅仅能当一个数据结构用，甚至可以被用来解决图论问题。 准确的说，树链剖分就是一种把“树”映射成“链”的想法，就像上面所描述的那样。对于这个“链”，我们就能进行很多处理，诸如挂上线段树，维护前缀和之类。通过这些优秀的数据结构，我们就可以很好的解决有关树上路径的诸多问题。 1 点对LCA最近公共祖先（Least Common Ancestors，LCA）也是可以用LCA求的。我们对树上的一个点对$(u,v)$进行跳链操作，直到两点处于一条重链上停止，那么此时$u,v$中深度浅（更靠近根）的那个就是$(u,v)$的LCA。 实际上这样就不需要再在树剖上挂线段树了。于是代码长这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const int CN = 5e5+5;class fs{ //边表 public: int to,nxt; void init(int t,int n) {to=t;nxt=n;}}E[CN&lt;&lt;1];int hd[CN],ecnt = 0;void add(int x,int y){ E[++ecnt].init(y,hd[x]); hd[x] = ecnt;}/*SGT*/int dep[CN],prv[CN],imp[CN],sz[CN],top[CN];void init1(int u){ dep[u] = dep[prv[u]]+1; sz[u] = 1; int mx = 0; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(!dep[v]){ prv[v] = u; init1(v); sz[u] += sz[v]; if(sz[v] &gt; mx) mx = sz[imp[u] = v]; } }}void init2(int u,int t){ top[u] = t; if(!imp[u]) return; init2(imp[u], t); for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v!=prv[u] &amp;&amp; v!=imp[u]) init2(v, v); }}int LCA(int u,int v){ //查询 (u,v) 的LCA while(top[u] != top[v]){ //跳链 if(dep[top[u]] &gt; dep[top[v]]) swap(u,v); v = prv[top[v]]; } if(dep[u] &gt; dep[v]) swap(u,v); //让 u 成为深度浅的那个 return u;} 一个LCA的例题：HDU 4547 CD Opt。 2 点对路径和 HDU 2874 Connections between cities给你多棵树，树有边权。每次询问一个点对$(u,v)$间的路径上的边权和，若不连通输出Not connected。 首先是判联通，这个可以用并查集，不多讲了。 前面提到过树剖在处理边权问题的时候，可以把边权改点权。具体的做法是让边$u\\to v$的权变成$v$点的权，因为一个儿子节点只对应一个父节点，也就是只对应一条通向父节点的边。 但是这样实际在统计边权的时候上会多统计一条边，也就是两个点的LCA对应的那条边。于是我们在两个点跳到同一条重链之后（也就是求出了LCA），要把LCA往它的重儿子偏移一个节点，然后再统计边权和。但是有时候还会使得最后这个区间不存在，那么我们加个特判就好了。 另一个边权问题的例子：USACO11DEC Grass Planting。 于是点对间的边权和问题就被转化成了点对间的点权和问题。并且这个点权和还不需要支持修改，于是我们只需要树剖之后，维护一个前缀和就好了。 代码长这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const int CN = 1e4+4;const string FAIL = \"Not connected\";class fs{ //边表 public: int from,to,nxt,dist; void init(int f,int t,int n,int d) {from = f; to = t; nxt = n; dist = d;}}E[CN&lt;&lt;1];int hd[CN],ecnt = 0;void add(int x,int y,int z){ E[++ecnt].init(x,y,hd[x],z); hd[x] = ecnt;}void fs_init(){memset(hd,0,sizeof(hd)); ecnt = 0;} //边表初始化（多组数据！）class ufs{ //并查集，用来判联通 public: int fa[CN]; ufs() {for(int i=0;i&lt;=10001;i++) fa[i] = i;} //构造函数 void init() {for(int i=0;i&lt;=10001;i++) fa[i] = i;} //初始化 int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);} void merge(int x,int y) {fa[find(x)] = find(y);} bool exm(int x,int y) {return find(x) != find(y);}}con;int n; //点数/*SGT*/int top[CN],pos[CN],sz[CN],imp[CN],prv[CN],dep[CN],idx;void sgt_init(){ //树剖初始化 memset(top,0,sizeof(top)); memset(pos,0,sizeof(pos)); memset(sz,0,sizeof(sz)); memset(imp,0,sizeof(imp)); memset(prv,0,sizeof(prv)); memset(dep,0,sizeof(dep)); idx = 0;}void init1(int u){ dep[u] = dep[prv[u]]+1; sz[u] = 1; int mx = 0; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v != prv[u]){ prv[v] = u; init1(v); sz[u] += sz[v]; if(sz[v] &gt; mx) mx = sz[imp[u] = v]; } }}void init2(int u,int t){ pos[u] = ++idx; top[u] = t; if(!imp[u]) return; init2(imp[u],t); for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v!=prv[u] &amp;&amp; v!=imp[u]) init2(v,v); }}int sum[CN]; //前缀和void NodeValInit(int u){ //边权转点权 for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v != prv[u]){ sum[pos[v]] = E[k].dist; NodeValInit(v); } }}void SGT_Prep(){ //初始化树剖的主调用函数 sgt_init(); for(int i=1;i&lt;=n;i++) //枚举根，因为可能有多棵树 if(!dep[i]){ init1(i); init2(i,i); NodeValInit(i); } for(int i=1;i&lt;=n;i++) sum[i] += sum[i-1]; //推前缀和}int PathQuery(int u,int v){ //回答路径查询 int rec = 0; while(top[u] != top[v]){ if(dep[top[u]] &gt; dep[top[v]]) swap(u,v); rec += sum[pos[v]]-sum[pos[top[v]]-1]; v = prv[top[v]]; } if(dep[u] &gt; dep[v]) swap(u,v); //u is lca u = imp[u]; //下移一个节点 if(dep[u] &gt; dep[v]) return rec; //区间不存在 return rec + sum[pos[v]]-sum[pos[u]-1];} 3 重构树后的树链剖分 NOIP2013 D1T3 货车运输给定一张不保证是树的图，边有边权。定义一条$x\\to y$的路径的宽度是这条路径上所有边权的最小值。每次询问图上两点对$(u,v)$间的所有路径上，宽度最大的那条路径的宽度值。 两个相邻的点间可能有多条边，那么肯定要保留边权大的。推广，考虑到要保证图的连通性，我们需要选出最少的边，使每条边的权值都尽量大，并且要求这些边不能使图的连通性改变。 那么也就是最大生成树了。重构最大生成树之后，剩下的问题就是一个查询两点路径上的最小边权。这个可以树剖，然后挂一个线段树就好了。 还有一个细节：图不保证联通。这个像上面一样用并查集维护就好了。 代码长这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131const int CN = 1e5+4;const int INF = 0x3f3f3f3f;class fs{ //边表 public: int from,to,nxt,dist; void init(int f,int t,int n,int d) {from=f;to=t;nxt=n;dist=d;} bool operator &lt; (const fs &amp;a)const {return dist &gt; a.dist;} //最大生成树}E[CN&lt;&lt;1];int hd[CN],ecnt = 0;void add(int x,int y,int z){ E[++ecnt].init(x,y,hd[x],z); hd[x] = ecnt;}void fs_init() {memset(hd,0,sizeof(hd)); ecnt = 0;} //边表初始化class ufs{ //并查集 public: int fa[CN]; ufs() {for(int i=0;i&lt;=10001;i++) fa[i]=i;} void init() {for(int i=0;i&lt;=10001;i++) fa[i]=i;} //初始化，为了循环利用空间 int find(int x) {return fa[x]==x? x : fa[x]=find(fa[x]);} void merge(int x,int y) {fa[find(x)] = find(y);} bool exm(int x,int y) {return find(x) != find(y);}}con;int n; //点数/*MST*/int X[CN],Y[CN],Z[CN]; //记录选中的边void MST(){ //最大生成树 Kruskal sort(E+1,E+ecnt+1); for(int k=1;k&lt;=ecnt;k++){ int x = E[k].from,y = E[k].to; if(!con.exm(x,y)) continue; con.merge(x,y); ++X[0]; X[X[0]] = x; Y[X[0]] = y; Z[X[0]] = E[k].dist; }}void ReBuild(){ //重构树 fs_init(); con.init(); //初始化图 for(int i=1;i&lt;n;i++){ add(X[i],Y[i],Z[i]),add(Y[i],X[i],Z[i]); if(con.exm(X[i],Y[i])) con.merge(X[i],Y[i]); //维护联通性 }}/*MST end*//*SGT*/class SGT{ //线段树 支持查询静态区间最小值 public: int d[CN&lt;&lt;1],org[CN]; void build(int l,int r,int k){ if(l == r) return (void)(d[k] = org[l]); int m = (l+r)&gt;&gt;1; build(l,m,k&lt;&lt;1); build(m+1,r,k&lt;&lt;1|1); d[k] = min(d[k&lt;&lt;1], d[k&lt;&lt;1|1]); } int query(int l,int r,int k,int s,int t){ if(s&lt;=l &amp;&amp; r&lt;=t) return d[k]; int m = (l+r)&gt;&gt;1,rec = INF; if(s &lt;= m) rec = min(rec, query(l,m,k&lt;&lt;1,s,t)); if(m &lt; t) rec = min(rec, query(m+1,r,k&lt;&lt;1|1,s,t)); return rec; }}sgt;int dep[CN],pos[CN],sz[CN],top[CN],prv[CN],imp[CN],idx = 0;void init1(int u){ dep[u] = dep[prv[u]]+1; sz[u] = 1; int mx = 0; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(!dep[v]){ prv[v] = u; init1(v); sz[u] += sz[v]; if(sz[v] &gt; mx) mx = sz[imp[u] = v]; } }}void init2(int u,int t){ pos[u] = ++idx; top[u] = t; if(!imp[u]) return; init2(imp[u], t); for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v!=prv[u] &amp;&amp; v!=imp[u]) init2(v, v); }}void NodeValInit(int u){ //边权转点权 for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v != prv[u]){ sgt.org[pos[v]] = E[k].dist; NodeValInit(v); } }}void SGT_Prep(){ //初始化树剖的主调用函数 for(int i=1;i&lt;=n;i++){ //枚举根 if(dep[i]) continue; init1(i); init2(i, i); NodeValInit(i); } sgt.build(1,n,1); //初始化线段树}int PathQuery(int u,int v){ //求 (u,v) 路径上的最小值 int mn = INF; while(top[u] != top[v]){ if(dep[top[u]] &gt; dep[top[v]]) swap(u,v); mn = min(mn, sgt.query(1,n,1, pos[top[v]],pos[v])); v = prv[top[v]]; } if(dep[u] &gt; dep[v]) swap(u,v); //u is LCA u = imp[u]; //下移一个节点 if(dep[u] &gt; dep[v]) return mn; return min(mn, sgt.query(1,n,1, pos[u],pos[v]));}/*SGT end*/int main(){ ... //Scan Data /*重构树*/ MST(); ReBuild(); /*初始化树剖*/ SGT_Prep(); ... //Answer Question return 0;} $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/07/18/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}],"tags":[{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"2-SAT","slug":"2-SAT","link":"/tags/2-SAT/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"瞎搞","slug":"瞎搞","link":"/tags/%E7%9E%8E%E6%90%9E/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀数组","slug":"后缀数组","link":"/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最大流","slug":"最大流","link":"/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"最大权闭合子图","slug":"最大权闭合子图","link":"/tags/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"},{"name":"优化","slug":"优化","link":"/tags/%E4%BC%98%E5%8C%96/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"后缀自动机","slug":"后缀自动机","link":"/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"树形DP","slug":"树形DP","link":"/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"双连通分量","slug":"双连通分量","link":"/tags/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"割顶","slug":"割顶","link":"/tags/%E5%89%B2%E9%A1%B6/"},{"name":"区间DP","slug":"区间DP","link":"/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"强连通分量","slug":"强连通分量","link":"/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"扫描线法","slug":"扫描线法","link":"/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF%E6%B3%95/"},{"name":"线段覆盖","slug":"线段覆盖","link":"/tags/%E7%BA%BF%E6%AE%B5%E8%A6%86%E7%9B%96/"},{"name":"拆点","slug":"拆点","link":"/tags/%E6%8B%86%E7%82%B9/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"基环树","slug":"基环树","link":"/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/"},{"name":"矩阵","slug":"矩阵","link":"/tags/%E7%9F%A9%E9%98%B5/"},{"name":"缩点","slug":"缩点","link":"/tags/%E7%BC%A9%E7%82%B9/"},{"name":"最长路","slug":"最长路","link":"/tags/%E6%9C%80%E9%95%BF%E8%B7%AF/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"欧拉路","slug":"欧拉路","link":"/tags/%E6%AC%A7%E6%8B%89%E8%B7%AF/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"最小点覆盖","slug":"最小点覆盖","link":"/tags/%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96/"},{"name":"背包","slug":"背包","link":"/tags/%E8%83%8C%E5%8C%85/"},{"name":"容斥","slug":"容斥","link":"/tags/%E5%AE%B9%E6%96%A5/"},{"name":"树的直径","slug":"树的直径","link":"/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"floyd","slug":"floyd","link":"/tags/floyd/"},{"name":"差分约束","slug":"差分约束","link":"/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"排列组合","slug":"排列组合","link":"/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"打表","slug":"打表","link":"/tags/%E6%89%93%E8%A1%A8/"},{"name":"生成树","slug":"生成树","link":"/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"费用流","slug":"费用流","link":"/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流24题","slug":"网络流24题","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"},{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"线性基","slug":"线性基","link":"/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"name":"后缀树","slug":"后缀树","link":"/tags/%E5%90%8E%E7%BC%80%E6%A0%91/"},{"name":"带权并查集","slug":"带权并查集","link":"/tags/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"悬线法","slug":"悬线法","link":"/tags/%E6%82%AC%E7%BA%BF%E6%B3%95/"},{"name":"字典树","slug":"字典树","link":"/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"AC自动机","slug":"AC自动机","link":"/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"启发式搜索","slug":"启发式搜索","link":"/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"A*","slug":"A","link":"/tags/A/"},{"name":"IDA*","slug":"IDA","link":"/tags/IDA/"},{"name":"筛法","slug":"筛法","link":"/tags/%E7%AD%9B%E6%B3%95/"},{"name":"反演","slug":"反演","link":"/tags/%E5%8F%8D%E6%BC%94/"},{"name":"主席树","slug":"主席树","link":"/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"可持久化","slug":"可持久化","link":"/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"桥","slug":"桥","link":"/tags/%E6%A1%A5/"},{"name":"斯坦纳树","slug":"斯坦纳树","link":"/tags/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"},{"name":"状压DP","slug":"状压DP","link":"/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"倍增","slug":"倍增","link":"/tags/%E5%80%8D%E5%A2%9E/"},{"name":"树的重心","slug":"树的重心","link":"/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"迭代加深搜索","slug":"迭代加深搜索","link":"/tags/%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2/"},{"name":"逆元","slug":"逆元","link":"/tags/%E9%80%86%E5%85%83/"},{"name":"多项式","slug":"多项式","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"子段和","slug":"子段和","link":"/tags/%E5%AD%90%E6%AE%B5%E5%92%8C/"},{"name":"同余","slug":"同余","link":"/tags/%E5%90%8C%E4%BD%99/"},{"name":"概率与期望","slug":"概率与期望","link":"/tags/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"},{"name":"期望DP","slug":"期望DP","link":"/tags/%E6%9C%9F%E6%9C%9BDP/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"期望","slug":"期望","link":"/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"虚树","slug":"虚树","link":"/tags/%E8%99%9A%E6%A0%91/"}],"categories":[{"name":"OI笔记","slug":"OI笔记","link":"/categories/OI%E7%AC%94%E8%AE%B0/"},{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","link":"/categories/%E9%A2%98%E8%A7%A3/Codeforces/"},{"name":"AtCoder","slug":"题解/AtCoder","link":"/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"USACO","slug":"题解/USACO","link":"/categories/%E9%A2%98%E8%A7%A3/USACO/"},{"name":"HDU","slug":"题解/HDU","link":"/categories/%E9%A2%98%E8%A7%A3/HDU/"},{"name":"UVa","slug":"题解/UVa","link":"/categories/%E9%A2%98%E8%A7%A3/UVa/"},{"name":"NOIP","slug":"题解/NOIP","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/"},{"name":"备忘录","slug":"杂谈/备忘录","link":"/categories/%E6%9D%82%E8%B0%88/%E5%A4%87%E5%BF%98%E5%BD%95/"}]}