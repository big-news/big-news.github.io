<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bn&#39; Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://big-news.cn/"/>
  <updated>2020-08-17T06:36:26.716Z</updated>
  <id>https://big-news.cn/</id>
  
  <author>
    <name>big-news</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>主席树</title>
    <link href="https://big-news.cn/2020/08/17/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>https://big-news.cn/2020/08/17/%E4%B8%BB%E5%B8%AD%E6%A0%91/</id>
    <published>2020-08-17T01:47:00.000Z</published>
    <updated>2020-08-17T06:36:26.716Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，主席树即可持久化值域线段树， 用于解决区间 $k$ 小值问题，可带修也可不带修。</p><a id="more"></a><h3 id="1-静态主席树"><a href="#1-静态主席树" class="headerlink" title="1 静态主席树"></a>1 静态主席树</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>静态区间 k 小值</strong></p><p>给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。</p></div></article><p>静态主席树一般指可持久化值域线段树，并不支持修改操作。</p><p>容易发现区间信息是满足可减性的，则只需要在每次插入时建立一个船新版本即可，查询也只需要对两个历史版本作差便能得到区间信息。<br>类似的，01-Trie 与 Treap 之类的无法维护区间信息的数据结构也可以通过可持久化来实现区间信息的维护。</p><p>容易得出下面的这份代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] = d[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, ch[v][<span class="number">0</span>], l, m, p), rc = ch[v][<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">else</span> md(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p), lc = ch[v][<span class="number">0</span>];</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = d[lc] - d[ ch[v][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= k) <span class="keyword">return</span> qu(lc, ch[v][<span class="number">0</span>], l, m, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qu(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, k - s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = a[i] = read();</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + n + <span class="number">1</span>);</span><br><span class="line">    val[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[ ++val[<span class="number">0</span>] ] = val[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.md(D.rt[i], D.rt[i - <span class="number">1</span>], <span class="number">1</span>, val[<span class="number">0</span>], id( a[i] ));</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), k = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, val[ D.qu( D.rt[r], D.rt[l - <span class="number">1</span>], <span class="number">1</span>, val[<span class="number">0</span>], k ) ]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-带修主席树"><a href="#2-带修主席树" class="headerlink" title="2 带修主席树"></a>2 带修主席树</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>动态区间 k 小值</strong></p><p>给定一个含有 $n$ 个数的序列 $a_1, a_2, …, a_n$ ，需要支持两种操作：</p><ul><li>Q l r k 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数</li><li>C x y 表示将 $a_x$ 改为 $y$</div></article></li></ul><p>带修主席树一般指树状数组套可持久化值域线段树。</p><p>容易发现主席树的每个版本是对区间信息做一个前缀和，这样如果在某个版本上修改是 $O(n)$ 的。<br>既然是前缀和，套用树状数组的方式写主席树就好了，复杂度 $O(n\log^2n)$ 。</p><p>于是容易得到下面的这份代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], rt[CN], idx, n;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 修改不新建版本</span></span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, l, m, p, x); <span class="keyword">else</span> md(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 修改 BIT 中所有的树</span></span><br><span class="line">        <span class="keyword">while</span>(u &lt;= rt[<span class="number">0</span>]) md(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t1[<span class="number">101</span>], t2[<span class="number">101</span>]; <span class="comment">// 把 O(log) 棵主席树的根搞下来</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qu_pre</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="comment">// (l, r]</span></span><br><span class="line">        t1[<span class="number">0</span>] = t2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = l; <span class="keyword">while</span>(u) t1[ ++t1[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">        u = r; <span class="keyword">while</span>(u) t2[ ++t2[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) s -= d[ ch[ t1[i] ][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) s += d[ ch[ t2[i] ][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(l, m, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(m + <span class="number">1</span>, r, k - s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QUERY</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> tp, a, b, c;</span><br><span class="line">&#125; Q[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    D.rt[<span class="number">0</span>] = n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[ ++val[<span class="number">0</span>] ] = a[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c; <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'Q'</span>) Q[i].tp = <span class="number">0</span>, Q[i].a = read(), Q[i].b = read(), Q[i].c = read();</span><br><span class="line">        <span class="keyword">else</span> Q[i].tp = <span class="number">1</span>, Q[i].a = read(), val[ ++val[<span class="number">0</span>] ] = Q[i].b = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[ ++cnt ] = val[i];</span><br><span class="line">    D.n = val[<span class="number">0</span>] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.cg(i, id( a[i] ), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Q[i].tp)&#123;</span><br><span class="line">            D.qu_pre(Q[i].a - <span class="number">1</span>, Q[i].b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, val[ D.qu(<span class="number">1</span>, val[<span class="number">0</span>], Q[i].c) ]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            D.cg(Q[i].a, id( a[ Q[i].a ] ), <span class="number">-1</span>), a[ Q[i].a ] = Q[i].b, D.cg(Q[i].a, id( a[ Q[i].a ] ), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，导致其常数巨大，不过它依然能在 1s 左右的时间内通过此题。</p><h3 id="3-一道栗题"><a href="#3-一道栗题" class="headerlink" title="3 一道栗题"></a>3 一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「CQOI2011」动态逆序对</strong></p><p>给出 $1\sim n$ 的一个排列，按照某种顺序依次删除 $m$ 个元素，在每次删除一个元素之前统计整个序列的逆序对数。</p></div></article><p>如果是静态问题，那么只需要用权值树状数组就可以简单维护。</p><p>由于只有删除操作，考虑计算删除一个元素对答案的贡献（实际上是减少量而不是增加量），容易发现这样的查询同时存在下标和权值两个维度；下标即通过版本来区分，因此用主席树。考虑到修改和影响传递的过程，仿照上题套一个树状数组即可。</p><p>于是容易得到如下代码。同样的，由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，其常数巨大，不过它依然能在 1.2s 左右的时间内通过此题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx, n;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, l, m, p, x); <span class="keyword">else</span> md(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(u &lt;= rt[<span class="number">0</span>]) md(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t[CN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pqu</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = r; <span class="keyword">while</span>(u) t[ ++t[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) s += d[ t[i] ];</span><br><span class="line">            <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) t[i] = ch[ t[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(l, m, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) s += d[ ch[ t[i] ][<span class="number">0</span>] ];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) t[i] = ch[ t[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> s + qu(m + <span class="number">1</span>, r, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN], rk[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = a[i] = read(), rk[ a[i] ] = i;</span><br><span class="line">    D.rt[<span class="number">0</span>] = D.n = n;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        D.cg(i, a[i], <span class="number">1</span>), D.pqu(i - <span class="number">1</span>), ans -= D.qu(<span class="number">1</span>, n, a[i]), D.pqu(i - <span class="number">1</span>), ans += D.qu(<span class="number">1</span>, n, n);</span><br><span class="line"></span><br><span class="line">    m -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> x = read(), p = rk[x], s1, s2;</span><br><span class="line">        D.cg(p, x, <span class="number">-1</span>);</span><br><span class="line">        D.pqu(p - <span class="number">1</span>), s2 = D.qu(<span class="number">1</span>, n, x);</span><br><span class="line">        D.pqu(p - <span class="number">1</span>), s1 = D.qu(<span class="number">1</span>, n, n) - s2;</span><br><span class="line">        D.pqu(n), s2 = D.qu(<span class="number">1</span>, n, x) - s2;</span><br><span class="line">        ans -= s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，主席树即可持久化值域线段树， 用于解决区间 $k$ 小值问题，可带修也可不带修。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://big-news.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="https://big-news.cn/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>后缀树</title>
    <link href="https://big-news.cn/2020/08/16/%E5%90%8E%E7%BC%80%E6%A0%91/"/>
    <id>https://big-news.cn/2020/08/16/%E5%90%8E%E7%BC%80%E6%A0%91/</id>
    <published>2020-08-16T08:03:00.000Z</published>
    <updated>2020-08-16T12:08:29.441Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知：后缀树是不对劲的 Tire 树….</p><a id="more"></a><p>后缀树即是路径压缩之后的后缀 Trie ，满足其中的 <strong>一些节点</strong> 可以双射原串的所有后缀。<br>其分为 <strong>显示构造</strong> 与 <strong>隐式构造</strong> 两种，区别在于是否在字符串尾添加一个终止符。其中，显示构造的后缀树满足每个叶子双射原串的一个后缀。</p><p>众所周知，SAM 的 Parent 树是反串的后缀树，从而可以通过将字符串倒着插入 SAM 来得到一个串的后缀树。注意，这样得到的后缀树是隐式构造的。</p><p>后缀树为我们提供了一个新的思路：两个字符串的 LCP 是它们在 Trie 上的 LCA ，则两个后缀的 LCP 也是它们在后缀树上的 LCA。这可以被形式化地表达如下：</p><p>$$ \text{LCP}(s[i:n], s[j:n]) = \text{len}[ \text{LCA}(i, j) ] $$</p><p>其中等号后面的 $i, j$ 应当对应为在树上的编号，$\text{len}[]$ 即为 SAM 中的 <code>len[]</code> 数组。</p><p>给出一份查询两个后缀的 LCP 的代码。显然，该份代码也可以通过 SA 实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> len[CN &lt;&lt; <span class="number">1</span>], nxt[CN &lt;&lt; <span class="number">1</span>], son[CN &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], lst, idx; </span><br><span class="line">    SAM() &#123;nxt[<span class="number">0</span>] = <span class="number">-1</span>, idx = lst = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">et</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = ++idx, p = lst;</span><br><span class="line">        len[u] = len[p] + <span class="number">1</span>, lst = u;</span><br><span class="line">        <span class="keyword">while</span>(p ^ <span class="number">-1</span> &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">-1</span>) <span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">int</span> d = son[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[d] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> nxt[u] = d, idx;</span><br><span class="line">        <span class="keyword">int</span> v = ++idx;</span><br><span class="line">        nxt[v] = nxt[d], nxt[d] = nxt[u] = v, len[v] = len[p] + <span class="number">1</span>, <span class="built_in">memcpy</span>(son[v], son[d], <span class="keyword">sizeof</span>(son[d]));</span><br><span class="line">        <span class="keyword">while</span>(p ^ <span class="number">-1</span> &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p];</span><br><span class="line">        <span class="keyword">return</span> idx - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, id[CN]; <span class="keyword">char</span> ch[CN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; to[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D.idx; i++) to[ D.nxt[i] ].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[CN][<span class="number">30</span>], dep[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>; <span class="keyword">int</span> sz = to[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v) &#123;<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][<span class="number">0</span>];&#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch; n = <span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i + <span class="number">1</span>; i--) id[i + <span class="number">1</span>] = D.et( ch[i] - <span class="string">'a'</span> );</span><br><span class="line"></span><br><span class="line">    rbd(), dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D.idx; i++)</span><br><span class="line">            fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = read(), j = read(), l = lca( id[i], id[j] );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.len[l]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知：后缀树是不对劲的 Tire 树….&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="后缀树" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>组合数学再基础</title>
    <link href="https://big-news.cn/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/"/>
    <id>https://big-news.cn/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-07T06:00:00.000Z</published>
    <updated>2020-08-10T03:02:53.542Z</updated>
    
    <content type="html"><![CDATA[<p>之前好像写过「组合数学基础」，在这里再来堆点柿子。</p><a id="more"></a><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-asia mr-2"></i>此页面存在相关页面。关于组合数学基础，请参见<a href="/2019/07/26/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">「组合数学基础」</a>。</div></article><h3 id="1-Stirling-数"><a href="#1-Stirling-数" class="headerlink" title="1 Stirling 数"></a>1 Stirling 数</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>众所周知，Stirling 数有两类，分别是：</p><p>$$ \begin{align} \begin{bmatrix}n\newline m \end{bmatrix} = \begin{bmatrix}n-1\newline m-1 \end{bmatrix}+(n-1)\begin{bmatrix}n-1\newline m \end{bmatrix}  \newline  \begin{Bmatrix}n\newline m \end{Bmatrix}=\begin{Bmatrix}n-1\newline m-1\end{Bmatrix}+m \begin{Bmatrix}n-1\newline m \end{Bmatrix} \end{align} \tag1 $$</p><p>接下来介绍 Stirling 数的性质。</p><h4 id="1-2-常幂展开"><a href="#1-2-常幂展开" class="headerlink" title="1.2 常幂展开"></a>1.2 常幂展开</h4><p>一个组合意义显然的柿子：</p><p>$$ \begin{align} n^m &amp;= \sum\limits_{k=0}^m  \begin{Bmatrix}m\newline k \end{Bmatrix}k! \dbinom{n}{k} \tag2 \newline &amp;= \sum\limits_{k=0}^m  \begin{Bmatrix}m\newline k\end{Bmatrix} n^{\underline{k}} \tag{3} \end{align} $$</p><p>$(3)$ 式通常被称为 <strong>常幂展开</strong>。</p><h4 id="1-3-Stirling-反演"><a href="#1-3-Stirling-反演" class="headerlink" title="1.3 Stirling 反演"></a>1.3 Stirling 反演</h4><p>$$ f(n) = \sum\limits_{k=0}^n \begin{Bmatrix}n\newline k\end{Bmatrix} g(k) \Leftrightarrow g(n) = \sum\limits_{k=0}^n (-1)^{n - k} \begin{bmatrix}n\newline k\end{bmatrix} f(k)  \tag{4} $$</p><p>$(4)$ 式通常被称为 <strong>Stirling 反演公式</strong>。</p><h4 id="1-4-阶乘幂展开"><a href="#1-4-阶乘幂展开" class="headerlink" title="1.4 阶乘幂展开"></a>1.4 阶乘幂展开</h4><p>对 $(3)$ 应用 $(4)$ 式得：</p><p>$$ n^{\underline{m}}= \sum\limits_{k=0}^m (-1)^{m-k} \begin{bmatrix}m\newline k\end{bmatrix} n^k \tag{5} $$</p><p>可以证明有：</p><p>$$ n^{\overline{m}}= \sum\limits_{k=0}^m \begin{bmatrix}m\newline k\end{bmatrix} n^k \tag{6} $$</p><p>$(5),(6)$ 两式被称作 <strong>阶乘幂展开</strong>。</p><h3 id="2-组合数"><a href="#2-组合数" class="headerlink" title="2 组合数"></a>2 组合数</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>众所周知，小葱同学擅长计算，尤其擅长计算组合数，但是这跟本文的主题并没有什么关系。</div></article><p>小葱同学擅长计算的组合数定义为：</p><p>$$\dbinom{n}{m} = \dbinom{n-1}{m} + \dbinom{n-1}{m-1}$$</p><h4 id="2-2-二项式定理"><a href="#2-2-二项式定理" class="headerlink" title="2.2 二项式定理"></a>2.2 二项式定理</h4><p>$$(x+y)^k = \sum\limits_{i=0}^k \dbinom{k}{i} x^i y^{k-i} \tag{7}$$</p><p>$(7)$ 式被称作 <strong>二项式定理</strong>。</p><h4 id="2-3-组合恒等式"><a href="#2-3-组合恒等式" class="headerlink" title="2.3 组合恒等式"></a>2.3 组合恒等式</h4><ul><li>组合恒等式 I</li></ul><p>在 $(7)$ 式中令 $x=y=1$ ，得：</p><p>$$\sum\limits_{i=0}^k \dbinom{k}{i} = 2^k \tag{8}$$</p><ul><li>组合恒等式 II</li></ul><p>$$\sum\limits_{i=0}^k \dbinom{k}{i}[2|i] =\sum\limits_{i=0}^k \dbinom{k}{i}[2\nmid i] = 2^{k-1} \tag9$$</p><p>证明显然。</p><ul><li>组合恒等式  III</li></ul><p>$$\dbinom{n}{k}\dbinom{k}{j} = \dbinom{n}{j} \dbinom{n-j}{k-j} \tag{10}$$</p><p>证明显然。</p><ul><li>组合恒等式 IV</li></ul><p>$$\begin{align} \sum\limits_{i=m}^n \dbinom{i}{m} &amp;= \dbinom{n+1}{m+1} \tag{11} \newline<br>\sum\limits_{i=0}^n \dbinom{m+i}{m} &amp;= \dbinom{n+m+1}{n} \tag{12} \end{align}$$</p><p>证明显然。</p><ul><li>组合恒等式 V</li></ul><p>$$ \dbinom{n+m}{k}= \sum\limits_{i=0}^k \dbinom{n}{i}\dbinom{m}{k-i} \tag{13}$$</p><p>证明显然。</p><p>$(8),(9),(10),(11),(12),(13)$ 式通常被称作 <strong>组合恒等式</strong>。</p><h4 id="2-4-二项式反演"><a href="#2-4-二项式反演" class="headerlink" title="2.4 二项式反演"></a>2.4 二项式反演</h4><ul><li>形式  I</li></ul><p>$$ f(n) = \sum\limits_{k=0}^n (-1)^k\dbinom{n}{k} g(k) \Leftrightarrow g(n) = \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k} f(k)  \tag{14} $$</p><ul><li>形式  II</li></ul><p>$$ f(n) = \sum\limits_{k=0}^n\dbinom{n}{k} g(k) \Leftrightarrow g(n) = \sum\limits_{k=0}^n (-1)^{n-k} \dbinom{n}{k} f(k)  \tag{15} $$</p><ul><li>形式  III</li></ul><p>$$ f(n) = \sum\limits_{k=n}^m\dbinom{k}{n} g(k) \Leftrightarrow g(n) = \sum\limits_{k=n}^m (-1)^{k-n} \dbinom{k}{n} f(k)  \tag{16} $$</p><p>$(14),(15),(16)$ 式被称作 <strong>二项式反演公式</strong>。</p><h4 id="2-5-第二类-Stirling-数通项"><a href="#2-5-第二类-Stirling-数通项" class="headerlink" title="2.5 第二类 Stirling 数通项"></a>2.5 第二类 Stirling 数通项</h4><p>对 $(2)$ 式应用 $(15)$ 式得：</p><p>$$ \begin{Bmatrix}n\newline m \end{Bmatrix}m! = \sum\limits_{k=0}^m  (-1)^k \dbinom{m}{k} (m-k)^n \tag{17} $$</p><p>其中 $(17)$ 式被称为 <strong>第二类 Stirling 数通项公式</strong>。</p><h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3 应用"></a>3 应用</h3><p><a href="https://darkbzoj.tk/problem/2839">「bzoj2839」集合计数</a><br><a href="https://darkbzoj.tk/problem/3622">「bzoj3622」已经没有什么好害怕的了</a><br><a href="https://codeforces.com/problemset/problem/932/E">「CF932E」 Team Work</a><br><a href="https://vjudge.net/problem/TopCoder-13444">「2018 雅礼集训」方阵</a><br><a href="https://loj.ac/problem/2058">「TJOI / HEOI2016」求和</a><br><a href="https://loj.ac/problem/6716">「LOJ #6716.」 自然数幂之和</a><br><a href="https://loj.ac/problem/3300">「2020联考A卷」组合数问题</a><br>「各种数数题」…</p><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-clock mr-2"></i>最近更新: 2020.8.9</div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前好像写过「组合数学基础」，在这里再来堆点柿子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://big-news.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Typewriter</title>
    <link href="https://big-news.cn/2020/08/06/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Typewriter/"/>
    <id>https://big-news.cn/2020/08/06/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Typewriter/</id>
    <published>2020-08-06T14:30:00.000Z</published>
    <updated>2020-08-09T01:30:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>一道很好的SAM+DP综合题，虽然说坑点也很多……</p><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6583">原题链接</a></p><p>考虑DP。设 $f[i]$ 为考虑前 $i$ 个位置的答案，应当有转移 $f[i] = \min f[i - 1] + p, f[l]+q$ ，其中 $l$ 满足 $s[l+1:r]\subseteq s[1:l]$ 。$f[]$ 显然是不降的，那么我们应取最小的 $l$ 。</p><p>考虑 $r\to r + 1$ ，容易发现 $l$ 是不降的；那么对 $s[1:l]$ 建立SAM，每次尝试扩展 $s[r+1]$，如果不行则令 $l\to l + 1$，即可找到最小的 $l$。维护当前的 $s[l+1:r]$ 对应在SAM上的路径，则可 O(1) 做到删除该路径上的第一个字符 $s[l+1]$ ，然后再扩展出$s[r+1]$即可。</p><p>小细节：当SAM在<code>extend()</code>的时候，若该路径的终点 $d$ 被拆成了 $v,d’$ 两个节点，且$\text{nxt}[d’]=v$，则应当将路径的终点变换为 $v$，否则维护的路径就被破坏了。<br>HDU不给数据，然后上面那个坑点卡了我一晚上…</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, prv[CN]; <span class="keyword">long</span> <span class="keyword">long</span> p, q, f[CN]; <span class="keyword">char</span> s[CN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> nxt[CN &lt;&lt; <span class="number">1</span>], son[CN &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], len[CN &lt;&lt; <span class="number">1</span>], sz, lst, cur, l;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (n &lt;&lt; <span class="number">1</span>);i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++) son[i][j] = <span class="number">0</span>; <span class="comment">// 题目卡memset()</span></span><br><span class="line">        sz = <span class="number">1</span>, lst = cur = l = len[<span class="number">0</span>] = <span class="number">0</span>, nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">et</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = sz++, p = lst;</span><br><span class="line">        lst = u, len[u] = len[p] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">-1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(nxt[u] = <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> d = son[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[d] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(nxt[u] = d);</span><br><span class="line">        <span class="keyword">int</span> v = sz++; </span><br><span class="line">        <span class="keyword">if</span>(d == cur) cur = v; <span class="comment">// 坑点</span></span><br><span class="line">        len[v] = len[p] + <span class="number">1</span>, nxt[v] = nxt[d], nxt[d] = nxt[u] = v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) son[v][i] = son[d][i];</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;<span class="keyword">if</span>(nxt[cur] != <span class="number">-1</span> &amp;&amp; --l == len[ nxt[cur] ]) cur = nxt[cur];&#125;   <span class="comment">// delete</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">rd</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;<span class="keyword">return</span> son[cur][c] ? cur = son[cur][c], l++, <span class="literal">true</span> : <span class="literal">false</span>;&#125; <span class="comment">// read</span></span><br><span class="line">&#125;D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">// freopen("wa.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>))&#123;</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;p, &amp;q), D.init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>; D.et(s[<span class="number">1</span>] - <span class="string">'a'</span>), prv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!D.rd(s[i] - <span class="string">'a'</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(l + <span class="number">1</span> == i) &#123;flag = <span class="literal">false</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">                D.del(), D.et(s[++l] - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            prv[i] = flag ? l : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!flag) D.et(s[++l] - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">1</span>] = p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">if</span>(prv[i]) f[i] = min(f[i - <span class="number">1</span>] + p, f[ prv[i] ] + q);</span><br><span class="line">            <span class="keyword">else</span> f[i] = f[i - <span class="number">1</span>] + p;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道很好的SAM+DP综合题，虽然说坑点也很多……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="后缀自动机" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【题解】AC自动机（简单版）</title>
    <link href="https://big-news.cn/2020/08/04/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/"/>
    <id>https://big-news.cn/2020/08/04/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/</id>
    <published>2020-08-04T07:01:00.000Z</published>
    <updated>2020-08-09T01:30:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>虽然说这题是AC自动机吧…但是后缀数组也能解。<br>在这里提供一个清新的后缀数组解法。</p><a id="more"></a><h3 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h3><p>后缀数组是个好东西啊，通过这个工具可以解决许多类型的字符串问题，这里简单介绍一下：</p><p>形式化地，对于一个长度为 $n$ 的字符串 $s$，它的形如 $s[i:n]$ 的子串被称作 $s$ 的后缀。</p><p>容易发现 $s$ 一共有 $n$ 个后缀，不妨记 $s[i:n]$ 为后缀 $i$，将所有的后缀排序后，顺序写下后缀的编号，就得到了后缀数组 (Suffix Array)。</p><p>举个例子，对 $s=ababa$，其后缀有 $a,ba,aba,baba,ababa$，排序后得到 $a,aba,ababa,ba,baba$，依次写下其编号，得到后缀数组为 $5,3,1,2,4$。</p><p>朴素求后缀数组是 $O(n^2 \log n)$ 的，这显然是不太好的。通过倍增法去求，容易发现倍增的过程是某种双关键字排序，那么对其进行基数排序，可做到 $O(n \log n)$。具体的实现超出了本篇题解的范畴，请移步 <a href="https://www.luogu.com.cn/problem/P3809">后缀排序</a>。</p><h3 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h3><p>容易发现，一个串 $s$ 若能与 $t$ 匹配，那么它必然是 $t$ 的 <strong>某个后缀的前缀</strong>。<br>我们可以快速把所有后缀都排序，这样后缀就是有序的了，可以通过二分来找 $s$ 是否与 $t$ 匹配。</p><p>具体实现上，因为后缀的长度和是 $O(n^2)$ 级别的，所以不能把他们全部搞出来（会MLE）。实际上只需要写一个 <code>cmp()</code> 函数来比较字符串大小就好了，实现起来比较清新易懂。</p><p>复杂度因为每次要二分，所以整体多了一个 $\log$，不过均摊下来跑的非常快，常数比AC自动机大了不到一半。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fake-acam.cpp */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> t[CN], s[CN];</span><br><span class="line"><span class="built_in">string</span> mem[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sa[CN], rk[CN &lt;&lt; <span class="number">1</span>], prk[CN &lt;&lt; <span class="number">1</span>], id[CN], px[CN], cnt[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = max(n, <span class="number">300</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) rk[i] = t[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cnt[ rk[i] ] ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[ cnt[ rk[i] ]-- ] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt; n; w &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = sa[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] + w ] ]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = sa[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] ] ]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i];</span><br><span class="line">        <span class="built_in">memcpy</span>(prk, rk, <span class="keyword">sizeof</span>(rk)); m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">if</span>(prk[ sa[i] ] == prk[ sa[i - <span class="number">1</span>] ] &amp;&amp; prk[ sa[i] + w ] == prk[ sa[i - <span class="number">1</span>] + w ])</span><br><span class="line">                rk[ sa[i] ] = m;</span><br><span class="line">            <span class="keyword">else</span> rk[ sa[i] ] = ++m;</span><br><span class="line">        <span class="keyword">if</span>(m == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, lt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 a[] &lt; b[]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">le</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b, <span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[p] == b[p] &amp;&amp; p &lt; min(la, lb)) p++;</span><br><span class="line">    <span class="keyword">if</span>(p == lb) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == la) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> a[p] &lt; b[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("_in.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen("out.txt", "w", stdout);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; mem[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t; lt = <span class="built_in">strlen</span>(t);</span><br><span class="line"></span><br><span class="line">    SA(lt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = mem[i].size();</span><br><span class="line">        s[ls] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; ls;j++) s[j] = mem[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = lt, m; <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> leq = le(t + sa[m] - <span class="number">1</span>, s, lt - sa[m] + <span class="number">1</span>,ls);</span><br><span class="line">            <span class="keyword">if</span>(leq == <span class="number">-1</span>) &#123;found = <span class="literal">true</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(leq) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt += found ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然说这题是AC自动机吧…但是后缀数组也能解。&lt;br&gt;在这里提供一个清新的后缀数组解法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀数组" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Unusual Sequences</title>
    <link href="https://big-news.cn/2020/07/08/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Unusual%20Sequences/"/>
    <id>https://big-news.cn/2020/07/08/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Unusual%20Sequences/</id>
    <published>2020-07-08T14:36:00.000Z</published>
    <updated>2020-08-09T01:30:11.241Z</updated>
    
    <content type="html"><![CDATA[<p>题意：输入 $x,y$，求有多少个数列满足其gcd为 $x$，和为 $y$。<br>这里提供一个不使用反演的清奇思路……</p><a id="more"></a><p>设 $f(s,g)$ 表示和为 $s$ ,gcd为 $g$ 的数列的数量，容易发现以下性质：</p><p>$$\begin{aligned} f(s,g)&amp;=0, \text{ }g\nmid s  \newline f(s,g)&amp;=f(s/g,1), \text{ } g|s \end{aligned}$$</p><p>我们知道和为 $s$ 的数列应当有 $2^{s - 1}$ 个，即把 $s$ 看成 $s$ 个1，然后插上 $s - 1$ 个隔板。那么有：</p><p>$$\begin{aligned} 2^{s - 1} &amp;= \sum\limits_{g=1}^s f(s,g)<br>\newline &amp;=\sum\limits_{g | s}f(s,g)<br>\newline &amp;=\sum\limits_{g | s}f(s/g,1)<br>\end{aligned}$$</p><p>移一下项，得到：<br>$$ f(s,1)=2^{s - 1}-\sum\limits_{g|s,g&gt;1}f(s / g,1) $$</p><p>设 $f[s]$ 表示 $f(s, 1)$ ，得到递推方程：<br>$$ f[s] =  2^{s - 1}-\sum\limits_{g|s,g&gt;1}f[s/g]$$</p><p>直接做是 $O(n)$ 的，但是容易知道有些位置的值是用不到的。开一个 <code>map</code> 储存 $f[]$ 数组，大力递推计算，参考杜教筛的复杂度，大约是 $O(n^{\frac{3}{4}})$，但是实际上跑得出奇的快。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = (<span class="number">1l</span>l * a * r) % P;</span><br><span class="line">        a = (<span class="number">1l</span>l * a * a) % P; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(f.count(s)) <span class="keyword">return</span> f[s];</span><br><span class="line">    <span class="keyword">int</span> r = qp(<span class="number">2</span>, s - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> g = <span class="number">2</span>;g * g &lt;= s;g++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s % g) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(g * g == s) r = (r - dfs(g) + P) % P;</span><br><span class="line">        <span class="keyword">else</span> r = ((r - dfs(s / g) - dfs(g)) % P + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s] = (r - <span class="number">1</span> + P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("_in.in", "r", stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span>(y % x) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, dfs(y / x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：输入 $x,y$，求有多少个数列满足其gcd为 $x$，和为 $y$。&lt;br&gt;这里提供一个不使用反演的清奇思路……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>Splay</title>
    <link href="https://big-news.cn/2020/06/26/Splay/"/>
    <id>https://big-news.cn/2020/06/26/Splay/</id>
    <published>2020-06-26T08:39:00.000Z</published>
    <updated>2020-08-10T03:02:53.542Z</updated>
    
    <content type="html"><![CDATA[<p>没有摘要可以提供，因为摘要还在<code>rotate</code>……</p><a id="more"></a><p><a href="https://cd.big-news.cn/index.php?user/publicLink&fid=a8091gCayaFIqHmMorCoWJ8ePzc45SkS5IwJdDvzTuKV6lVwKgBhuRcVfd6-gkeff4QmNAb0YEMSd6YKgpgrIHFSNci_txkRWPjiYEFU0httgmeWELTdCK83FleK7RmRlOsrQp8mb05hm_v7o-BL5Q&file_name=/Splay%20-%20OI%20Wiki.pdf">Splay - OI Wiki.pdf</a><br><a href="https://www.luogu.com.cn/problem/P3369">LGp3316 普通平衡树</a></p><p>模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> ch[CN][<span class="number">2</span>],fa[CN],val[CN],sz[CN],cnt[CN],tot,rt;</span><br><span class="line">    Splay() &#123;<span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span>(ch)); <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)); tot = rt = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">return</span> u == ch[ fa[u] ][<span class="number">1</span>];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;sz[u] = sz[lc] + sz[rc] + cnt[u];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;lc = rc = sz[u] = val[u] = fa[u] = cnt[u] = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">int</span> u = ++tot; sz[u] = cnt[u] = <span class="number">1</span>, val[u] = k, fa[u] = f; <span class="keyword">if</span>(f) ch[f][val[f] &lt; k] = u;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = fa[u], gf = fa[ fa[u] ], chk = get(u);</span><br><span class="line">        ch[f][chk] = ch[u][chk ^ <span class="number">1</span>], fa[ ch[u][chk ^ <span class="number">1</span>] ] = f;</span><br><span class="line">        ch[u][chk ^ <span class="number">1</span>] = f, fa[f] = u;</span><br><span class="line">        fa[u] = gf; <span class="keyword">if</span>(gf) ch[gf][f == ch[gf][<span class="number">1</span>]] = u;</span><br><span class="line">        maintain(f), maintain(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> f = fa[u]; f = fa[u]; rotate(u)) <span class="keyword">if</span>(fa[f]) rotate(get(f) == get(u) ? f : u);</span><br><span class="line">        rt = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _ins(<span class="keyword">int</span> u,<span class="keyword">int</span> f,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) &#123;make(f, k); rt = tot; maintain(f); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(val[u] == k) &#123;cnt[rt = u]++,sz[u]++; maintain(f); <span class="keyword">return</span>;&#125;</span><br><span class="line">        _ins(val[u] &gt; k ? lc : rc, u, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;_ins(rt, <span class="number">0</span>, k); splay(rt);&#125;</span><br><span class="line">    <span class="comment">// //</span></span><br><span class="line">    <span class="keyword">int</span> _rank(<span class="keyword">int</span> u,<span class="keyword">int</span> k) &#123;<span class="keyword">return</span> val[u] == k ? rt = u, sz[lc] + <span class="number">1</span> : (val[u] &gt; k ? _rank(lc, k) : sz[lc] + cnt[u] + _rank(rc, k));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">int</span> r = _rank(rt, k); splay(rt); <span class="keyword">return</span> r;&#125;</span><br><span class="line">    <span class="comment">// //</span></span><br><span class="line">    <span class="keyword">int</span> _kth(<span class="keyword">int</span> u,<span class="keyword">int</span> k) &#123;<span class="keyword">return</span> sz[lc] &gt;= k ? _kth(lc, k) : (sz[lc] + cnt[u] &gt;= k ? val[rt = u] : _kth(rc, k - sz[lc] - cnt[u]));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">int</span> r = _kth(rt, k); splay(rt); <span class="keyword">return</span> r;&#125;</span><br><span class="line">    <span class="comment">// //</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> u = ch[rt][<span class="number">0</span>]; <span class="keyword">while</span>(rc) u = rc; <span class="keyword">return</span> u;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nxt</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> u = ch[rt][<span class="number">1</span>]; <span class="keyword">while</span>(lc) u = lc; <span class="keyword">return</span> u;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        rank(k); <span class="keyword">int</span> u = rt;</span><br><span class="line">        <span class="keyword">if</span>(cnt[u] &gt; <span class="number">1</span>) &#123;sz[u]--,cnt[u]--; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!lc &amp;&amp; !rc) &#123;rt = <span class="number">0</span>, clear(u); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!lc) &#123;rt = rc, fa[rc] = <span class="number">0</span>; clear(u); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!rc) &#123;rt = lc, fa[lc] = <span class="number">0</span>; clear(u); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> x = pre(); splay(x);</span><br><span class="line">        ch[x][<span class="number">1</span>] = rc,fa[rc] = x; clear(u); maintain(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> tp = read(),x = read();</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">1</span>) t.ins(x);</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">2</span>) t.del(x);</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, t.rank(x));</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, t.kth(x));</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">5</span>) t.ins(x), <span class="built_in">printf</span>(<span class="string">"%d"</span>, t.val[ t.pre() ]), t.del(x);</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">6</span>) t.ins(x), <span class="built_in">printf</span>(<span class="string">"%d"</span>, t.val[ t.nxt() ]), t.del(x);</span><br><span class="line">        <span class="keyword">if</span>(tp &gt; <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-clock mr-2"></i>最近更新: 2020.6.26</div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有摘要可以提供，因为摘要还在&lt;code&gt;rotate&lt;/code&gt;……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://big-news.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="平衡树" scheme="https://big-news.cn/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】旧试题</title>
    <link href="https://big-news.cn/2020/06/19/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%97%A7%E8%AF%95%E9%A2%98/"/>
    <id>https://big-news.cn/2020/06/19/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%97%A7%E8%AF%95%E9%A2%98/</id>
    <published>2020-06-19T12:22:00.000Z</published>
    <updated>2020-08-09T01:30:11.241Z</updated>
    
    <content type="html"><![CDATA[<p>来自神仙 <code>11Dimensions</code> 的神仙做法……</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://www.luogu.com.cn/record/list?pid=P4619">原题链接</a></p></blockquote><p>求：<br>$$ \sum\limits_{i=1}^A \sum\limits_{j=1}^B \sum\limits_{k=1}^C d(ijk) $$<br>其中 $A,B,C ⩽ 200005$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>记$x⊥y$表示$(x,y)=1$。<br>结论：</p><p>$$d(ijk)=\sum\limits_{x|i}\sum\limits_{y|i}\sum\limits_{z|i}[x⊥y][x⊥z][y⊥z]$$</p><p>其中<code>[]</code>表示艾弗森括号，当且仅当括号内命题为真时取值为1，否则为0。<br>在本篇题解中，这个括号的意义等价于单位函数，即$\epsilon((a,b))=[(a,b)=1]=[a⊥b]$。<br>那么：</p><p>$$\begin{aligned}&amp; \sum\limits_{i=1}^A \sum\limits_{j=1}^B \sum\limits_{k=1}^C d(xyz) \newline<br>=&amp; \sum\limits_{i=1}^A \sum\limits_{j=1}^B\sum\limits_{k=1}^C\sum\limits_{x|i}\sum\limits_{y|i}\sum\limits_{z|i}[x⊥y][x⊥z][y⊥z] \newline<br>=&amp; \sum\limits_{x=1}^A \sum\limits_{y=1}^B \sum\limits_{z=1}^C[x⊥y][x⊥z][y⊥z] \lfloor\frac{A}{x}\rfloor \lfloor\frac{B}{y}\rfloor \lfloor\frac{C}{z}\rfloor \end{aligned}$$</p><p>从三个单位函数里面任选一个反演，利用$\epsilon=\mu*1$：</p><p>$$\begin{aligned}&amp; \sum\limits_{x=1}^A \sum\limits_{y=1}^B \sum\limits_{z=1}^C[x⊥y][x⊥z][y⊥z] \lfloor\frac{A}{x}\rfloor \lfloor\frac{B}{y}\rfloor \lfloor\frac{C}{z}\rfloor \newline<br>=&amp; \sum\limits_{x=1}^A \sum\limits_{y=1}^B \sum\limits_{z=1}^C (\sum\limits_{d|x,d|y}\mu(d)) [x⊥z][y⊥z] \lfloor\frac{A}{x}\rfloor \lfloor\frac{B}{y}\rfloor \lfloor\frac{C}{z}\rfloor \newline<br>=&amp; \sum\limits_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum\limits_{d=1}^{\min(A,B)}\mu(d)\sum\limits_{k_1=1}^{\lfloor\frac{A}{d}\rfloor}\sum\limits_{k_2=1}^{\lfloor\frac{B}{d}\rfloor}[k_1d⊥z][k_2d⊥z]<br>\lfloor\frac{A}{k_1d}\rfloor \lfloor\frac{B}{k_2d}\rfloor\end{aligned}$$</p><p>依据$[ab⊥c]\iff[a⊥c][b⊥c]$，整理得到：</p><p>$$\sum\limits_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum\limits_{d=1}^{\min(A,B)}\mu(d)[d⊥z]<br>(\sum\limits_{x=1}^{\lfloor\frac{A}{d}\rfloor}[x⊥z]\lfloor\frac{A}{xd}\rfloor)<br>(\sum\limits_{y=1}^{\lfloor\frac{B}{d}\rfloor}<br>[y⊥z] \lfloor\frac{B}{yd}\rfloor)$$</p><p>记：</p><p>$$\begin{aligned} g(n,x) = \sum\limits_{i=1}^n\mu(i)[i⊥x] \newline<br>f(n,x) = \sum\limits_{i=1}^n\lfloor\frac{n}{i}\rfloor[i⊥x] \end{aligned}$$</p><p>答案变成：</p><p>$$\begin{aligned}&amp; \sum\limits_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum\limits_{d=1}^{\min(A,B)}\mu(d)[d⊥z]f(\lfloor\frac{A}{d}\rfloor, z)f(\lfloor\frac{B}{d}\rfloor, z) \newline<br>=&amp; \sum\lfloor\frac{C}{z}\rfloor\sum(g(r,z) - g(l - 1, z))f(\lfloor\frac{A}{d}\rfloor, z)f(\lfloor\frac{B}{d}\rfloor, z)\end{aligned}$$</p><p>即对$\mu()$做前缀和然后对后面的$f()$分段，其中$[l,r]$表示整除分段的一段区间。</p><p>假设$O(n)$枚举$z$，那么求出后面的$\sum$的值是$O(\sqrt{n})$的。但是发现$z$是变化的，当$z$变化时暴力维护$f(),g()$是$O(n^2)$的，这成为了代码复杂度的瓶颈。如何解决？<br>能不能减少更新$f(),g()$的次数？不难发现$z$在函数中发挥作用的地方是判断一个数与其互质。考虑将$z$质因数分解，容易看出一个数与其互质仅和$z$的质因子的种类有关，而与质因子的幂次无关。<br>记：</p><p>$$lw(z) = \prod\limits_{i=1}^np_i, \text{where }z = \prod\limits_{i=1}^np_i^{\alpha_i}$$</p><p>那么我们只需要考虑$z\in [1,C]$的所有$lw(z)$值即可（即所有无平方因子的数），它们共用一套$f(),g()$的函数值。<strong>通过dfs暴力生成无平方因子数，我们可以把它们一并更新。</strong></p><p>但是这远远不够，考虑通过递推来维护$f(),g()$。这个套路参考<a href="https://www.luogu.com.cn/problem/P1587">NOI2016 循环之美</a>。<br>考虑在$z$中删去其一个质因子$x$，即$f(n,z)\to f(n,z/x)$，将出现何种变化？应当有一部分多加了，要减去：</p><p>$$\begin{aligned}f(n,z) &amp;= \sum\limits_{i=1}^n\lfloor\frac{n}{i}\rfloor[i⊥z/x] -<br>\sum\limits_{i=1}^n\lfloor\frac{n}{i}\rfloor[i⊥z/x][x|i] \newline<br>&amp;= f(n, z / x) - \sum\limits_{k=1}^{\lfloor\frac{n}{x}\rfloor}[kx⊥z/x]\lfloor\frac{n}{kx}\rfloor \newline<br>&amp;= f(n, z / x) - [x⊥z/x]\sum\limits_{k=1}^{\lfloor\frac{n}{x}\rfloor}[k⊥z/x]\lfloor\frac{n}{kx}\rfloor\newline<br>&amp;= f(n, z / x) - f(\lfloor\frac{n}{x}\rfloor, z/x)\end{aligned}$$</p><p>对$g()$的推导也同理，利用$\mu(ab)=\mu(a)\mu(b)[a⊥b]$，可以得出：</p><p>$$\begin{aligned}g(n,z) &amp;= \sum\limits_{i=1}^n \mu(i) [i⊥z/x] -<br>\sum\limits_{i=1}^n \mu(i) [i⊥z/x][x|i] \newline<br>&amp;= g(n, z / x) - \sum\limits_{k=1}^{\lfloor\frac{n}{x}\rfloor}[kx⊥z/x] \mu(kx) \newline<br>&amp;= g(n, z / x) - \mu(x)\sum\limits_{k=1}^{\lfloor\frac{n}{x}\rfloor}\mu(k)[k⊥x][k⊥z/x] \newline<br>&amp;= g(n, z / x) + \sum\limits_{k=1}^{\lfloor\frac{n}{x}\rfloor}\mu(k)[k⊥x(z/x)] \newline<br>&amp;= g(n, z / x) + g(\lfloor\frac{n}{x}\rfloor, z)\end{aligned}$$</p><p>即：</p><p>$$\begin{aligned} g(n,z) = g(n, z / x) + g(\lfloor\frac{n}{x}\rfloor, z) \newline<br>f(n,z) = f(n, z / x) - f(\lfloor\frac{n}{x}\rfloor, z/x) \end{aligned}$$</p><p>那么就可以递推了，但是直接更新是$O(n)$的。容易发现整除分段并不会用到所用的$f(),g()$值，所以我们边做分段边更新就好了，这是$O(\sqrt{n})$的。<br>空间复杂度呢？<code>f[2e5][2e5],g[2e5][2e5]</code>看似存不下来，但是容易发现后面一维是不连续使用的，那么将其离散化，考虑在dfs构造无平方因子数的时候，下层状态的转移依赖于上层状态，而dfs树的深度是$O(\log_2n)$的，所以开<code>f[2e5][10]</code>即可。</p><p>总复杂度？粗略估计，爆搜的复杂度是$O(2^{\log_2n})$即$O(n)$的，后面的求和通过整除分段可以$O(\sqrt{n})$得出，那么总复杂度是$O(n\sqrt{n})$的。但实际上复杂度要小很多，也就是说如果常数写得好那么它可以跑的飞快（预处理整除分段的端点、cache-friendly之类的），但是本人代码常数没那么小，最慢一个点大约4s？<br>比三元环是好得多了。</p><p>Orz <code>11Dimensions</code></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    LL s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>; c = getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[CN],mu[CN],lw[CN]; LL d[CN]; <span class="keyword">bool</span> np[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    np[<span class="number">1</span>] = <span class="literal">true</span>; mu[<span class="number">1</span>] = <span class="number">1</span>, d[<span class="number">1</span>] = <span class="number">1</span>, lw[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) p[ ++p[<span class="number">0</span>] ] = i, d[i] = <span class="number">2</span>, lw[i] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= p[<span class="number">0</span>] &amp;&amp; i * p[j] &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i * p[j]; np[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j]) d[x] = d[i] &lt;&lt; <span class="number">1</span>, lw[x] = lw[i] * p[j], mu[x] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;d[x] = (d[i] &lt;&lt; <span class="number">1</span>) - d[i / p[j]], lw[x] = lw[i]; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) d[i] += d[i - <span class="number">1</span>],mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">int</span> t,A,B,C;</span><br><span class="line">LL f[CN][<span class="number">10</span>],g[CN][<span class="number">10</span>],s[CN],ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= A; l++)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = min(A / (A / l), B / (B / l));</span><br><span class="line">        g[r][<span class="number">1</span>] = mu[r]; f[A / l][<span class="number">1</span>] = d[A / l]; f[B / l][<span class="number">1</span>] = d[B / l];</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span> , <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>;z &lt;= C; z++) s[ lw[z] ] += <span class="number">1l</span>l * C / z;</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= A; l++)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = min(A / (A / l), B / (B / l));</span><br><span class="line">        g[r][k] = g[r][k - <span class="number">1</span>] + g[r / x][k];</span><br><span class="line">        f[A / l][k] = f[A / l][k - <span class="number">1</span>] - f[(A / l) / x][k - <span class="number">1</span>];</span><br><span class="line">        f[B / l][k] = f[B / l][k - <span class="number">1</span>] - f[(B / l) / x][k - <span class="number">1</span>];</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> z0, <span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    LL cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= A; l++)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = min(A / (A / l), B / (B / l));</span><br><span class="line">        cur += (g[r][k] - g[l - <span class="number">1</span>][k]) * f[A / l][k] * f[B / l][k];</span><br><span class="line">        cur = (cur % P + P) % P;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (s[z0] * cur) % P; ans %= P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = u; <span class="number">1l</span>l * p[v] * z0 &lt;= C; v++) upd(p[v], k + <span class="number">1</span>), dfs(z0 * p[v], v + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    t = read(); sieve(<span class="number">2e5</span>); </span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        A = read(), B = read(), C = read();</span><br><span class="line">        <span class="keyword">if</span>(A &gt; B) swap(A, B);</span><br><span class="line"></span><br><span class="line">        init(); dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自神仙 &lt;code&gt;11Dimensions&lt;/code&gt; 的神仙做法……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="https://big-news.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="筛法" scheme="https://big-news.cn/tags/%E7%AD%9B%E6%B3%95/"/>
    
      <category term="反演" scheme="https://big-news.cn/tags/%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>除夕闲扯</title>
    <link href="https://big-news.cn/2020/01/24/%E9%99%A4%E5%A4%95%E9%97%B2%E6%89%AF/"/>
    <id>https://big-news.cn/2020/01/24/%E9%99%A4%E5%A4%95%E9%97%B2%E6%89%AF/</id>
    <published>2020-01-23T22:47:00.000Z</published>
    <updated>2020-08-09T10:14:10.573Z</updated>
    
    <content type="html"><![CDATA[<article class="message message-immersive is-danger"><div class="message-body"><i class="fas fa-exclamation-triangle mr-2"></i>请人为忽略与主题有关的内容，这其实是一个目录。</div></article><a id="more"></a><p>文化课真好系列<br>为了证明 bn 还没入坟，他决定闲的没事瞎bb几句<br>起名做：A Simple Proof of BN’s Aliving</p><h2 id="A-Simple-Proof-of-BN’s-Aliving"><a href="#A-Simple-Proof-of-BN’s-Aliving" class="headerlink" title="A Simple Proof of BN’s Aliving"></a>A Simple Proof of BN’s Aliving</h2><h3 id="P1-Analyse-the-Problem"><a href="#P1-Analyse-the-Problem" class="headerlink" title="P1 Analyse the Problem"></a>P1 Analyse the Problem</h3><p>该命题<strong>显然</strong>不成立。</p><h3 id="P2-Conclusion"><a href="#P2-Conclusion" class="headerlink" title="P2 Conclusion"></a>P2 Conclusion</h3><p>bn 已经入坟，故证伪。</p><hr><p>因 bn 已经入坟，所以他对之前的 post 们搞了一个整理，以备 <del>后人之用</del> 自己欣赏。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-asia mr-2"></i>此页面存在相关页面。关于另一个集合贴，请参见<a href="/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/">「OI模板梳理」</a>。</div></article><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>最短路</p><ul><li>Dijkstra：<a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#1-1-Dijkstra">OI模板梳理 2.1.1</a></li><li>SPFA: <a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#1-3-Bellman-Ford-SPFA">OI模板梳理 2.1.3</a></li><li>Floyd: Floyd本质探究-<a href="https://big-news.cn/2019/03/24/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA/">【题解】灾后重建</a></li></ul><p>树</p><ul><li>最小生成树(MST)：<a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#2-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">OI模板梳理 2.2</a>，变形-<a href="https://big-news.cn/2019/11/09/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91%20Codeforces%20Round%20599%20(Div.%202)/#D-0-1-MST">CFR599D 0-1 MST</a></li><li><a href="https://big-news.cn/2019/06/26/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/">树的重心</a>，<a href="https://big-news.cn/2019/04/11/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/">树的直径</a></li><li>LCA: 倍增法-<a href="https://big-news.cn/2019/03/10/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">最近公共祖先</a>，树链剖分法-<a href="https://big-news.cn/2019/07/18/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/#1-%E7%82%B9%E5%AF%B9LCA">树链剖分 3.1</a></li><li>树上类RMQ问题：<a href="https://big-news.cn/2019/07/18/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/">树链剖分</a></li></ul><p>连通性</p><ul><li><a href="https://big-news.cn/2019/02/07/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/">强连通分量/SCC</a></li><li><a href="https://big-news.cn/2019/03/08/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/">双连通分量/BCC</a></li><li>割点和桥：<a href="https://big-news.cn/2019/03/08/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/#%E4%BA%8C-%E5%89%B2%E9%A1%B6">双连通分量 2</a></li><li>2-SAT：<a href="https://cd.big-news.cn/data/User/admin/home/%E6%96%87%E6%A1%A3/2019.10%20JN%20%E6%80%BB%E7%BB%93.pdf">2019.10 JN 总结.pdf</a></li></ul><p>网络</p><ul><li>最大流-最小割：<a href="https://big-news.cn/2019/02/23/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/">网络最大流</a></li><li><a href="https://big-news.cn/2019/03/19/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/">最小费用最大流</a></li></ul><p>二分图</p><ul><li>最大匹配：匈牙利算法-<a href="https://big-news.cn/2019/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/">二分图匹配</a>，费用流法-<a href="https://big-news.cn/2019/03/19/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/#1-%E6%9C%80%E5%A4%A7%E5%9F%BA%E6%95%B0%E5%8C%B9%E9%85%8D">最小费用最大流 4.1</a></li><li>最大点全覆盖集：<a href="https://big-news.cn/2019/03/19/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/#2-%E6%9C%80%E5%A4%A7%E5%B8%A6%E6%9D%83%E5%8C%B9%E9%85%8D">最小费用最大流 4.2</a></li><li>最大独立集：<a href="https://big-news.cn/2019/03/19/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/#3-%E6%9C%80%E5%A4%A7%E5%B8%A6%E6%9D%83%E7%8B%AC%E7%AB%8B%E9%9B%86">最小费用最大流 4.3</a></li></ul><p>欧拉图：<a href="https://big-news.cn/2019/02/26/%E6%AC%A7%E6%8B%89%E8%B7%AF/">欧拉路</a></p><p>拓扑：<a href="https://big-news.cn/2019/02/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">拓扑排序</a></p><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p><a href="https://big-news.cn/2019/08/16/%E7%BA%BF%E6%80%A7%E7%AD%9B/">线性筛</a></p><p>高斯消元：<a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#3-%E9%AB%98%E6%96%AF-%E7%BA%A6%E6%97%A6%E6%B6%88%E5%85%83">OI模板梳理 4.3</a></p><p>乘法逆元</p><ul><li>费马小定理法-<a href="https://big-news.cn/2019/07/18/%E9%80%86%E5%85%83/">逆元</a></li><li>exgcd法-<a href="https://big-news.cn/2019/07/22/%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/#%E4%BA%8C-%E6%B1%82%E8%A7%A3%E5%8D%95%E5%8F%98%E5%85%83%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B">模线性方程组与中国剩余定理 2</a></li><li>线性求逆元-<a href="https://big-news.cn/2019/07/18/%E9%80%86%E5%85%83/#3-%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%E6%B1%82%E9%80%86%E5%85%83">逆元 2.3</a>    </li></ul><p>欧几里得系列：<a href="https://big-news.cn/2019/05/19/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/">欧几里得与扩展欧几里得定理</a></p><p>中国剩余定理系列：<a href="https://big-news.cn/2019/07/22/%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/">模线性方程组与中国剩余定理</a></p><p>矩阵系列：<a href="https://big-news.cn/2019/07/30/%E7%9F%A9%E9%98%B5%E5%9F%BA%E7%A1%80/">矩阵基础</a></p><p>概论系列：<a href="https://big-news.cn/2019/05/26/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">概率与期望</a></p><p>组合学系列：<a href="https://big-news.cn/2019/07/26/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">组合数学基础</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>单调栈：<a href="https://www.luogu.com.cn/problem/P1823">音乐会的等待</a></p><p><a href="https://big-news.cn/2019/02/28/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">单调队列</a>，对DP的优化-<a href="https://big-news.cn/2019/08/04/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Watching%20Fireworks%20is%20Fun/">【题解】Watching Fireworks is Fun</a></p><p>堆：<a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#3-%E5%A0%86">OI模板梳理 1.3</a>，或pq一行完成</p><p>并查集：<a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#4-%E5%B9%B6%E6%9F%A5%E9%9B%86">OI模板梳理 1.4</a></p><p><a href="https://big-news.cn/2019/01/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">树状数组</a></p><p><a href="https://big-news.cn/2019/01/30/%E7%BA%BF%E6%AE%B5%E6%A0%91/">线段树</a>，线段覆盖-<a href="https://big-news.cn/2019/07/17/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Atlantis/">【题解】Atlantis</a></p><p><a href="https://big-news.cn/2019/11/06/%E6%95%B0%E5%88%97%E5%B7%AE%E5%88%86/">数列差分</a></p><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p><a href="https://big-news.cn/2019/01/29/%E8%83%8C%E5%8C%85/">背包</a>，变式-<a href="https://big-news.cn/2019/10/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/">【题解】硬币购物</a></p><p><a href="https://big-news.cn/2019/02/01/%E6%A0%91%E4%B8%8A%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">树形DP</a>，变式-<a href="https://big-news.cn/2019/10/26/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E9%87%8D%E5%BB%BA%E9%81%93%E8%B7%AF/">【题解】重建道路</a></p><p><a href="https://big-news.cn/2019/02/18/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">状压DP</a></p><p>优化：单调队列优化-<a href="https://big-news.cn/2019/08/04/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Watching%20Fireworks%20is%20Fun/">【题解】Watching Fireworks is Fun</a>，矩阵乘法优化-<a href="https://big-news.cn/2019/08/01/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%91%86%E8%8A%B1/">【题解】摆花</a></p><p>其他DP内容，请参见<a href="https://big-news.cn/tags/DP/">标签：DP</a></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>字符串：KMP-<a href="https://big-news.cn/2019/07/27/KMP%E7%AE%97%E6%B3%95/">KMP算法</a></p><p>关于本博客的内容，顺便还有之前的<a href="https://big-news.cn/2019/08/12/hexo%E4%B8%BB%E9%A2%98Icarus%E6%B5%85%E5%BA%A6%E4%BF%AE%E6%94%B9%E6%95%99%E7%A8%8B/">Icarus魔改教程</a>，<del>教你一步步走向深渊。</del></p><p>顺便一说，bn 的 luogu 还没有掉蓝（珂怕）。</p><hr><p>以上</p><p>祝各位新春快乐<br>qwq.</p><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;article class=&quot;message message-immersive is-danger&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-exclamation-triangle mr-2&quot;&gt;&lt;/i&gt;
请人为忽略与主题有关的内容，这其实是一个目录。
&lt;/div&gt;
&lt;/article&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://big-news.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>CSP2019 退役记</title>
    <link href="https://big-news.cn/2019/11/16/CSP2019%20%E9%80%80%E5%BD%B9%E8%AE%B0/"/>
    <id>https://big-news.cn/2019/11/16/CSP2019%20%E9%80%80%E5%BD%B9%E8%AE%B0/</id>
    <published>2019-11-16T08:15:00.000Z</published>
    <updated>2020-08-09T01:36:49.457Z</updated>
    
    <content type="html"><![CDATA[<p>没有摘要可以提供，因为摘要自闭去了……</p><a id="more"></a><h2 id="d0"><a href="#d0" class="headerlink" title="d0"></a>d0</h2><p>14:00p.m.+ arrived.<br>然后颓了约 1h+ ，出去买了一瓶钟水回来切题。<br>考前想练练码力，于是去做<a href="https://www.luogu.org/problem/P3952">NOIP2017d1t2 时间复杂度</a>，结果交了五遍才过……</p><p>然后因为想用vscode编译，去搞环境变量，终于没出错，于是很满足的去恰饭……</p><p>7:40p.m.+ 去试机，发现电脑并没有什么问题。试了试gdb也活着，然后大约还剩20min左右吧，就去打树剖的板子。结果等到试机结束，只剩下读入没写完….于是放弃。</p><p>回宿舍，想起来钟水喝完了，于是又去买了一瓶（total : 2）。宿舍里凳子不够，只好上床上肝题，一直肝到宿管都走了才睡觉，大约11:10p.m.</p><h2 id="d1"><a href="#d1" class="headerlink" title="d1"></a>d1</h2><p>6:20a.m. get up.<br><del>然后又睡了15min</del></p><p>7:30a.m. 去考场，在门口等了将近30min才进去。</p><p>8:30a.m. 准时开题。看了看t1觉得做法显然，然后去看t2，发现链的分数居然这么多。。。遂在草纸上写下：t2 链 O(n^2) 30pts + O(n) 25pts；暴力 O(n^2) 20 pts。觉得如果都能拿到也很可观。</p><p>去看t3，发现又是一道树上问题。。看来出题人是真的互相不知情。。。发现 25pts 是链，25pts 是菊花图，然后暴力分只有 10pts 。。。按照去年的经验，这种题特殊情况应该比较好想，所以觉得这题期望60pts。</p><p>然后去开t1，发现貌似会爆精度。不过不要紧，我可以特判啊，于是写了个类似于高精读入然后再转低精的东西，20min码完20min调完，时间用的貌似有点多。</p><p>开t2，发现并不会线性的做法。。。只会O(n^2)大力递推，然后想可能能用数据结构优化到O(nlogn)级别，不过没有思路。发现链的做法和树没有什么本质的区别，于是感觉要有25pts拿不到了。</p><p>开t3，发现两个特殊情况一个也不显然<del>（真香）</del>。。没救了，觉得可能t2更可做一点，于是打完10pts暴力去肝t2。</p><p>然而只剩下50min-。再看t2依然没有更优秀的想法，于是果断放弃去检查t1。<br>发现t1写的处处是锅。。。然后发现貌似并不会爆精度，于是直接开<code>unsigned long long</code>大力搞。结果一些小细节一直在出锅，一直搞到11:55a.m.。</p><p>期间去看t2和t3，觉得我的t3绝不可能写挂，于是重点看t2有没有被卡精度，并没有发现明显的锅。</p><p>然后就这样了，最后看了看文件也没有出锅，就到12:00了。期望：100+50+10=160，考满也才到大众分。。。不过突然很怂t1写锅。</p><p>下午又去买钟水（total: 3）。</p><p>5:04p.m. t1过民间数据，看来思路没锅。不过最后5min改代码还是怂。。<br>恰完晚饭又开始怂t2写锅。。</p><p>6:33p.m. t2自测居然80pts。。一定是数据太水。</p><h2 id="d2"><a href="#d2" class="headerlink" title="d2"></a>d2</h2><p>6:50a.m. get up.<br>然后并不想恰早饭，喝了两碗粥散伙。</p><p>7:40a.m. 就憨憨的去了考场，然后等了半个小时。。。</p><p>8:25a.m. 拿到题目。t1居然是emiya。。emiya你为何如此nb。。然后发现我并不能把这个题看透，越看越像背包，但是并没有显然的想法，写了30min发现写不出来，于是去看t2。</p><p>开t2，一眼不可做。看数据更觉得这题绝不可做，直接考虑暴力，复杂度大概 O(玄学) ？看不透到底是有12pts还是24pts，于是告辞去看t3。</p><p>开t3，又是树。。ccf你一年考三道树上问题可还行。。发现暴力有40pts，反手一个O(n^2)大力枚举，单走一个样例，过掉，然后去写t2。</p><p>10min码出t2暴力，走前两个样例居然都过了，第三个样例太大肯定过不去，于是自己造了一个n=50的数据，发现跑的还挺快？++24pts。</p><p>10:00a.m. 重开t1。<del>我剩两个小时写t1你能秒我？我两个小时t1你能把我秒了？</del>结果活活推了1h毫无想法。只好去写暴力，测到第三个样例就炸掉了，估计只有32pts。</p><p>还剩大约40min，去看t3发现链的情况可做，因为链上的重心显然可以O(1)算出来。然后20min调试好代码，造了几个数据对拍都过掉了，于是觉得大概不会有什么锅，心想++15pts。</p><p>最后15min把三个源程序都重新看了一遍，没看出什么锅来，然后就告辞了。</p><p>回去的路上又去买了一瓶钟水（total : 4）。可能是退役之前的最后一瓶钟水了。。。</p><p>后来发现我t3链的情况写锅了。。。(Pi,Pi+1)活活看成(i,i+1)，当时还觉得没问题。。。于是成功–15pts。</p><p>估分：32+24+40=96，两天100+80+10+32+24+40=286封顶，预测会被锅到250~260左右，成功AFO。</p><p>然后回来的时候听说全国划线。。。目测省四稳了。</p><p>然后就没然后了。。技不如人，肝败下风。</p><hr><p>退役了，虽然好像还有很多事没去完成。</p><p>cf一直想上蓝，结果直到最后都在Specialist的底部徘徊。。<br>洛谷红了快两年了吧，停课之后打了几场月赛，排名居然升到了rk264，不过马上也就要掉下去了。。<br>顺带一说昨天恰好499AC，差一道就到500题了。本来想在退役之前把差的题目刷上去，可惜觉得找不到适合充当这最后一道题目的题。。那就不刷了吧，有时候不完美也是一种完美。</p><p>2017.9~2019.11 Away From OI，虽然打的很菜，但至少我来过。</p><hr><p>Upd on 2019.11.20 几天没上洛谷居然又上分了，rk181，xswl。<br>Upd on 2019.11.25 洛谷居然又上分了……rk168…</p><hr><p>Upd on 2019.12.17 </p><p>迟到好久的最终更新</p><p>最后 t2 的大力DP终究还是没能活下来，然后成功地100+50+10+32+24+40=256，省rk110+，原地升天爆炸退役。</p><p>然后就这样吧。因为太菜，所以只能选择退役。</p><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有摘要可以提供，因为摘要自闭去了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://big-news.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>【解题报告】NIKKEI Prog. Contest 2019-2</title>
    <link href="https://big-news.cn/2019/11/10/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91NIKKEI%20Prog%20Contest%202019-2/"/>
    <id>https://big-news.cn/2019/11/10/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91NIKKEI%20Prog%20Contest%202019-2/</id>
    <published>2019-11-10T00:16:00.000Z</published>
    <updated>2020-08-09T01:30:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>又是签到走人的一天……</p><a id="more"></a><h2 id="A-Sum-of-Two-Integers"><a href="#A-Sum-of-Two-Integers" class="headerlink" title="A. Sum of Two Integers"></a>A. Sum of Two Integers</h2><p><a href="https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_a">Source</a></p><p>签到题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span>) n += <span class="number">1</span>; n /= <span class="number">2</span>; <span class="built_in">printf</span>(<span class="string">"%d"</span>,n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Counting-of-Trees"><a href="#B-Counting-of-Trees" class="headerlink" title="B. Counting of Trees"></a>B. Counting of Trees</h2><p><a href="https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_b">Source</a></p><p>签到题。考虑每一层的方案数，直接乘法原理就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL R = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,fir; LL s[CN];</span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a,LL b)</span></span>&#123;</span><br><span class="line">    LL rec = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) (rec *= a) %= R;</span><br><span class="line">        (a *= a) %= R; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;fir);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); </span><br><span class="line">        <span class="keyword">if</span>(!x) &#123;fir = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        s[x]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(s[i]) s[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s[<span class="number">0</span>];i++) <span class="keyword">if</span>(!s[i]) fir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fir) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        LL ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s[<span class="number">0</span>];i++) (ans *= qpow(s[i<span class="number">-1</span>], s[i])) %= R;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 不会，skip 。</p><h2 id="D-Shortest-Path-on-a-Line"><a href="#D-Shortest-Path-on-a-Line" class="headerlink" title="D. Shortest Path on a Line"></a>D. Shortest Path on a Line</h2><p><a href="https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_d">Source</a></p><p>这题把我卡了一个多小时还没想出来，当时一直在想建个线段树搞线段覆盖……</p><p>实际上一段区间里面任意两点间有等距的有向边，这个东西等价于把这段区间连成一个简单环：节点顺序连边，然后仅有一条边有边权为 ci ，其余为 0 。那么如果我们逆着这个环的方向去求最短路，就能得到这个长度总是 ci ，因为没法直接到达，就总要经过那条边权为 ci 的边。</p><p>一张图解：<br><img src="https://upl.big-news.cn/2019/11/10/nk2019.jpg"></p><p>剩下的问题跑 DJ 就好了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f2f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar()) <span class="keyword">if</span>(c==<span class="string">'-'</span>) ne=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar()) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s*ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; LL di; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,LL d)</span> </span>&#123;to=t;nxt=n;di=d;&#125;</span><br><span class="line">&#125;E[CN * <span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN],ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,LL z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DJ */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> id; LL v; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ&amp; a)<span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;DJ&gt; Q; </span><br><span class="line">LL d[CN]; <span class="keyword">bool</span> vis[CN];</span><br><span class="line"><span class="function">LL <span class="title">SP</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> ed)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    Q.push((DJ)&#123;st, d[st] = <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.top().id; Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">            <span class="keyword">if</span>(d[v] &gt; d[u] + E[k].di)&#123;</span><br><span class="line">                d[v] = d[u] + E[k].di;</span><br><span class="line">                Q.push((DJ)&#123;v, d[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[ed] &lt; INF ? d[ed] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(),v = read(); LL c = read();</span><br><span class="line">        add(u, v, c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) add(i + <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, SP(<span class="number">1</span>, n));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是签到走人的一天……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>【解题报告】 Codeforces Round 599 (Div. 2)</title>
    <link href="https://big-news.cn/2019/11/09/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91%20Codeforces%20Round%20599%20(Div.%202)/"/>
    <id>https://big-news.cn/2019/11/09/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91%20Codeforces%20Round%20599%20(Div.%202)/</id>
    <published>2019-11-09T06:58:00.000Z</published>
    <updated>2020-08-09T01:30:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>解题报告貌似鸽了好几天了，毕竟是晚上爆肝打的比赛，第二天早上起来还要 % 拟 ……<br>其实之前还有场 Div. 3 ，不过打的太烂就不写解题报告了……</p><a id="more"></a><p>先是掉分经过：<br>开场 15min 切 A,B1 签到不多说，然后去看 B2 ，觉得它不显然；就去看 C 题，然后觉得这个东西貌似可以分解质因数然后搞一搞，结果后来代码一直锅掉，调了将近一个小时才过……期间去看 D 题，也没有什么本质的想法，然后就睡觉去了，大概在 0:20 a.m. 左右，目测掉分预定。<br>第二天早上起来发现 C 题居然没锅，然后就神奇的 rating +19 ，不过依然是 $\text{Specialist}$ 。</p><h2 id="A-Maximum-Square"><a href="#A-Maximum-Square" class="headerlink" title="A. Maximum Square"></a>A. Maximum Square</h2><p><a href="https://codeforces.com/contest/1243/problem/A">Source</a></p><p>签到题。当时切了 C 题去 room 里砍人，居然发现这题有人写二分……无言以对。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e3</span>+<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="comment">/* omitted */</span>&#125;</span><br><span class="line"><span class="keyword">int</span> q,n,a[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(a[j] &gt;= i) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= i) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i); <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B1-Character-Swap-Easy-Version"><a href="#B1-Character-Swap-Easy-Version" class="headerlink" title="B1. Character Swap (Easy Version)"></a>B1. Character Swap (Easy Version)</h2><p><a href="https://codeforces.com/contest/1243/problem/B1">Source</a></p><p>依然签到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e4</span>+<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="comment">/* omitted */</span>&#125;</span><br><span class="line"><span class="keyword">int</span> k,n; <span class="keyword">char</span> s[CN],t[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    k = read();</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        n = read(); <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(s[i] != t[i]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt != <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p[<span class="number">20</span>],q = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(s[i] != t[i]) p[q++] = i;</span><br><span class="line">            swap(s[ p[<span class="number">0</span>] ], t[ p[<span class="number">1</span>] ]);</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(s[i] != t[i]) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(!cnt) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B2 不会，skip 。</p><h2 id="C-Tile-Painting"><a href="#C-Tile-Painting" class="headerlink" title="C. Tile Painting"></a>C. Tile Painting</h2><p><a href="https://codeforces.com/contest/1243/problem/C">Source</a></p><p>考虑有哪些格子的颜色相同，不难发现这个东西跟它的质因子有关系。<br>从一个点出发，我们应该筛掉从该点出发，以 n 的任一质因子为“距离”能到达的所有点，这些点的颜色相同；然后下一次我们应该再去找一个没有被筛过的点重复上述过程。问题的本质在于“没有被筛过的点”我们能找到几个。</p><p>不难发现如果一个数字只有一个质因子 p ，那么这样的点我们有 p 个，即 1~p ；若其存在两个或更多的质因子，那么看起来从第一个点开始就能筛掉所有点，于是答案是 1 .</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL n,p[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(LL k=<span class="number">2</span>;k*k&lt;=x;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x % k)) p[ ++p[<span class="number">0</span>] ] = k;</span><br><span class="line">        <span class="keyword">while</span>(!(x % k)) x /= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) p[ ++p[<span class="number">0</span>] ] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    div(n);</span><br><span class="line">    <span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%I64d"</span>,p[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-0-1-MST"><a href="#D-0-1-MST" class="headerlink" title="D. 0-1 MST"></a>D. 0-1 MST</h2><p><a href="https://codeforces.com/contest/1243/problem/D">Source</a></p><p>显然连 0 边更优，也就是说我们只在迫不得已的情况下去连 1 边。考虑在图上只保留 0 边，那么显然一个联通块里面我们是不需要连 1 边的。把每个联通块整体考虑，则需要连 1 边的数量为联通块数 -1 。</p><p>上述过程大力搜索实现显然是不行的，考虑用并查集维护联通性。我们怎么判定一个点属于一个联通块？假设某一联通块的大小为 sz ，那么一个点向它连的 1 边的数量（记作 ct ）是可以统计的，而该点和此联通块一共有 sz 条边相连；当 sz  &gt; ct 时，即可推出该点与联通块之间有 0 边。</p><p>可是上述过程大力去做还是 O(n^2) 的，考虑到一个联通块只需要被合并一次，于是对于所有找到的联通块，只记录其中一个点进行合并就好了，也就是把该联通块在并查集中的根记下来。因为原图上 0 边很多，也就是说联通块个数很少，所以这个想法就会跑得很快。</p><p>最后的答案是并查集中根的个数 -1，其中根的个数即为联通块数。考虑到我们此前维护的根可能被合并，也就是说有些根 gg 掉了，所以最后还得再统计一下根的数量。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fa[CN],sz[CN]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rt;</span><br><span class="line">    dsu() &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;CN;i++) fa[i]=i,sz[i]=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> find(x) != find(y);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;x = find(x); y = find(y); sz[y] += sz[x]; fa[x] = y;&#125;</span><br><span class="line">&#125;co;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to=t;nxt=n;&#125;</span><br><span class="line">&#125;E[CN * <span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN],ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ve[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    co.rt.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ve, <span class="number">0</span>, <span class="keyword">sizeof</span>(ve));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=hd[i];k;k=E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">            <span class="keyword">if</span>(v &lt; i) ve[ co.find(v) ]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cn = co.rt.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cn;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = co.rt[j]; r = co.find(r);</span><br><span class="line">            <span class="keyword">if</span>(co.sz[r] &gt; ve[r] &amp;&amp; co.exm(i, r)) co.merge(i, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(co.find(i) == i) co.rt.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(co.find(i) == i) cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u, v); add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ct() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解题报告貌似鸽了好几天了，毕竟是晚上爆肝打的比赛，第二天早上起来还要 % 拟 ……&lt;br&gt;其实之前还有场 Div. 3 ，不过打的太烂就不写解题报告了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>数列差分</title>
    <link href="https://big-news.cn/2019/11/06/%E6%95%B0%E5%88%97%E5%B7%AE%E5%88%86/"/>
    <id>https://big-news.cn/2019/11/06/%E6%95%B0%E5%88%97%E5%B7%AE%E5%88%86/</id>
    <published>2019-11-06T08:52:00.000Z</published>
    <updated>2020-08-15T12:46:56.086Z</updated>
    
    <content type="html"><![CDATA[<p>差分是一种对于数列区间修改问题的很优秀的 idea ，对于每个独立的查询操作，它可以做到在线性时间内完成任务……</p><a id="more"></a><h1 id="一-一阶差分"><a href="#一-一阶差分" class="headerlink" title="一 一阶差分"></a>一 一阶差分</h1><h2 id="1-模型"><a href="#1-模型" class="headerlink" title="1 模型"></a>1 模型</h2><article class="message is-primary" style="font-size:inherit"><div class="message-body">维护一段数列，支持将区间 $ [l,r] $ 内的每个元素加或减某个值，并查询所有操作后的数列。要求在线性时间内完成任务。</div></article><p>以上为数列差分问题的基本模型。</p><p>对于数列$a_1,a_2,a_3,…,a_n$，我们定义它的差分数列为$b_1,b_2,b_3,…b_n$，满足$b_i = a_i-a_{i-1}$。不难发现，有 $a_i=\sum_{j=1}^i b_j$。</p><p>我们发现在对区间 $[l,r]$ 进行某次操作之后，该区间内元素的相对大小是不变的，也就是任意两数的差值固定。利用这个性质，我们发现在对一段区间 $[l,r]$ 操作之后，数列 $\begin{Bmatrix} b \end{Bmatrix}$ 中仅有两个元素 $b_l$ 和 $b_{r+1}$ 发生了变化；我们想要记录这次操作的影响，只需要对 $b_l$ 和 $b_{r+1}$ 做一些加加减减就好了。</p><p>于是我们做到了在 $O(1)$ 的时间内“传递影响”，那么也就是说我们可以在 $O(q)$ 的时间内处理完所有操作，最后再 $O(n)$ 推一遍前缀和，我们就得到了修改后的 $\begin{Bmatrix} a \end{Bmatrix}$ 数列。</p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2 代码"></a>2 代码</h2><p>代码，实际上差分数组和原序列可以共用一个数组，此处是为了便于理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,a[CN],b[CN]; <span class="comment">// b[] : 差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推 b[] */</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i] = a[i] - a[i<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    更新 b[] 数组 </span></span><br><span class="line"><span class="comment">    我们发现 [l,r] + v 会使得 b[r + 1] - v 和 b[l] + v</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    b[y + <span class="number">1</span>] -= z; b[x] += z; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前缀和推出操作后的 a[] 数组 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i<span class="number">-1</span>] + b[i];</span><br></pre></td></tr></table></figure><p>更简化的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,a[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i] - a[i<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    a[y + <span class="number">1</span>] -= z; a[x] += z; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] += a[i<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><hr><h1 id="二-二阶差分"><a href="#二-二阶差分" class="headerlink" title="二 二阶差分"></a>二 二阶差分</h1><h2 id="1-模型-1"><a href="#1-模型-1" class="headerlink" title="1 模型"></a>1 模型</h2><article class="message is-primary" style="font-size:inherit"><div class="message-body">维护一段数列，支持将区间 $ [l,r] $ 加一个等差数列 $s:e$ （ $[l,r]$ 内每个元素分别加等差数列的第 $1,2,3,...$ 项，其中等差数列的第一项为 $s$ ，最后一项为 $e$ ），并查询所有操作后的数列。要求在线性时间内完成任务。</div></article><p>不难发现，某段区间整体加上一个等差数列，相当于该区间上的差分数列整体加了这个等差数列的公差。当然，在差分数列的两个端点还会有一些小的细节。</p><p>对于“差分数列整体加公差”这个操作，我们直接对差分数列进差分即可维护。注意，差分数列中加上公差的区间是 $[l+1,r]$ 。</p><p>剩下的是一点小细节：区间 $[l,r]$ 加一个等差数列 $s:e$ 后，还会使得 $b_l + s$ 和 $b_{r+1} - e$ 。这两个特例均是对差分数列 $\begin{Bmatrix} b \end{Bmatrix}$ 进行的单点操作，我们在二次差分推出数列  $\begin{Bmatrix} b \end{Bmatrix}$ 后，暴力修改就好了。</p><h2 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2 代码"></a>2 代码</h2><p>代码，实际上三个计算数组可以合成一个，此处是为了便于理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123; <span class="comment">/* 省略 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> l[CN],r[CN]; LL s[CN],e[CN]; <span class="comment">// 记录操作</span></span><br><span class="line"></span><br><span class="line">LL a[CN],b[CN],c[CN]; <span class="comment">// b[] : 原序列的差分</span></span><br><span class="line">                      <span class="comment">// c[] : 差分序列的差分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推 b[] */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i] = a[i] - a[i - <span class="number">1</span>]; </span><br><span class="line"><span class="comment">/* 推 c[] */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[i] = b[i] - b[i - <span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">q = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">    l[i] = read(); r[i] = read(); s[i] = read(); e[i] = read();</span><br><span class="line">    LL k = (e[i] - s[i]) / (r[i] - l[i]); <span class="comment">// 公比</span></span><br><span class="line">    <span class="comment">/* 更新 c[] 数组 */</span></span><br><span class="line">    c[ r[i] + <span class="number">1</span> ] -= k; c[ l[i] + <span class="number">1</span> ] += k; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推出操作后的 b[] 数组 */</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i] = b[i - <span class="number">1</span>] + c[i]; </span><br><span class="line"><span class="comment">/* 对 b[] 进行单点修改 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) b[ r[i] + <span class="number">1</span> ] -= e[i], b[ l[i] ] += s[i]; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前缀和推出处理后的 a[] 数组 */</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i - <span class="number">1</span>] + b[i];</span><br></pre></td></tr></table></figure><p>更简化的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123; <span class="comment">/* 省略 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> l[CN],r[CN]; LL s[CN],e[CN],a[CN]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i] - a[i - <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i] - a[i - <span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">q = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">    l[i] = read(); r[i] = read(); s[i] = read(); e[i] = read();</span><br><span class="line">    LL k = (e[i] - s[i]) / (r[i] - l[i]);</span><br><span class="line">    a[ r[i] + <span class="number">1</span> ] -= k; a[ l[i] + <span class="number">1</span> ] += k; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] += a[i - <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) a[ r[i] + <span class="number">1</span> ] -= e[i], a[ l[i] ] += s[i]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] += a[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;差分是一种对于数列区间修改问题的很优秀的 idea ，对于每个独立的查询操作，它可以做到在线性时间内完成任务……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前缀和" scheme="https://big-news.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="差分" scheme="https://big-news.cn/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Two Contests</title>
    <link href="https://big-news.cn/2019/11/04/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Two%20Contests/"/>
    <id>https://big-news.cn/2019/11/04/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Two%20Contests/</id>
    <published>2019-11-04T08:39:00.000Z</published>
    <updated>2020-08-09T01:30:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>把一些线段分成两组，使得 每组线段的并的长度 之和最大……</p><a id="more"></a><h1 id="一-题目"><a href="#一-题目" class="headerlink" title="一 题目"></a>一 题目</h1><blockquote><p><a href="https://atcoder.jp/contests/agc040/tasks/agc040_b">Source</a></p></blockquote><h2 id="Descriptions"><a href="#Descriptions" class="headerlink" title="Descriptions"></a>Descriptions</h2><p>10^9 contestants, numbered 1 to 10^9, will compete in a competition. There will be two contests in this competition.</p><p>The organizer prepared N problems, numbered 1 to N, to use in these contests. When Problem i is presented in a contest, it will be solved by all contestants from Contestant Li to Contestant Ri (inclusive), and will not be solved by any other contestants.</p><p>The organizer will use these N problems in the two contests. Each problem must be used in exactly one of the contests, and each contest must have at least one problem.</p><p>The joyfulness of each contest is the number of contestants who will solve all the problems in the contest. Find the maximum possible total joyfulness of the two contests.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Input is given from Standard Input in the following format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N</span><br><span class="line">L1 R1</span><br><span class="line">L2 R2</span><br><span class="line">⋮</span><br><span class="line">LN RN</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Print the maximum possible total joyfulness of the two contests.</p><hr><h1 id="二-题解"><a href="#二-题解" class="headerlink" title="二 题解"></a>二 题解</h1><p>首先肯定能想到对线段进行”某种排序“，然后前面分一组，后面分另一组。</p><p>然后发现并的长度受两个东西的限制： max(l[i]) 和 min(r[i]) 。<br>我们先找出所有线段中，l[] 值最大的那一条（记为 p ）和 r[] 值最小的那一条（记为 q ），然后分类讨论。</p><p>考虑把 p,q 分到同一组线段里，那么显然，这组线段的并的长度一定是 max(0, r[q] - l[p]) 。于是想到留一条最长的线段另成第二组，然后其它的线段都分到第一组里，这样一定是坠吼的。</p><p>考虑不把 p,q 分到同一组里，那么考虑通过“某种排序”使得某一组里面的线段在数列里面连续。显然，与 p 分到同一组里面的线段的左端点受制于 p ，也就是说左端点固定，那么我们可以按照右端点进行升序排序，此时答案受制于最小的那个 r[] 值，也就是靠前面的 r[] 值；<br>再考虑右端点相同的情况，我们可能会把前面一部分线段划给 q ，那么我们需要靠前的线段 l[] 值尽量小，于是按 l[] 升序排序，此时答案受制于最大的那个 l[] 值，也就是靠后面 l[] 值。</p><p>剩下的问题是枚举一个断点（前面化成一组，后面另一组），然后贪心就好了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,l[CN],r[CN],id[CN],mnr,pr,mxl,pl;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* calc the length of a certain segment */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">d</span><span class="params">(<span class="keyword">int</span> cl,<span class="keyword">int</span> cr)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l * max(<span class="number">0</span>, cr - cl + <span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[x] != r[y] ? r[x] &lt; r[y] : l[x] &lt; l[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l[i],&amp;r[i]);</span><br><span class="line">    </span><br><span class="line">    mnr = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(r[i] &lt; mnr) mnr = r[pr = i];</span><br><span class="line">    mxl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(l[i] &gt; mxl) mxl = l[pl = i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* in same */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(i != pl &amp;&amp; i != pr) </span><br><span class="line">            ans = max(ans, d(mxl, mnr) + d(l[i], r[i]));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* in diff */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> premxl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        premxl = max(premxl, l[ id[i - <span class="number">1</span>] ]);</span><br><span class="line">        ans = max(ans, d(mxl, r[ id[i] ]) + d(premxl, mnr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把一些线段分成两组，使得 每组线段的并的长度 之和最大……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>【解题报告】Codeforces Round 597 (Div. 2)</title>
    <link href="https://big-news.cn/2019/11/03/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91Codeforces%20Round%20597%20(Div.%202)/"/>
    <id>https://big-news.cn/2019/11/03/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91Codeforces%20Round%20597%20(Div.%202)/</id>
    <published>2019-11-03T01:28:00.000Z</published>
    <updated>2020-08-09T01:30:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>真香警告.jpg……</p><a id="more"></a><h2 id="A-Good-ol’-Numbers-Coloring"><a href="#A-Good-ol’-Numbers-Coloring" class="headerlink" title="A. Good ol’ Numbers Coloring"></a>A. Good ol’ Numbers Coloring</h2><p><a href="https://codeforces.com/contest/1245/problem/A">Source</a></p><p>看完样例就很显然了，切掉就好了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar()) s = (s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> !b ? a : gcd(b, a % b);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        a = read(); b = read();</span><br><span class="line">        <span class="keyword">if</span>(gcd(a,b) == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Finite\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Infinite\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Restricted-RPS"><a href="#B-Restricted-RPS" class="headerlink" title="B. Restricted RPS"></a>B. Restricted RPS</h2><p><a href="https://codeforces.com/contest/1245/problem/B">Source</a></p><p>每步贪心，能干就干。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar()) s = (s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n,s0,s1,s2,opt[CN],ans[CN]; <span class="keyword">bool</span> bt[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = read(); s1 = read(); s0 = read(); s2 = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c; <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'P'</span>) opt[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'R'</span>) opt[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'S'</span>) opt[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(bt,<span class="number">0</span>,<span class="keyword">sizeof</span>(bt));</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!opt[i] &amp;&amp; s2) bt[i] = <span class="literal">true</span>,s2--;</span><br><span class="line">            <span class="keyword">if</span>(opt[i] == <span class="number">1</span> &amp;&amp; s0) bt[i] = <span class="literal">true</span>,s0--;</span><br><span class="line">            <span class="keyword">if</span>(opt[i] == <span class="number">2</span> &amp;&amp; s1) bt[i] = <span class="literal">true</span>,s1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bt[i]) ans[i] = (opt[i] + <span class="number">2</span>) % <span class="number">3</span>,cnt++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s0) ans[i] = <span class="number">0</span>,s0--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s1) ans[i] = <span class="number">1</span>,s1--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s2) ans[i] = <span class="number">2</span>,s2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> vs = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span>) vs += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= vs)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ans[i]) <span class="built_in">cout</span>&lt;&lt;<span class="string">'P'</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans[i] == <span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">'R'</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans[i] == <span class="number">2</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">'S'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Constanze’s-Machine"><a href="#C-Constanze’s-Machine" class="headerlink" title="C. Constanze’s Machine"></a>C. Constanze’s Machine</h2><p><a href="https://codeforces.com/contest/1245/problem/C">Source</a></p><p>这题看上去还是比较有感觉的，只不过式子错了，这就很dl了（真香）。</p><p>首先显然可以把每个连续字段的方案数算出来然后再乘法原理，剩下的问题是求一个“连续字段”的方案数。</p><p>关于“连续字段”的方案，这个问题可以抽象成给你一段序列类似于“uuuuuu”这个样子，让你在其中划若干条长度为 2 的线，两两线不能相交，求方案数。那么显然这个东西可以设个状态写写方程，于是设 f[i] 表示考虑长度为 i 的序列的方案数。考虑新加入的这个元素，我们可以把它和元素 i-1 划成一段，方案数 f[i-2] ；也可以不划到任何一段，方案数 f[i-1] 。于是 f[i]=f[i-1]+f[i-2] ，又是 fibonacci 数列…然后做完了。</p><p>比赛的时候方程推成了 f[i]=f[i-1]+i-2 ，因为实际上我只考虑了划两段的情况…然后pretest9一直WA，自闭了，看来还是不够熟练…</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL R = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> ch[CN]; <span class="keyword">int</span> n;</span><br><span class="line">LL f[CN],ans = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch; n = <span class="built_in">strlen</span>(ch);</span><br><span class="line"> </span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>; f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">3</span>;i&lt;=n;i++) f[i] = (f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]) % R;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(ch[i] == <span class="string">'m'</span> || ch[i] == <span class="string">'w'</span>) flag = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i] != <span class="string">'n'</span> &amp;&amp; ch[i] != <span class="string">'u'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p = i,l = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p &lt; n &amp;&amp; ch[p] == ch[p+<span class="number">1</span>]) p++,l++;</span><br><span class="line">            (ans *= f[l]) %= R;</span><br><span class="line">            i = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Shichikuji-and-Power-Grid"><a href="#D-Shichikuji-and-Power-Grid" class="headerlink" title="D. Shichikuji and Power Grid"></a>D. Shichikuji and Power Grid</h2><p><a href="https://codeforces.com/contest/1245/problem/D">Source</a></p><p>第一眼没什么感觉，看了 tutorial 发现就是个 mst … 建一个虚点向每个点连边，表示建电站就好了，看来还是不够熟练…</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fr,to; LL di;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,LL d)</span> </span>&#123;fr=f;to=t;di=d;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> fs&amp; a)<span class="keyword">const</span> &#123;<span class="keyword">return</span> di &lt; a.di;&#125;</span><br><span class="line">&#125;E[CN * CN];</span><br><span class="line"><span class="keyword">int</span> ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,LL z)</span> </span>&#123;E[++ecnt].init(x,y,z);&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ufs</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fa[CN];</span><br><span class="line">    ufs() &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;CN;i++) fa[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> find(x) != find(y);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;fa[find(x)] = find(y);&#125; </span><br><span class="line">&#125;ck;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,px[CN],py[CN],pc[CN],pk[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&lt;<span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(px[a] - px[b]) + <span class="built_in">abs</span>(py[a] - py[b]);&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> sel[CN * CN]; LL si = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sel,<span class="literal">false</span>,<span class="keyword">sizeof</span>(sel));</span><br><span class="line">    sort(E+<span class="number">1</span>,E+ecnt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ecnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ck.exm(E[i].fr, E[i].to)) <span class="keyword">continue</span>;</span><br><span class="line">        ck.merge(E[i].fr, E[i].to); </span><br><span class="line">        cnt++; si += E[i].di; sel[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;px[i],&amp;py[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pc[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pk[i]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            add(i,j,<span class="number">1l</span>l*(pk[i]+pk[j])*dist(i,j));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(i,n+<span class="number">1</span>,pc[i]);</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    MST();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,si);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ecnt;i++) <span class="keyword">if</span>(sel[i] &amp;&amp; E[i].to == n) cnt++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ecnt;i++) <span class="keyword">if</span>(sel[i] &amp;&amp; E[i].to == n) <span class="built_in">printf</span>(<span class="string">"%d "</span>,E[i].fr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    cnt = n - <span class="number">1</span> - cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ecnt;i++) <span class="keyword">if</span>(sel[i] &amp;&amp; E[i].to != n) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,E[i].fr,E[i].to);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真香警告.jpg……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>【题解】Good Numbers</title>
    <link href="https://big-news.cn/2019/10/28/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Good%20Numbers/"/>
    <id>https://big-news.cn/2019/10/28/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Good%20Numbers/</id>
    <published>2019-10-27T23:37:00.000Z</published>
    <updated>2020-08-09T01:30:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>可爱的数学题++……</p><a id="more"></a><h1 id="一-题目"><a href="#一-题目" class="headerlink" title="一 题目"></a>一 题目</h1><blockquote><p><a href="https://codeforces.com/contest/1249/problem/C2">Source</a></p></blockquote><h2 id="Descriptions"><a href="#Descriptions" class="headerlink" title="Descriptions"></a>Descriptions</h2><p>The only difference between easy and hard versions is the maximum value of n.</p><p>You are given a positive integer number n. You really love good numbers so you want to find the smallest good number greater than or equal to n.</p><p>The positive integer is called good if it can be represented as a sum of distinct powers of 3 (i.e. no duplicates of powers of 3 are allowed).</p><p>For example:<br>30 is a good number: 30=33+31,<br>1 is a good number: 1=30,<br>12 is a good number: 12=32+31,<br>but 2 is not a good number: you can’t represent it as a sum of distinct powers of 3 (2=30+30),<br>19 is not a good number: you can’t represent it as a sum of distinct powers of 3 (for example, the representations 19=32+32+30=32+31+31+31+30 are invalid),<br>20 is also not a good number: you can’t represent it as a sum of distinct powers of 3 (for example, the representation 20=32+32+30+30 is invalid).<br>Note, that there exist other representations of 19 and 20 as sums of powers of 3 but none of them consists of distinct powers of 3.</p><p>For the given positive integer n find such smallest m (n≤m) that m is a good number.</p><p>You have to answer q independent queries.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line of the input contains one integer q (1≤q≤500) — the number of queries. Then q queries follow.<br>The only line of the query contains one integer n (1≤n≤1018).</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each query, print such smallest integer m (where n≤m) that m is a good number.</p><hr><h1 id="二-题解"><a href="#二-题解" class="headerlink" title="二 题解"></a>二 题解</h1><p>考虑 n⩽10^4 的情况。我们现在要在数列 [3^0,3^1,3^2,…,3^k](3^k&gt;n) 中选出一些数，使得它们的和 ⩾n ，并使得这个和最小。<br>考虑 k 的范围，此时 k⩽log3(10^4)≈14 ，所以只需要 2^k 枚举每个数字选不选就好了。总复杂度 O(q·2^k) ，解决了 easy version 。</p><p>考虑 n⩽10^18 的情况。实际上上述枚举过程可以通过枚举二进制状态来实现，即用一个数字二进制位上的 0/1 来表示数列某一项选不选。假设我们当前二进制枚举的状态码为 S ，那么实际上该状态码所对应的数值是单调的；换句话说，随着 S 变大，其表示的那个数字也变大。</p><p>简单的 proof ，请理性偷税。<br>考虑把二进制数 0100 变成 0101 （前者表示 3^2 ，后者表示 3^2+3^0） ，一定变大，因为又多了新的一项。考虑把二进制数 0100 变成 1000 （前者表示 3^2 ，后者表示 3^3），也一定变大，因为次数+1。</p><p>那么也就是说现在枚举的数值具有单调性，那么为什么不二分呢？只需要二分查找出一个 ⩾n 的最小位置就好了。总复杂度 O(qk)，其中 k 为常数，它大概是 log2(2^40) = 40 ，这已经很小了，于是切掉。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL s=<span class="number">0</span>,ne=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar()) <span class="keyword">if</span>(c==<span class="string">'-'</span>) ne=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar()) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s*ne; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q; LL n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Pow3</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    LL rec = <span class="number">1</span>,base = <span class="number">3</span>; </span><br><span class="line">    <span class="keyword">while</span>(a) &#123;<span class="keyword">if</span>(a &amp; <span class="number">1</span>) rec *= base; base *= base,a &gt;&gt;= <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> rec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">gen</span><span class="params">(LL u)</span></span>&#123;</span><br><span class="line">    LL g = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++) <span class="keyword">if</span>(u &amp; (<span class="number">1l</span>l &lt;&lt; i)) g += Pow3(i);</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        n = read();</span><br><span class="line">        LL l = <span class="number">0</span>,r = (<span class="number">1l</span>l &lt;&lt; <span class="number">40</span>);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            LL m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(gen(m) &gt;= n) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,gen((l + r) &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可爱的数学题++……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="数学" scheme="https://big-news.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分查找" scheme="https://big-news.cn/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>【解题报告】Codeforces Round 596 (Div. 2)</title>
    <link href="https://big-news.cn/2019/10/27/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91Codeforces%20Round%20596%20(Div.%202)/"/>
    <id>https://big-news.cn/2019/10/27/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91Codeforces%20Round%20596%20(Div.%202)/</id>
    <published>2019-10-27T00:18:00.000Z</published>
    <updated>2020-08-09T13:49:30.182Z</updated>
    
    <content type="html"><![CDATA[<p>又被C题的一些小细节卡死……</p><a id="more"></a><h2 id="A-Forgetting-Things"><a href="#A-Forgetting-Things" class="headerlink" title="A. Forgetting Things"></a>A. Forgetting Things</h2><p><a href="https://codeforces.com/contest/1247/problem/A">Source</a></p><p>不难发现只有 a+1 = b 或 a = b 时才有解。前一种直接输出 ‘a b’ ，后一种输出 ‘a0 b1’ 。<br>然后还有一个坑点是 a = 9,b = 1 的情况，此时是有解的，应输出 ‘9 10’。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="keyword">if</span>(a == b) <span class="built_in">printf</span>(<span class="string">"%d0 %d1"</span>,a,b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a + <span class="number">1</span> == b) <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,a,b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">9</span> &amp;&amp; b == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"9 10"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-TV-Subscriptions"><a href="#B-TV-Subscriptions" class="headerlink" title="B. TV Subscriptions"></a>B. TV Subscriptions</h2><p><a href="https://codeforces.com/contest/1247/problem/B1">Source (Easy Version)</a><br><a href="https://codeforces.com/contest/1247/problem/B2">Source (Hard Version)</a></p><p>区间的长度是固定的，那么只需要开一个桶，维护一下在某段区间内有那些元素。<br>考虑从一个区间滑动到另一个区间，那么这时候区间内元素个数是可以 O(1) 维护的，然后切了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,ne=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar()) <span class="keyword">if</span>(c==<span class="string">'-'</span>) ne=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar()) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s*ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,k,d,a[CN];</span><br><span class="line"><span class="keyword">int</span> tot[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tot,<span class="number">0</span>,<span class="keyword">sizeof</span>(tot));</span><br><span class="line">        </span><br><span class="line">        n = read(); k = read(); d = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = read();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = INF,cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;d;i++) &#123;<span class="keyword">if</span>(!tot[ a[i] ]) cnt++; tot[ a[i] ]++;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tot[ a[i] ]) cnt++; tot[ a[i] ]++;</span><br><span class="line">            tot[ a[i-d] ]--; <span class="keyword">if</span>(!tot[ a[i-d] ]) cnt--;</span><br><span class="line">            ans = min(ans, cnt); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-p-binary"><a href="#C-p-binary" class="headerlink" title="C. p-binary"></a>C. p-binary</h2><p><a href="https://codeforces.com/contest/1247/problem/C">Source</a></p><p>简化一下题意：给定 $p,s$ ，试求得一个最小的 $n$ ，使得存在一组 $\begin{Bmatrix} k_1,k_2,…,k_n \end{Bmatrix}$ ，满足 $\sum\limits_{i=1}^n 2^{k_i} + np = s$ 。</p><p>把 $np$ 移到右边去，变形成 $\sum\limits_{i=1}^n 2^{k_i} = s-np$ 。枚举 $n$ 之后， $s-np$ 就变成了一个定值，于是很自然的联想到可以把 $s-np$ 这个数表示成二进制下的和的形式，也就是 $s-np=\sum\limits_{(s-np) \And 2^i} 2^i$ 。<br>那么这实际上就是一种可行的拆分方案，我们只需要 check 一下 $(s-np)  \And  2^i$ 成立的数量是否恰好等于 $n$ 即可，也就是判断 $s-np$ 在二进制下 $1$  的数量是否恰好等于 $n$ ，这是 $O(\log)$ 的。</p><p>但是这并不能涵盖所有的方案。事实上，对于一个正整数 $k$，总有 $2^k=2\times(2^{k-1})=2^{k-1} + 2^{k-1}$ ，也就是说有一些项我们依然可以继续拆分。考虑 $2^k$ 能拆出的项数的范围：最少只有它自己，也就是一项；最多呢？<br>考虑把上面拆分的过程看作一棵二叉树，不难发先我们总可以拆出两项，三项，…，直到 $k$ 项。那么对于任意的 $2^k$ ，它总可以被拆分一项，两项，…， $k$ 项，也就是说它“能拆出的项数的范围”是 $[1,k]$ 。</p><p>考虑 $s-np=\sum\limits_{(s-np) \And 2^i} 2^i$ 中，后面那些部分能变成多少项。显然，任意 $2^i$ 能拆出的项数的范围是 $[1,i]$ ，那么设 $s-np = 2^{i_1}+2^{i_2}+…+2^{i_k} $ ，其中后面那一部分共有 $k$ 项，即可推出 $s-np$ 能拆出的项数的范围就是 $[k,i_1+i_2+…+i_k]$ 。</p><p>于是我们要做的就变成了 check 一下 $n\in [k,i_1+i_2+…+i_k]$ 是否成立，若成立则我们找到了一个可行解。这个判断还是 $O(\log)$ 的，那么只需要在 $10^6$ 内枚举 $n$ 就好了。</p><p>然后还有一些小细节，比赛的时候把我卡死了。。。具体看代码。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>; <span class="comment">// 枚举的边界，实际上还可以更小</span></span><br><span class="line"></span><br><span class="line">LL n,p,ans = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checker</span><span class="params">(LL u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 特判 u 为 0 时一定无解</span></span><br><span class="line">    <span class="keyword">int</span> lb = <span class="number">0</span>,rb = <span class="number">1</span>,i = <span class="number">0</span>; <span class="comment">// rb 一定要初始化为 1, 因为至少有一项</span></span><br><span class="line">    <span class="keyword">while</span>(u)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u &amp; <span class="number">1</span>) lb++,rb += i;</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>,i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lb &lt;= k &amp;&amp; k &lt;= rb;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;n,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">        LL c = n - <span class="number">1l</span>l * k * p;</span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(checker(c,k))&#123;</span><br><span class="line">            ans = <span class="number">1l</span>l * k;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又被C题的一些小细节卡死……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>【题解】重建道路</title>
    <link href="https://big-news.cn/2019/10/26/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E9%87%8D%E5%BB%BA%E9%81%93%E8%B7%AF/"/>
    <id>https://big-news.cn/2019/10/26/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E9%87%8D%E5%BB%BA%E9%81%93%E8%B7%AF/</id>
    <published>2019-10-26T00:58:00.000Z</published>
    <updated>2020-08-09T01:30:11.242Z</updated>
    
    <content type="html"><![CDATA[<p>第一道自己切掉的树形DP，写个题解纪念一下……</p><a id="more"></a><h1 id="一-题目"><a href="#一-题目" class="headerlink" title="一 题目"></a>一 题目</h1><blockquote><p><a href="https://www.luogu.org/problem/P1272">原题链接</a></p></blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一场可怕的地震后，人们用N个牲口棚(1≤N≤150，编号1..N)重建了农夫John的牧场。由于人们没有时间建设多余的道路，所以现在从一个牲口棚到另一个牲口棚的道路是惟一的。因此，牧场运输系统可以被构建成一棵树。John想要知道另一次地震会造成多严重的破坏。有些道路一旦被毁坏，就会使一棵含有P(1≤P≤N)个牲口棚的子树和剩余的牲口棚分离，John想知道这些道路的最小数目。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第1行：2个整数，N和P<br>第2..N行：每行2个整数I和J，表示节点I是节点J的父节点。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>单独一行，包含一旦被破坏将分离出恰含P个节点的子树的道路的最小数目。</p><hr><h1 id="二-题解"><a href="#二-题解" class="headerlink" title="二 题解"></a>二 题解</h1><p>首先可以有这么一个想法：设 f[u][s] 表示在节点 u ，获得大小为 s 的子树所需要删除的边的个数。</p><p><strong>考虑转移要做什么</strong><br>考虑对于一个 s ，我们需要找到一种“空间”的分配方案。讲的形象一点，设 s(vi) 表示在子树 vi 内我们留下的节点个数，其中 vi 表示当前节点 u 的第 i 个子节点；再设 c(vi) 表示我们在子树 vi 中留下 s(vi) 个节点所删除的边的数量。那么现在我们要做的事情就是：对于全部 vi ，找到一种 s(vi) 的分配方式，使得 ∑s(vi) = s ，且 ∑c(vi) 最小，然后我们就可以令 f[u][s] = ∑c(vi)，也就完成了状态的转移。</p><p>然后上面那句“对于全部 vi ，找到一种 s(vi) 的分配方式，使得 ∑s(vi) = s ，且 ∑c(vi) 最小”，你不觉得这是一个背包么？<br>然后这个时候你就会发现我们所设的 f[u][s] 这个状态实际上是不完全的。不考虑滚动数组，我们应该设 f[u][k][s] 表示考虑节点 u 的前 k 个子节点，取 s 个节点所需要的最小花费，这就是一个背包。</p><p><strong>方程</strong><br>那么可以写出一个转移：f[u][k][s] = min(f[u][k-1][s] + 1, f[u][k-1][s-sv] + f[v][kv][sv])，其中 kv 表示 v 的所有子节点数量，sv 表示在子树 v 上选取的点的数量。<br>上面那个方程很好理解：前面表示不从子树 v 选取节点，那么要删除 (u,v) 这条边，答案 +1 ；后面是在考虑子树 v 内选取的节点个数。</p><p><strong>考虑滚动</strong><br>然后上面那个方程它一点也不可爱，考虑滚动掉 k 这一维，方程变成 f[u][s] = min(f[u][s] + 1, f[u][s-sv] + f[v][sv])，但是在转移的顺序上还有点小问题。<br>我们发现 f[u][k][s] 总从 f[u][k-1][s] 或 f[u][k-1][s-sv] 的状态更新。也就是说，去掉 k 这一维，我们需要保证 f[u][s-sv] 比 f[u][sv] 后更新，这样 f[u][sv] 才是我们想要用来转移的“上层状态”。那么也就是倒序枚举 s 去更新。</p><p>于是我们只需要枚举 s，然后再枚举 sv，去转移就好了。</p><p><strong>考虑答案的统计</strong><br>上面那个状态里面， u 实际上是强制选择的，否则就缺少一个能把若干子树连接起来的“桥梁”。但是贪心的想，我们不一定非得强制选择某一个节点啊。那么答案应该对所有的 f[u][p] 取一个 min 。然后还有一个问题，就是在某一个非根节点的位置，我们想要取出这棵子树，还得把这个节点和它的父亲节点断掉，那么答案还得 +1，细节见代码。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">160</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to=t;nxt=n;&#125;</span><br><span class="line">&#125;E[CN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN],ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y,hd[x]);hd[x]=ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,P,ans,sum[CN],f[CN][CN]; <span class="comment">// sum[u] 表示子树 u 的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    sum[u] = <span class="number">1</span>; f[u][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 初始时不考虑子树，因此 f[u][1] = 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=hd[u];k;k=E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u); <span class="comment">// 求出子树的答案</span></span><br><span class="line">        sum[u] += sum[v]; <span class="comment">// 累加大小</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=sum[u]; s; s--)&#123; <span class="comment">// 考虑背包问题的更新方式，那么一定要每次都更新一下</span></span><br><span class="line">            f[u][s] += <span class="number">1</span>; <span class="comment">// 实际上是 f[u][k][s] = f[u][k-1][s] + 1 ，滚动了 k 这一维</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> sv=<span class="number">0</span>;sv&lt;=min(s<span class="number">-1</span>, sum[v]);sv++) <span class="comment">// s-1 为了强制选根</span></span><br><span class="line">                f[u][s] = min(f[u][s], f[u][s - sv] + f[v][sv]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("p1272.in","r",stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;P);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        add(x,y); add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ans = f[<span class="number">1</span>][P]; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) ans = min(ans, f[i][P] + <span class="number">1</span>); <span class="comment">// 加上与父亲之间的那条边</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一道自己切掉的树形DP，写个题解纪念一下……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="树形DP" scheme="https://big-news.cn/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】能量采集</title>
    <link href="https://big-news.cn/2019/10/24/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"/>
    <id>https://big-news.cn/2019/10/24/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/</id>
    <published>2019-10-24T09:32:00.000Z</published>
    <updated>2020-08-09T13:45:40.704Z</updated>
    
    <content type="html"><![CDATA[<p>又是一道可爱的数学题……</p><a id="more"></a><h1 id="一-题目"><a href="#一-题目" class="headerlink" title="一 题目"></a>一 题目</h1><blockquote><p><a href="https://www.luogu.org/problem/P1447">原题链接</a></p></blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。</p><p>栋栋的植物种得非常整齐，一共有n列，每列有m棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标(x, y)来表示，其中x的范围是1至n，表示是在第x列，y的范围是1至m，表示是在第x列的第y棵。</p><p>由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是(0, 0)。</p><p>能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有k棵植物，则能 量的损失为2k + 1。例如，当能量汇集机器收集坐标为(2, 4)的植物时，由于连接线段上存在一棵植物(1, 2)，会产生3的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为1。现在要计算总的能量损失。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>仅包含一行，为两个整数n和m。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>仅包含一个整数，表示总共产生的能量损失。1 ≤ n, m ≤ 100,000。</p><hr><h1 id="二-题解"><a href="#二-题解" class="headerlink" title="二 题解"></a>二 题解</h1><p>这题实际上没那么难，我都能推出来……</p><p>首先有一个结论就是说：若在坐标系中从 (0,0) 向 (x,y) 连一条线段，那么这条线段经过的整点的数量（不包含端点）为 gcd(x,y)-1 。</p><p>实际上上面那个东西很显然，如果你没办法感性理解，你可以用相似三角形或者斜率或者什么奇奇怪怪的东西理解一下，以下是一种理解：<br>假设 (a,b) 在 (0,0) 到 (x,y) 线段上，那么一定有 a/b = x/y 。你把 x/y 约分，即 x / y = (x0×gcd(x,y)) / (y0×gcd(x,y)) = x0 / y0 。<br>那么对于所有整数 i∈[1,gcd(x,y)) ，(x0×i) / (y0×i) 都是一个满足条件的整点，这样的整点一共有 gcd(x,y)-1 个。</p><p>实际上这个结论还可以推广到任意两点间线段上整点的数量，不过我懒得推，感性理解。</p><p>然后就好办了，实际上就是让你求$\sum\limits_{i=1}^n\sum\limits_{j=1}^m 2\times(\text{gcd}(i,j)-1)+1$。<br>把常数都提出来，很显然上面等价于$( 2\times \sum\limits_{i=1}^n\sum\limits_{j=1}^m\text{gcd}(i,j) ) -n\times m$。剩下的问题是求$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\text{gcd}(i,j)$。</p><p>考虑一个因子 g 对和的贡献，它会被形如 (k×g, h×g) 的点累加到 sigma 里面，并且前面的 k,h 互质。先不考虑互质，那么直接乘法原理，这样的点有 ⌊n/g⌋×⌊m/g⌋ 个。<br>考虑有哪些东西是多出来的。对于一个因子 g ，满足 gcd(x,y) = kg (k∈{1,2,3 … }) 的点 (x,y) 实际上被多累加了。那么枚举一个系数 k ，我们在 ⌊n/g⌋×⌊m/g⌋ 中减掉 ⌊n/kg⌋×⌊m/kg⌋ 就好了。<br>不过还有一部分可能会被多减掉（考虑简单的容斥原理），然后我也不想容斥，于是设 cnt[g] 表示“形如 (k×g, h×g) ，其中 k,h 互质”的点的个数，从大到小枚举 g ，然后枚举 k ， cnt[g] -= cnt[kg] 就好了，正确性感性理解。</p><p>然后$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\text{gcd}(i,j) = \sum\limits_{g=1}^{\max n,m}g\times cnt[g]$，然后切了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">LL n,m,sigma = <span class="number">0</span>,cnt[CN];</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a%b) : a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(LL g = <span class="number">1</span>; g &lt;= max(n, m); g++)</span><br><span class="line">        cnt[g] = (n / g) * (m / g);</span><br><span class="line">    <span class="keyword">for</span>(LL g = max(n, m); g; g--) <span class="comment">// 一定倒序枚举</span></span><br><span class="line">        <span class="keyword">for</span>(LL k = <span class="number">2</span>; k * g &lt;= max(n, m); k++)</span><br><span class="line">            cnt[g] -= cnt[k * g];</span><br><span class="line">    <span class="keyword">for</span>(LL g = <span class="number">1</span>; g &lt;= max(n, m); g++)</span><br><span class="line">        sigma += g * cnt[g];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,sigma * <span class="number">2</span> - n * m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一道可爱的数学题……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="https://big-news.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="gcd" scheme="https://big-news.cn/tags/gcd/"/>
    
  </entry>
  
  <entry>
    <title>【题解】硬币购物</title>
    <link href="https://big-news.cn/2019/10/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/"/>
    <id>https://big-news.cn/2019/10/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/</id>
    <published>2019-10-23T11:00:00.000Z</published>
    <updated>2020-08-09T01:30:11.241Z</updated>
    
    <content type="html"><![CDATA[<p>一道有意思的容斥题 + 对于背包求方案数的总结……</p><a id="more"></a><h1 id="一-题目"><a href="#一-题目" class="headerlink" title="一 题目"></a>一 题目</h1><blockquote><p><a href="https://www.luogu.org/problem/P1450">原题链接</a></p></blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>硬币购物一共有4种硬币。面值分别为c1,c2,c3,c4。某人去商店买东西，去了tot次。每次带di枚ci硬币，买si的价值的东西。请问每次有多少种付款方法。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行 c1,c2,c3,c4,tot 下面tot行 d1,d2,d3,d4,s。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>每次的方法数。</p><hr><h1 id="二-题解"><a href="#二-题解" class="headerlink" title="二 题解"></a>二 题解</h1><p>直接拆分物品多重背包肯定是要T掉的。</p><p>先考虑没有硬币限制的情况，那么就是完全背包求方案数。这里有点东西可说。</p><p><strong>完全背包求方案数</strong><br>实际上就是一个完全背包的变形，不过有两种写法：不去重 和 去重，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不去重 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">        <span class="keyword">if</span>(j - c[i] == <span class="number">0</span>) f[j] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j - c[i] &gt; <span class="number">0</span>) f[j] += f[ j - c[i] ];</span><br><span class="line"><span class="comment">/* 去重 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    f[ c[i] ] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=c[i];j&lt;=m;j++) f[j] += f[ j - c[i] ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两份代码的本质区别就是循环的顺序：先枚举物品 还是 先枚举空间。但是为什么对呢。</p><p>实际上，先枚举物品可以理解做人为地制定了一个取物品的“顺序”，一个物品在转移的时候，前面的物品就已经不可能再次被用来转移状态，因此不会出现重复；先枚举空间则反之。</p><p>然后是考虑容斥。</p><p><strong>答案的容斥</strong><br>首先，对于给定的 s ，在不考虑限制的情况下，答案一定为 f[s] 。</p><p>现在来考虑限制。<br>什么样的状态是不合法的？不妨我们先假定取了 (di+1) 枚硬币 i ，这肯定是不行的。考虑这部分硬币对答案的贡献：取过它们之后，还剩下 (s-ci(di+1)) 的面值没有被凑出，这一部分一共有 f[s-ci(di+1)] 种选取方案，那么<strong>一定包含</strong> (di+1) 枚硬币 i 的方案的数量就是 1×f[s-ci(di+1)] = f[s-ci(di+1)] 。这部分是不合法的，因此减掉，答案变成 f[s] - f[s-ci(di+1)] 。</p><p>然后就是简单的容斥了：把减了两遍的部分加回来，再把加了两遍的部分减回去，再加，再减 …… 直到最后的区间两两无交（或只剩一个区间）。</p><p>然后就做完了，代码太丑就不放了，核心部分是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k1 = (d[<span class="number">1</span>]+<span class="number">1</span>)*c[<span class="number">1</span>],k2 = (d[<span class="number">2</span>]+<span class="number">1</span>)*c[<span class="number">2</span>],k3 = (d[<span class="number">3</span>]+<span class="number">1</span>)*c[<span class="number">3</span>],k4 = (d[<span class="number">4</span>]+<span class="number">1</span>)*c[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span>(s-k1 &gt;= <span class="number">0</span>) ans -= f[s-k1];</span><br><span class="line"><span class="keyword">if</span>(s-k2 &gt;= <span class="number">0</span>) ans -= f[s-k2];</span><br><span class="line"><span class="keyword">if</span>(s-k3 &gt;= <span class="number">0</span>) ans -= f[s-k3];</span><br><span class="line"><span class="keyword">if</span>(s-k4 &gt;= <span class="number">0</span>) ans -= f[s-k4];</span><br><span class="line"><span class="keyword">if</span>(s-k1-k2 &gt;= <span class="number">0</span>) ans += f[s-k1-k2];</span><br><span class="line"><span class="keyword">if</span>(s-k1-k3 &gt;= <span class="number">0</span>) ans += f[s-k1-k3];</span><br><span class="line"><span class="keyword">if</span>(s-k1-k4 &gt;= <span class="number">0</span>) ans += f[s-k1-k4];</span><br><span class="line"><span class="keyword">if</span>(s-k2-k3 &gt;= <span class="number">0</span>) ans += f[s-k2-k3];</span><br><span class="line"><span class="keyword">if</span>(s-k2-k4 &gt;= <span class="number">0</span>) ans += f[s-k2-k4];</span><br><span class="line"><span class="keyword">if</span>(s-k3-k4 &gt;= <span class="number">0</span>) ans += f[s-k3-k4];</span><br><span class="line"><span class="keyword">if</span>(s-k1-k2-k3 &gt;= <span class="number">0</span>) ans -= f[s-k1-k2-k3];</span><br><span class="line"><span class="keyword">if</span>(s-k1-k2-k4 &gt;= <span class="number">0</span>) ans -= f[s-k1-k2-k4];</span><br><span class="line"><span class="keyword">if</span>(s-k1-k3-k4 &gt;= <span class="number">0</span>) ans -= f[s-k1-k3-k4];</span><br><span class="line"><span class="keyword">if</span>(s-k2-k3-k4 &gt;= <span class="number">0</span>) ans -= f[s-k2-k3-k4];</span><br><span class="line"><span class="keyword">if</span>(s-k1-k2-k3-k4 &gt;= <span class="number">0</span>) ans += f[s-k1-k2-k3-k4];</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道有意思的容斥题 + 对于背包求方案数的总结……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="背包" scheme="https://big-news.cn/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="容斥" scheme="https://big-news.cn/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
</feed>
