<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://big-news.cn/"/>
  <updated>2020-08-26T07:42:28.472Z</updated>
  <id>https://big-news.cn/</id>
  
  <author>
    <name>big-news</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「杂题选做」八月口胡合集</title>
    <link href="https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/"/>
    <id>https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/</id>
    <published>2020-08-24T10:06:00.000Z</published>
    <updated>2020-08-26T07:42:28.472Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，做题的关键在于口胡出解法，而我还是什么都不会……</p><a id="more"></a><p>本篇 Blog 多以口胡为主，杂题居多。</p><h3 id="1-Hunger-Game"><a href="#1-Hunger-Game" class="headerlink" title="1 Hunger Game"></a>1 Hunger Game</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $N$ 个箱子，每个箱子有 $a[i]$ 个石头，一开始所有箱子都是关着的。<br>Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。<br>不能操作的输，求先手必胜还是后手必胜。<br>$1\le N\le 20, 0\le a[i]&lt;10^9$</p></div></article><p>对于每个状态有 $SG_i=a_i$ ，则终态是 P 态的充要条件是 $a_1\oplus a_2\oplus … \oplus a_n = 0$。<br>考虑先手如何给后手丢包：若存在一个极大的子集使得其异或和为 0，先手打开这些箱子，后手就无法再给先手丢一个异或和为 0 的状态。<br>因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。</p><p>大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。</p><h3 id="2-Minimum-Value-of-Equation"><a href="#2-Minimum-Value-of-Equation" class="headerlink" title="2 Minimum Value of Equation"></a>2 Minimum Value of Equation</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定 $k[i],b[i]$，有 $n$ 个函数，第 $j$ 个函数为 $f_j(x)=\sum |k[i]x+b[i]|$，其中$1\le i\le j$。<br>对于每个 $j=1…n$，求出 $f_j(x)$ 的最小值。<br>$1\le n\le 10^5 , |k[i]|\le 1000$</p></div></article><p>提一下公因式变成 $\sum k_i|x+(b_i/k_i)|$ ，即 $x$ 到数轴上的一堆点 $b_i/k_i$ 的距离和，那么 $x$ 取这些点的中位数就好了。</p><h3 id="3-DFS-Count"><a href="#3-DFS-Count" class="headerlink" title="3 DFS Count"></a>3 DFS Count</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个 $n$ 个点的有向图，求合法的 DFS 序的个数。<br>$n \le 13$</p></div></article><p>直接搜？？？（雾<br>设 $f[u,S]$ 表示当前在 $u$ ，没走过的点集为 $S$ 的方案数。$|S|$ 是递减的，可通过其来划分子问题，得到转移：<br>$$ f[v,T_v \And S]·f[u,S-(T_v \And S)] \to f[u, S] | (u,v)\in E$$<br>其中 $T_v$ 是 $v$ 能到达的点集。容易发现这次从小集合往大集合转移，则其是可操作的。</p><h3 id="4-XOR-Product"><a href="#4-XOR-Product" class="headerlink" title="4 XOR Product"></a>4 XOR Product</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定序列 $a_1,…,a_n$ ，求：<br>$$ \sum\limits_{i&lt;j&lt;k}(a_i\oplus a_j)·(a_j \oplus a_k) $$</p></div></article><p>把 $j$ 提出来，拆一下柿子：<br>$$ \sum\limits_j(\sum\limits_{i&lt;j}a_i\oplus a_j)(\sum\limits_{j&lt;k}a_j \oplus a_k) $$<br>考虑求 $\sum\limits_{i&lt;j}a_i\oplus a_j$ ，把每一位拆开算贡献，则应当统计 $a_1,…,a_{j-1}$ 中这一位上有多少个 1 ，预处理即可。<br>预处理是 $O(n\log)$ 的，枚举 $j$ 处理前后两个 sigma 是 $O(n\log)$ 的，最后统计答案也是 $O(n)$ 的。</p><h3 id="5-SUMXOR"><a href="#5-SUMXOR" class="headerlink" title="5 SUMXOR"></a>5 SUMXOR</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定序列 $a[1…n]$ 和 $b[1…n]$ ，求：<br>$$ \bigoplus\limits_{i,j}a_i+b_j $$</p></div></article><p>依然拆开每一位算，考虑第 $w$ 位的贡献应当是 $2^w\sum[(a_i+b_j)\text{ mod } 2^{w+1} \ge 2^w] \text{ mod }2$。<br>令 $a_i\gets a_i\text{ mod }2^{w+1},b_i\gets b_i\text{ mod }2^{w+1} $，有两种情况：</p><ol><li>$a_i + b_j \ge 2^{w+1}$，则应当有 $a_i+b_j-2^{w+1}\ge 2^w$，移项得 $a_i+b_j\ge 2^w+2^{w+1}$</li><li>$a_i+b_j&lt; 2^{w+1}$，则应当有 $2^w\le a_i+b_j&lt; 2^{w+1}$</li></ol><p>于是转化成序列上的查询问题，Two-Pointers 扫即可。</p><h3 id="6-The-Hanged-Man"><a href="#6-The-Hanged-Man" class="headerlink" title="6 The Hanged Man"></a>6 The Hanged Man</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个 $n$ 个点的树，每个点有一个体积 $v[i]$ 和收益 $w[i]$，现在你能选一个独立集，对于每个 $i$ 输出体积和为 $i$ 的收益和最大的独立集的值。<br>$n\le 50, m\le 5000$</p></div></article><p>$O(nm^2)$ 的 DP 显然啊，但是重链剖分 DP 看不懂啊，这个先咕着。</p><p>资料：<a href="https://www.cnblogs.com/dqsssss/p/11534336.html">乱搞</a>，<a href="https://blog.aor.sd.cn/archives/1122/">重链剖分</a></p><p>附一个 $O(nm^2)$ 的 DP：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, vi[CN], wi[CN], f[CN][<span class="number">5005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][ vi[u] ][<span class="number">1</span>] = wi[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> V = m; V; V--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> Vp = <span class="number">0</span>; Vp &lt;= V; Vp++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(V - Vp &gt;= vi[u]) f[u][V][<span class="number">1</span>] = max(f[u][V][<span class="number">1</span>], f[v][Vp][<span class="number">0</span>] + f[u][V - Vp][<span class="number">1</span>]);</span><br><span class="line">                f[u][V][<span class="number">0</span>] = max(f[u][V][<span class="number">0</span>], max(f[v][Vp][<span class="number">0</span>], f[v][Vp][<span class="number">1</span>]) + f[u][V - Vp][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Anton-and-Ira"><a href="#7-Anton-and-Ira" class="headerlink" title="7 Anton and Ira"></a>7 Anton and Ira</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定两个排列 $s$ 和 $p$ ，每次可以交换 $p$ 中的两个数，代价为它们间的距离，问最小代价使 $p$ 变为 $s$ ，输出方案。<br>$n\le 1000$</p></div></article><p>设 $to[u]$ 是 $u$ 想要去到的位置，可以将其看作一条有向边。根据抽屉原理，某一时刻必然存在一个点使 $to[u]$ 与 $to[to[u]]$ 反向，于是贪心就好了。<br>设这样得到的答案为 $s$，容易发现对于一种操作方案，必然存在另一种与之互为补集的操作方案，其答案也为 $s$。两者可以组成全集，即有 $2s=\sum|i-to[i]|$，从而 $s=\sum|i-to[i]|/2$。</p><h3 id="8-Increasing-Shortest-Path"><a href="#8-Increasing-Shortest-Path" class="headerlink" title="8 Increasing Shortest Path"></a>8 Increasing Shortest Path</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有个 $n$ 个点 $m$ 条边的有向图，有 $q$ 个询问：从 $ai$ 到 $bi$，边权递增，经过不超过 $ci$ 条边，权值和最小是多少？<br>$T$组数据（$T\le 100$）。<br>$n ≤ 150, m, q ≤ 5000.$</p></div></article><p>$n$ 比较小，那么考虑 DP。<br>边权看上去没办法放进状态里面，有一个技巧是把边升序排序，然后按照边来转移状态，即可满足要求。</p><p>设 $f[u,v,m]$ 表示 $u\to v$ 经过不超过 $m$ 条边的答案，$O(n)$ 固定起点 $s$，$O(m)$ 枚举一条边 $(u,v,w)$，则有转移：<br>$$ f[s,u,k]+w\to f[s,v,k+1] $$<br>这样看上去是 $O(nm^2)$ 的，但是考虑到限制是“至多经过”，而要求最小路径，则一个环不应在路径中出现，即一个点不会被访问超过一次。考虑到一个点之多有一条出边被选中，因此状态第三维的数量实际上是 $O(n)$ 的。对于 $ci&gt; n$ 的询问，其答案一定等于 $ci=n$ 的询问。</p><p>复杂度 $O(T(m\log m+n^2m+q))$，瓶颈在于 $O(Tn^2m)$；考虑到时限是 60s， 因此可以通过。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sort(G + <span class="number">1</span>, G + m + <span class="number">1</span>), <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) f[i][i][k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= n; s++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = G[i].u, v = G[i].v, w = G[i].w;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) </span><br><span class="line">                f[s][v][k + <span class="number">1</span>] = min(f[s][u][k] + w, f[s][v][k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="9-Increasing-Number"><a href="#9-Increasing-Number" class="headerlink" title="9 Increasing Number"></a>9 Increasing Number</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个数是Increasing当且仅当它的十进制表示是不降的，求 $n$ 位不降十进制数中被 $m$ 整除的有多少个。<br>$n ≤ 10^{18}, m ≤ 500.$</p></div></article><p>显然有状态 $f[n,p,k]$ 表示考虑第 $n$ 位数字，当前位填 $p$，模 $m$ 等于 $k$ 的方案数，转移可以枚举当前位数字和上一位数字，有关系 $f[n,p,(p·10^n+k)\text{ mod }m]\gets f[n-1,p’,k]$，复杂度 $O(100nm)$，不太可行。<br>对于这种转移关系比较固定的 DP，可以考虑矩乘加速，但是这是 $O((10m)^3\log n)$ 的，看上去也不太行。</p><p>一个重要的性质：一个合法数字必然是至多 9 个仅由 1 组成的数的和。<br>则可以按 $111…111$ 模 $m$ 的值将其分类，这样有 $m$ 类，然后对类做 DP 即可。<br>这也令我们可以得出一个结论：位数小于 $n$ 的不降数的总个数是 $\sum\limits_{i=1}^9\dbinom{i+n-1}{n-1}=\dbinom{n+9}{n}-1$。</p><h3 id="10-Little-Elephant-and-Colored-Coins"><a href="#10-Little-Elephant-and-Colored-Coins" class="headerlink" title="10 Little Elephant and Colored Coins"></a>10 Little Elephant and Colored Coins</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定 $n$ 个物品，每个物品可以取无限次，每个物品有两种属性：价值 $v$ 和颜色 $c$。<br>现在有 $q$ 个询问，询问最多能用多少种颜色组成 $S$。<br>$n ≤ 30, v_i ≤ 2·10^5,s\le 10^{18}$</p></div></article><p>对于这种题目，一般来说技巧是取 $w=\min v_i$ ，把问题转化到模 $w$ 的剩余系下做。这样做的正确性在于：$\mathbb{F}_P$ 中的所有数与 $P$ 的倍数组合能够填满整个整数域。<br>然后可以设状态 $f[u,k]$ 或 $f[k]$ 表示模 $w$ 为 $k$ 的答案，对于物品的价值 $v$ 可以抽象成一条边的边权，然后套用最短路模型，于是做到 $O(w\log w)$ 转移状态。</p><p>对于本题，考虑到硬币种类可能在统计过程中重复，因此设 $f[i,k]$ 表示选至少 $i$ 种，模 $w$ 为 $k$ 的路径的最小长度；用最短路模型来转移看上去也不太行，考虑换成背包模型，即有 $f[i,k]\gets f[i+1,(k+v_i)\text{ mod }w]$，然后按 $i$ 分组 DP 更新即可，复杂度 $O(n^2w)$。</p><p>给出大致的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = read(), w = w ? min(w, v[i]) : v[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j + <span class="number">1</span>; j--) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">            f[j + <span class="number">1</span>][(k + v[i]) % w] = min(f[j][k] + v[i], f[j + <span class="number">1</span>][(k + v[i]) % w]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">            f[i][(k + v[j]) % w] = min(f[i][k] + v[j], f[i][(k + v[j]) % w]);</span><br><span class="line">    </span><br><span class="line">q = read();</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> s = read(), sw = s % w;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &amp;&amp; !flag; i--)</span><br><span class="line">        <span class="keyword">if</span>(f[i][sw] &lt; INF &amp;&amp; f[i][sw] &lt;= s) <span class="built_in">printf</span>(<span class="string">"%d"</span>, i), <span class="built_in">puts</span>(<span class="string">""</span>), flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Balance"><a href="#11-Balance" class="headerlink" title="11 Balance"></a>11 Balance</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个杠杆，半长为 $n$，$2n+1$ 个整数坐标各有一个质量相同的砝码，取走 $k$ 个，问最终杠杆仍然平衡的方案数。<br>$n\le 10^4, k\le 10$</p></div></article><p>整数划分问题。<br>容易发现两边是完全对称的，那么只需要考虑一边。考虑枚举取的数字和是多少，设 $f[i,k]$ 表示把数字 $i$ 拆分成 $k$ 个小于 $n$ 的不同数字的方案数，有转移：<br>$$ \begin{aligned}f[i,k]&amp;=f[i-k,k]+f[i-k,k-1]\newline f[i,k]&amp;=f[i,k]-f[i-n-1,k-1] \text{ }\text{ }| \text{ }\text{ }i\ge n + 1 \end{aligned}$$<br>复杂度 $O(nk^2)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - K + <span class="number">1</span>; i &lt;= n; i++) N += i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        f[i][k] = i &gt;= k ? (f[i - k][k] + f[i - k][k - <span class="number">1</span>]) % p : <span class="number">0</span>,</span><br><span class="line">        f[i][k] = i &gt; n ? (f[i][k] - f[i - n - <span class="number">1</span>][k - <span class="number">1</span>] + p) % p : f[i][k];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= N; w++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K; j++) ans = (<span class="number">1l</span>l * f[w][j] * f[w][K - j] % p + ans) % p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= N; w++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K - <span class="number">1</span>; j++) ans = (<span class="number">1l</span>l * f[w][j] * f[w][K - j - <span class="number">1</span>] % p + ans) % p;</span><br></pre></td></tr></table></figure><h3 id="12-Arrangement-Count"><a href="#12-Arrangement-Count" class="headerlink" title="12 Arrangement Count"></a>12 Arrangement Count</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>求有多少个排列 $A\subseteq [n]$，使得 $A$ 中每个位置与相邻位置的数的差不为 1。<br>$n\le 1000$</p></div></article><p>设 $f[i,j,0/1]$ 表示考虑 $A\subseteq [i]$，有 $j$ 对相邻位置相差为 1 ，$i$ 是否与 $i+1$ 相邻的方案数，有转移：</p><ol><li>$f[i,j,0]·j\to f[i+1,j-1,0]$</li><li>$f[i,j,0]·2\to f[i+1, j + 1, 1], f[i,j,1]·2\to f[i+1, j, 1]$</li><li>$f[i,j,0/1]·(i-j-1)\to f[i+1,j,0]$</li></ol><p>复杂度 $O(n^2)$。</p><h3 id="13-Cut-Tree"><a href="#13-Cut-Tree" class="headerlink" title="13 Cut Tree"></a>13 Cut Tree</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个节点的树，点有点权，要切两条边和加一个点使得形成的三个子树点权和相等，最小化新加节点点权的绝对值。<br>$n \le 10^5$</p></div></article><p>考虑固定一整棵树的根，对所有 $n$ 棵子树的大小统计其出现次数 $cnt[]$。不妨设当前的根处需要割断一条边，那么枚举其的枚举一个子树 $v$，设其大小为 $sz[v]$ ，则当 $cnt[sz[v]]&gt;1$ 时，可将整棵树切成三个部分：两个 $sz[v]$ 和一个 $n-sz[v]$ ，于是可以更新答案。</p><p>但是当前根处不一定会割断边，那么考虑换根。容易发现当根向某个儿子移动时，至多有两个节点的 $sz[]$ 值会发生变化，则简单维护即可。</p><p>于是可以做到不漏算答案，时间复杂度 $O(n)$。</p><h3 id="14-Number-Game"><a href="#14-Number-Game" class="headerlink" title="14 Number Game"></a>14 Number Game</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>Alice 和 Bob 又双叒叕在玩游戏。<br>Bob 每次会想一个 $0\text{~}n$ 的数，Alice 每次猜 $k$，Bob 告诉 Alice 大了还是小了。Alice 猜 $k$ 会付出 $a_k$ 的代价，Alice 要最小化代价，Bob 要最大化代价（并在不违反前面询问的情况下改数）。假设二人都绝顶聪明，求 Alice 最后付出多少代价。<br>$n \le 10^5, a_i\le 9$</p></div></article><p>本人只会 $O(n^3)$ 的辣鸡 DP……</p><p>设 $f[l,r]$ 为考虑区间 $[l,r]$ 的答案，应当有转移：<br>$$ f[l,r]=\min\limits_k a_k+ \max(f[l,k-1],f[k+1,r]) $$ 边界是 $f[i,i]=a_i$，直接大力 DP 即可做到 $O(n^3)$。</p><h3 id="15-Distributs"><a href="#15-Distributs" class="headerlink" title="15 Distributs"></a>15 Distributs</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>小 A 带来了 $m$ 种特产，第 $i$ 种特产的数量为 $a_i$。小 A 要把它们全部分给 $n$ 个同学，要求每个同学至少拿到一个特产，问有多少种分法，对 $10^9+7$ 取模。<br>$n,m \le 1000$</p></div></article><p>容斥简单题，钦点 $k$ 个人一定分不到，剩下的随便分，在总方案数中减去就好了，则答案是：<br>$$ \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k}\sum\limits_j \dbinom{a_j+n-k-1}{n-k-1}$$ 复杂度 $O(n^2)$。</p><h3 id="16-Solutions-of-the-Equation"><a href="#16-Solutions-of-the-Equation" class="headerlink" title="16 Solutions of the Equation"></a>16 Solutions of the Equation</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个变量 $x_1…x_n$，每个变量 $0&lt;x\le R$，给定 $S$，求方程 $x_1+x_2+…+x_n=S$有多少组正整数解。<br>$n \le 1000$</p></div></article><p>容斥简单题，如果不考虑限制答案是 $\dbinom{S-1}{n-1}$，然后钦点有 $k$ 个变量不合法然后去加加减减，答案是：<br>$$ \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k}\dbinom{S-kR-1}{n-1} $$ 复杂度 $O(n^2)$。</p><h3 id="17-Bohater"><a href="#17-Bohater" class="headerlink" title="17 Bohater"></a>17 Bohater</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>在一款电脑游戏中，你需要打败$n$只怪物（从 $1$ 到 $n$ 编号），初始生命值为 $z$。<br>为了打败第 $i$ 只怪物，你需要消耗 $d_i$ 点生命值，但怪物死后会掉落血药，使你恢复 $a_i$ 点生命值。<br>任何时候你的生命值都不能降到 0（或 0 以下）。请问是否存在一种打怪顺序，使得你可以打完这 $n$ 只怪物而不死掉。如果存在请输出方案，不存在输出NO。<br>$1≤n,z≤10^5，0≤d_i,a_i≤10^5$</p></div></article><p>考虑把怪分成两类，先打加血怪，再打减血怪；考虑打加血怪的过程：应当按 $d_i$ 升序去打。<br>减血怪呢？考虑打怪的反过程：不打一个怪，血量增加 $d_i$ 而减少 $a_i$。<br>则反过程应当按 $a_i$ 升序排，正过来就是按 $a_i$ 降序排。</p><p>复杂度 $O(n\log n)$。</p><h3 id="18-Swap-Space"><a href="#18-Swap-Space" class="headerlink" title="18 Swap Space"></a>18 Swap Space</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>你有许多电脑，它们的硬盘用不同的文件系统储存数据。你想要通过格式化来统一文件系统。格式化硬盘可能使它的容量从 $a_i$ 变成 $b_i$。<br>为了格式化，你需要买额外的硬盘。当然，你想要买容量最小的额外储存设备以便省钱。<br>你可以按任意顺序格式化硬盘。格式化之前，你要把该硬盘上所有数据移到一个或更多的其他硬盘上，数据可以分割。<br>格式化后，该硬盘可以立刻开始使用。你没有必要把数据放到它原来所在的硬盘上。数据也可以被放到你额外买的硬盘上。<br>求最小的额外储存设备容量。<br>$1≤n≤10^6,1≤a_i,b_i≤10^9$</p></div></article><p>考虑二分最终的答案 $M$ ，表示一开始购买的硬盘大小，则模型变为：</p><ul><li>给定一些元素 $(a,b)$ ，选择某个元素会付出代价 $a$ 得到收益 $b$ ，求能否选择所有元素。</li></ul><p>这就是上题模型，复杂度 $O(n\log^2n)$，看上去有点卡。</p><p>实际上二分大可不必，依然按照上题的思路去做，当代价和多于当前的承受限度时，把多出来的那一部分加到答案里即可，复杂度 $O(n\log n)$。</p><h3 id="19-Maximum-Value-of-Linear-Function"><a href="#19-Maximum-Value-of-Linear-Function" class="headerlink" title="19 Maximum Value of Linear Function"></a>19 Maximum Value of Linear Function</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>现在有 $n$ 个一次函数，$f_i(x)=a_ix+b_i$。给定 $x$，并且对于所有的 $f_i(x)$ 可以任意改变顺序嵌套函数，求 $f(f(f(…f(x))…)$ 的最大值。<br>$n\le 10^6$</p></div></article><p>容易发现 $x$ 的系数一定，那么只需要考虑常数项最大。<br>考虑交换，对二元组 $(a_1,b_1)$ 和 $(a_2,b_2)$ ，前者放在外层当且仅当 $a_1(a_2x+b_2)+b_1&gt;a_2(a_1x+b_1)+b_2$，移项得 $(a_1-1)/b_1&gt;(a_2-1)/b_2$，则按照 $(a_i-1)/b_i$ 降序排序，把靠前的放在外层即可。</p><p>这个题也可以类比一下<a href="https://www.luogu.com.cn/problem/P1080">「国王游戏」</a>那道题。考虑何时应该交换相邻的两个元素 $i,j$：当且仅当 $\Pi/b_i+(a_i·\Pi)/b_j &gt; \Pi/b_j+(a_j·\Pi)/b_i$，化简得 $(a_j-1)·b_j&lt;(a_i-1)·b_i$，因此按 $(a_i-1)·b_i$ 为关键字排序即可。</p><h3 id="20-Kuglarz"><a href="#20-Kuglarz" class="headerlink" title="20 Kuglarz"></a>20 Kuglarz</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个杯子排成一排，每个杯子中可能放有也可能没有一个小球。你每次可以花费 $C(i,j)$ 的代价得知区间 $[i,j]$ 的杯子中球的总数的奇偶性。<br>问最少花费多少代价才能求出每个杯子中是否有小球。<br>$n\le 1000$</p></div></article><p>看上去很像 DP，但我的做法假掉了……<br>建一张图，边 $(u,v)$ 的边权为 $C(u,v)$，则问题等价于求出图上的最小生成树。<br>时间复杂度 $O(n^2)$。</p><h3 id="21-OSU"><a href="#21-OSU" class="headerlink" title="21 OSU!"></a>21 OSU!</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。<br>求该 01 串的价值的期望。<br>$n\le 10^5$</p></div></article><p>考察期望的定义，和应用用贡献法计算每一位的价值期望。<br>设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：<br>$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：<br>$$ \begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \end{aligned}$$ 于是可以做到 $O(n)$。<br>注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l[i] = a[i] * (l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l2[i] = a[i] * (l2[i - <span class="number">1</span>] + <span class="number">2</span> * l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] + a[i] * (<span class="number">3</span> * l2[i - <span class="number">1</span>] + <span class="number">3</span> * l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，做题的关键在于口胡出解法，而我还是什么都不会……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>最小斯坦纳树</title>
    <link href="https://big-news.cn/2020/08/23/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    <id>https://big-news.cn/2020/08/23/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/</id>
    <published>2020-08-23T10:30:00.000Z</published>
    <updated>2020-08-23T23:48:55.140Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，斯坦纳树问题是一类特殊的生成树问题……</p><a id="more"></a><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。<br>再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G=(V,E)$，使得：</p><ol><li>$S\subseteq V$；</li><li>$G$ 为连通图；</li><li>$E$ 中所有边的权值和最小。</li></ol><p>你只需要求出 $E$ 中所有边的权值和。<br>$n\le 100, m\le 500, k\le 10$</p></div></article><p>上述问题被称作「最小斯坦纳树」问题。</p><p>设 $f[i,S]$ 表示当前在 $i$ ，$S$ 中的点已经连通的最小代价，则有转移：</p><p>$$ \begin{aligned} f[i,S] &amp;=\min f[i,S_0]+f[i,S\oplus S_0]\newline f[i,S] &amp;=\min f[j,S]+\text{sp}(i,j)   \end{aligned} $$</p><p>容易发现后一个转移是最短路的形式，考虑到不存在负权边，使用 Dijkstra 转移，复杂度 $O(2^k n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,w; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> d)</span> </span>&#123;to = t, nxt = n, w = d;&#125; &#125; E[CN * CN];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, key[CN], f[CN][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> id, v; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ &amp; a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;&#125;;</span><br><span class="line"><span class="function">DJ <span class="title">make</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;DJ c; c.id = a, c.v = b; <span class="keyword">return</span> c;&#125;</span><br><span class="line">priority_queue&lt;DJ&gt; Q; <span class="keyword">bool</span> vis[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sp</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(f[i][S] &lt; INF) Q.push( make(i, f[i][S]) );</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.top().id; Q.pop();</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[v][S] &gt; f[u][S] + E[k].w)&#123;</span><br><span class="line">                f[v][S] = f[u][S] + E[k].w;</span><br><span class="line">                Q.push( make(v, f[v][S]) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read(), k = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) key[i] = read();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) f[ key[i] ][ <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>) ] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); S++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> V = S; V; V = (V - <span class="number">1</span>) &amp; S)</span><br><span class="line">                f[i][S] = min(f[i][S], f[i][V] + f[i][S ^ V]);</span><br><span class="line">        sp(S);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = min(ans, f[i][(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，斯坦纳树问题是一类特殊的生成树问题……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="斯坦纳树" scheme="https://big-news.cn/tags/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
      <category term="状压DP" scheme="https://big-news.cn/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」牛客小白月赛 27</title>
    <link href="https://big-news.cn/2020/08/22/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B%2027/"/>
    <id>https://big-news.cn/2020/08/22/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B%2027/</id>
    <published>2020-08-22T12:29:00.000Z</published>
    <updated>2020-08-22T14:37:27.394Z</updated>
    
    <content type="html"><![CDATA[<p>又是签到走人的一天……</p><a id="more"></a><p><a href="https://ac.nowcoder.com/acm/contest/6874">比赛链接</a></p><h3 id="A-巨木之森"><a href="#A-巨木之森" class="headerlink" title="A 巨木之森"></a>A 巨木之森</h3><p>签到题，对每个点维护一个到叶子的最长距离，随便怎么搞搞就行了。本人脑子笨，写了个线段树，复杂度 $O(n\log n)$，实际上有严格 $O(n)$ 解法。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,d; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> dd)</span> </span>&#123;to = t, nxt = n, d = dd;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN &lt;&lt; <span class="number">2</span>], tag[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        d[lc] += tag[k], d[rc] += tag[k], tag[lc] += tag[k], tag[rc] += tag[k], tag[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> (<span class="keyword">void</span>)(tag[k] += x, d[k] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(tag[k]) pd(l, r, k);</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) md(l, m, lc, s, t, x); <span class="keyword">if</span>(m &lt; t) md(m + <span class="number">1</span>, r, rc, s, t, x);</span><br><span class="line">        d[k] = max(d[lc], d[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(tag[k]) pd(l, r, k);</span><br><span class="line">        upd(l, m, lc), upd(m + <span class="number">1</span>, r, rc); d[k] = max(d[lc], d[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> d[<span class="number">1</span>];&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sum = <span class="number">0</span>, d[CN], id[CN], sz[CN], idx = <span class="number">0</span>, mxd[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    id[u] = ++idx, sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) d[v] = d[u] + E[k].d, bd(v, u), sz[u] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    mxd[u] = D.qu();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p)&#123;</span><br><span class="line">            D.md(<span class="number">1</span>, n, <span class="number">1</span>, <span class="number">1</span>, n, E[k].d), D.md(<span class="number">1</span>, n, <span class="number">1</span>, id[v], id[v] + sz[v] - <span class="number">1</span>, <span class="number">-2l</span>l * E[k].d);</span><br><span class="line">            dfs(v, u);</span><br><span class="line">            D.md(<span class="number">1</span>, n, <span class="number">1</span>, <span class="number">1</span>, n, -E[k].d), D.md(<span class="number">1</span>, n, <span class="number">1</span>, id[v], id[v] + sz[v] - <span class="number">1</span>, <span class="number">2l</span>l * E[k].d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w), sum += w;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">2l</span>l * sum;</span><br><span class="line"></span><br><span class="line">    bd(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.md(<span class="number">1</span>, n, <span class="number">1</span>, id[i], id[i], d[i]);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mxd[i] = sum - mxd[i];</span><br><span class="line">    sort(mxd + <span class="number">1</span>, mxd + n + <span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n &amp;&amp; sum + mxd[p] &lt;= m) sum += mxd[p++], ans++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-乐团派对"><a href="#B-乐团派对" class="headerlink" title="B 乐团派对"></a>B 乐团派对</h3><p>考察快速排序以及输入输出。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;a[i] = read(); <span class="keyword">if</span>(a[i] &gt; n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;&#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp); </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n) &#123;<span class="keyword">if</span>(p + a[p] &lt;= n + <span class="number">1</span>) ans++, p += a[p]; <span class="keyword">else</span> p++;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-巅峰对决"><a href="#D-巅峰对决" class="headerlink" title="D 巅峰对决"></a>D 巅峰对决</h3><p>线段树板子题。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> !b ? a : gcd(b, a % b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN &lt;&lt; <span class="number">2</span>], mx[CN &lt;&lt; <span class="number">2</span>], mn[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(mx[k] = mn[k] = d[k] = a[l]);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; bd(l, m, lc, a), bd(m + <span class="number">1</span>, r, rc, a);</span><br><span class="line">        d[k] = gcd(d[lc], d[rc]), mx[k] = max(mx[lc], mx[rc]), mn[k] = min(mn[lc], mn[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(mx[k] = mn[k] = d[k] = x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(p &lt;= m) md(l, m, lc, p, x); <span class="keyword">else</span> md(m + <span class="number">1</span>, r, rc, p, x);</span><br><span class="line">        d[k] = gcd(d[lc], d[rc]), mx[k] = max(mx[lc], mx[rc]), mn[k] = min(mn[lc], mn[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> d[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = gcd(qu(l, m, lc, s, t), ans);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = gcd(qu(m + <span class="number">1</span>, r, rc, s, t), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> mx[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = max(qum(l, m, lc, s, t), ans);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = max(qum(m + <span class="number">1</span>, r, rc, s, t), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qun</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> mn[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = INF;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = min(qun(l, m, lc, s, t), ans);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = min(qun(m + <span class="number">1</span>, r, rc, s, t), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> MX = D.qum(<span class="number">1</span>, n, <span class="number">1</span>, s, t), MN = D.qun(<span class="number">1</span>, n, <span class="number">1</span>, s, t);</span><br><span class="line">    <span class="keyword">if</span>((MX - MN) ^ (t - s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> G = D.qu(<span class="number">1</span>, n, <span class="number">1</span>, s, t);</span><br><span class="line">    <span class="keyword">return</span> G ^ <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    D.bd(<span class="number">1</span>, n, <span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op = read(), x = read(), y = read();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) D.md(<span class="number">1</span>, n, <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">else</span> ck(x, y) ? <span class="built_in">puts</span>(<span class="string">"YES"</span>) : <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-核弹剑仙"><a href="#F-核弹剑仙" class="headerlink" title="F 核弹剑仙"></a>F 核弹剑仙</h3><p>傻题。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, f[CN]; <span class="keyword">bool</span> vis[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(!vis[v]) dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dfs(u); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(vis[i]) ans++;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read(); add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt(i)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是签到走人的一天……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://big-news.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>「题解」Emiya家今天的饭</title>
    <link href="https://big-news.cn/2020/08/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DEmiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/"/>
    <id>https://big-news.cn/2020/08/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DEmiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/</id>
    <published>2020-08-21T11:07:00.000Z</published>
    <updated>2020-08-21T13:33:49.332Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，小葱同学擅长计算几何，但是并不擅长 DP。</p><a id="more"></a><ul><li>$m = 2/3$</li></ul><p>设 $f[i,j,k]$ 表示考虑前 $i$ 行，第一列选了 $j$ 个，第二列选了 $k$ 个的方案数之和，有转移：$$f[i,j,k]\gets f[i-1,j-1,k]·a[i,1]+f[i-1,j,k-1]·a[i,2]$$ $m = 3$ 的情况也同理，多开一维状态就好了，复杂度 $O(n^3)$ 或 $O(n^4)$，能拿到 64pts。</p><ul><li>$m\le 500$</li></ul><p>根据 lorem ipsum 原理，不合法方案中至多有一列的选择数超过 $\lfloor k/2 \rfloor$ ，则考虑补集转化，把不合法的方案 DP 出来。<br>钦点第 $u$ 行不合法，设 $f[i,j,k]$ 表示考虑前 $i$ 行，其它行一共选 $j$ 个， $u$ 行选了 $k$ 个的方案数，有转移：<br>$$ f[i,j,k]\gets f[i-1,j,k]+f[i,j,k-1]·a[i,u]+\sum\limits_{v\neq u} f[i,j-1,k]·a[i,v] $$ 预处理前缀和即可 $O(1)$ 转移，复杂度 $O(mn^3)$，能拿到 84pts。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="number">1l</span>l * ans * (a[i][<span class="number">0</span>] + <span class="number">1</span>) % P; ans = (ans + P - <span class="number">1</span>) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= m; u++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(k) f[i][j][k] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][j][k - <span class="number">1</span>] * a[i][u] % P + f[i][j][k]) % P;</span><br><span class="line">                <span class="keyword">if</span>(j) f[i][j][k] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] * (a[i][<span class="number">0</span>] - a[i][u] + P) % P + f[i][j][k]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = (j + k) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(k &lt;= s) <span class="keyword">continue</span>;</span><br><span class="line">            ans = (ans - f[n][j][k] + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$n\le 100, m \le 2000$</li></ul><p>考虑削状态，设 $f[i,l]$ 表示考虑前 $i$ 行，$n+k-j=l$ 时的方案数，有转移：<br>$$ f[i,l]\gets f[i-1,l]+f[i-1,l+1]·a[i,u]+\sum\limits_{u\neq v}f[i-1,l-1]·a[i,v] $$ 预处理前缀和即可 $O(1)$ 转移，复杂度 $O(mn^2)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="number">1l</span>l * ans * (a[i][<span class="number">0</span>] + <span class="number">1</span>) % P; ans = (ans + P - <span class="number">1</span>) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= m; u++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= (n &lt;&lt; <span class="number">1</span>); l++)&#123;</span><br><span class="line">            f[i][l] = f[i - <span class="number">1</span>][l];</span><br><span class="line">            f[i][l] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][l + <span class="number">1</span>] * a[i][u] + f[i][l]) % P;</span><br><span class="line">            <span class="keyword">if</span>(l) f[i][l] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][l - <span class="number">1</span>] * (a[i][<span class="number">0</span>] - a[i][u] + P) % P + f[i][l]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) ans = (ans - f[n][l] + P) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，小葱同学擅长计算几何，但是并不擅长 DP。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>01-Trie</title>
    <link href="https://big-news.cn/2020/08/18/01-Trie/"/>
    <id>https://big-news.cn/2020/08/18/01-Trie/</id>
    <published>2020-08-18T05:32:00.000Z</published>
    <updated>2020-08-19T12:33:51.139Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，01-Trie 是字符集为 $\begin{Bmatrix}0,1\end{Bmatrix}$ 的 Trie ，可用于维护若干数字的二进制位，处理点对异或最值、某种动态异或和问题。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>与线性基不同，01-Trie 无法处理子集异或问题，但是可以通过前缀和转化来处理区间异或问题。</div></article><a id="more"></a><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>01-Trie 支持在 $O(\log a_i)$ 的时间内完成如下操作：</p><ul><li>查询全局异或和</li><li>数列全局加一，维护全局异或和</li><li>查询数列中某个数与指定数字异或的最大值</li><li>合并两棵 01-Trie 维护的信息</li></ul><p>通过将其可持久化，还可以支持如下操作：</p><ul><li>查询区间异或和</li><li>查询区间中某个数与指定数字异或的最大值</li></ul><p>通过观察容易实现上述若干操作，则可以得到这样一份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 非可持久化 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TRIE</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> ch[CN * <span class="number">30</span>][<span class="number">2</span>], d[CN * <span class="number">30</span>], w[CN * <span class="number">30</span>], idx, rt, MAXH;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    TRIE() &#123;rt = idx = <span class="number">0</span>, MAXH = <span class="number">30</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mt</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        d[u] = <span class="number">0</span>, w[u] = w[lc] + w[rc];</span><br><span class="line">        <span class="keyword">if</span>(rc) d[u] ^= (d[rc] &lt;&lt; <span class="number">1</span>) | (w[rc] &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lc) d[u] ^= d[lc] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        w[u] &amp;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span></span>&#123;                      <span class="comment">// 插入一个数</span></span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(dep == MAXH) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[u] ^= <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ins(rc, x &gt;&gt; <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ins(lc, x &gt;&gt; <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">        mt(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">if</span>(rc) add(rc); swap(lc, rc), mt(u);&#125; <span class="comment">// 全局加一</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> d[rt];&#125;                              <span class="comment">// 全局异或和</span></span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><p>注意，01-Trie 的可持久化看上去并不支持版本修改，因为无法使用树状数组维护子树交换信息。</p><h3 id="2-一道栗题"><a href="#2-一道栗题" class="headerlink" title="2 一道栗题"></a>2 一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「TJOI2017」异或和</strong></p><p>给定一段数列，定义数列的“连续和”为数列的某个子串的所有数之和，求序列所有连续和的异或值。</p></div></article><p>考虑固定左端点 $l$ ，$O(n)$ 枚举右端点 $r$ ，则可以求出一些左端点固定的区间 $[l,r]$ 权值和异或和。</p><p>考虑优化这个过程：对于一个左端点 $l$ ，如何快速求出其能对应的所有区间 $[l,r]$ 的异或和。由于数列是静态的，那么我们考虑 $l\to l-1$ 时贡献的变化，它应该是这个样子：</p><p>$$\begin{aligned} &amp; (s[n]-s[l])\oplus (s[n-1]-s[l])\oplus … \oplus (s[l+1]-s[l]) \newline \to &amp;(s[n]-s[l]+a[l-1])\oplus (s[n-1]-s[l]+a[l-1])\oplus …\oplus a[l-1] \end{aligned}$$</p><p>其中 $s[]$ 代表 $a[]$ 的前缀和。容易发现这个变化是对每一项同时加了一个值之后再查询异或和，显然可以通过 01-Tire 来维护，总复杂度 $O((n+\sum a_i)\log a_i)$；由于 $\sum a_i \le 10^6$，所以可以通过。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123; <span class="comment">/* 略 */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TRIE</span> &#123;</span> <span class="comment">/* 同上 */</span> &#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i + <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(s--) D.add( D.rt );</span><br><span class="line">        D.ins(D.rt, a[i + <span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        ans ^= D.sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-又一道栗题"><a href="#3-又一道栗题" class="headerlink" title="3 又一道栗题"></a>3 又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「TJOI2018」异或</strong></p><p>现在有一颗以 $1$ 为根节点的由 $n$ 个节点组成的树，节点从 $1$ 至 $n$ 编号。树上每个节点上都有一个权值 $v_i$。现在有 $q$ 次操作，操作如下：</p><ul><li>1 x z：查询节点 $x$ 的子树中的节点权值与 $z$ 异或结果的最大值。</li><li>2 x y z：查询节点 $x$ 到节点 $y$ 的简单路径上的节点的权值与 $z$ 异或结果最大值。</div></article></li></ul><p>容易想到树剖，则转化为序列上的查询操作。通过版本来区分区间，即将 01-Tire 可持久化，即可解决本题。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>可持久化 01-Trie 一般用于处理静态区间异或最大值问题。</div></article><p>容易得到如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TRIE</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> rt[CN], ch[CN * <span class="number">30</span>][<span class="number">2</span>], w[CN * <span class="number">30</span>], MAXH, idx;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    TRIE() &#123;idx = <span class="number">0</span>, MAXH = <span class="number">31</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(dep &lt; <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[u] = w[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> b = (x &gt;&gt; dep) &amp; <span class="number">1</span>; ch[u][!b] = ch[v][!b];</span><br><span class="line">        ins(ch[u][b], ch[v][b], x, dep - <span class="number">1</span>);</span><br><span class="line">        w[u] = w[lc] + w[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qm</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> k, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = (k &gt;&gt; dep) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(w[ ch[u][!b] ] &gt; w[ ch[v][!b] ]) <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; dep) | qm(ch[u][!b], ch[v][!b], k, dep - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qm(ch[u][b], ch[v][b], k, dep - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, v[CN], oid[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> top[CN], id[CN], sz[CN], imp[CN], dep[CN], fa[CN], idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[p] + <span class="number">1</span>, sz[u] = <span class="number">1</span>, fa[u] = p; <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs1(v, u), sz[u] += sz[v], mx = sz[v] &gt; mx ? imp[u] = v, sz[v] : mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    top[u] = t, id[u] = ++idx;</span><br><span class="line">    <span class="keyword">if</span>(imp[u]) dfs2(imp[u], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ imp[u] &amp;&amp; v ^ fa[u]) dfs2(v, v); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[ top[x] ] &lt; dep[ top[y] ]) swap(x, y);</span><br><span class="line">        ans = max(ans, D.qm(D.rt[ id[x] ], D.rt[ id[ top[x] ] - <span class="number">1</span> ], z, D.MAXH));</span><br><span class="line">        x = fa[ top[x] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    ans = max(ans ,D.qm(D.rt[ id[x] ], D.rt[ id[y] - <span class="number">1</span> ], z, D.MAXH));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> id[x] &lt; id[y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = read(), oid[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"></span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    sort(oid + <span class="number">1</span>, oid + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.ins(D.rt[i], D.rt[i - <span class="number">1</span>], v[ oid[i] ], D.MAXH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> o = read(), x = read(), y = read(), z;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.qm(D.rt[ id[x] + sz[x] - <span class="number">1</span> ], D.rt[ id[x] - <span class="number">1</span> ], y, D.MAXH)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> z = read(), <span class="built_in">printf</span>(<span class="string">"%d"</span>, qu(x, y, z)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-双一道栗题"><a href="#4-双一道栗题" class="headerlink" title="4 双一道栗题"></a>4 双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「联合省选 2020 A」树</strong></p><p>给定一棵 $n$ 个结点的有根树 $T$，结点从 $1$ 开始编号，根结点为 $1$ 号结点，每个结点有一个正整数权值 $v_i$。<br>设 $x$ 号结点的子树内（包含 $x$ 自身）的所有结点编号为 $c_1,c_2,\dots,c_k$，定义 $x$ 的价值为：<br>$$val(x)=(v_{c_1}+d(c_1,x)) \oplus (v_{c_2}+d(c_2,x)) \oplus \cdots \oplus (v_{c_k}+d(c_k, x))$$<br>其中 $d(x,y)$ 表示树上 $x$ 号结点与 $y$ 号结点间唯一简单路径所包含的边数，$d(x,x) = 0$。$\oplus$ 表示异或运算。<br>请你求出 $\sum\limits_{i=1}^n val(i)$ 的结果。</p></div></article><p>对每个叶子建立一棵 01-Trie ，然后每次合起来再全局加一即可得到父亲的 01-Trie ，统计答案即可。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>01-Trie 合并的序列意义是：把两段序列的所有数字插入同一个 01-Trie ，并维护异或和。</div></article><p>容易得到如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125;&#125;E[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN],ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">trie</span>&#123;</span> <span class="comment">// dep = 0,dep &gt; 20</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> ch[CN * <span class="number">30</span>][<span class="number">2</span>], w[CN * <span class="number">30</span>], val[CN * <span class="number">30</span>], rt[CN], tot;</span><br><span class="line">    trie() &#123;<span class="built_in">memset</span>(rt, <span class="number">0</span>, <span class="keyword">sizeof</span>(rt)); tot = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> u = ++tot; lc = rc = w[u] = val[u] = <span class="number">0</span>; <span class="keyword">return</span> tot;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        w[u] = val[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(lc) w[u] += w[lc], val[u] ^= val[lc] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(rc) w[u] += w[rc], val[u] ^= (val[rc] &lt;&lt; <span class="number">1</span>) | w[rc];</span><br><span class="line">        w[u] &amp;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> x,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(dep &gt; <span class="number">20</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[u] ^= <span class="number">1</span>);</span><br><span class="line">        ins(ch[u][x &amp; <span class="number">1</span>], x &gt;&gt; <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">        maintain(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addall</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">if</span>(rc) addall(rc); swap(lc, rc); maintain(u);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k) <span class="keyword">return</span> u; <span class="keyword">if</span>(!u) <span class="keyword">return</span> k;</span><br><span class="line">        w[u] = (w[u] + w[k]) &amp; <span class="number">1</span>; val[u] ^= val[k];</span><br><span class="line">        lc = merge(lc, ch[k][<span class="number">0</span>]); rc = merge(rc, ch[k][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,v[CN],va[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!hd[u])&#123;</span><br><span class="line">        va[u] = v[u];</span><br><span class="line">        D.ins(D.rt[u], v[u], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = hd[u], s1;</span><br><span class="line">    <span class="keyword">for</span>(; k; k = E[k].nxt) dfs(E[k].to);</span><br><span class="line">    </span><br><span class="line">    k = hd[u], s1 = E[k].to, k = E[k].nxt, D.rt[u] = D.rt[s1];</span><br><span class="line">    <span class="keyword">for</span>(; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        D.merge(D.rt[u], D.rt[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    D.addall(D.rt[u]), D.ins(D.rt[u], v[u], <span class="number">0</span>);</span><br><span class="line">    va[u] = D.val[ D.rt[u] ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) v[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) add(read(), i);</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans += <span class="number">1l</span>l * va[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，01-Trie 是字符集为 $\begin{Bmatrix}0,1\end{Bmatrix}$ 的 Trie ，可用于维护若干数字的二进制位，处理点对异或最值、某种动态异或和问题。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-primary&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-lightbulb mr-2&quot;&gt;&lt;/i&gt;
与线性基不同，01-Trie 无法处理子集异或问题，但是可以通过前缀和转化来处理区间异或问题。
&lt;/div&gt;
&lt;/article&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字典树" scheme="https://big-news.cn/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="Trie" scheme="https://big-news.cn/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>主席树</title>
    <link href="https://big-news.cn/2020/08/17/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>https://big-news.cn/2020/08/17/%E4%B8%BB%E5%B8%AD%E6%A0%91/</id>
    <published>2020-08-17T00:47:00.000Z</published>
    <updated>2020-08-26T08:42:42.419Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，主席树即可持久化值域线段树， 用于解决区间 $k$ 小值问题以及动态二维数点问题。</p><a id="more"></a><h3 id="1-静态主席树"><a href="#1-静态主席树" class="headerlink" title="1 静态主席树"></a>1 静态主席树</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>静态区间 k 小值</strong></p><p>给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。</p></div></article><p>静态主席树一般指可持久化值域线段树，并不支持修改操作。</p><p>容易发现区间信息是满足可减性的，则只需要在每次插入时建立一个船新版本即可，查询也只需要对两个历史版本作差便能得到区间信息。<br>类似的，01-Trie 与 Treap 之类的无法维护区间信息的数据结构也可以通过可持久化来实现区间信息的维护。</p><p>容易得出下面的这份代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] = d[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, ch[v][<span class="number">0</span>], l, m, p), rc = ch[v][<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">else</span> md(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p), lc = ch[v][<span class="number">0</span>];</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = d[lc] - d[ ch[v][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= k) <span class="keyword">return</span> qu(lc, ch[v][<span class="number">0</span>], l, m, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qu(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, k - s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = a[i] = read();</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + n + <span class="number">1</span>);</span><br><span class="line">    val[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[ ++val[<span class="number">0</span>] ] = val[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.md(D.rt[i], D.rt[i - <span class="number">1</span>], <span class="number">1</span>, val[<span class="number">0</span>], id( a[i] ));</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), k = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, val[ D.qu( D.rt[r], D.rt[l - <span class="number">1</span>], <span class="number">1</span>, val[<span class="number">0</span>], k ) ]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-带修主席树"><a href="#2-带修主席树" class="headerlink" title="2 带修主席树"></a>2 带修主席树</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>动态区间 k 小值</strong></p><p>给定一个含有 $n$ 个数的序列 $a_1, a_2, …, a_n$ ，需要支持两种操作：</p><ul><li>Q l r k 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数</li><li>C x y 表示将 $a_x$ 改为 $y$</div></article></li></ul><p>带修主席树一般指树状数组套可持久化值域线段树。</p><p>容易发现主席树的每个版本是对区间信息做一个前缀和，这样如果在某个版本上修改是 $O(n)$ 的。<br>既然是前缀和，套用树状数组的方式写主席树就好了，复杂度 $O(n\log^2n)$ 。</p><p>于是容易得到下面的这份代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], rt[CN], idx, n;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 修改不新建版本</span></span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, l, m, p, x); <span class="keyword">else</span> md(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 修改 BIT 中所有的树</span></span><br><span class="line">        <span class="keyword">while</span>(u &lt;= rt[<span class="number">0</span>]) md(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t1[<span class="number">101</span>], t2[<span class="number">101</span>]; <span class="comment">// 把 O(log) 棵主席树的根搞下来</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qu_pre</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="comment">// (l, r]</span></span><br><span class="line">        t1[<span class="number">0</span>] = t2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = l; <span class="keyword">while</span>(u) t1[ ++t1[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">        u = r; <span class="keyword">while</span>(u) t2[ ++t2[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) s -= d[ ch[ t1[i] ][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) s += d[ ch[ t2[i] ][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(l, m, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(m + <span class="number">1</span>, r, k - s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QUERY</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> tp, a, b, c;</span><br><span class="line">&#125; Q[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    D.rt[<span class="number">0</span>] = n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[ ++val[<span class="number">0</span>] ] = a[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c; <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'Q'</span>) Q[i].tp = <span class="number">0</span>, Q[i].a = read(), Q[i].b = read(), Q[i].c = read();</span><br><span class="line">        <span class="keyword">else</span> Q[i].tp = <span class="number">1</span>, Q[i].a = read(), val[ ++val[<span class="number">0</span>] ] = Q[i].b = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[ ++cnt ] = val[i];</span><br><span class="line">    D.n = val[<span class="number">0</span>] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.cg(i, id( a[i] ), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Q[i].tp)&#123;</span><br><span class="line">            D.qu_pre(Q[i].a - <span class="number">1</span>, Q[i].b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, val[ D.qu(<span class="number">1</span>, val[<span class="number">0</span>], Q[i].c) ]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            D.cg(Q[i].a, id( a[ Q[i].a ] ), <span class="number">-1</span>), a[ Q[i].a ] = Q[i].b, D.cg(Q[i].a, id( a[ Q[i].a ] ), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，导致其常数巨大，不过它依然能在 1s 左右的时间内通过此题。</p><h3 id="3-一道栗题"><a href="#3-一道栗题" class="headerlink" title="3 一道栗题"></a>3 一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「CQOI2011」动态逆序对</strong></p><p>给出 $1\sim n$ 的一个排列，按照某种顺序依次删除 $m$ 个元素，在每次删除一个元素之前统计整个序列的逆序对数。</p></div></article><p>如果是静态问题，那么只需要用权值树状数组就可以简单维护。</p><p>由于只有删除操作，考虑计算删除一个元素对答案的贡献（实际上是减少量而不是增加量），容易发现这样的查询同时存在下标和权值两个维度；下标即通过版本来区分，因此用主席树。考虑到修改和影响传递的过程，仿照上题套一个树状数组即可。</p><p>于是容易得到如下代码。同样的，由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，其常数巨大，不过它依然能在 1.2s 左右的时间内通过此题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx, n;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, l, m, p, x); <span class="keyword">else</span> md(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(u &lt;= rt[<span class="number">0</span>]) md(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t[CN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pqu</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = r; <span class="keyword">while</span>(u) t[ ++t[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) s += d[ t[i] ];</span><br><span class="line">            <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) t[i] = ch[ t[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(l, m, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) s += d[ ch[ t[i] ][<span class="number">0</span>] ];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) t[i] = ch[ t[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> s + qu(m + <span class="number">1</span>, r, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN], rk[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = a[i] = read(), rk[ a[i] ] = i;</span><br><span class="line">    D.rt[<span class="number">0</span>] = D.n = n;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        D.cg(i, a[i], <span class="number">1</span>), D.pqu(i - <span class="number">1</span>), ans -= D.qu(<span class="number">1</span>, n, a[i]), D.pqu(i - <span class="number">1</span>), ans += D.qu(<span class="number">1</span>, n, n);</span><br><span class="line"></span><br><span class="line">    m -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> x = read(), p = rk[x], s1, s2;</span><br><span class="line">        D.cg(p, x, <span class="number">-1</span>);</span><br><span class="line">        D.pqu(p - <span class="number">1</span>), s2 = D.qu(<span class="number">1</span>, n, x);</span><br><span class="line">        D.pqu(p - <span class="number">1</span>), s1 = D.qu(<span class="number">1</span>, n, n) - s2;</span><br><span class="line">        D.pqu(n), s2 = D.qu(<span class="number">1</span>, n, x) - s2;</span><br><span class="line">        ans -= s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-二维数点"><a href="#4-二维数点" class="headerlink" title="4 二维数点"></a>4 二维数点</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「SHOI2007」园丁的烦恼</strong></p><p>维护二维坐标系上的 $n$ 个点，$q$ 次查询矩形 $(a,b):(c,d)$ 内的点的个数。</p></div></article><p>二维数点是一类宽泛的 RMQ 问题，甚至于许多树上问题都能通过 dfs 序转化成二维数点问题。</p><p>众所周知，带修主席树可以用来解决动态二维数点问题，其本质与上面的题目类似。对于静态的二维数点，带修主席树 $O(n\log^2n)$ 的复杂度要比 $O(n\log n)$ 的树状数组解法要劣，可通过实现一个版本修改函数来避免带修。具体实现也较为简单，因此不再赘述。</p><p>这里给出一份带修主席树解决静态二维数点的代码，使用时需注意常数因子对程序效率带来的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], rt[CN], idx, n, m;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pmd</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(p &lt;= m) pmd(lc, l, m, p, x); <span class="keyword">else</span> pmd(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(u &lt;= m) pmd(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);&#125;</span><br><span class="line">    <span class="keyword">int</span> t1[<span class="number">25</span>], t2[<span class="number">25</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pqu</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = s; t1[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">while</span>(u) t1[ ++t1[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">        u = t; t2[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">while</span>(u) t2[ ++t2[<span class="number">0</span>] ] = rt[u], u -= lb(u); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) ans += d[ t2[i] ];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) ans -= d[ t1[i] ];</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>, tmp1[<span class="number">25</span>], tmp2[<span class="number">25</span>];</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m &lt; t) <span class="built_in">memcpy</span>(tmp1, t1, <span class="keyword">sizeof</span>(t1)), <span class="built_in">memcpy</span>(tmp2, t2, <span class="keyword">sizeof</span>(t2));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">0</span>];</span><br><span class="line">            ans += qu(l, m, s, t);</span><br><span class="line">            <span class="keyword">if</span>(m &lt; t) <span class="built_in">memcpy</span>(t1, tmp1, <span class="keyword">sizeof</span>(tmp1)), <span class="built_in">memcpy</span>(t2, tmp2, <span class="keyword">sizeof</span>(tmp2));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(m &lt; t)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">1</span>];</span><br><span class="line">            ans += qu(m + <span class="number">1</span>, r, s, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, vX[CN], vY[CN], X[CN], Y[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(vX + <span class="number">1</span>, vX + vX[<span class="number">0</span>] + <span class="number">1</span>, x) - vX;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idy</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(vY + <span class="number">1</span>, vY + vY[<span class="number">0</span>] + <span class="number">1</span>, x) - vY;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QU</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> a, b, c, d;&#125; q[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vX[i] = X[i] = read() + <span class="number">1</span>, vY[i] = Y[i] = read() + <span class="number">1</span>; vX[<span class="number">0</span>] = vY[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) vX[ ++vX[<span class="number">0</span>] ] = q[i].a = read() + <span class="number">1</span>, vY[ ++vY[<span class="number">0</span>] ] = q[i].b = read() + <span class="number">1</span>, vX[ ++vX[<span class="number">0</span>] ] = q[i].c = read() + <span class="number">1</span>, vY[ ++vY[<span class="number">0</span>] ] = q[i].d = read() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sort(vX + <span class="number">1</span>, vX + vX[<span class="number">0</span>] + <span class="number">1</span>), sort(vY + <span class="number">1</span>, vY + vY[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= vX[<span class="number">0</span>]; i++) <span class="keyword">if</span>(vX[i] ^ vX[i - <span class="number">1</span>]) vX[++tmp] = vX[i]; vX[<span class="number">0</span>] = tmp;</span><br><span class="line">    tmp = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= vY[<span class="number">0</span>]; i++) <span class="keyword">if</span>(vY[i] ^ vY[i - <span class="number">1</span>]) vY[++tmp] = vY[i]; vY[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    D.n = vY[<span class="number">0</span>], D.m = vX[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.md( idx( X[i] ), idy( Y[i] ), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = q[i].a, b = q[i].b, c = q[i].c, d = q[i].d;</span><br><span class="line">        D.pqu(idx(a) - <span class="number">1</span>, idx(c)), <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.qu(<span class="number">1</span>, D.n, idy(b), idy(d))), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-clock mr-2"></i>最近更新：2020-8-26 添加了二维数点的内容。</div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，主席树即可持久化值域线段树， 用于解决区间 $k$ 小值问题以及动态二维数点问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://big-news.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="https://big-news.cn/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="可持久化" scheme="https://big-news.cn/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>后缀树</title>
    <link href="https://big-news.cn/2020/08/16/%E5%90%8E%E7%BC%80%E6%A0%91/"/>
    <id>https://big-news.cn/2020/08/16/%E5%90%8E%E7%BC%80%E6%A0%91/</id>
    <published>2020-08-16T08:03:00.000Z</published>
    <updated>2020-08-16T12:08:29.441Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知：后缀树是不对劲的 Tire 树….</p><a id="more"></a><p>后缀树即是路径压缩之后的后缀 Trie ，满足其中的 <strong>一些节点</strong> 可以双射原串的所有后缀。<br>其分为 <strong>显示构造</strong> 与 <strong>隐式构造</strong> 两种，区别在于是否在字符串尾添加一个终止符。其中，显示构造的后缀树满足每个叶子双射原串的一个后缀。</p><p>众所周知，SAM 的 Parent 树是反串的后缀树，从而可以通过将字符串倒着插入 SAM 来得到一个串的后缀树。注意，这样得到的后缀树是隐式构造的。</p><p>后缀树为我们提供了一个新的思路：两个字符串的 LCP 是它们在 Trie 上的 LCA ，则两个后缀的 LCP 也是它们在后缀树上的 LCA。这可以被形式化地表达如下：</p><p>$$ \text{LCP}(s[i:n], s[j:n]) = \text{len}[ \text{LCA}(i, j) ] $$</p><p>其中等号后面的 $i, j$ 应当对应为在树上的编号，$\text{len}[]$ 即为 SAM 中的 <code>len[]</code> 数组。</p><p>给出一份查询两个后缀的 LCP 的代码。显然，该份代码也可以通过 SA 实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> len[CN &lt;&lt; <span class="number">1</span>], nxt[CN &lt;&lt; <span class="number">1</span>], son[CN &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], lst, idx; </span><br><span class="line">    SAM() &#123;nxt[<span class="number">0</span>] = <span class="number">-1</span>, idx = lst = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">et</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = ++idx, p = lst;</span><br><span class="line">        len[u] = len[p] + <span class="number">1</span>, lst = u;</span><br><span class="line">        <span class="keyword">while</span>(p ^ <span class="number">-1</span> &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">-1</span>) <span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">int</span> d = son[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[d] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> nxt[u] = d, idx;</span><br><span class="line">        <span class="keyword">int</span> v = ++idx;</span><br><span class="line">        nxt[v] = nxt[d], nxt[d] = nxt[u] = v, len[v] = len[p] + <span class="number">1</span>, <span class="built_in">memcpy</span>(son[v], son[d], <span class="keyword">sizeof</span>(son[d]));</span><br><span class="line">        <span class="keyword">while</span>(p ^ <span class="number">-1</span> &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p];</span><br><span class="line">        <span class="keyword">return</span> idx - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, id[CN]; <span class="keyword">char</span> ch[CN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; to[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D.idx; i++) to[ D.nxt[i] ].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[CN][<span class="number">30</span>], dep[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>; <span class="keyword">int</span> sz = to[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v) &#123;<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][<span class="number">0</span>];&#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch; n = <span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i + <span class="number">1</span>; i--) id[i + <span class="number">1</span>] = D.et( ch[i] - <span class="string">'a'</span> );</span><br><span class="line"></span><br><span class="line">    rbd(), dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D.idx; i++)</span><br><span class="line">            fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = read(), j = read(), l = lca( id[i], id[j] );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.len[l]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知：后缀树是不对劲的 Tire 树….&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="后缀树" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>组合数学再基础</title>
    <link href="https://big-news.cn/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/"/>
    <id>https://big-news.cn/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-07T06:00:00.000Z</published>
    <updated>2020-08-26T08:43:10.720Z</updated>
    
    <content type="html"><![CDATA[<p>之前好像写过「组合数学基础」，在这里再来堆点柿子。</p><a id="more"></a><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-asia mr-2"></i>此页面存在相关页面。关于组合数学基础，请参见<a href="/2019/07/26/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">「组合数学基础」</a>。</div></article><h3 id="1-Stirling-数"><a href="#1-Stirling-数" class="headerlink" title="1 Stirling 数"></a>1 Stirling 数</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>众所周知，Stirling 数有两类，分别是：</p><p>$$ \begin{align} \begin{bmatrix}n\newline m \end{bmatrix} = \begin{bmatrix}n-1\newline m-1 \end{bmatrix}+(n-1)\begin{bmatrix}n-1\newline m \end{bmatrix}  \newline  \begin{Bmatrix}n\newline m \end{Bmatrix}=\begin{Bmatrix}n-1\newline m-1\end{Bmatrix}+m \begin{Bmatrix}n-1\newline m \end{Bmatrix} \end{align} \tag1 $$</p><p>接下来介绍 Stirling 数的性质。</p><h4 id="1-2-常幂展开"><a href="#1-2-常幂展开" class="headerlink" title="1.2 常幂展开"></a>1.2 常幂展开</h4><p>一个组合意义显然的柿子：</p><p>$$ \begin{align} n^m &amp;= \sum\limits_{k=0}^m  \begin{Bmatrix}m\newline k \end{Bmatrix}k! \dbinom{n}{k} \tag2 \newline &amp;= \sum\limits_{k=0}^m  \begin{Bmatrix}m\newline k\end{Bmatrix} n^{\underline{k}} \tag{3} \end{align} $$</p><p>$(3)$ 式通常被称为 <strong>常幂展开</strong>。</p><h4 id="1-3-Stirling-反演"><a href="#1-3-Stirling-反演" class="headerlink" title="1.3 Stirling 反演"></a>1.3 Stirling 反演</h4><p>$$ f(n) = \sum\limits_{k=0}^n \begin{Bmatrix}n\newline k\end{Bmatrix} g(k) \Leftrightarrow g(n) = \sum\limits_{k=0}^n (-1)^{n - k} \begin{bmatrix}n\newline k\end{bmatrix} f(k)  \tag{4} $$</p><p>$(4)$ 式通常被称为 <strong>Stirling 反演公式</strong>。</p><h4 id="1-4-阶乘幂展开"><a href="#1-4-阶乘幂展开" class="headerlink" title="1.4 阶乘幂展开"></a>1.4 阶乘幂展开</h4><p>对 $(3)$ 应用 $(4)$ 式得：</p><p>$$ n^{\underline{m}}= \sum\limits_{k=0}^m (-1)^{m-k} \begin{bmatrix}m\newline k\end{bmatrix} n^k \tag{5} $$</p><p>可以证明有：</p><p>$$ n^{\overline{m}}= \sum\limits_{k=0}^m \begin{bmatrix}m\newline k\end{bmatrix} n^k \tag{6} $$</p><p>$(5),(6)$ 两式被称作 <strong>阶乘幂展开</strong>。</p><h3 id="2-组合数"><a href="#2-组合数" class="headerlink" title="2 组合数"></a>2 组合数</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>众所周知，小葱同学擅长计算，尤其擅长计算组合数，但是这跟本文的主题并没有什么关系。</div></article><p>小葱同学擅长计算的组合数定义为：</p><p>$$\dbinom{n}{m} = \dbinom{n-1}{m} + \dbinom{n-1}{m-1}$$</p><h4 id="2-2-二项式定理"><a href="#2-2-二项式定理" class="headerlink" title="2.2 二项式定理"></a>2.2 二项式定理</h4><p>$$(x+y)^k = \sum\limits_{i=0}^k \dbinom{k}{i} x^i y^{k-i} \tag{7}$$</p><p>$(7)$ 式被称作 <strong>二项式定理</strong>。</p><h4 id="2-3-组合恒等式"><a href="#2-3-组合恒等式" class="headerlink" title="2.3 组合恒等式"></a>2.3 组合恒等式</h4><ul><li>组合恒等式 I</li></ul><p>在 $(7)$ 式中令 $x=y=1$ ，得：</p><p>$$\sum\limits_{i=0}^k \dbinom{k}{i} = 2^k \tag{8}$$</p><ul><li>组合恒等式 II</li></ul><p>$$\sum\limits_{i=0}^k \dbinom{k}{i}[2|i] =\sum\limits_{i=0}^k \dbinom{k}{i}[2\nmid i] = 2^{k-1} \tag9$$</p><p>证明显然。</p><ul><li>组合恒等式  III</li></ul><p>$$\dbinom{n}{k}\dbinom{k}{j} = \dbinom{n}{j} \dbinom{n-j}{k-j} \tag{10}$$</p><p>证明显然。</p><ul><li>组合恒等式 IV</li></ul><p>$$\begin{align} \sum\limits_{i=m}^n \dbinom{i}{m} &amp;= \dbinom{n+1}{m+1} \tag{11} \newline<br>\sum\limits_{i=0}^n \dbinom{m+i}{m} &amp;= \dbinom{n+m+1}{n} \tag{12} \end{align}$$</p><p>证明显然。</p><ul><li>组合恒等式 V</li></ul><p>$$ \dbinom{n+m}{k}= \sum\limits_{i=0}^k \dbinom{n}{i}\dbinom{m}{k-i} \tag{13}$$</p><p>证明显然。</p><p>$(8),(9),(10),(11),(12),(13)$ 式通常被称作 <strong>组合恒等式</strong>。</p><h4 id="2-4-二项式反演"><a href="#2-4-二项式反演" class="headerlink" title="2.4 二项式反演"></a>2.4 二项式反演</h4><ul><li>形式  I</li></ul><p>$$ f(n) = \sum\limits_{k=0}^n (-1)^k\dbinom{n}{k} g(k) \Leftrightarrow g(n) = \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k} f(k)  \tag{14} $$</p><ul><li>形式  II</li></ul><p>$$ f(n) = \sum\limits_{k=0}^n\dbinom{n}{k} g(k) \Leftrightarrow g(n) = \sum\limits_{k=0}^n (-1)^{n-k} \dbinom{n}{k} f(k)  \tag{15} $$</p><ul><li>形式  III</li></ul><p>$$ f(n) = \sum\limits_{k=n}^m\dbinom{k}{n} g(k) \Leftrightarrow g(n) = \sum\limits_{k=n}^m (-1)^{k-n} \dbinom{k}{n} f(k)  \tag{16} $$</p><p>$(14),(15),(16)$ 式被称作 <strong>二项式反演公式</strong>。</p><h4 id="2-5-第二类-Stirling-数通项"><a href="#2-5-第二类-Stirling-数通项" class="headerlink" title="2.5 第二类 Stirling 数通项"></a>2.5 第二类 Stirling 数通项</h4><p>对 $(2)$ 式应用 $(15)$ 式得：</p><p>$$ \begin{Bmatrix}n\newline m \end{Bmatrix}m! = \sum\limits_{k=0}^m  (-1)^k \dbinom{m}{k} (m-k)^n \tag{17} $$</p><p>其中 $(17)$ 式被称为 <strong>第二类 Stirling 数通项公式</strong>。</p><h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3 应用"></a>3 应用</h3><p><a href="https://darkbzoj.tk/problem/2839">「bzoj2839」集合计数</a><br><a href="https://darkbzoj.tk/problem/3622">「bzoj3622」已经没有什么好害怕的了</a><br><a href="https://codeforces.com/problemset/problem/932/E">「CF932E」 Team Work</a><br><a href="https://vjudge.net/problem/TopCoder-13444">「2018 雅礼集训」方阵</a><br><a href="https://loj.ac/problem/2058">「TJOI / HEOI2016」求和</a><br><a href="https://loj.ac/problem/6716">「LOJ #6716.」 自然数幂之和</a><br><a href="https://loj.ac/problem/3300">「2020联考A卷」组合数问题</a><br>「各种数数题」…</p><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-clock mr-2"></i>最近更新： 2020.8.9</div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前好像写过「组合数学基础」，在这里再来堆点柿子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://big-news.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>「题解」Typewriter</title>
    <link href="https://big-news.cn/2020/08/06/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DTypewriter/"/>
    <id>https://big-news.cn/2020/08/06/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DTypewriter/</id>
    <published>2020-08-06T14:30:00.000Z</published>
    <updated>2020-08-17T07:56:40.554Z</updated>
    
    <content type="html"><![CDATA[<p>一道很好的SAM+DP综合题，虽然说坑点也很多……</p><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6583">原题链接</a></p><p>考虑DP。设 $f[i]$ 为考虑前 $i$ 个位置的答案，应当有转移 $f[i] = \min f[i - 1] + p, f[l]+q$ ，其中 $l$ 满足 $s[l+1:r]\subseteq s[1:l]$ 。$f[]$ 显然是不降的，那么我们应取最小的 $l$ 。</p><p>考虑 $r\to r + 1$ ，容易发现 $l$ 是不降的；那么对 $s[1:l]$ 建立SAM，每次尝试扩展 $s[r+1]$，如果不行则令 $l\to l + 1$，即可找到最小的 $l$。维护当前的 $s[l+1:r]$ 对应在SAM上的路径，则可 O(1) 做到删除该路径上的第一个字符 $s[l+1]$ ，然后再扩展出$s[r+1]$即可。</p><p>小细节：当SAM在<code>extend()</code>的时候，若该路径的终点 $d$ 被拆成了 $v,d’$ 两个节点，且$\text{nxt}[d’]=v$，则应当将路径的终点变换为 $v$，否则维护的路径就被破坏了。<br>HDU不给数据，然后上面那个坑点卡了我一晚上…</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, prv[CN]; <span class="keyword">long</span> <span class="keyword">long</span> p, q, f[CN]; <span class="keyword">char</span> s[CN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> nxt[CN &lt;&lt; <span class="number">1</span>], son[CN &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], len[CN &lt;&lt; <span class="number">1</span>], sz, lst, cur, l;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (n &lt;&lt; <span class="number">1</span>);i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++) son[i][j] = <span class="number">0</span>; <span class="comment">// 题目卡memset()</span></span><br><span class="line">        sz = <span class="number">1</span>, lst = cur = l = len[<span class="number">0</span>] = <span class="number">0</span>, nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">et</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = sz++, p = lst;</span><br><span class="line">        lst = u, len[u] = len[p] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">-1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(nxt[u] = <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> d = son[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[d] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(nxt[u] = d);</span><br><span class="line">        <span class="keyword">int</span> v = sz++; </span><br><span class="line">        <span class="keyword">if</span>(d == cur) cur = v; <span class="comment">// 坑点</span></span><br><span class="line">        len[v] = len[p] + <span class="number">1</span>, nxt[v] = nxt[d], nxt[d] = nxt[u] = v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) son[v][i] = son[d][i];</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;<span class="keyword">if</span>(nxt[cur] != <span class="number">-1</span> &amp;&amp; --l == len[ nxt[cur] ]) cur = nxt[cur];&#125;   <span class="comment">// delete</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">rd</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;<span class="keyword">return</span> son[cur][c] ? cur = son[cur][c], l++, <span class="literal">true</span> : <span class="literal">false</span>;&#125; <span class="comment">// read</span></span><br><span class="line">&#125;D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">// freopen("wa.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>))&#123;</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;p, &amp;q), D.init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>; D.et(s[<span class="number">1</span>] - <span class="string">'a'</span>), prv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!D.rd(s[i] - <span class="string">'a'</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(l + <span class="number">1</span> == i) &#123;flag = <span class="literal">false</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">                D.del(), D.et(s[++l] - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            prv[i] = flag ? l : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!flag) D.et(s[++l] - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">1</span>] = p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">if</span>(prv[i]) f[i] = min(f[i - <span class="number">1</span>] + p, f[ prv[i] ] + q);</span><br><span class="line">            <span class="keyword">else</span> f[i] = f[i - <span class="number">1</span>] + p;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道很好的SAM+DP综合题，虽然说坑点也很多……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="后缀自动机" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>「题解」AC自动机（简单版）</title>
    <link href="https://big-news.cn/2020/08/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DAC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/"/>
    <id>https://big-news.cn/2020/08/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DAC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/</id>
    <published>2020-08-04T07:01:00.000Z</published>
    <updated>2020-08-17T07:56:40.555Z</updated>
    
    <content type="html"><![CDATA[<p>虽然说这题是AC自动机吧…但是后缀数组也能解。<br>在这里提供一个清新的后缀数组解法。</p><a id="more"></a><h3 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h3><p>后缀数组是个好东西啊，通过这个工具可以解决许多类型的字符串问题，这里简单介绍一下：</p><p>形式化地，对于一个长度为 $n$ 的字符串 $s$，它的形如 $s[i:n]$ 的子串被称作 $s$ 的后缀。</p><p>容易发现 $s$ 一共有 $n$ 个后缀，不妨记 $s[i:n]$ 为后缀 $i$，将所有的后缀排序后，顺序写下后缀的编号，就得到了后缀数组 (Suffix Array)。</p><p>举个例子，对 $s=ababa$，其后缀有 $a,ba,aba,baba,ababa$，排序后得到 $a,aba,ababa,ba,baba$，依次写下其编号，得到后缀数组为 $5,3,1,2,4$。</p><p>朴素求后缀数组是 $O(n^2 \log n)$ 的，这显然是不太好的。通过倍增法去求，容易发现倍增的过程是某种双关键字排序，那么对其进行基数排序，可做到 $O(n \log n)$。具体的实现超出了本篇题解的范畴，请移步 <a href="https://www.luogu.com.cn/problem/P3809">后缀排序</a>。</p><h3 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h3><p>容易发现，一个串 $s$ 若能与 $t$ 匹配，那么它必然是 $t$ 的 <strong>某个后缀的前缀</strong>。<br>我们可以快速把所有后缀都排序，这样后缀就是有序的了，可以通过二分来找 $s$ 是否与 $t$ 匹配。</p><p>具体实现上，因为后缀的长度和是 $O(n^2)$ 级别的，所以不能把他们全部搞出来（会MLE）。实际上只需要写一个 <code>cmp()</code> 函数来比较字符串大小就好了，实现起来比较清新易懂。</p><p>复杂度因为每次要二分，所以整体多了一个 $\log$，不过均摊下来跑的非常快，常数比AC自动机大了不到一半。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fake-acam.cpp */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> t[CN], s[CN];</span><br><span class="line"><span class="built_in">string</span> mem[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sa[CN], rk[CN &lt;&lt; <span class="number">1</span>], prk[CN &lt;&lt; <span class="number">1</span>], id[CN], px[CN], cnt[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = max(n, <span class="number">300</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) rk[i] = t[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cnt[ rk[i] ] ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[ cnt[ rk[i] ]-- ] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt; n; w &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = sa[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] + w ] ]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = sa[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] ] ]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i];</span><br><span class="line">        <span class="built_in">memcpy</span>(prk, rk, <span class="keyword">sizeof</span>(rk)); m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">if</span>(prk[ sa[i] ] == prk[ sa[i - <span class="number">1</span>] ] &amp;&amp; prk[ sa[i] + w ] == prk[ sa[i - <span class="number">1</span>] + w ])</span><br><span class="line">                rk[ sa[i] ] = m;</span><br><span class="line">            <span class="keyword">else</span> rk[ sa[i] ] = ++m;</span><br><span class="line">        <span class="keyword">if</span>(m == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, lt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 a[] &lt; b[]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">le</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b, <span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[p] == b[p] &amp;&amp; p &lt; min(la, lb)) p++;</span><br><span class="line">    <span class="keyword">if</span>(p == lb) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == la) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> a[p] &lt; b[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("_in.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen("out.txt", "w", stdout);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; mem[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t; lt = <span class="built_in">strlen</span>(t);</span><br><span class="line"></span><br><span class="line">    SA(lt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = mem[i].size();</span><br><span class="line">        s[ls] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; ls;j++) s[j] = mem[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = lt, m; <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> leq = le(t + sa[m] - <span class="number">1</span>, s, lt - sa[m] + <span class="number">1</span>,ls);</span><br><span class="line">            <span class="keyword">if</span>(leq == <span class="number">-1</span>) &#123;found = <span class="literal">true</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(leq) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt += found ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然说这题是AC自动机吧…但是后缀数组也能解。&lt;br&gt;在这里提供一个清新的后缀数组解法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀数组" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「题解」Unusual Sequences</title>
    <link href="https://big-news.cn/2020/07/08/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DUnusual%20Sequences/"/>
    <id>https://big-news.cn/2020/07/08/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DUnusual%20Sequences/</id>
    <published>2020-07-08T14:36:00.000Z</published>
    <updated>2020-08-17T07:56:40.554Z</updated>
    
    <content type="html"><![CDATA[<p>题意：输入 $x,y$，求有多少个数列满足其gcd为 $x$，和为 $y$。<br>这里提供一个不使用反演的清奇思路……</p><a id="more"></a><p>设 $f(s,g)$ 表示和为 $s$ ,gcd为 $g$ 的数列的数量，容易发现以下性质：</p><p>$$\begin{aligned} f(s,g)&amp;=0, \text{ }g\nmid s  \newline f(s,g)&amp;=f(s/g,1), \text{ } g|s \end{aligned}$$</p><p>我们知道和为 $s$ 的数列应当有 $2^{s - 1}$ 个，即把 $s$ 看成 $s$ 个1，然后插上 $s - 1$ 个隔板。那么有：</p><p>$$\begin{aligned} 2^{s - 1} &amp;= \sum\limits_{g=1}^s f(s,g)<br>\newline &amp;=\sum\limits_{g | s}f(s,g)<br>\newline &amp;=\sum\limits_{g | s}f(s/g,1)<br>\end{aligned}$$</p><p>移一下项，得到：<br>$$ f(s,1)=2^{s - 1}-\sum\limits_{g|s,g&gt;1}f(s / g,1) $$</p><p>设 $f[s]$ 表示 $f(s, 1)$ ，得到递推方程：<br>$$ f[s] =  2^{s - 1}-\sum\limits_{g|s,g&gt;1}f[s/g]$$</p><p>直接做是 $O(n)$ 的，但是容易知道有些位置的值是用不到的。开一个 <code>map</code> 储存 $f[]$ 数组，大力递推计算，参考杜教筛的复杂度，大约是 $O(n^{\frac{3}{4}})$，但是实际上跑得出奇的快。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = (<span class="number">1l</span>l * a * r) % P;</span><br><span class="line">        a = (<span class="number">1l</span>l * a * a) % P; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(f.count(s)) <span class="keyword">return</span> f[s];</span><br><span class="line">    <span class="keyword">int</span> r = qp(<span class="number">2</span>, s - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> g = <span class="number">2</span>;g * g &lt;= s;g++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s % g) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(g * g == s) r = (r - dfs(g) + P) % P;</span><br><span class="line">        <span class="keyword">else</span> r = ((r - dfs(s / g) - dfs(g)) % P + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s] = (r - <span class="number">1</span> + P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("_in.in", "r", stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span>(y % x) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, dfs(y / x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：输入 $x,y$，求有多少个数列满足其gcd为 $x$，和为 $y$。&lt;br&gt;这里提供一个不使用反演的清奇思路……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>Splay</title>
    <link href="https://big-news.cn/2020/06/26/Splay/"/>
    <id>https://big-news.cn/2020/06/26/Splay/</id>
    <published>2020-06-26T08:39:00.000Z</published>
    <updated>2020-08-26T08:43:10.720Z</updated>
    
    <content type="html"><![CDATA[<p>没有摘要可以提供，因为摘要还在<code>rotate</code>……</p><a id="more"></a><p><a href="https://cd.big-news.cn/index.php?user/publicLink&fid=a8091gCayaFIqHmMorCoWJ8ePzc45SkS5IwJdDvzTuKV6lVwKgBhuRcVfd6-gkeff4QmNAb0YEMSd6YKgpgrIHFSNci_txkRWPjiYEFU0httgmeWELTdCK83FleK7RmRlOsrQp8mb05hm_v7o-BL5Q&file_name=/Splay%20-%20OI%20Wiki.pdf">Splay - OI Wiki.pdf</a><br><a href="https://www.luogu.com.cn/problem/P3369">LGp3316 普通平衡树</a></p><p>模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> ch[CN][<span class="number">2</span>],fa[CN],val[CN],sz[CN],cnt[CN],tot,rt;</span><br><span class="line">    Splay() &#123;<span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span>(ch)); <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)); tot = rt = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">return</span> u == ch[ fa[u] ][<span class="number">1</span>];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;sz[u] = sz[lc] + sz[rc] + cnt[u];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;lc = rc = sz[u] = val[u] = fa[u] = cnt[u] = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">int</span> u = ++tot; sz[u] = cnt[u] = <span class="number">1</span>, val[u] = k, fa[u] = f; <span class="keyword">if</span>(f) ch[f][val[f] &lt; k] = u;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = fa[u], gf = fa[ fa[u] ], chk = get(u);</span><br><span class="line">        ch[f][chk] = ch[u][chk ^ <span class="number">1</span>], fa[ ch[u][chk ^ <span class="number">1</span>] ] = f;</span><br><span class="line">        ch[u][chk ^ <span class="number">1</span>] = f, fa[f] = u;</span><br><span class="line">        fa[u] = gf; <span class="keyword">if</span>(gf) ch[gf][f == ch[gf][<span class="number">1</span>]] = u;</span><br><span class="line">        maintain(f), maintain(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> f = fa[u]; f = fa[u]; rotate(u)) <span class="keyword">if</span>(fa[f]) rotate(get(f) == get(u) ? f : u);</span><br><span class="line">        rt = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _ins(<span class="keyword">int</span> u,<span class="keyword">int</span> f,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) &#123;make(f, k); rt = tot; maintain(f); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(val[u] == k) &#123;cnt[rt = u]++,sz[u]++; maintain(f); <span class="keyword">return</span>;&#125;</span><br><span class="line">        _ins(val[u] &gt; k ? lc : rc, u, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;_ins(rt, <span class="number">0</span>, k); splay(rt);&#125;</span><br><span class="line">    <span class="comment">// //</span></span><br><span class="line">    <span class="keyword">int</span> _rank(<span class="keyword">int</span> u,<span class="keyword">int</span> k) &#123;<span class="keyword">return</span> val[u] == k ? rt = u, sz[lc] + <span class="number">1</span> : (val[u] &gt; k ? _rank(lc, k) : sz[lc] + cnt[u] + _rank(rc, k));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">int</span> r = _rank(rt, k); splay(rt); <span class="keyword">return</span> r;&#125;</span><br><span class="line">    <span class="comment">// //</span></span><br><span class="line">    <span class="keyword">int</span> _kth(<span class="keyword">int</span> u,<span class="keyword">int</span> k) &#123;<span class="keyword">return</span> sz[lc] &gt;= k ? _kth(lc, k) : (sz[lc] + cnt[u] &gt;= k ? val[rt = u] : _kth(rc, k - sz[lc] - cnt[u]));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">int</span> r = _kth(rt, k); splay(rt); <span class="keyword">return</span> r;&#125;</span><br><span class="line">    <span class="comment">// //</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> u = ch[rt][<span class="number">0</span>]; <span class="keyword">while</span>(rc) u = rc; <span class="keyword">return</span> u;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nxt</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> u = ch[rt][<span class="number">1</span>]; <span class="keyword">while</span>(lc) u = lc; <span class="keyword">return</span> u;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        rank(k); <span class="keyword">int</span> u = rt;</span><br><span class="line">        <span class="keyword">if</span>(cnt[u] &gt; <span class="number">1</span>) &#123;sz[u]--,cnt[u]--; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!lc &amp;&amp; !rc) &#123;rt = <span class="number">0</span>, clear(u); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!lc) &#123;rt = rc, fa[rc] = <span class="number">0</span>; clear(u); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!rc) &#123;rt = lc, fa[lc] = <span class="number">0</span>; clear(u); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> x = pre(); splay(x);</span><br><span class="line">        ch[x][<span class="number">1</span>] = rc,fa[rc] = x; clear(u); maintain(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> tp = read(),x = read();</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">1</span>) t.ins(x);</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">2</span>) t.del(x);</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, t.rank(x));</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, t.kth(x));</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">5</span>) t.ins(x), <span class="built_in">printf</span>(<span class="string">"%d"</span>, t.val[ t.pre() ]), t.del(x);</span><br><span class="line">        <span class="keyword">if</span>(tp == <span class="number">6</span>) t.ins(x), <span class="built_in">printf</span>(<span class="string">"%d"</span>, t.val[ t.nxt() ]), t.del(x);</span><br><span class="line">        <span class="keyword">if</span>(tp &gt; <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-clock mr-2"></i>最近更新： 2020.6.26</div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有摘要可以提供，因为摘要还在&lt;code&gt;rotate&lt;/code&gt;……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://big-news.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="平衡树" scheme="https://big-news.cn/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「题解」旧试题</title>
    <link href="https://big-news.cn/2020/06/19/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%97%A7%E8%AF%95%E9%A2%98/"/>
    <id>https://big-news.cn/2020/06/19/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%97%A7%E8%AF%95%E9%A2%98/</id>
    <published>2020-06-19T12:22:00.000Z</published>
    <updated>2020-08-17T07:56:40.554Z</updated>
    
    <content type="html"><![CDATA[<p>来自神仙 <code>11Dimensions</code> 的神仙做法……</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://www.luogu.com.cn/record/list?pid=P4619">原题链接</a></p></blockquote><p>求：<br>$$ \sum\limits_{i=1}^A \sum\limits_{j=1}^B \sum\limits_{k=1}^C d(ijk) $$<br>其中 $A,B,C ⩽ 200005$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>记$x⊥y$表示$(x,y)=1$。<br>结论：</p><p>$$d(ijk)=\sum\limits_{x|i}\sum\limits_{y|i}\sum\limits_{z|i}[x⊥y][x⊥z][y⊥z]$$</p><p>其中<code>[]</code>表示艾弗森括号，当且仅当括号内命题为真时取值为1，否则为0。<br>在本篇题解中，这个括号的意义等价于单位函数，即$\epsilon((a,b))=[(a,b)=1]=[a⊥b]$。<br>那么：</p><p>$$\begin{aligned}&amp; \sum\limits_{i=1}^A \sum\limits_{j=1}^B \sum\limits_{k=1}^C d(xyz) \newline<br>=&amp; \sum\limits_{i=1}^A \sum\limits_{j=1}^B\sum\limits_{k=1}^C\sum\limits_{x|i}\sum\limits_{y|i}\sum\limits_{z|i}[x⊥y][x⊥z][y⊥z] \newline<br>=&amp; \sum\limits_{x=1}^A \sum\limits_{y=1}^B \sum\limits_{z=1}^C[x⊥y][x⊥z][y⊥z] \lfloor\frac{A}{x}\rfloor \lfloor\frac{B}{y}\rfloor \lfloor\frac{C}{z}\rfloor \end{aligned}$$</p><p>从三个单位函数里面任选一个反演，利用$\epsilon=\mu*1$：</p><p>$$\begin{aligned}&amp; \sum\limits_{x=1}^A \sum\limits_{y=1}^B \sum\limits_{z=1}^C[x⊥y][x⊥z][y⊥z] \lfloor\frac{A}{x}\rfloor \lfloor\frac{B}{y}\rfloor \lfloor\frac{C}{z}\rfloor \newline<br>=&amp; \sum\limits_{x=1}^A \sum\limits_{y=1}^B \sum\limits_{z=1}^C (\sum\limits_{d|x,d|y}\mu(d)) [x⊥z][y⊥z] \lfloor\frac{A}{x}\rfloor \lfloor\frac{B}{y}\rfloor \lfloor\frac{C}{z}\rfloor \newline<br>=&amp; \sum\limits_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum\limits_{d=1}^{\min(A,B)}\mu(d)\sum\limits_{k_1=1}^{\lfloor\frac{A}{d}\rfloor}\sum\limits_{k_2=1}^{\lfloor\frac{B}{d}\rfloor}[k_1d⊥z][k_2d⊥z]<br>\lfloor\frac{A}{k_1d}\rfloor \lfloor\frac{B}{k_2d}\rfloor\end{aligned}$$</p><p>依据$[ab⊥c]\iff[a⊥c][b⊥c]$，整理得到：</p><p>$$\sum\limits_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum\limits_{d=1}^{\min(A,B)}\mu(d)[d⊥z]<br>(\sum\limits_{x=1}^{\lfloor\frac{A}{d}\rfloor}[x⊥z]\lfloor\frac{A}{xd}\rfloor)<br>(\sum\limits_{y=1}^{\lfloor\frac{B}{d}\rfloor}<br>[y⊥z] \lfloor\frac{B}{yd}\rfloor)$$</p><p>记：</p><p>$$\begin{aligned} g(n,x) = \sum\limits_{i=1}^n\mu(i)[i⊥x] \newline<br>f(n,x) = \sum\limits_{i=1}^n\lfloor\frac{n}{i}\rfloor[i⊥x] \end{aligned}$$</p><p>答案变成：</p><p>$$\begin{aligned}&amp; \sum\limits_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum\limits_{d=1}^{\min(A,B)}\mu(d)[d⊥z]f(\lfloor\frac{A}{d}\rfloor, z)f(\lfloor\frac{B}{d}\rfloor, z) \newline<br>=&amp; \sum\lfloor\frac{C}{z}\rfloor\sum(g(r,z) - g(l - 1, z))f(\lfloor\frac{A}{d}\rfloor, z)f(\lfloor\frac{B}{d}\rfloor, z)\end{aligned}$$</p><p>即对$\mu()$做前缀和然后对后面的$f()$分段，其中$[l,r]$表示整除分段的一段区间。</p><p>假设$O(n)$枚举$z$，那么求出后面的$\sum$的值是$O(\sqrt{n})$的。但是发现$z$是变化的，当$z$变化时暴力维护$f(),g()$是$O(n^2)$的，这成为了代码复杂度的瓶颈。如何解决？<br>能不能减少更新$f(),g()$的次数？不难发现$z$在函数中发挥作用的地方是判断一个数与其互质。考虑将$z$质因数分解，容易看出一个数与其互质仅和$z$的质因子的种类有关，而与质因子的幂次无关。<br>记：</p><p>$$lw(z) = \prod\limits_{i=1}^np_i, \text{where }z = \prod\limits_{i=1}^np_i^{\alpha_i}$$</p><p>那么我们只需要考虑$z\in [1,C]$的所有$lw(z)$值即可（即所有无平方因子的数），它们共用一套$f(),g()$的函数值。<strong>通过dfs暴力生成无平方因子数，我们可以把它们一并更新。</strong></p><p>但是这远远不够，考虑通过递推来维护$f(),g()$。这个套路参考<a href="https://www.luogu.com.cn/problem/P1587">NOI2016 循环之美</a>。<br>考虑在$z$中删去其一个质因子$x$，即$f(n,z)\to f(n,z/x)$，将出现何种变化？应当有一部分多加了，要减去：</p><p>$$\begin{aligned}f(n,z) &amp;= \sum\limits_{i=1}^n\lfloor\frac{n}{i}\rfloor[i⊥z/x] -<br>\sum\limits_{i=1}^n\lfloor\frac{n}{i}\rfloor[i⊥z/x][x|i] \newline<br>&amp;= f(n, z / x) - \sum\limits_{k=1}^{\lfloor\frac{n}{x}\rfloor}[kx⊥z/x]\lfloor\frac{n}{kx}\rfloor \newline<br>&amp;= f(n, z / x) - [x⊥z/x]\sum\limits_{k=1}^{\lfloor\frac{n}{x}\rfloor}[k⊥z/x]\lfloor\frac{n}{kx}\rfloor\newline<br>&amp;= f(n, z / x) - f(\lfloor\frac{n}{x}\rfloor, z/x)\end{aligned}$$</p><p>对$g()$的推导也同理，利用$\mu(ab)=\mu(a)\mu(b)[a⊥b]$，可以得出：</p><p>$$\begin{aligned}g(n,z) &amp;= \sum\limits_{i=1}^n \mu(i) [i⊥z/x] -<br>\sum\limits_{i=1}^n \mu(i) [i⊥z/x][x|i] \newline<br>&amp;= g(n, z / x) - \sum\limits_{k=1}^{\lfloor\frac{n}{x}\rfloor}[kx⊥z/x] \mu(kx) \newline<br>&amp;= g(n, z / x) - \mu(x)\sum\limits_{k=1}^{\lfloor\frac{n}{x}\rfloor}\mu(k)[k⊥x][k⊥z/x] \newline<br>&amp;= g(n, z / x) + \sum\limits_{k=1}^{\lfloor\frac{n}{x}\rfloor}\mu(k)[k⊥x(z/x)] \newline<br>&amp;= g(n, z / x) + g(\lfloor\frac{n}{x}\rfloor, z)\end{aligned}$$</p><p>即：</p><p>$$\begin{aligned} g(n,z) = g(n, z / x) + g(\lfloor\frac{n}{x}\rfloor, z) \newline<br>f(n,z) = f(n, z / x) - f(\lfloor\frac{n}{x}\rfloor, z/x) \end{aligned}$$</p><p>那么就可以递推了，但是直接更新是$O(n)$的。容易发现整除分段并不会用到所用的$f(),g()$值，所以我们边做分段边更新就好了，这是$O(\sqrt{n})$的。<br>空间复杂度呢？<code>f[2e5][2e5],g[2e5][2e5]</code>看似存不下来，但是容易发现后面一维是不连续使用的，那么将其离散化，考虑在dfs构造无平方因子数的时候，下层状态的转移依赖于上层状态，而dfs树的深度是$O(\log_2n)$的，所以开<code>f[2e5][10]</code>即可。</p><p>总复杂度？粗略估计，爆搜的复杂度是$O(2^{\log_2n})$即$O(n)$的，后面的求和通过整除分段可以$O(\sqrt{n})$得出，那么总复杂度是$O(n\sqrt{n})$的。但实际上复杂度要小很多，也就是说如果常数写得好那么它可以跑的飞快（预处理整除分段的端点、cache-friendly之类的），但是本人代码常数没那么小，最慢一个点大约4s？<br>比三元环是好得多了。</p><p>Orz <code>11Dimensions</code></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    LL s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>; c = getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[CN],mu[CN],lw[CN]; LL d[CN]; <span class="keyword">bool</span> np[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    np[<span class="number">1</span>] = <span class="literal">true</span>; mu[<span class="number">1</span>] = <span class="number">1</span>, d[<span class="number">1</span>] = <span class="number">1</span>, lw[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) p[ ++p[<span class="number">0</span>] ] = i, d[i] = <span class="number">2</span>, lw[i] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= p[<span class="number">0</span>] &amp;&amp; i * p[j] &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i * p[j]; np[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j]) d[x] = d[i] &lt;&lt; <span class="number">1</span>, lw[x] = lw[i] * p[j], mu[x] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;d[x] = (d[i] &lt;&lt; <span class="number">1</span>) - d[i / p[j]], lw[x] = lw[i]; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) d[i] += d[i - <span class="number">1</span>],mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">int</span> t,A,B,C;</span><br><span class="line">LL f[CN][<span class="number">10</span>],g[CN][<span class="number">10</span>],s[CN],ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= A; l++)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = min(A / (A / l), B / (B / l));</span><br><span class="line">        g[r][<span class="number">1</span>] = mu[r]; f[A / l][<span class="number">1</span>] = d[A / l]; f[B / l][<span class="number">1</span>] = d[B / l];</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span> , <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>;z &lt;= C; z++) s[ lw[z] ] += <span class="number">1l</span>l * C / z;</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= A; l++)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = min(A / (A / l), B / (B / l));</span><br><span class="line">        g[r][k] = g[r][k - <span class="number">1</span>] + g[r / x][k];</span><br><span class="line">        f[A / l][k] = f[A / l][k - <span class="number">1</span>] - f[(A / l) / x][k - <span class="number">1</span>];</span><br><span class="line">        f[B / l][k] = f[B / l][k - <span class="number">1</span>] - f[(B / l) / x][k - <span class="number">1</span>];</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> z0, <span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    LL cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= A; l++)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = min(A / (A / l), B / (B / l));</span><br><span class="line">        cur += (g[r][k] - g[l - <span class="number">1</span>][k]) * f[A / l][k] * f[B / l][k];</span><br><span class="line">        cur = (cur % P + P) % P;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (s[z0] * cur) % P; ans %= P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = u; <span class="number">1l</span>l * p[v] * z0 &lt;= C; v++) upd(p[v], k + <span class="number">1</span>), dfs(z0 * p[v], v + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    t = read(); sieve(<span class="number">2e5</span>); </span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        A = read(), B = read(), C = read();</span><br><span class="line">        <span class="keyword">if</span>(A &gt; B) swap(A, B);</span><br><span class="line"></span><br><span class="line">        init(); dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自神仙 &lt;code&gt;11Dimensions&lt;/code&gt; 的神仙做法……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="https://big-news.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="筛法" scheme="https://big-news.cn/tags/%E7%AD%9B%E6%B3%95/"/>
    
      <category term="反演" scheme="https://big-news.cn/tags/%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>除夕闲扯</title>
    <link href="https://big-news.cn/2020/01/24/%E9%99%A4%E5%A4%95%E9%97%B2%E6%89%AF/"/>
    <id>https://big-news.cn/2020/01/24/%E9%99%A4%E5%A4%95%E9%97%B2%E6%89%AF/</id>
    <published>2020-01-23T22:47:00.000Z</published>
    <updated>2020-08-19T06:23:55.401Z</updated>
    
    <content type="html"><![CDATA[<article class="message message-immersive is-danger"><div class="message-body"><i class="fas fa-exclamation-triangle mr-2"></i>请人为忽略与主题有关的内容，这其实是一个目录。</div></article><a id="more"></a><p>文化课真好系列<br>为了证明 bn 还没入坟，他决定闲的没事瞎bb几句<br>起名做：A Simple Proof of BN’s Aliving</p><h2 id="A-Simple-Proof-of-BN’s-Aliving"><a href="#A-Simple-Proof-of-BN’s-Aliving" class="headerlink" title="A Simple Proof of BN’s Aliving"></a>A Simple Proof of BN’s Aliving</h2><h3 id="P1-Analyse-the-Problem"><a href="#P1-Analyse-the-Problem" class="headerlink" title="P1 Analyse the Problem"></a>P1 Analyse the Problem</h3><p>该命题<strong>显然</strong>不成立。</p><h3 id="P2-Conclusion"><a href="#P2-Conclusion" class="headerlink" title="P2 Conclusion"></a>P2 Conclusion</h3><p>bn 已经入坟，故证伪。</p><hr><p>因 bn 已经入坟，所以他对之前的 post 们搞了一个整理，以备 <del>后人之用</del> 自己欣赏。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-asia mr-2"></i>此页面存在相关页面。关于另一个集合贴，请参见<a href="/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/">「OI模板梳理」</a>。</div></article><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>最短路</p><ul><li>Dijkstra：<a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#1-1-Dijkstra">OI模板梳理 2.1.1</a></li><li>SPFA: <a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#1-3-Bellman-Ford-SPFA">OI模板梳理 2.1.3</a></li><li>Floyd: Floyd本质探究-<a href="https://big-news.cn/2019/03/24/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA/">「题解」灾后重建</a></li></ul><p>树</p><ul><li>最小生成树(MST)：<a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#2-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">OI模板梳理 2.2</a>，变形-<a href="https://big-news.cn/2019/11/09/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91%20Codeforces%20Round%20599%20(Div.%202)/#D-0-1-MST">CFR599D 0-1 MST</a></li><li><a href="https://big-news.cn/2019/06/26/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/">树的重心</a>，<a href="https://big-news.cn/2019/04/11/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/">树的直径</a></li><li>LCA: 倍增法-<a href="https://big-news.cn/2019/03/10/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">最近公共祖先</a>，树链剖分法-<a href="https://big-news.cn/2019/07/18/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/#1-%E7%82%B9%E5%AF%B9LCA">树链剖分 3.1</a></li><li>树上类RMQ问题：<a href="https://big-news.cn/2019/07/18/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/">树链剖分</a></li></ul><p>连通性</p><ul><li><a href="https://big-news.cn/2019/02/07/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/">强连通分量/SCC</a></li><li><a href="https://big-news.cn/2019/03/08/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/">双连通分量/BCC</a></li><li>割点和桥：<a href="https://big-news.cn/2019/03/08/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/#%E4%BA%8C-%E5%89%B2%E9%A1%B6">双连通分量 2</a></li><li>2-SAT：<a href="https://cd.big-news.cn/data/User/admin/home/%E6%96%87%E6%A1%A3/2019.10%20JN%20%E6%80%BB%E7%BB%93.pdf">2019.10 JN 总结.pdf</a></li></ul><p>网络</p><ul><li>最大流-最小割：<a href="https://big-news.cn/2019/02/23/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/">网络最大流</a></li><li><a href="https://big-news.cn/2019/03/19/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/">最小费用最大流</a></li></ul><p>二分图</p><ul><li>最大匹配：匈牙利算法-<a href="https://big-news.cn/2019/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/">二分图匹配</a>，费用流法-<a href="https://big-news.cn/2019/03/19/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/#1-%E6%9C%80%E5%A4%A7%E5%9F%BA%E6%95%B0%E5%8C%B9%E9%85%8D">最小费用最大流 4.1</a></li><li>最大点全覆盖集：<a href="https://big-news.cn/2019/03/19/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/#2-%E6%9C%80%E5%A4%A7%E5%B8%A6%E6%9D%83%E5%8C%B9%E9%85%8D">最小费用最大流 4.2</a></li><li>最大独立集：<a href="https://big-news.cn/2019/03/19/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/#3-%E6%9C%80%E5%A4%A7%E5%B8%A6%E6%9D%83%E7%8B%AC%E7%AB%8B%E9%9B%86">最小费用最大流 4.3</a></li></ul><p>欧拉图：<a href="https://big-news.cn/2019/02/26/%E6%AC%A7%E6%8B%89%E8%B7%AF/">欧拉路</a></p><p>拓扑：<a href="https://big-news.cn/2019/02/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">拓扑排序</a></p><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p><a href="https://big-news.cn/2019/08/16/%E7%BA%BF%E6%80%A7%E7%AD%9B/">线性筛</a></p><p>高斯消元：<a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#3-%E9%AB%98%E6%96%AF-%E7%BA%A6%E6%97%A6%E6%B6%88%E5%85%83">OI模板梳理 4.3</a></p><p>乘法逆元</p><ul><li>费马小定理法-<a href="https://big-news.cn/2019/07/18/%E9%80%86%E5%85%83/">逆元</a></li><li>exgcd法-<a href="https://big-news.cn/2019/07/22/%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/#%E4%BA%8C-%E6%B1%82%E8%A7%A3%E5%8D%95%E5%8F%98%E5%85%83%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B">模线性方程组与中国剩余定理 2</a></li><li>线性求逆元-<a href="https://big-news.cn/2019/07/18/%E9%80%86%E5%85%83/#3-%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%E6%B1%82%E9%80%86%E5%85%83">逆元 2.3</a>    </li></ul><p>欧几里得系列：<a href="https://big-news.cn/2019/05/19/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/">欧几里得与扩展欧几里得定理</a></p><p>中国剩余定理系列：<a href="https://big-news.cn/2019/07/22/%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/">模线性方程组与中国剩余定理</a></p><p>矩阵系列：<a href="https://big-news.cn/2019/07/30/%E7%9F%A9%E9%98%B5%E5%9F%BA%E7%A1%80/">矩阵基础</a></p><p>概论系列：<a href="https://big-news.cn/2019/05/26/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">概率与期望</a></p><p>组合学系列：<a href="https://big-news.cn/2019/07/26/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">组合数学基础</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>单调栈：<a href="https://www.luogu.com.cn/problem/P1823">音乐会的等待</a></p><p><a href="https://big-news.cn/2019/02/28/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">单调队列</a>，对DP的优化-<a href="https://big-news.cn/2019/08/04/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Watching%20Fireworks%20is%20Fun/">「题解」Watching Fireworks is Fun</a></p><p>堆：<a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#3-%E5%A0%86">OI模板梳理 1.3</a>，或pq一行完成</p><p>并查集：<a href="https://big-news.cn/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#4-%E5%B9%B6%E6%9F%A5%E9%9B%86">OI模板梳理 1.4</a></p><p><a href="https://big-news.cn/2019/01/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">树状数组</a></p><p><a href="https://big-news.cn/2019/01/30/%E7%BA%BF%E6%AE%B5%E6%A0%91/">线段树</a>，线段覆盖-<a href="https://big-news.cn/2019/07/17/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Atlantis/">「题解」Atlantis</a></p><p><a href="https://big-news.cn/2019/11/06/%E6%95%B0%E5%88%97%E5%B7%AE%E5%88%86/">数列差分</a></p><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p><a href="https://big-news.cn/2019/01/29/%E8%83%8C%E5%8C%85/">背包</a>，变式-<a href="https://big-news.cn/2019/10/23/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/">「题解」硬币购物</a></p><p><a href="https://big-news.cn/2019/02/01/%E6%A0%91%E4%B8%8A%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">树形DP</a>，变式-<a href="https://big-news.cn/2019/10/26/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%87%8D%E5%BB%BA%E9%81%93%E8%B7%AF/">「题解」重建道路</a></p><p><a href="https://big-news.cn/2019/02/18/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">状压DP</a></p><p>优化：单调队列优化-<a href="https://big-news.cn/2019/08/04/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Watching%20Fireworks%20is%20Fun/">「题解」Watching Fireworks is Fun</a>，矩阵乘法优化-<a href="https://big-news.cn/2019/08/01/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%91%86%E8%8A%B1/">「题解」摆花</a></p><p>其他DP内容，请参见<a href="https://big-news.cn/tags/DP/">标签：DP</a></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>字符串：KMP-<a href="https://big-news.cn/2019/07/27/KMP%E7%AE%97%E6%B3%95/">KMP算法</a></p><p>关于本博客的内容，顺便还有之前的<a href="https://big-news.cn/2019/08/12/hexo%E4%B8%BB%E9%A2%98Icarus%E6%B5%85%E5%BA%A6%E4%BF%AE%E6%94%B9%E6%95%99%E7%A8%8B/">Icarus魔改教程</a>，<del>教你一步步走向深渊。</del></p><p>顺便一说，bn 的 luogu 还没有掉蓝（珂怕）。</p><hr><p>以上</p><p>祝各位新春快乐<br>qwq.</p><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;article class=&quot;message message-immersive is-danger&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-exclamation-triangle mr-2&quot;&gt;&lt;/i&gt;
请人为忽略与主题有关的内容，这其实是一个目录。
&lt;/div&gt;
&lt;/article&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://big-news.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>CSP2019 退役记</title>
    <link href="https://big-news.cn/2019/11/16/CSP2019%20%E9%80%80%E5%BD%B9%E8%AE%B0/"/>
    <id>https://big-news.cn/2019/11/16/CSP2019%20%E9%80%80%E5%BD%B9%E8%AE%B0/</id>
    <published>2019-11-16T08:15:00.000Z</published>
    <updated>2020-08-09T01:36:49.457Z</updated>
    
    <content type="html"><![CDATA[<p>没有摘要可以提供，因为摘要自闭去了……</p><a id="more"></a><h2 id="d0"><a href="#d0" class="headerlink" title="d0"></a>d0</h2><p>14:00p.m.+ arrived.<br>然后颓了约 1h+ ，出去买了一瓶钟水回来切题。<br>考前想练练码力，于是去做<a href="https://www.luogu.org/problem/P3952">NOIP2017d1t2 时间复杂度</a>，结果交了五遍才过……</p><p>然后因为想用vscode编译，去搞环境变量，终于没出错，于是很满足的去恰饭……</p><p>7:40p.m.+ 去试机，发现电脑并没有什么问题。试了试gdb也活着，然后大约还剩20min左右吧，就去打树剖的板子。结果等到试机结束，只剩下读入没写完….于是放弃。</p><p>回宿舍，想起来钟水喝完了，于是又去买了一瓶（total : 2）。宿舍里凳子不够，只好上床上肝题，一直肝到宿管都走了才睡觉，大约11:10p.m.</p><h2 id="d1"><a href="#d1" class="headerlink" title="d1"></a>d1</h2><p>6:20a.m. get up.<br><del>然后又睡了15min</del></p><p>7:30a.m. 去考场，在门口等了将近30min才进去。</p><p>8:30a.m. 准时开题。看了看t1觉得做法显然，然后去看t2，发现链的分数居然这么多。。。遂在草纸上写下：t2 链 O(n^2) 30pts + O(n) 25pts；暴力 O(n^2) 20 pts。觉得如果都能拿到也很可观。</p><p>去看t3，发现又是一道树上问题。。看来出题人是真的互相不知情。。。发现 25pts 是链，25pts 是菊花图，然后暴力分只有 10pts 。。。按照去年的经验，这种题特殊情况应该比较好想，所以觉得这题期望60pts。</p><p>然后去开t1，发现貌似会爆精度。不过不要紧，我可以特判啊，于是写了个类似于高精读入然后再转低精的东西，20min码完20min调完，时间用的貌似有点多。</p><p>开t2，发现并不会线性的做法。。。只会O(n^2)大力递推，然后想可能能用数据结构优化到O(nlogn)级别，不过没有思路。发现链的做法和树没有什么本质的区别，于是感觉要有25pts拿不到了。</p><p>开t3，发现两个特殊情况一个也不显然<del>（真香）</del>。。没救了，觉得可能t2更可做一点，于是打完10pts暴力去肝t2。</p><p>然而只剩下50min-。再看t2依然没有更优秀的想法，于是果断放弃去检查t1。<br>发现t1写的处处是锅。。。然后发现貌似并不会爆精度，于是直接开<code>unsigned long long</code>大力搞。结果一些小细节一直在出锅，一直搞到11:55a.m.。</p><p>期间去看t2和t3，觉得我的t3绝不可能写挂，于是重点看t2有没有被卡精度，并没有发现明显的锅。</p><p>然后就这样了，最后看了看文件也没有出锅，就到12:00了。期望：100+50+10=160，考满也才到大众分。。。不过突然很怂t1写锅。</p><p>下午又去买钟水（total: 3）。</p><p>5:04p.m. t1过民间数据，看来思路没锅。不过最后5min改代码还是怂。。<br>恰完晚饭又开始怂t2写锅。。</p><p>6:33p.m. t2自测居然80pts。。一定是数据太水。</p><h2 id="d2"><a href="#d2" class="headerlink" title="d2"></a>d2</h2><p>6:50a.m. get up.<br>然后并不想恰早饭，喝了两碗粥散伙。</p><p>7:40a.m. 就憨憨的去了考场，然后等了半个小时。。。</p><p>8:25a.m. 拿到题目。t1居然是emiya。。emiya你为何如此nb。。然后发现我并不能把这个题看透，越看越像背包，但是并没有显然的想法，写了30min发现写不出来，于是去看t2。</p><p>开t2，一眼不可做。看数据更觉得这题绝不可做，直接考虑暴力，复杂度大概 O(玄学) ？看不透到底是有12pts还是24pts，于是告辞去看t3。</p><p>开t3，又是树。。ccf你一年考三道树上问题可还行。。发现暴力有40pts，反手一个O(n^2)大力枚举，单走一个样例，过掉，然后去写t2。</p><p>10min码出t2暴力，走前两个样例居然都过了，第三个样例太大肯定过不去，于是自己造了一个n=50的数据，发现跑的还挺快？++24pts。</p><p>10:00a.m. 重开t1。<del>我剩两个小时写t1你能秒我？我两个小时t1你能把我秒了？</del>结果活活推了1h毫无想法。只好去写暴力，测到第三个样例就炸掉了，估计只有32pts。</p><p>还剩大约40min，去看t3发现链的情况可做，因为链上的重心显然可以O(1)算出来。然后20min调试好代码，造了几个数据对拍都过掉了，于是觉得大概不会有什么锅，心想++15pts。</p><p>最后15min把三个源程序都重新看了一遍，没看出什么锅来，然后就告辞了。</p><p>回去的路上又去买了一瓶钟水（total : 4）。可能是退役之前的最后一瓶钟水了。。。</p><p>后来发现我t3链的情况写锅了。。。(Pi,Pi+1)活活看成(i,i+1)，当时还觉得没问题。。。于是成功–15pts。</p><p>估分：32+24+40=96，两天100+80+10+32+24+40=286封顶，预测会被锅到250~260左右，成功AFO。</p><p>然后回来的时候听说全国划线。。。目测省四稳了。</p><p>然后就没然后了。。技不如人，肝败下风。</p><hr><p>退役了，虽然好像还有很多事没去完成。</p><p>cf一直想上蓝，结果直到最后都在Specialist的底部徘徊。。<br>洛谷红了快两年了吧，停课之后打了几场月赛，排名居然升到了rk264，不过马上也就要掉下去了。。<br>顺带一说昨天恰好499AC，差一道就到500题了。本来想在退役之前把差的题目刷上去，可惜觉得找不到适合充当这最后一道题目的题。。那就不刷了吧，有时候不完美也是一种完美。</p><p>2017.9~2019.11 Away From OI，虽然打的很菜，但至少我来过。</p><hr><p>Upd on 2019.11.20 几天没上洛谷居然又上分了，rk181，xswl。<br>Upd on 2019.11.25 洛谷居然又上分了……rk168…</p><hr><p>Upd on 2019.12.17 </p><p>迟到好久的最终更新</p><p>最后 t2 的大力DP终究还是没能活下来，然后成功地100+50+10+32+24+40=256，省rk110+，原地升天爆炸退役。</p><p>然后就这样吧。因为太菜，所以只能选择退役。</p><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有摘要可以提供，因为摘要自闭去了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://big-news.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」NIKKEI Prog. Contest 2019-2</title>
    <link href="https://big-news.cn/2019/11/10/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DNIKKEI%20Prog%20Contest%202019-2/"/>
    <id>https://big-news.cn/2019/11/10/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DNIKKEI%20Prog%20Contest%202019-2/</id>
    <published>2019-11-10T00:16:00.000Z</published>
    <updated>2020-08-19T06:21:21.817Z</updated>
    
    <content type="html"><![CDATA[<p>又是签到走人的一天……</p><a id="more"></a><h2 id="A-Sum-of-Two-Integers"><a href="#A-Sum-of-Two-Integers" class="headerlink" title="A. Sum of Two Integers"></a>A. Sum of Two Integers</h2><p><a href="https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_a">Source</a></p><p>签到题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span>) n += <span class="number">1</span>; n /= <span class="number">2</span>; <span class="built_in">printf</span>(<span class="string">"%d"</span>,n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Counting-of-Trees"><a href="#B-Counting-of-Trees" class="headerlink" title="B. Counting of Trees"></a>B. Counting of Trees</h2><p><a href="https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_b">Source</a></p><p>签到题。考虑每一层的方案数，直接乘法原理就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL R = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,fir; LL s[CN];</span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a,LL b)</span></span>&#123;</span><br><span class="line">    LL rec = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) (rec *= a) %= R;</span><br><span class="line">        (a *= a) %= R; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;fir);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); </span><br><span class="line">        <span class="keyword">if</span>(!x) &#123;fir = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        s[x]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(s[i]) s[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s[<span class="number">0</span>];i++) <span class="keyword">if</span>(!s[i]) fir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fir) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        LL ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s[<span class="number">0</span>];i++) (ans *= qpow(s[i<span class="number">-1</span>], s[i])) %= R;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 不会，skip 。</p><h2 id="D-Shortest-Path-on-a-Line"><a href="#D-Shortest-Path-on-a-Line" class="headerlink" title="D. Shortest Path on a Line"></a>D. Shortest Path on a Line</h2><p><a href="https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_d">Source</a></p><p>这题把我卡了一个多小时还没想出来，当时一直在想建个线段树搞线段覆盖……</p><p>实际上一段区间里面任意两点间有等距的有向边，这个东西等价于把这段区间连成一个简单环：节点顺序连边，然后仅有一条边有边权为 ci ，其余为 0 。那么如果我们逆着这个环的方向去求最短路，就能得到这个长度总是 ci ，因为没法直接到达，就总要经过那条边权为 ci 的边。</p><p>一张图解：<br><img src="https://upl.big-news.cn/2019/11/10/nk2019.jpg"></p><p>剩下的问题跑 DJ 就好了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f2f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar()) <span class="keyword">if</span>(c==<span class="string">'-'</span>) ne=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar()) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s*ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; LL di; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,LL d)</span> </span>&#123;to=t;nxt=n;di=d;&#125;</span><br><span class="line">&#125;E[CN * <span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN],ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,LL z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DJ */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> id; LL v; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ&amp; a)<span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;DJ&gt; Q; </span><br><span class="line">LL d[CN]; <span class="keyword">bool</span> vis[CN];</span><br><span class="line"><span class="function">LL <span class="title">SP</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> ed)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    Q.push((DJ)&#123;st, d[st] = <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.top().id; Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">            <span class="keyword">if</span>(d[v] &gt; d[u] + E[k].di)&#123;</span><br><span class="line">                d[v] = d[u] + E[k].di;</span><br><span class="line">                Q.push((DJ)&#123;v, d[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[ed] &lt; INF ? d[ed] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(),v = read(); LL c = read();</span><br><span class="line">        add(u, v, c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) add(i + <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, SP(<span class="number">1</span>, n));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是签到走人的一天……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」 Codeforces Round 599 (Div. 2)</title>
    <link href="https://big-news.cn/2019/11/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%20Codeforces%20Round%20599%20(Div.%202)/"/>
    <id>https://big-news.cn/2019/11/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%20Codeforces%20Round%20599%20(Div.%202)/</id>
    <published>2019-11-09T06:58:00.000Z</published>
    <updated>2020-08-19T06:21:21.817Z</updated>
    
    <content type="html"><![CDATA[<p>解题报告貌似鸽了好几天了，毕竟是晚上爆肝打的比赛，第二天早上起来还要 % 拟 ……<br>其实之前还有场 Div. 3 ，不过打的太烂就不写解题报告了……</p><a id="more"></a><p>先是掉分经过：<br>开场 15min 切 A,B1 签到不多说，然后去看 B2 ，觉得它不显然；就去看 C 题，然后觉得这个东西貌似可以分解质因数然后搞一搞，结果后来代码一直锅掉，调了将近一个小时才过……期间去看 D 题，也没有什么本质的想法，然后就睡觉去了，大概在 0:20 a.m. 左右，目测掉分预定。<br>第二天早上起来发现 C 题居然没锅，然后就神奇的 rating +19 ，不过依然是 $\text{Specialist}$ 。</p><h2 id="A-Maximum-Square"><a href="#A-Maximum-Square" class="headerlink" title="A. Maximum Square"></a>A. Maximum Square</h2><p><a href="https://codeforces.com/contest/1243/problem/A">Source</a></p><p>签到题。当时切了 C 题去 room 里砍人，居然发现这题有人写二分……无言以对。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e3</span>+<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="comment">/* omitted */</span>&#125;</span><br><span class="line"><span class="keyword">int</span> q,n,a[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(a[j] &gt;= i) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= i) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i); <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B1-Character-Swap-Easy-Version"><a href="#B1-Character-Swap-Easy-Version" class="headerlink" title="B1. Character Swap (Easy Version)"></a>B1. Character Swap (Easy Version)</h2><p><a href="https://codeforces.com/contest/1243/problem/B1">Source</a></p><p>依然签到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e4</span>+<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="comment">/* omitted */</span>&#125;</span><br><span class="line"><span class="keyword">int</span> k,n; <span class="keyword">char</span> s[CN],t[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    k = read();</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        n = read(); <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(s[i] != t[i]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt != <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p[<span class="number">20</span>],q = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(s[i] != t[i]) p[q++] = i;</span><br><span class="line">            swap(s[ p[<span class="number">0</span>] ], t[ p[<span class="number">1</span>] ]);</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(s[i] != t[i]) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(!cnt) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B2 不会，skip 。</p><h2 id="C-Tile-Painting"><a href="#C-Tile-Painting" class="headerlink" title="C. Tile Painting"></a>C. Tile Painting</h2><p><a href="https://codeforces.com/contest/1243/problem/C">Source</a></p><p>考虑有哪些格子的颜色相同，不难发现这个东西跟它的质因子有关系。<br>从一个点出发，我们应该筛掉从该点出发，以 n 的任一质因子为“距离”能到达的所有点，这些点的颜色相同；然后下一次我们应该再去找一个没有被筛过的点重复上述过程。问题的本质在于“没有被筛过的点”我们能找到几个。</p><p>不难发现如果一个数字只有一个质因子 p ，那么这样的点我们有 p 个，即 1~p ；若其存在两个或更多的质因子，那么看起来从第一个点开始就能筛掉所有点，于是答案是 1 .</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL n,p[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(LL k=<span class="number">2</span>;k*k&lt;=x;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x % k)) p[ ++p[<span class="number">0</span>] ] = k;</span><br><span class="line">        <span class="keyword">while</span>(!(x % k)) x /= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) p[ ++p[<span class="number">0</span>] ] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    div(n);</span><br><span class="line">    <span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%I64d"</span>,p[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-0-1-MST"><a href="#D-0-1-MST" class="headerlink" title="D. 0-1 MST"></a>D. 0-1 MST</h2><p><a href="https://codeforces.com/contest/1243/problem/D">Source</a></p><p>显然连 0 边更优，也就是说我们只在迫不得已的情况下去连 1 边。考虑在图上只保留 0 边，那么显然一个联通块里面我们是不需要连 1 边的。把每个联通块整体考虑，则需要连 1 边的数量为联通块数 -1 。</p><p>上述过程大力搜索实现显然是不行的，考虑用并查集维护联通性。我们怎么判定一个点属于一个联通块？假设某一联通块的大小为 sz ，那么一个点向它连的 1 边的数量（记作 ct ）是可以统计的，而该点和此联通块一共有 sz 条边相连；当 sz  &gt; ct 时，即可推出该点与联通块之间有 0 边。</p><p>可是上述过程大力去做还是 O(n^2) 的，考虑到一个联通块只需要被合并一次，于是对于所有找到的联通块，只记录其中一个点进行合并就好了，也就是把该联通块在并查集中的根记下来。因为原图上 0 边很多，也就是说联通块个数很少，所以这个想法就会跑得很快。</p><p>最后的答案是并查集中根的个数 -1，其中根的个数即为联通块数。考虑到我们此前维护的根可能被合并，也就是说有些根 gg 掉了，所以最后还得再统计一下根的数量。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fa[CN],sz[CN]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rt;</span><br><span class="line">    dsu() &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;CN;i++) fa[i]=i,sz[i]=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> find(x) != find(y);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;x = find(x); y = find(y); sz[y] += sz[x]; fa[x] = y;&#125;</span><br><span class="line">&#125;co;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to=t;nxt=n;&#125;</span><br><span class="line">&#125;E[CN * <span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN],ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ve[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    co.rt.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ve, <span class="number">0</span>, <span class="keyword">sizeof</span>(ve));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=hd[i];k;k=E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">            <span class="keyword">if</span>(v &lt; i) ve[ co.find(v) ]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cn = co.rt.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cn;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = co.rt[j]; r = co.find(r);</span><br><span class="line">            <span class="keyword">if</span>(co.sz[r] &gt; ve[r] &amp;&amp; co.exm(i, r)) co.merge(i, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(co.find(i) == i) co.rt.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(co.find(i) == i) cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u, v); add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ct() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解题报告貌似鸽了好几天了，毕竟是晚上爆肝打的比赛，第二天早上起来还要 % 拟 ……&lt;br&gt;其实之前还有场 Div. 3 ，不过打的太烂就不写解题报告了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>数列差分</title>
    <link href="https://big-news.cn/2019/11/06/%E6%95%B0%E5%88%97%E5%B7%AE%E5%88%86/"/>
    <id>https://big-news.cn/2019/11/06/%E6%95%B0%E5%88%97%E5%B7%AE%E5%88%86/</id>
    <published>2019-11-06T08:52:00.000Z</published>
    <updated>2020-08-15T12:46:56.086Z</updated>
    
    <content type="html"><![CDATA[<p>差分是一种对于数列区间修改问题的很优秀的 idea ，对于每个独立的查询操作，它可以做到在线性时间内完成任务……</p><a id="more"></a><h1 id="一-一阶差分"><a href="#一-一阶差分" class="headerlink" title="一 一阶差分"></a>一 一阶差分</h1><h2 id="1-模型"><a href="#1-模型" class="headerlink" title="1 模型"></a>1 模型</h2><article class="message is-primary" style="font-size:inherit"><div class="message-body">维护一段数列，支持将区间 $ [l,r] $ 内的每个元素加或减某个值，并查询所有操作后的数列。要求在线性时间内完成任务。</div></article><p>以上为数列差分问题的基本模型。</p><p>对于数列$a_1,a_2,a_3,…,a_n$，我们定义它的差分数列为$b_1,b_2,b_3,…b_n$，满足$b_i = a_i-a_{i-1}$。不难发现，有 $a_i=\sum_{j=1}^i b_j$。</p><p>我们发现在对区间 $[l,r]$ 进行某次操作之后，该区间内元素的相对大小是不变的，也就是任意两数的差值固定。利用这个性质，我们发现在对一段区间 $[l,r]$ 操作之后，数列 $\begin{Bmatrix} b \end{Bmatrix}$ 中仅有两个元素 $b_l$ 和 $b_{r+1}$ 发生了变化；我们想要记录这次操作的影响，只需要对 $b_l$ 和 $b_{r+1}$ 做一些加加减减就好了。</p><p>于是我们做到了在 $O(1)$ 的时间内“传递影响”，那么也就是说我们可以在 $O(q)$ 的时间内处理完所有操作，最后再 $O(n)$ 推一遍前缀和，我们就得到了修改后的 $\begin{Bmatrix} a \end{Bmatrix}$ 数列。</p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2 代码"></a>2 代码</h2><p>代码，实际上差分数组和原序列可以共用一个数组，此处是为了便于理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,a[CN],b[CN]; <span class="comment">// b[] : 差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推 b[] */</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i] = a[i] - a[i<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    更新 b[] 数组 </span></span><br><span class="line"><span class="comment">    我们发现 [l,r] + v 会使得 b[r + 1] - v 和 b[l] + v</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    b[y + <span class="number">1</span>] -= z; b[x] += z; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前缀和推出操作后的 a[] 数组 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i<span class="number">-1</span>] + b[i];</span><br></pre></td></tr></table></figure><p>更简化的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,a[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i] - a[i<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    a[y + <span class="number">1</span>] -= z; a[x] += z; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] += a[i<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><hr><h1 id="二-二阶差分"><a href="#二-二阶差分" class="headerlink" title="二 二阶差分"></a>二 二阶差分</h1><h2 id="1-模型-1"><a href="#1-模型-1" class="headerlink" title="1 模型"></a>1 模型</h2><article class="message is-primary" style="font-size:inherit"><div class="message-body">维护一段数列，支持将区间 $ [l,r] $ 加一个等差数列 $s:e$ （ $[l,r]$ 内每个元素分别加等差数列的第 $1,2,3,...$ 项，其中等差数列的第一项为 $s$ ，最后一项为 $e$ ），并查询所有操作后的数列。要求在线性时间内完成任务。</div></article><p>不难发现，某段区间整体加上一个等差数列，相当于该区间上的差分数列整体加了这个等差数列的公差。当然，在差分数列的两个端点还会有一些小的细节。</p><p>对于“差分数列整体加公差”这个操作，我们直接对差分数列进差分即可维护。注意，差分数列中加上公差的区间是 $[l+1,r]$ 。</p><p>剩下的是一点小细节：区间 $[l,r]$ 加一个等差数列 $s:e$ 后，还会使得 $b_l + s$ 和 $b_{r+1} - e$ 。这两个特例均是对差分数列 $\begin{Bmatrix} b \end{Bmatrix}$ 进行的单点操作，我们在二次差分推出数列  $\begin{Bmatrix} b \end{Bmatrix}$ 后，暴力修改就好了。</p><h2 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2 代码"></a>2 代码</h2><p>代码，实际上三个计算数组可以合成一个，此处是为了便于理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123; <span class="comment">/* 省略 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> l[CN],r[CN]; LL s[CN],e[CN]; <span class="comment">// 记录操作</span></span><br><span class="line"></span><br><span class="line">LL a[CN],b[CN],c[CN]; <span class="comment">// b[] : 原序列的差分</span></span><br><span class="line">                      <span class="comment">// c[] : 差分序列的差分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推 b[] */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i] = a[i] - a[i - <span class="number">1</span>]; </span><br><span class="line"><span class="comment">/* 推 c[] */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[i] = b[i] - b[i - <span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">q = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">    l[i] = read(); r[i] = read(); s[i] = read(); e[i] = read();</span><br><span class="line">    LL k = (e[i] - s[i]) / (r[i] - l[i]); <span class="comment">// 公比</span></span><br><span class="line">    <span class="comment">/* 更新 c[] 数组 */</span></span><br><span class="line">    c[ r[i] + <span class="number">1</span> ] -= k; c[ l[i] + <span class="number">1</span> ] += k; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推出操作后的 b[] 数组 */</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i] = b[i - <span class="number">1</span>] + c[i]; </span><br><span class="line"><span class="comment">/* 对 b[] 进行单点修改 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) b[ r[i] + <span class="number">1</span> ] -= e[i], b[ l[i] ] += s[i]; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前缀和推出处理后的 a[] 数组 */</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i - <span class="number">1</span>] + b[i];</span><br></pre></td></tr></table></figure><p>更简化的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123; <span class="comment">/* 省略 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> l[CN],r[CN]; LL s[CN],e[CN],a[CN]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i] - a[i - <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i] - a[i - <span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">q = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">    l[i] = read(); r[i] = read(); s[i] = read(); e[i] = read();</span><br><span class="line">    LL k = (e[i] - s[i]) / (r[i] - l[i]);</span><br><span class="line">    a[ r[i] + <span class="number">1</span> ] -= k; a[ l[i] + <span class="number">1</span> ] += k; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] += a[i - <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) a[ r[i] + <span class="number">1</span> ] -= e[i], a[ l[i] ] += s[i]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] += a[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;差分是一种对于数列区间修改问题的很优秀的 idea ，对于每个独立的查询操作，它可以做到在线性时间内完成任务……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前缀和" scheme="https://big-news.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="差分" scheme="https://big-news.cn/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>「题解」Two Contests</title>
    <link href="https://big-news.cn/2019/11/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DTwo%20Contests/"/>
    <id>https://big-news.cn/2019/11/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DTwo%20Contests/</id>
    <published>2019-11-04T08:39:00.000Z</published>
    <updated>2020-08-17T07:56:40.555Z</updated>
    
    <content type="html"><![CDATA[<p>把一些线段分成两组，使得 每组线段的并的长度 之和最大……</p><a id="more"></a><h1 id="一-题目"><a href="#一-题目" class="headerlink" title="一 题目"></a>一 题目</h1><blockquote><p><a href="https://atcoder.jp/contests/agc040/tasks/agc040_b">Source</a></p></blockquote><h2 id="Descriptions"><a href="#Descriptions" class="headerlink" title="Descriptions"></a>Descriptions</h2><p>10^9 contestants, numbered 1 to 10^9, will compete in a competition. There will be two contests in this competition.</p><p>The organizer prepared N problems, numbered 1 to N, to use in these contests. When Problem i is presented in a contest, it will be solved by all contestants from Contestant Li to Contestant Ri (inclusive), and will not be solved by any other contestants.</p><p>The organizer will use these N problems in the two contests. Each problem must be used in exactly one of the contests, and each contest must have at least one problem.</p><p>The joyfulness of each contest is the number of contestants who will solve all the problems in the contest. Find the maximum possible total joyfulness of the two contests.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Input is given from Standard Input in the following format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N</span><br><span class="line">L1 R1</span><br><span class="line">L2 R2</span><br><span class="line">⋮</span><br><span class="line">LN RN</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Print the maximum possible total joyfulness of the two contests.</p><hr><h1 id="二-题解"><a href="#二-题解" class="headerlink" title="二 题解"></a>二 题解</h1><p>首先肯定能想到对线段进行”某种排序“，然后前面分一组，后面分另一组。</p><p>然后发现并的长度受两个东西的限制： max(l[i]) 和 min(r[i]) 。<br>我们先找出所有线段中，l[] 值最大的那一条（记为 p ）和 r[] 值最小的那一条（记为 q ），然后分类讨论。</p><p>考虑把 p,q 分到同一组线段里，那么显然，这组线段的并的长度一定是 max(0, r[q] - l[p]) 。于是想到留一条最长的线段另成第二组，然后其它的线段都分到第一组里，这样一定是坠吼的。</p><p>考虑不把 p,q 分到同一组里，那么考虑通过“某种排序”使得某一组里面的线段在数列里面连续。显然，与 p 分到同一组里面的线段的左端点受制于 p ，也就是说左端点固定，那么我们可以按照右端点进行升序排序，此时答案受制于最小的那个 r[] 值，也就是靠前面的 r[] 值；<br>再考虑右端点相同的情况，我们可能会把前面一部分线段划给 q ，那么我们需要靠前的线段 l[] 值尽量小，于是按 l[] 升序排序，此时答案受制于最大的那个 l[] 值，也就是靠后面 l[] 值。</p><p>剩下的问题是枚举一个断点（前面化成一组，后面另一组），然后贪心就好了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,l[CN],r[CN],id[CN],mnr,pr,mxl,pl;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* calc the length of a certain segment */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">d</span><span class="params">(<span class="keyword">int</span> cl,<span class="keyword">int</span> cr)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l * max(<span class="number">0</span>, cr - cl + <span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[x] != r[y] ? r[x] &lt; r[y] : l[x] &lt; l[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l[i],&amp;r[i]);</span><br><span class="line">    </span><br><span class="line">    mnr = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(r[i] &lt; mnr) mnr = r[pr = i];</span><br><span class="line">    mxl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(l[i] &gt; mxl) mxl = l[pl = i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* in same */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(i != pl &amp;&amp; i != pr) </span><br><span class="line">            ans = max(ans, d(mxl, mnr) + d(l[i], r[i]));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* in diff */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> premxl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        premxl = max(premxl, l[ id[i - <span class="number">1</span>] ]);</span><br><span class="line">        ans = max(ans, d(mxl, r[ id[i] ]) + d(premxl, mnr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把一些线段分成两组，使得 每组线段的并的长度 之和最大……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 597 (Div. 2)</title>
    <link href="https://big-news.cn/2019/11/03/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20597%20(Div.%202)/"/>
    <id>https://big-news.cn/2019/11/03/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20597%20(Div.%202)/</id>
    <published>2019-11-03T01:28:00.000Z</published>
    <updated>2020-08-19T06:21:21.817Z</updated>
    
    <content type="html"><![CDATA[<p>真香警告.jpg……</p><a id="more"></a><h2 id="A-Good-ol’-Numbers-Coloring"><a href="#A-Good-ol’-Numbers-Coloring" class="headerlink" title="A. Good ol’ Numbers Coloring"></a>A. Good ol’ Numbers Coloring</h2><p><a href="https://codeforces.com/contest/1245/problem/A">Source</a></p><p>看完样例就很显然了，切掉就好了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar()) s = (s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> !b ? a : gcd(b, a % b);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        a = read(); b = read();</span><br><span class="line">        <span class="keyword">if</span>(gcd(a,b) == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Finite\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Infinite\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Restricted-RPS"><a href="#B-Restricted-RPS" class="headerlink" title="B. Restricted RPS"></a>B. Restricted RPS</h2><p><a href="https://codeforces.com/contest/1245/problem/B">Source</a></p><p>每步贪心，能干就干。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar()) s = (s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n,s0,s1,s2,opt[CN],ans[CN]; <span class="keyword">bool</span> bt[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = read(); s1 = read(); s0 = read(); s2 = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c; <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'P'</span>) opt[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'R'</span>) opt[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'S'</span>) opt[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(bt,<span class="number">0</span>,<span class="keyword">sizeof</span>(bt));</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!opt[i] &amp;&amp; s2) bt[i] = <span class="literal">true</span>,s2--;</span><br><span class="line">            <span class="keyword">if</span>(opt[i] == <span class="number">1</span> &amp;&amp; s0) bt[i] = <span class="literal">true</span>,s0--;</span><br><span class="line">            <span class="keyword">if</span>(opt[i] == <span class="number">2</span> &amp;&amp; s1) bt[i] = <span class="literal">true</span>,s1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bt[i]) ans[i] = (opt[i] + <span class="number">2</span>) % <span class="number">3</span>,cnt++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s0) ans[i] = <span class="number">0</span>,s0--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s1) ans[i] = <span class="number">1</span>,s1--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s2) ans[i] = <span class="number">2</span>,s2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> vs = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span>) vs += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= vs)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ans[i]) <span class="built_in">cout</span>&lt;&lt;<span class="string">'P'</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans[i] == <span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">'R'</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans[i] == <span class="number">2</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">'S'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Constanze’s-Machine"><a href="#C-Constanze’s-Machine" class="headerlink" title="C. Constanze’s Machine"></a>C. Constanze’s Machine</h2><p><a href="https://codeforces.com/contest/1245/problem/C">Source</a></p><p>这题看上去还是比较有感觉的，只不过式子错了，这就很dl了（真香）。</p><p>首先显然可以把每个连续字段的方案数算出来然后再乘法原理，剩下的问题是求一个“连续字段”的方案数。</p><p>关于“连续字段”的方案，这个问题可以抽象成给你一段序列类似于“uuuuuu”这个样子，让你在其中划若干条长度为 2 的线，两两线不能相交，求方案数。那么显然这个东西可以设个状态写写方程，于是设 f[i] 表示考虑长度为 i 的序列的方案数。考虑新加入的这个元素，我们可以把它和元素 i-1 划成一段，方案数 f[i-2] ；也可以不划到任何一段，方案数 f[i-1] 。于是 f[i]=f[i-1]+f[i-2] ，又是 fibonacci 数列…然后做完了。</p><p>比赛的时候方程推成了 f[i]=f[i-1]+i-2 ，因为实际上我只考虑了划两段的情况…然后pretest9一直WA，自闭了，看来还是不够熟练…</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL R = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> ch[CN]; <span class="keyword">int</span> n;</span><br><span class="line">LL f[CN],ans = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch; n = <span class="built_in">strlen</span>(ch);</span><br><span class="line"> </span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>; f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">3</span>;i&lt;=n;i++) f[i] = (f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]) % R;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(ch[i] == <span class="string">'m'</span> || ch[i] == <span class="string">'w'</span>) flag = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i] != <span class="string">'n'</span> &amp;&amp; ch[i] != <span class="string">'u'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p = i,l = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p &lt; n &amp;&amp; ch[p] == ch[p+<span class="number">1</span>]) p++,l++;</span><br><span class="line">            (ans *= f[l]) %= R;</span><br><span class="line">            i = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Shichikuji-and-Power-Grid"><a href="#D-Shichikuji-and-Power-Grid" class="headerlink" title="D. Shichikuji and Power Grid"></a>D. Shichikuji and Power Grid</h2><p><a href="https://codeforces.com/contest/1245/problem/D">Source</a></p><p>第一眼没什么感觉，看了 tutorial 发现就是个 mst … 建一个虚点向每个点连边，表示建电站就好了，看来还是不够熟练…</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fr,to; LL di;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,LL d)</span> </span>&#123;fr=f;to=t;di=d;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> fs&amp; a)<span class="keyword">const</span> &#123;<span class="keyword">return</span> di &lt; a.di;&#125;</span><br><span class="line">&#125;E[CN * CN];</span><br><span class="line"><span class="keyword">int</span> ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,LL z)</span> </span>&#123;E[++ecnt].init(x,y,z);&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ufs</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fa[CN];</span><br><span class="line">    ufs() &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;CN;i++) fa[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> find(x) != find(y);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;fa[find(x)] = find(y);&#125; </span><br><span class="line">&#125;ck;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,px[CN],py[CN],pc[CN],pk[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&lt;<span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(px[a] - px[b]) + <span class="built_in">abs</span>(py[a] - py[b]);&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> sel[CN * CN]; LL si = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sel,<span class="literal">false</span>,<span class="keyword">sizeof</span>(sel));</span><br><span class="line">    sort(E+<span class="number">1</span>,E+ecnt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ecnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ck.exm(E[i].fr, E[i].to)) <span class="keyword">continue</span>;</span><br><span class="line">        ck.merge(E[i].fr, E[i].to); </span><br><span class="line">        cnt++; si += E[i].di; sel[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;px[i],&amp;py[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pc[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pk[i]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            add(i,j,<span class="number">1l</span>l*(pk[i]+pk[j])*dist(i,j));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(i,n+<span class="number">1</span>,pc[i]);</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    MST();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,si);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ecnt;i++) <span class="keyword">if</span>(sel[i] &amp;&amp; E[i].to == n) cnt++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ecnt;i++) <span class="keyword">if</span>(sel[i] &amp;&amp; E[i].to == n) <span class="built_in">printf</span>(<span class="string">"%d "</span>,E[i].fr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    cnt = n - <span class="number">1</span> - cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ecnt;i++) <span class="keyword">if</span>(sel[i] &amp;&amp; E[i].to != n) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,E[i].fr,E[i].to);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$ - - - - \mathcal{End} - - - -  $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真香警告.jpg……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
</feed>
