<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://big-news.cn/"/>
  <updated>2020-11-26T15:00:26.676Z</updated>
  <id>https://big-news.cn/</id>
  
  <author>
    <name>big-news</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>置换群学习笔记</title>
    <link href="https://big-news.cn/2020/11/26/%E7%BD%AE%E6%8D%A2%E7%BE%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/11/26/%E7%BD%AE%E6%8D%A2%E7%BE%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-26T13:39:00.000Z</published>
    <updated>2020-11-26T15:00:26.676Z</updated>
    
    <content type="html"><![CDATA[<p>置换群的相关内容主要用于解决一类“充满对称性”的计数问题。基于轨道-稳定子群定理的 Burnside 引理和引申出的 Pólya 计数原理是我们解决这类问题的有力工具……</p><a id="more"></a><h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p>对于一个非空集合 $S$ 和该集合上定义的二元运算 $·$，当该运算满足一些性质时，我们称它们构成一个群，记作 $(S,·)$。运算需要满足的性质是：</p><ul><li>封闭性：$\forall x,y\in S, x·y\in S$</li><li>结合性：$\forall x,y,z\in S,(x·y)·z=x·(y·z)=x·y·z$</li><li>存在单位元：$\exists e\in S, \text{s.t. }\forall y\in S, e·y=y$</li><li>存在逆元：$\forall y\in S,\exists x\in S,\text{s.t. } x·y=e$</li></ul><p>这是群论的基本定义，在 OI 界，更加常用的是置换群。</p><h3 id="置换和置换群"><a href="#置换和置换群" class="headerlink" title="置换和置换群"></a>置换和置换群</h3><ul><li>置换：一个从某个排列到某个排列的双射称作置换，记作 $p:f\to g$，其中 $f\to g$ 指代某种双射。</li><li>乘法：两个置换 $u,v$ 的乘法定义为它们对排列<strong>先后</strong>作用得到的结果，记作 $v·u$。</li><li>置换群：根据群论的基本概念，置换构成的集合和建立在置换上的乘法构成置换群。</li></ul><p>然后是一些有关于计数的概念。</p><ul><li>染色：给序列中的每个元素分配一个“颜色”从而得到的不同序列的过程称作染色。形式化地，可以用序列 $c$ 表示一个染色，其中 $c[i]$ 表示 $i$ 这个位置上的颜色。所有染色组成染色全集 $\mathcal{C}$。</li><li>置换对染色的作用：对于一个置换 $g$，其作用于某个染色 $c$ 可以得到一个新的染色，记作 $g·c$。</li><li>置换群对染色的作用（轨道）：对于一个置换群 $G$ 和一个染色 $c$，将所有 $g\in G$ 作用于 $c$ 得到的集合称作 $c$ 在 $G$ 下的轨道，记作 $G·c=\begin{Bmatrix}g·c\text{ | }g\in G \end{Bmatrix}$。</li></ul><p>Burnside 引理与 Pólya 计数原理用于解决在某种置换群 $G$ 作用下染色集合 $X\subseteq \mathcal{C}$ 共有多少本质不同的元素，即轨道数 $|X/G|$。</p><h3 id="Burnside-引理"><a href="#Burnside-引理" class="headerlink" title="Burnside 引理"></a>Burnside 引理</h3><p>设 $X\subseteq \mathcal{C}$ 是某个染色集合， $G$ 是作用在 $X$ 上的置换群，我们称 $X/G$ 为在 $G$ 作用下 $X$ 的轨道集合，即 $X/G=\begin{Bmatrix} gc\text{ | } c\in X, g\in G\end{Bmatrix}$。</p><ul><li>不动点（稳定子）：置换 $g\in G$ 作用在 $X$ 上的不动点为 $X$ 中在 $g$ 作用下不发生变化的元素，组成的集合即 $\begin{Bmatrix}c\in X\text{ | }gc=c\end{Bmatrix}$，记作 $X^g$。</li></ul><p>Burnside 引理指出，轨道数 $|X/G|$ 等于 $G$ 中所有置换对应的不动点个数对置换数的平均值，即有：</p><p>$$ |X/G|= \dfrac{1}{|G|}\sum\limits_{g\in G}|X^g| $$</p><h3 id="Polya-计数原理"><a href="#Polya-计数原理" class="headerlink" title="Pólya 计数原理"></a>Pólya 计数原理</h3><ul><li><p>置换的循环表示：简单来讲，如果把置换的双射看成图上的有向边，那么置换显然是成环的。我们可以据此把一个置换拆分成若干置换（轮换）的乘积，这称作置换的循环表示。</p></li><li><p>循环数：某一个置换 $g$ 具有的轮换的个数称作循环数，记作 $\chi(g)$。</p></li></ul><p>Pólya 原理指出，如果对于所有染色序列 $c\in X$ ，如果 $c$ 的所有位置可分配的颜色集合 $S$ 相同，那么不动点个数恰等于色数的循环数次方，即 $|X^g|=|S|^{\chi(g)}$。</p><p>根据 Burnside 引理，可以进一步得到一个常见的计数公式：</p><p> $$|X/G|=\sum\limits_{g\in G}|S|^{\chi(g)}$$</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n(n+1)/2$ 个格子形成一个 $n$ 层的三角形，我们要给每个格子涂上黑白两种颜色。三角形可以沿中线翻转或顺/逆时针旋转，问一共有多少种本质不同的涂色方式。<br>$n\le 20$</p></div></article><p>显然，旋转的置换一共有三种 $\sigma^0,\sigma^1,\sigma^2$，翻转的置换题目给出了一种。考虑到置换群需要满足自闭性，那么先翻转再旋转的置换也应当位于置换群中，这等价于沿着一条斜着的中线翻转。因此翻转的置换也共有三种。</p><p>然后需要求出某种置换的循环数。$\sigma^0$ 显然是 $n(n+1)/2$，$\sigma^1,\sigma^2$ 容易发现是 $\lceil n(n+1)/6 \rceil$，翻转的循环数显然是 $(n(n-1)/2-\lceil n/2\rceil)/2+\lceil n/2\rceil$，从而答案是 $\dfrac{1}{6}(2^{\binom{n+1}{2}}+2^{\lceil n(n+1)/6 \rceil+1}+3·2^{(\binom{n+1}{2}-\lceil n/2\rceil)/2+\lceil n/2\rceil})$。</p><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定三个整数 $A,B,C$ 和由 $m$ 个置换形成的置换群 $G=\begin{Bmatrix}p_1, p_2, …, p_m\end{Bmatrix}$。需要给 $n=A+B+C$ 个格子涂三种颜色，满足三种颜色的格子各有 $A,B,C$ 个，问在 $G$ 作用下共有多少不同的涂色方案。<br>$A,B,C\le 20,m\le 60$</p></div></article><p>考虑如何求在某个置换作用下的不动点个数。把每个置换循环分解，一个轮换上的点显然只能涂同一种颜色。然后看上去就可以背包一下，DP 把方案数计出来，套一个 Burnside 引理就可以算了。</p><p>朴素的复杂度大概是 $O(mnA^3)$，可能还能进一步优化。</p><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>现在有 $n$ 个点的环，需要给每个点染上 $m$ 种颜色 $0\text{ ~ }m-1$ 之一。环可以旋转，旋转得到的环视为相同的环，问有多少种本质不同的染色方案。<br>$ n,m\le 10^9 $</p></div></article><p>考虑先写出置换群 $G$ 来。我们设 $\sigma$ 为一次顺时针旋转（转动一个单位），则有 $G=\begin{Bmatrix} \sigma ^{x} \text{ | }x\ge 0\end{Bmatrix}$。注意到旋转 $n$ 次等价于不旋转，则 $|G|=n$。</p><p>根据  Pólya 原理，在 $\sigma^{i}$ 下的不动元素数 $|X|^{\sigma ^i}=m^{\chi(\sigma^i)}$。把 $\chi(\sigma^i)$ 写成循环表示的形式，即 $\sigma^i=(1,i,2i,…)(2,i+1,2i+1,…)…$，容易发现循环数为 $(i,n)$，这里的小括号特指两个数的最大公因数（Greatest Common Divisor, GCD）。</p><p>从而答案是 $\dfrac{1}{n}\sum\limits_{i=1}^n m^{(i,n)}$。</p><p>注意到 $(i,n)|n$，化一下柿子变成：<br>$$\begin{aligned}&amp;\dfrac{1}{n}\sum\limits_{i=1}^n m^{(i,n)}\newline =&amp; \dfrac{1}{n}\sum\limits_{d|n}m^d \sum\limits_{i=1}^n[(i,n)=d]\newline =&amp;\dfrac{1}{n}\sum\limits_{d|n}m^d \sum\limits_{d|i,i\le n}[(i/d,n/d)=1]\newline =&amp;\dfrac{1}{n}\sum\limits_{d|n}m^d \varphi(n/d)\end{aligned}$$</p><p>直接做就是 $O(\sqrt{n})$。</p><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>现在有 $n$ 个点的环，需要给每个点染上 $m$ 种颜色 $0\text{ ~ }m-1$ 之一。有两类置换：</p><ul><li>将环旋转若干次</li><li>给环上每个点的编号 $+1$ 再模 $m$。</li></ul><p>问共有多少种本质不同的染色方案。<br>$n,m\le 10^9$</p></div></article><p>设 $G_1=\begin{Bmatrix}\sigma^0,\sigma^1,…,\sigma^{n-1} \end{Bmatrix}$ 是旋转操作 $\sigma$ 的置换群， $G_2=\begin{Bmatrix}\tau^0,\tau^1,…,\tau^{m-1} \end{Bmatrix}$ 是加法操作 $\tau$ 的置换群，则本题中作用在环上的置换群 $G=G_1\times G_2$，其中 $\times$ 表示笛卡尔积。</p><p>分析一下不动点的个数，得到的柿子是：<br>$$\begin{aligned}&amp;\dfrac{1}{nm}\sum\limits_{i=1}^n\sum\limits_{k=1}^m [k\text{ is legal}]m^{(n,i)} \newline =&amp;\dfrac{1}{nm}\sum\limits_{i=1}^nm^{(n,i)}\sum\limits_{k=1}^m [m|\dfrac{kn}{(n,i)}]\newline =&amp;\dfrac{1}{nm}\sum\limits_{i=1}^nm^{(n,i)}(m,n/(n,i))\end{aligned}$$</p><p>第一个柿子里的 $[k\text{ is legal}]$ 这个条件一看就很吓人。但是冷静分析一下，就可以注意到我们实际上是需要轮换上相邻数字之差在模 $m$ 意义下恰好为 $k$，那么只需要判断是否能填充一个合法的轮换，即是否存在 $m|lk$，其中 $l$ 是轮换长，满足 $l=n/(n,i)$。</p><p>但是这个柿子看上去就很不可优化……先咕一咕。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p>参考：</p><ul><li>《浅谈群论在信息学竞赛中的简单应用》虞皓翔，IOI中国国家候选队论文2019</li></ul><p>相关题目：</p><ol><li><a href="https://www.luogu.com.cn/problem/P2561">「AHOI2002」黑白瓷砖</a></li><li><a href="https://www.luogu.com.cn/problem/P1446">「HNOI2008」Cards</a></li><li><a href="https://www.luogu.com.cn/problem/P4980">「LG-P4980」Pólya 定理</a></li><li>暂无来源</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;置换群的相关内容主要用于解决一类“充满对称性”的计数问题。基于轨道-稳定子群定理的 Burnside 引理和引申出的 Pólya 计数原理是我们解决这类问题的有力工具……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="群论" scheme="https://big-news.cn/tags/%E7%BE%A4%E8%AE%BA/"/>
    
      <category term="置换群" scheme="https://big-news.cn/tags/%E7%BD%AE%E6%8D%A2%E7%BE%A4/"/>
    
      <category term="Burnside引理" scheme="https://big-news.cn/tags/Burnside%E5%BC%95%E7%90%86/"/>
    
      <category term="Pólya原理" scheme="https://big-news.cn/tags/Polya%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>李超线段树</title>
    <link href="https://big-news.cn/2020/11/02/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://big-news.cn/2020/11/02/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2020-11-02T09:11:00.000Z</published>
    <updated>2020-11-02T14:38:22.900Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，李超线段树是一类在二维平面上维护最值线段的线段树，某些情况下具有着和动态凸包相类似的功用……</p><a id="more"></a><p>看一个栗子：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>要求在平面直角坐标系中维护若干线段，支持加入一条线段和查询所有线段与直线 $x=k$ （$k$ 给出）交点纵坐标的最大值。<br>一条线段以两个端点 $(x_0,y_0),(x_1,y_1)$ 的形式给出。<br>$q,k,x_0,y_0,x_1,y_1\le 10^5$</p></div></article><p>考虑用线段树维护这些斜线。方便起见，我们将线段看成解析式的形式 $f_i(x)$。对于区间 $[l,r]$，它的中点是 $m$，我们定义 $f_i(x)$ 在这个区间上比 $f_j(x)$ 更具优势，当且仅当 $f_i(m)&gt;f_j(m)$。对于线段树上的每个节点，我们只保留它的最优势线段，这样就可操作了。</p><p>剩余的是两个问题：一条当前区间的劣势线段可能是子区间的优势线段；统计 $p$ 点处的答案时，不一定 $[p,p]$ 上存的线段是最优秀的线段。</p><p>对于第二个问题，我们只需要将线段树上从根到 $[p,p]$ 的祖孙链上的所有线段都统计一遍即可；对于第一个问题，可以考虑把劣势线段下放到它和保留线段（优势线段）有交的那个子区间里，然后递归操作即可。</p><p>根据主定理，这一部分的复杂度（更新某个区间）是 $O(\log n)$ 的，因此李超树插入的总复杂度为 $O(\log^2 n)$，查询的总复杂度为 $O(\log n)$，不过它的常数很小。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> DB EPS = <span class="number">1e-10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equ</span><span class="params">(DB a, DB b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(a - b) &lt;= EPS;&#125;</span><br><span class="line"><span class="keyword">int</span> n, lastans;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SEG</span> &#123;</span><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> l, r, id; DB yl, yr;  SEG() &#123;l = id = <span class="number">0</span>, r = <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function">DB <span class="title">slp</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (yr - yl) / (<span class="number">1.0</span> * (r - l));&#125;</span><br><span class="line">    <span class="function">DB <span class="title">mid</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (yl + yr) / <span class="number">2</span>;&#125;</span><br><span class="line">    <span class="function">DB <span class="title">val</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> l == r ? yl : yl + slp() * (x - l);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cl</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;yl = val(x), l = x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;yr = val(x), r = x;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">SEG <span class="title">mk</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    SEG o; o.l = a, o.yl = b, o.r = c, o.yr = d, o.id = e;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">le</span><span class="params">(SEG a, SEG b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.mid() &lt; b.mid() || (equ(a.mid(), b.mid()) &amp;&amp; a.id &gt; b.id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: SEG d[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, SEG x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.l &lt; l) x.cl(l); <span class="keyword">if</span>(x.r &gt; r) x.cr(r);</span><br><span class="line">        <span class="keyword">if</span>(le(d[k], x)) swap(d[k], x);</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x.slp() &lt; d[k].slp()) upd(l, m, lc, x);</span><br><span class="line">        <span class="keyword">else</span> upd(m + <span class="number">1</span>, r, rc, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, SEG x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.l &lt; l) x.cl(l); <span class="keyword">if</span>(x.r &gt; r) x.cr(r);</span><br><span class="line">        <span class="keyword">if</span>(x.l == l &amp;&amp; x.r == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(upd(l, r, k, x));</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x.l &lt;= m) md(l, m, lc, x);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; x.r) md(m + <span class="number">1</span>, r, rc, x);</span><br><span class="line">    &#125; </span><br><span class="line">    pair&lt;DB, int&gt; qu(int l, int r, int k, int p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> mp(d[k].mid(), d[k].id);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; pair&lt;DB, <span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) ans = qu(l, m, lc, p);</span><br><span class="line">        <span class="keyword">else</span> ans = qu(m + <span class="number">1</span>, r, rc, p);</span><br><span class="line">        <span class="keyword">if</span>(d[k].val(p) &gt; ans.first || (equ(d[k].val(p), ans.first) &amp;&amp; d[k].id &lt; ans.second))</span><br><span class="line">            ans.first = d[k].val(p), ans.second = d[k].id;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">return</span> (x + lastans - <span class="number">1</span>) % p + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    n = read(); <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tp = read(), a = read(), b, c, d;</span><br><span class="line">        <span class="keyword">if</span>(tp)&#123;</span><br><span class="line">            b = read(), c = read(), d = read();</span><br><span class="line">            a = enc(a, <span class="number">39989</span>), b = enc(b, <span class="number">1e9</span>), c = enc(c, <span class="number">39989</span>), d = enc(d, <span class="number">1e9</span>);</span><br><span class="line">            <span class="keyword">if</span>(a &gt; c) swap(a, c), swap(b, d);</span><br><span class="line">            D.md(<span class="number">1</span>, <span class="number">1e5</span>, <span class="number">1</span>, mk(a, b, c, d, ++cnt));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> a = enc(a, <span class="number">39989</span>),</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lastans = D.qu(<span class="number">1</span>, <span class="number">1e5</span>, <span class="number">1</span>, a).second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在斜率优化中的应用"><a href="#在斜率优化中的应用" class="headerlink" title="在斜率优化中的应用"></a>在斜率优化中的应用</h3><p>看这样一个斜率优化的经典模型：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个点依次排列，第 $i$ 个点有正数权值 $h_i$。你可以划一条线段连接两个点 $i,j$，费用是 $(h_i-h_j)^2$；要求你画的所有线段只能在端点处相交，且对于每个未被连接的点 $i$，需要支付 $w_i$ 的费用。<br>现在需要把 $1$ 号点和 $n$ 号点连接，求连接的最小费用。<br>$n\le 2\times 10^5, 0\le |w_i|, h_i\le 10^6$</p></div></article><p>设 $f[i]$ 为连接到 $i$ 的最小费用，设 $s_i$ 是 $w_i$ 的前缀和，有 $f[i] = \min\limits_{j=1}^{i-1}f[j]+(h_i-h_j)^2+s_{i-1}-s_j$。</p><p>我们可以考虑将其化为斜率优化的一般形式，设 $y_j=f[j]+h^2_j-s_j,b_j=-2h_ih_j+y_j$，则可以看成有一堆点 $(h_j,y_j)$，每次给出一个斜率 $-2h_i$，求纵轴截距 $b_j$ 的最小值。由于 $h_j$ 和 $-2h_i$ 均不单调，朴素斜率优化思路需要用 Splay 维护下凸包二分，或者 CDQ 分治，但是我都不会。</p><p>换一个思路：设 $f_i(x)=k_ix+y_i$，其中 $k_i=-2h_i,y_i=f[i]+h^2_i-s_i$，则我们在求 $h^2_i+s_{i-1}+\min\limits_{j=1}^{i-1} f_j(h_i)$。后面那个式子直接用李超树维护即可，由于这里的线段是直线，因此复杂度 $O(n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CV = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n; LL h[CN], s[CN];</span><br><span class="line"><span class="function">LL <span class="title">squ</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">return</span> x * x;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SEG</span> &#123;</span><span class="keyword">public</span>: LL k, b; SEG() &#123;b = <span class="number">1e18</span>;&#125; <span class="function">LL <span class="title">val</span><span class="params">(LL p)</span> </span>&#123;<span class="keyword">return</span> k * p + b;&#125;&#125; ;</span><br><span class="line"><span class="function">SEG <span class="title">mk</span><span class="params">(LL a, LL b)</span> </span>&#123;SEG o; o.k = a, o.b = b; <span class="keyword">return</span> o;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: SEG d[CV &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, SEG x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x.val(m) &lt; d[k].val(m)) swap(d[k], x);</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(x.k &gt; d[k].k) upd(l, m, lc, x); <span class="keyword">else</span> upd(m + <span class="number">1</span>, r, rc, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> d[k].val(p);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; LL ans = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) ans = qu(l, m, lc, p); <span class="keyword">else</span> ans = qu(m + <span class="number">1</span>, r, rc, p);</span><br><span class="line">        <span class="keyword">return</span> min(ans, d[k].val(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) h[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + read();</span><br><span class="line">    LL yi = squ(h[<span class="number">1</span>]) - s[<span class="number">1</span>], ki = <span class="number">-2</span> * h[<span class="number">1</span>], fi;</span><br><span class="line">    D.upd(<span class="number">1</span>, <span class="number">1e6</span>, <span class="number">1</span>, mk(ki, yi));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        fi = squ(h[i]) + s[i - <span class="number">1</span>] + D.qu(<span class="number">1</span>, <span class="number">1e6</span>, <span class="number">1</span>, h[i]), </span><br><span class="line">        yi = squ(h[i]) - s[i] + fi, ki = <span class="number">-2</span> * h[i],</span><br><span class="line">        D.upd(<span class="number">1</span>, <span class="number">1e6</span>, <span class="number">1</span>, mk(ki, yi));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, fi);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://www.luogu.com.cn/problem/P4097">「HEOI2013」Segment</a></li><li><a href="https://loj.ac/problem/2483">「CEOI2017」Building Bridges</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，李超线段树是一类在二维平面上维护最值线段的线段树，某些情况下具有着和动态凸包相类似的功用……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="线段树" scheme="https://big-news.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="李超树" scheme="https://big-news.cn/tags/%E6%9D%8E%E8%B6%85%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>整数划分问题</title>
    <link href="https://big-news.cn/2020/10/19/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/"/>
    <id>https://big-news.cn/2020/10/19/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-19T07:42:00.000Z</published>
    <updated>2020-10-19T08:55:37.500Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，整数划分问题是一类计算将正整数 $n$ 无序拆分成若干可相同的正整数之和的划分数的问题，存在一类普适性的 DP 解法以及针对划分数问题的五边形数定理……</p><a id="more"></a><p>先来看一道小学奥数题。</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给出 $n$ 个小球和  $m$ 个盒子，分别计算在以下情况中，将小球放入盒子（盒子不能是空）的方案数：</p><ol><li>小球和盒子都有标号</li><li>小球有标号，盒子无标号</li><li>小球无标号，盒子有标号</li><li>小球和盒子都没有标号</div></article></li></ol><p>显然，问题 1 可以通过简单容斥来求，即我们钦点有 $k$ 个盒子是空的，得到答案是 $\sum\limits_{k=0}^m (-1)^k \dbinom{m}{k} (m-k)^n$。注意到这本质上是第二类斯特林数乘上盒子数的阶乘（见<a href="/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/#2-5-%E7%AC%AC%E4%BA%8C%E7%B1%BB-Stirling-%E6%95%B0%E9%80%9A%E9%A1%B9">通项公式</a>），即 $m!\begin{Bmatrix}n\newline m \end{Bmatrix}$。</p><p>对于问题 2 ，这显然是第二类斯特林数 $\begin{Bmatrix}n\newline m \end{Bmatrix}$ 的定义（组合意义？）。</p><p>对于问题 3，因为小球不可区分，所以我们考虑插板。因为盒子不空，所以答案是 $\dbinom{n-1}{m-1}$。</p><p>至此前三个问题都在 $O(nm)$ 的时间内解决掉了，但是第四个问题呢？显然我们不能直接对 3 除一个 $m!$ 了事，一个最明显的反例就是得到的结果甚至不一定是整数！</p><p>我们考虑 DP。</p><h3 id="整数划分-DP"><a href="#整数划分-DP" class="headerlink" title="整数划分 DP"></a>整数划分 DP</h3><p>问题 4 可以被如下转化：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定正整数 $n$ ，求将 $n$ 分解为 $m$ 个正整数之和的方案数。两种方案不同当且仅当 $m$ 个正整数构成的集合不相同。<br>$n, m\le 5000$</p></div></article><p>设 $f[i,k]$ 为考虑将 $i$ 划成 $k$ 个正整数的方案数。对于当前的状态，我们可以将其划成两种情况：</p><ol><li>当前划分包含数字 1，方案是 $f[i-1,k-1]$</li><li>当前划分不含数字 1，考虑对划分出的每个数字减 1，方案数不变，得到方案数是 $f[i-k,k]$</li></ol><p>因此转移：<br>$$ f[i,k]=f[i-1,k-1]+f[i - k, k] $$ 时间复杂度 $O(nm)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt;= n; i++)</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j];</span><br></pre></td></tr></table></figure><h3 id="一个变形"><a href="#一个变形" class="headerlink" title="一个变形"></a>一个变形</h3><p>考虑这样一个问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定正整数 $n$ ，求将 $n$ 分解为若干个正整数之和的方案数。两种方案不同当且仅当划分出的正整数构成的集合不相同。<br>$Subtask1, n \le 5000$<br>$Subtask2,n\le 10^5$</p></div></article><ul><li>Subtask1</li></ul><p>考虑 DP，注意到这本质上就是一个完全背包计数：有 $n$ 个物品 $1,2,…,n$，选出一些让和为 $n$，物品可以取多次。然后就可以 $O(n^2)$ 快乐DP了，代码略。</p><ul><li>Subtask2</li></ul><p>注意到我们有两种求划分数的 DP：第一类状态设计为 $f[i,k]$ 考虑将 $i$ 划成 $k$ 个正整数的方案数，复杂度是 $O(nk)$，即划分个数乘上划分值域；第二类是完全背包计数，复杂度是 $O(nV)$，即元素个数乘上划分值域。</p><p>考虑复杂度均摊，设阈值 $B$，我们把能用的数字划分为 $[1,B]$ 和 $[B+1,n]$ 两部分。第一部分一共有 $B$ 个能用的数字，跑完全背包计数，复杂度 $O(nB)$；第二部分不会选择超过 $\frac{n}{B}$ 个，跑第一种 DP，复杂度 $O(\frac{n^2}{B})$。最后可以模拟卷积合并 DP 结果，取 $B = \lceil\sqrt{n}\rceil$，总复杂度 $O(n\sqrt{n})$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, n, P, f[CN], g[CN][<span class="number">400</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a + b &gt;= P ? a + b - P : a + b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> B = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n)); </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= B; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">        f[j] = add(f[j], f[j - i]);</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(B, i); j++)</span><br><span class="line">        g[i][j] = add(g[i - <span class="number">1</span>][j - <span class="number">1</span>], g[i - j][j]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(B, i); j++)</span><br><span class="line">        <span class="keyword">if</span>(i + j * B &lt;= n) <span class="comment">// 每个数都 +B </span></span><br><span class="line">            g[i + j * B][<span class="number">0</span>] = add(g[i + j * B][<span class="number">0</span>], g[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="comment">// 合并状态 </span></span><br><span class="line">        ans = add(ans, <span class="number">1l</span>l * f[i] * g[n - i][<span class="number">0</span>] % P);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这个问题是一类经典问题，被称作整数拆分问题，另一种解法是五边形数定理。</p><h3 id="五边形数定理"><a href="#五边形数定理" class="headerlink" title="五边形数定理"></a>五边形数定理</h3><ul><li>五边形数<br>形如 $p_n = p_{n-1}+3n-2$ 的数字被称作是五边形数，通项是 $p_n=\dfrac{n(3n-1)}{2}$。</li></ul><p>五边形数定理指出：<br>$$ \phi(x) = \prod\limits_{k\ge 1}(1-x^k)=\sum\limits_{k=-\infty}^{+\infty}(-1)^kx^{p_k} $$ 其中 $p_k$ 是五边形数。<br>设 $f_n$ 为 $n$ 的拆分数，$F(x)$ 是 $f_n$ 的 OGF，有：<br>$$ F(x)=1/\phi(x) $$ 即：<br>$$ (1-x-x^2+x^5+x^7-…)(1+f_1x+f_2x^2+f_3x^3+…)=1 $$ 比较系数得：<br>$$\begin{aligned} &amp;f_n-f_{n-1}-f_{n-2}+f_{n-5}+f_{n-7}-…=0 \newline \Leftrightarrow &amp;f_n=f_{n-1}+f_{n-2}-f_{n-5}-f_{n-7}\end{aligned}$$ 其中数列 $1,2,5,7,12,15,…$ 对应广义五边形数 $p_1,p_{-1},p_2,p_{-2},…$。</p><p>然后我们就可以愉快的递推 $f[]$ 了，可以证明这样做的复杂度为 $O(n\sqrt{n})$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a + b &gt;= P ? a + b - P : a + b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x * (<span class="number">3</span> * x - <span class="number">1</span>) / <span class="number">2</span>;&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; ;j++)&#123; </span><br><span class="line">        <span class="keyword">int</span> k = p(j); <span class="keyword">if</span>(k &gt; i) <span class="keyword">break</span>;</span><br><span class="line">        f[i] = add(f[i], j &amp; <span class="number">1</span> ? f[i - k] : P - f[i - k]);</span><br><span class="line">        k = p(-j); <span class="keyword">if</span>(k &gt; i) <span class="keyword">break</span>;</span><br><span class="line">        f[i] = add(f[i], j &amp; <span class="number">1</span> ? f[i - k] : P - f[i - k]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，整数划分问题是一类计算将正整数 $n$ 无序拆分成若干可相同的正整数之和的划分数的问题，存在一类普适性的 DP 解法以及针对划分数问题的五边形数定理……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="五边形数" scheme="https://big-news.cn/tags/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」洛谷十月月赛 II</title>
    <link href="https://big-news.cn/2020/10/18/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E5%8D%81%E6%9C%88%E6%9C%88%E8%B5%9B%20II/"/>
    <id>https://big-news.cn/2020/10/18/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E5%8D%81%E6%9C%88%E6%9C%88%E8%B5%9B%20II/</id>
    <published>2020-10-18T10:38:00.000Z</published>
    <updated>2020-10-21T11:17:06.379Z</updated>
    
    <content type="html"><![CDATA[<p>又是垫底的一天啊，凉心出题人再次让我感受到了没技术的弱小，不过还是水个题解吧……</p><a id="more"></a><h3 id="A-梦中梦与不再有梦"><a href="#A-梦中梦与不再有梦" class="headerlink" title="A 梦中梦与不再有梦"></a>A 梦中梦与不再有梦</h3><p>签到结论题。首先 $n=1$ 时答案为 0，$n=2$ 时答案为 1，然后考虑 $n\ge 3$：</p><ol><li>当 $n$ 是奇数时，由于图上不存在奇点，那么必然有欧拉回路，答案为 $\dbinom{n}{2}$</li><li>当 $n$ 是偶数时，因 $n\ge 3$，则图上存在多于两个奇点。我们只能保留其中两个，那么删掉 $n/2-1$ 个奇点，答案是 $\dbinom{n}{2}-n/2+1$</li></ol><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, n * (n - <span class="number">1</span>) / <span class="number">2</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (n * (n - <span class="number">1</span>) / <span class="number">2</span>) - (n / <span class="number">2</span>) + <span class="number">1</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;T = read(); <span class="keyword">while</span>(T--)&#123;n = read(), work();&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="B-深海少女与胖头鱼"><a href="#B-深海少女与胖头鱼" class="headerlink" title="B 深海少女与胖头鱼"></a>B 深海少女与胖头鱼</h3><p>设 $f(n,m)$ 为当前场面剩余 $n$ 个带盾的和 $m$ 个不带盾的时，剩余操作次数的期望。显然有：<br>$$ \begin{align} f(n,0) &amp;=2+\dfrac{1}{n}f(n-1,0)+\dfrac{n-1}{n}f(n-1,1)\tag 1 \newline f(n,1)&amp;=1+\dfrac{n}{n+1}f(n,1)+\dfrac{1}{n+1}f(n,0)\tag 2 \newline f(n,m)&amp;=1+\dfrac{m}{n+m}f(n,m-1)+\dfrac{n}{n+m}f(n+m-1,1)\tag 3 | m&gt;1 \end{align} $$ 我们令 $(2)$ 代 $(1)$ 得：<br>$$ \begin{aligned} f(n,0)&amp;=n+1+f(n-1,0) \newline f(n,1)&amp;=n+1+f(n,0)  \end{aligned} $$ 归纳可得：<br>$$ f(n,0)=\dfrac{n(n+3)}{2},f(n,1)=n+1+\dfrac{n(n+3)}{2} $$ 于是 $m\le 1$ 的情况做完了，对于 $m&gt;1$ 的情况，根据 $(3)$ 式，容易发现此时分成了 $f(·,m-1)$ 和 $f(·,1)$ 两部分，然后就可以愉快的 $O(m)$ 递推了。</p><p>代码，常数不小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i2 = <span class="number">499122177</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a + b &gt;= P ? a + b - P : a + b;&#125;</span><br><span class="line"><span class="keyword">int</span> n, nn, nN, m, f[CN];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read() % P, m = read(), nn = <span class="number">1l</span>l * n * i2 % P, nN = add(n, <span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1l</span>l * nn * (n + <span class="number">3</span>) % P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> M = add(n, i), t;</span><br><span class="line">        t = add(add(M, <span class="number">1</span>), P - (<span class="number">2l</span>l * qp(M, P - <span class="number">2</span>) % P));</span><br><span class="line">        t = <span class="number">1l</span>l * t * nn % P;</span><br><span class="line">        f[i] = add(t, nN);</span><br><span class="line">        t = <span class="number">1l</span>l * i * qp(add(n, i), P - <span class="number">2</span>) % P;</span><br><span class="line">        t = <span class="number">1l</span>l * t * f[i - <span class="number">1</span>] % P;</span><br><span class="line">        f[i] = add(f[i], t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-蝴蝶与花"><a href="#C-蝴蝶与花" class="headerlink" title="C 蝴蝶与花"></a>C 蝴蝶与花</h3><p>不会/kk</p><h3 id="D-象棋与马"><a href="#D-象棋与马" class="headerlink" title="D 象棋与马"></a>D 象棋与马</h3><p>首先考虑 $p(a,b)$ 什么时候能等于 1。</p><p>显然有一个必要条件是 $(a,b)=1$，但是样例就已经说明了这不是充分的；这时候打个表就会发现第二个条件是 $|a-b| \text{ mod } 2 = 1$。</p><p>于是就变成了求 $\sum\limits_{i=1}^n\sum\limits_{j=1}^n [(i,j)=1][|i-j|\text{ mod }2=1]$，显然原式等于 $2\sum\limits_{i=1}^n\sum\limits_{j=1}^i [(i,j)=1][|i-j|\text{ mod }2=1]$，我们考虑求后面这个和式。</p><p>考虑对于偶数 $i$，因为偶数不可能和偶数互质，那么其贡献应当是 $\varphi(i)$。对于奇数 $i$，因为与其互质的数有一半是奇数，一半是偶数，所以其贡献应当是 $\dfrac{\varphi(i)}{2}$。所以我们在求：<br>$$ \sum\limits_{i=1}^n [i\text{ mod }2=0]\varphi(i)+\sum\limits_{i=1}^n [i\text{ mod }2=1]\dfrac{\varphi(i)}{2} $$ 剩下的就是杜教筛和常数的事了。可是我不会杜教筛啊/kk 流下没技术的泪水……</p><p>50 分辣鸡代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e7</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> phi[CN], p[CN]; <span class="keyword">bool</span> np[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    np[<span class="number">1</span>] = <span class="number">1</span>, phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) p[++p[<span class="number">0</span>]] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p[<span class="number">0</span>] &amp;&amp; i * p[j] &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i * p[j]; np[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j]) phi[x] = (p[j] - <span class="number">1</span>) * phi[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;phi[x] = p[j] * phi[i]; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sieve(<span class="number">1e7</span>), T = read();</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        n = read(); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>) ans += phi[i] &gt;&gt; <span class="number">1u</span>ll;</span><br><span class="line">            <span class="keyword">else</span> ans += phi[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%llu"</span>, ans &lt;&lt; <span class="number">1u</span>ll), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是垫底的一天啊，凉心出题人再次让我感受到了没技术的弱小，不过还是水个题解吧……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
  </entry>
  
  <entry>
    <title>考前的小知识积累</title>
    <link href="https://big-news.cn/2020/10/16/%E8%80%83%E5%89%8D%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <id>https://big-news.cn/2020/10/16/%E8%80%83%E5%89%8D%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/</id>
    <published>2020-10-16T12:05:00.000Z</published>
    <updated>2020-10-22T07:27:43.858Z</updated>
    
    <content type="html"><![CDATA[<p>快考试了，整理一下最近学到的细碎的东西。东西很杂，也有一些叫不上名字来，简单写写吧……</p><a id="more"></a><h3 id="max-矩阵乘法"><a href="#max-矩阵乘法" class="headerlink" title="max+ 矩阵乘法"></a>max+ 矩阵乘法</h3><p>定义一类新矩阵乘法：<br>$$ C= A * B\Leftrightarrow C_{i,j}=\max\limits_{i,j,k}A_{i,k}+B_{k,j} $$ 为矩阵的 max+ 乘法。注意到这类乘法是满足结合律的，因此可以快速幂优化。这类乘法的本质类似于一轮 Floyd 传递闭包。</p><p>相关题目：<a href="https://www.luogu.com.cn/problem/P3502">Hamsters</a></p><h3 id="max-卷积"><a href="#max-卷积" class="headerlink" title="max+ 卷积"></a>max+ 卷积</h3><p>定义一类新的序列卷积：<br>$$ C=A*B\Leftrightarrow C_k=\max\limits_{i+j=k}A_i+B_j $$ 这类卷积很难做到低于 $O(n^2)$ 的复杂度内计算，但是如果 $A,B$ 都是离散意义下的凸函数的话，可以做到 $O(n\log n)$ 计算，方法如下：</p><p>把序列 $A,B$ 分别排序后差分，把得到的增量合并到一个序列中降序排序，这会得到一个长度为 $2n-2$ 的新序列，记为 $\text{d}$。注意到必然有 $C_0=A_0+B_0$，我们下一步需要按从大到小的顺序把增量加进去，即有 $C_1=C_0+\text{d}_0, C_i=C_{i-1}+\text{d}_{i - 1}$，于是就还原出了卷积后的结果 $C$，时间复杂度只有排序的 $O(n\log n)$。</p><p>这种做法的正确性在于：对于凸函数而言，增量 $\text{d}$ 的可取范围与其大小是相应变化的。那么如果做凹函数的 min+ 卷积的时候，也可以适用类似的做法。</p><h3 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h3><p>有一种普适性的在亚线性时间复杂度内，解决一类距离最值问题的方法，通俗的叫法好像叫做斜率优化。</p><p>这类问题的一般模型是：定义一类新的距离 $\text{dist}(i,j)=A_i+B_j+C_iD_j$，求 $\min\limits_{i,j}\text{dist}(i,j)$。注意到关于 $i, j$ 的下标运算是二次的，因此无法拆开来简单维护。</p><p>考虑枚举 $i$，转化为求如下式的值：$p + \min\limits_{1\le j\le n} B_j+kD_j$，设有 $l_j=B_j+kD_j$，得到 $B_j=-kD_j+l_j$，这是一条过定点 $(D_j, B_j)$，斜率为 $-k$ 的直线，而我们要最小化的东西是这条直线的截距 $l_j$。</p><p>那么现在等价于给出一堆点 $(D_1,B_1),(D_2,B_2),…,(D_n,B_n)$ 和一个斜率 $-k$，让我们求一条直线使得截距最小。显然，所求点必然在这些点形成的下凸壳上，那么维护出下凸壳二分即可。<br>有时斜率给出的性质特殊，则可以单调维护；当点的选取范围有要求时，可以结合单调栈 / 线段树。</p><p>给出一个示例：求 $\min\limits_{i,j}a_i+b_j+(i-j)^2$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stk[++top] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span>(top &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        u = stk[top], v = stk[top - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1l</span>l * (b[u] - b[v]) * (i - u) &lt; <span class="number">1l</span>l * (b[i] - b[u]) * (u - v)) <span class="keyword">break</span>;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>, ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> u = stk[p], v = stk[p + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(p &lt; top &amp;&amp; b[v] - <span class="number">2</span> * i * v &lt; b[u] - <span class="number">2</span> * i * u) </span><br><span class="line">        p++, u = v, v = stk[p + <span class="number">1</span>];</span><br><span class="line">    u = stk[p], ans = min(ans, a[i] + b[u] - <span class="number">2</span> * i * u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关题目：<a href="http://oj.big-news.cn/problem/22">Thief</a></p><h3 id="常幂展开在贡献法中的应用"><a href="#常幂展开在贡献法中的应用" class="headerlink" title="常幂展开在贡献法中的应用"></a>常幂展开在贡献法中的应用</h3><p>看一道好题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给出简单无向图 $G=(V,E)$，设 $S=(V_S,E_S)$ 为 $G$ 的某个导出子图，求 $\sum\limits_{S\subseteq G}|E_S|^k$。<br>$|V|,|E|\le 10^5, 1\le k\le 3$</p></div></article><p>显然，当 $k=1$ 时，我们可以运用<strong>贡献法</strong>考虑每条边对答案的贡献，因此得到答案即是 $|E|2^{|V|-2}$。</p><p>但是当 $k\ge 2$ 时，因为乘幂运算的缘故，直接使用贡献法是不可以的。根据<a href="/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/#1-2-%E5%B8%B8%E5%B9%82%E5%B1%95%E5%BC%80">常幂展开</a>公式，我们可以这样给柿子变形：<br>$$ \begin{aligned}\sum\limits_{S\subseteq G}|E_S|^k= \sum\limits_{i=0}^k \begin{Bmatrix}k\newline i\end{Bmatrix}i!\sum\limits_{S\subseteq G}\dbinom{|E_S|}{i}   \end{aligned} $$ 注意到这是求和，因此贡献法又适用了，那我们可以考虑求后面的 $\sum\limits_{S\subseteq G}\dbinom{|E_S|}{i}$。<br>考虑这个柿子的意义，我们可以等价于在原图中任意钦点 $i$ 条边出来，统计所有情况下包含 $i$ 条边的导出子图的数量。即我们考虑钦点一个组合数选出来的东西，然后考虑它的贡献，即它被选到的次数。</p><p>我们分类讨论。设边数为 $m$，点数为 $n$，对于 $k=2(i=(0),1,2)$ 的情况，可以这样分类：</p><ol><li>$i=1$，即选一条边，显然是 $m2^{n-2}$；</li><li>$i=2$，即选两条边。注意到两条边可以共用一个端点，或者有四个独立的端点。我们只需要对这两种情况分别统计“方案数x被导出子图包含的次数”即可。</li></ol><p>$k=3$ 的情况也可以类似的进行分类，于是就可以完成了。复杂度的瓶颈在于 $k=3$ 时的三元环计数，因此复杂度 $O(m^{1.5})$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i2 = <span class="number">5e8</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i3 = <span class="number">333333336</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l * (<span class="number">1l</span>l * x * (x - <span class="number">1</span>) % P) * i2 % P;&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, pw[CN], du[CN]; </span><br><span class="line"><span class="keyword">namespace</span> sub1 &#123;<span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">"%lld"</span>, <span class="number">1l</span>l * m * pw[n - <span class="number">2</span>] % P);&#125;&#125;</span><br><span class="line"><span class="keyword">namespace</span> sub2 &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1l</span>l * m * pw[n - <span class="number">2</span>] % P, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>; <span class="comment">// i = 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(); du[x]++, du[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s1 = add(s1, C(du[i]));</span><br><span class="line">    s2 = add(C(m), P - s1);</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">3</span>) s1 = <span class="number">1l</span>l * s1 * pw[n - <span class="number">3</span>] % P; <span class="keyword">else</span> s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">4</span>) s2 = <span class="number">1l</span>l * s2 * pw[n - <span class="number">4</span>] % P; <span class="keyword">else</span> s2 = <span class="number">0</span>;</span><br><span class="line">    s1 = add(s1, s2);</span><br><span class="line">    ans = add(ans, add(s1, s1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">namespace</span> sub3 &#123;</span><br><span class="line"><span class="keyword">int</span> X[CN], Y[CN], col[CN]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">le</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> du[i] ^ du[j] ? du[i] &lt; du[j] : i &lt; j;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt1 = <span class="number">1l</span>l * m * pw[n - <span class="number">2</span>] % P, cnt2 = <span class="number">0</span>, cnt3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(); </span><br><span class="line">        du[x]++, du[y]++, X[i] = x, Y[i] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s4 = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">/* cnt2 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s1 = add(s1, C(du[i]));</span><br><span class="line">    s2 = add(C(m), P - s1);</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">3</span>) s1 = <span class="number">1l</span>l * s1 * pw[n - <span class="number">3</span>] % P;</span><br><span class="line">    <span class="keyword">else</span> s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">4</span>) s2 = <span class="number">1l</span>l * s2 * pw[n - <span class="number">4</span>] % P;</span><br><span class="line">    <span class="keyword">else</span> s2 = <span class="number">0</span>;</span><br><span class="line">    cnt2 = add(s1, s2);</span><br><span class="line">    <span class="comment">/* cnt3 */</span></span><br><span class="line">    s1 = s2 = s3 = s4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = X[i], v = Y[i];</span><br><span class="line">        <span class="keyword">if</span>(le(u, v)) G[v].pb(u); <span class="comment">// v &gt; u : v -&gt; u</span></span><br><span class="line">        <span class="keyword">else</span> G[u].pb(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = G[i].size(), j = <span class="number">0</span>; j &lt; l; j++) col[G[i][j]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = G[i].size(), t = <span class="number">0</span>; t &lt; l; t++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = G[i][t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ll = G[j].size(), tt = <span class="number">0</span>; tt &lt; ll; tt++)</span><br><span class="line">                <span class="keyword">if</span>(col[G[j][tt]] == i) s1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) s2 = add(s2, <span class="number">1l</span>l * (du[X[i]] - <span class="number">1</span>) * (du[Y[i]] - <span class="number">1</span>) % P);</span><br><span class="line">    s2 = add(s2, P - (<span class="number">3l</span>l * s1 % P));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s3 = add(s3, <span class="number">1l</span>l * C(du[i]) * (m - du[i]) % P);</span><br><span class="line">    s3 = add(s3, P - add(<span class="number">3l</span>l * s1 % P, <span class="number">2l</span>l * s2 % P));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1l</span>l * C(du[i]) * (du[i] - <span class="number">2</span>) % P; cur = <span class="number">1l</span>l * cur * i3 % P;</span><br><span class="line">        s2 = add(s2, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    s4 = <span class="number">1l</span>l * C(m) * (m - <span class="number">2</span>) % P, s4 = <span class="number">1l</span>l * s4 * i3 % P;</span><br><span class="line">    s4 = add(s4, P - add(add(s1, s2), s3));</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">3</span>) s1 = <span class="number">1l</span>l * s1 * pw[n - <span class="number">3</span>] % P; <span class="keyword">else</span> s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">4</span>) s2 = <span class="number">1l</span>l * s2 * pw[n - <span class="number">4</span>] % P; <span class="keyword">else</span> s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">5</span>) s3 = <span class="number">1l</span>l * s3 * pw[n - <span class="number">5</span>] % P; <span class="keyword">else</span> s3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">6</span>) s4 = <span class="number">1l</span>l * s4 * pw[n - <span class="number">6</span>] % P; <span class="keyword">else</span> s4 = <span class="number">0</span>;</span><br><span class="line">    cnt3 = add(add(s1, s2), add(s3, s4));</span><br><span class="line">    <span class="comment">/* answer */</span></span><br><span class="line">    cnt2 = <span class="number">6l</span>l * cnt2 % P, cnt3 = <span class="number">6l</span>l * cnt3 % P;</span><br><span class="line">    ans = add(cnt1, add(cnt2, cnt3)), <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), k = read();</span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pw[i] = add(pw[i - <span class="number">1</span>], pw[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) sub1 :: work();</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">2</span>) sub2 :: work();</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">3</span>) sub3 :: work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lorem-Ipsum"><a href="#Lorem-Ipsum" class="headerlink" title="Lorem Ipsum"></a>Lorem Ipsum</h3><p>一个新的技巧：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>众所周知，将 $m$ 划分为 $n$ 个非负整数有 $\dbinom{m+n-1}{n-1}$ 种方案。对于任意方案 $P$，我们定义 $val_k(P)$ 表示该划分中第 $k$ 大的数（降序排序后的第 $k$ 个）。设 $S$ 为总方案集，现在给定 $m,n,k$，请求出 $\sum\limits_{P\in S}val_k(P)$。<br>$n,m\le 5000$</p></div></article><p>设 $f[k,l]$ 表示一个划分中至少有 $k$ 个数字 $\ge l$ 的划分的数量。首先有等式：<br>$$ \sum\limits_{P\in S} val_k(P) =\sum\limits_{l=1}^mf[k,l] $$ 这个可以这样理解：我们考虑对于任意一个方案中第 $k$ 大的数，设它是 $p$，那么对于 $\forall l\le p$ 的 $f[k,l]$，$p$ 都会在 $f[k,l]$ 中被累加一次，一共累加 $p$ 次，因此这样是正确的。</p><p>那么现在的问题是求出“至少有 $k$ 个数字 $\ge l$ 的划分数”，这是一个“至少”限制，因此不可以直接选出来。可以这样理解：直接拿组合数选出来的是“钦定某 $k$ 个数字 $\ge l$ 的划分数”，而我们要求的是“有任意至少 $k$ 个数字 $\ge l$ 的划分数”。</p><p>形式化的说，设 $g[k,l]$ 为“恰好 $k$ 个数字 $\ge l$ 的划分数”，$h[k,l]$ 为“钦定 $k$ 个数字 $\ge l$ 的划分数”，$f[k,l]$ 为“至少有 $k$ 个数字 $\ge l$ 的划分数”，那么有：<br>$$ \begin{align} h[k,l]&amp;=\dbinom{n}{k}\dbinom{m-kl+n-1}{n-1}\newline &amp;=\sum\limits_{j=k}^n\dbinom{j}{k}g[j,l] \newline \Leftrightarrow g[k,l]&amp;=\sum\limits_{j=k}^n(-1)^{j-k}\dbinom{j}{k}\dbinom{n}{k}\dbinom{m-kl+n-1}{n-1} \end{align}$$ 即是二项式反演，注意到这里实现了“钦定”到“恰好”的转化。“恰好”到“至少”的转化也可以类似的表示：<br>$$ \begin{align} f[k,l]&amp;=\sum\limits_{j=k}^n g[j,l]\newline \Leftrightarrow g[k,l]&amp;=f[k,l]-f[k+1,l] \end{align} $$ 总结来说，二项式反演联系了“钦定”与“恰好”限制，前/后缀和和差分联系了“至少”和“恰好”限制。</p><h3 id="用-set-维护线段覆盖"><a href="#用-set-维护线段覆盖" class="headerlink" title="用 set 维护线段覆盖"></a>用 set 维护线段覆盖</h3><p>看这样一个问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给出 $n$ 条线段 $[l_1,r_1],…[l_n,r_n]$，$q$ 次询问编号在 $[a,b]$ 内的线段覆盖的总长度是多少。<br>$n,q\le 10^5, l_i, r_i \le 10^9$</p></div></article><p>首先离线询问，把每个询问挂在询问区间的右端点上。考虑枚举询问的右端点 $b$，并用数据结构来维护每个 $i(i\le b)$ 的答案。</p><p>考虑怎样能快速地维护。如果对数轴上的每一个点维护一下它最后一次被覆盖是在什么时候（没覆盖就是 0），那么可以发现数轴会被划分成若干值相同的连续段。注意到同一时刻连续段的数量只有 $O(n)$ 种，那么我们考虑用 set 去维护这个东西。</p><p>具体来说，我们可以维护一个二元组 $(r,t)$，其中 $r$ 是当前连续段的分界点（右端点），$t$ 是当前连续段最晚被覆盖的时间。我们考虑新加入一个段 $(r_i,i)$，那么首先所有与其有交的连续段都会受到影响。具体来说，会有一些连续段被完全覆盖，即等价于删除，还有至多两个连续段会被分裂成两部分，其中一部分被保留，另一部分被替代。</p><p>我们考虑如果删除了一个连续段 $(r’,t’)$，它的长度是 $l$，那么左端点在 $[t’+1,i]$ 内区间的答案都会被加上 $l$，因为当前连续段的影响从 $t’$ 扩大到了 $i$。那么我们需要一个数据结构，支持区间加和单点求值，那么套一个 BIT 就可以解决了。时间复杂度是 $O(n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter set<span class="meta-string">&lt;PAIR&gt; :: iterator</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) ne = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PAIR</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> PAIR &amp;o) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x ^ o.x ? x &lt; o.x : y &lt; o.y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">PAIR <span class="title">mp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;PAIR o; o.x = a, o.y = b; <span class="keyword">return</span> o;&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;PAIR&gt; S; <span class="built_in">vector</span>&lt;PAIR&gt; Q[CN];</span><br><span class="line"><span class="keyword">int</span> n, m, L[CN], R[CN], ans[CN];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(p &lt;= n) d[p] += x, p += p &amp; (-p);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;add(l, x), add(r + <span class="number">1</span>, -x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(p) r += d[p], p -= p &amp; (-p); <span class="keyword">return</span> r;&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) L[i] = read(), R[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">        Q[r].pb(mp(l, i));</span><br><span class="line">    &#125;</span><br><span class="line">    S.insert(mp(<span class="number">1e9</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = L[i], r = R[i], fst = <span class="number">-1</span>, prv = l - <span class="number">1</span>;</span><br><span class="line">        iter it = S.lower_bound(mp(l, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it == S.end()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = (*it).x, p = (*it).y, len;</span><br><span class="line">            <span class="keyword">if</span>(fst &lt; <span class="number">0</span>) fst = p;</span><br><span class="line">            len = min(cur, r) - prv, D.md(p + <span class="number">1</span>, i, len);</span><br><span class="line">            <span class="keyword">if</span>(cur &lt;= r)&#123;</span><br><span class="line">                prv = cur;</span><br><span class="line">                iter pit = it; it++, S.erase(pit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; <span class="number">1</span>) S.insert(mp(l - <span class="number">1</span>, fst));</span><br><span class="line">        S.insert(mp(r, i));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = Q[i].size(), j = <span class="number">0</span>; j &lt; l; j++)</span><br><span class="line">            ans[Q[i][j].y] = D.qu(Q[i][j].x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快考试了，整理一下最近学到的细碎的东西。东西很杂，也有一些叫不上名字来，简单写写吧……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>圆方树</title>
    <link href="https://big-news.cn/2020/09/21/%E5%9C%86%E6%96%B9%E6%A0%91/"/>
    <id>https://big-news.cn/2020/09/21/%E5%9C%86%E6%96%B9%E6%A0%91/</id>
    <published>2020-09-21T06:15:00.000Z</published>
    <updated>2020-09-27T03:48:20.670Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，圆方树是用以解决一类仙人掌图问题的重构树，但是类似的方法也可以用来解决某些普通无向图问题。依赖于其优美的树形结构，我们可以在 $\log |V|$ 的时间复杂度内回答一类图上的点对路径并集的询问问题……</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>我们对一张联通无向图的每个 BCC（点双连通分量）建一个方点，原图上每个点作为一个圆点。对于不在环上的点，保留它们之间的边；对于环上的点，把它们和对应的方点相连边，就得到了一棵圆方树，如下图。</p><p><img src="/pictures/1126418-20190711015718548-2063534813.png" alt="圆方树的构建"></p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>这里使用的是 <code>PinkRabbit</code> 兔队的<a href="https://www.cnblogs.com/PinkRabbit/p/10446473.html#codeforces-487etourists">构建方法</a>，用于一般无向图的圆方树构建。注意，对于仙人掌图的圆方树构建，可以在 dfs 中枚举返祖边来完成，它的好处在于能求出环上的点的顺序，以便于维护环上路径信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, ext = n; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ext++; <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], T[ext].push_back(v), T[v].push_back(ext);</span><br><span class="line">                T[ext].push_back(u), T[u].push_back(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，$q$ 次询问 $u,v$ 之间的割点的数量。<br>$n,m,q\le 5\times 10^5$</p></div></article><p>容易发现答案就是圆方树上 $u\to v$ 的路径上圆点的数量，倍增维护即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, ext, fa[CN][<span class="number">21</span>]; <span class="keyword">bool</span> w[CN]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u, w[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ext++, fa[ext][<span class="number">0</span>] = u, T[u].push_back(ext);</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], fa[pos][<span class="number">0</span>] = ext, T[ext].push_back(pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[CN], dep[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dep[u] = dep[p] + <span class="number">1</span>, dis[u] = dis[p] + w[u];</span><br><span class="line">    <span class="keyword">int</span> sz = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) dfs(T[u][i], u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ext = n = read(), m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bd(<span class="number">1</span>, <span class="number">0</span>), dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(), l = lca(x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, dis[x] + dis[y] - dis[l] - dis[ fa[l][<span class="number">0</span>] ]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，问有多少三元组 $(s,c,f)$ 满足存在一条 $s\to f$ 的路径经过 $c$。<br>$n,m\le 2\times 10^5$</p></div></article><p>题目本质上就是在求 $s\to f$ 的简单路径的并集大小。</p><p>有一个经典结论：</p><ol><li>一张无向图上相同 BCC 中两个点 $(u,v)$ 之间的简单路径并集恰好是这个 BCC</li><li>一张无向图上不同 BCC 中两个点 $(u,v)$ 之间的简单路径并集是这两个 BCC 并上把它们连接的点</li></ol><p>于是可以圆方树上的点恰当赋值：方点点权为该 BCC 的大小，圆点点权为 $-1$。那么 $s\to f$ 在树上的路径权就是合法的 $c$ 的数量。</p><p>考虑计算所有圆点对 $(s,f)$ 的路径长度和。运用贡献法去想，答案是每个 $w[u]$（即点权）乘上经过这个点的路径数量。经过 $u$ 的路径可以分为两种：从 $u$ 子树内到 $u$ 子树外；$u$ 子树内兄弟节点之间的路径。前者的数量是 $sz[u]\times (n-sz[u])$，后者的数量大概是 $\dbinom{sz[u]}{2}$ 再减去若干部分，直接在 dfs 的过程中计算即可，时间复杂度 $O(n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar(); <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> s * ne;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, ext, w[CN], num; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u, w[u] = <span class="number">-1</span>, num++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ext++, T[u].push_back(ext);</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>; w[ext] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], T[ext].push_back(pos), w[ext]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>; <span class="keyword">int</span> sz[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[u].size(); sz[u] = u &lt;= n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) dfs(T[u][i]), ans += <span class="number">1l</span>l * sz[u] * sz[ T[u][i] ] * w[u], sz[u] += sz[ T[u][i] ];</span><br><span class="line">    ans += <span class="number">1l</span>l * sz[u] * (num - sz[u]) * w[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    ext = n = read(), m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!dfn[i]) num = <span class="number">0</span>, bd(i, <span class="number">0</span>), dfs(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，点有点权，$q$ 次询问 $u\to v$ 的可行简单路径上权值最小值，支持修改点权。<br>$n,m,q\le 10^5$</p></div></article><p>注意到如果不带修改，直接圆方树上倍增即可。带修的话，显然的想法是重链剖分之后套个线段树。</p><p>但是这样有个问题，就是修改一个圆点需要修改所有与其相连的方点，这样实际上是 $O(n)$ 的。<br>我们考虑利用圆方树的性质，把方点的点权设为它的儿子的权值最小值，那么因为一个圆点至多有一个方点作为父亲，这样修改就变成了 $O(1)$ 的。<br>但是这样查询的时候如果方点的父亲没被访问到，即方点作为 lca 的情况，还需要对这个方点的父亲的权值取 $\min$。</p><p>时间复杂度 $O(n\log^2 n)$，常数不小，因为实际上我们需要一个 <code>multiset</code> 去维护方点的点权……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar(); <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> s * ne;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; </span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; val[CN]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], dfc = <span class="number">0</span>, w[CN], ext = <span class="number">0</span>, stk[CN], tp = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++dfc, stk[++tp] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>; ext++;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) </span><br><span class="line">                    pos = stk[tp--], T[ext].push_back(pos), val[ext].insert(w[pos]);</span><br><span class="line">                w[ext] = *val[ext].begin(), T[u].push_back(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[k] = x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(l, m, lc, p, x); <span class="keyword">else</span> md(m + <span class="number">1</span>, r, rc, p, x);</span><br><span class="line">        d[k] = min(d[lc], d[rc]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> d[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = INF;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = qu(l, m, lc, s, t);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = min(ans, qu(m + <span class="number">1</span>, r, rc, s, t));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[CN], id[CN], idx = <span class="number">0</span>, top[CN], imp[CN], sz[CN], fa[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u] = p, dep[u] = dep[p] + <span class="number">1</span>, sz[u] = <span class="number">1</span>; <span class="keyword">int</span> mx = <span class="number">0</span>, l = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = T[u][i]; </span><br><span class="line">        dfs1(v, u), sz[u] += sz[v], imp[u] = mx &lt; sz[v] ? mx = sz[v], v : imp[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    id[u] = ++idx, D.md(<span class="number">1</span>, ext, <span class="number">1</span>, id[u], w[u]), top[u] = t;</span><br><span class="line">    <span class="keyword">if</span>(imp[u]) dfs2(imp[u], t); <span class="keyword">int</span> l = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = T[u][i]; </span><br><span class="line">        <span class="keyword">if</span>(v ^ imp[u]) dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">while</span>(top[x] ^ top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[ top[x] ] &lt; dep[ top[y] ]) swap(x, y);</span><br><span class="line">        ans = min(ans, D.qu(<span class="number">1</span>, ext, <span class="number">1</span>, id[ top[x] ], id[x]));</span><br><span class="line">        x = fa[ top[x] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    ans = min(ans, D.qu(<span class="number">1</span>, ext, <span class="number">1</span>, id[y], id[x]));</span><br><span class="line">    <span class="keyword">if</span>(y &gt; n) ans = min(ans, w[ fa[y] ]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    ext = n = read(), m = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) w[i] = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bd(<span class="number">1</span>, <span class="number">0</span>), dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">char</span> c;  <span class="built_in">cin</span> &gt;&gt; c; <span class="keyword">int</span> a = read(), b = read();</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'C'</span>)&#123;</span><br><span class="line">            D.md(<span class="number">1</span>, ext, <span class="number">1</span>, id[a], b); <span class="keyword">int</span> f = fa[a];</span><br><span class="line">            <span class="keyword">if</span>(f &gt; n)&#123;</span><br><span class="line">                val[f].erase(w[a]), val[f].insert(b);</span><br><span class="line">                <span class="keyword">if</span>(*val[f].begin() ^ w[f]) w[f] = *val[f].begin(), D.md(<span class="number">1</span>, ext, <span class="number">1</span>, id[f], w[f]);</span><br><span class="line">            &#125;</span><br><span class="line">            w[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, qu(a, b)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，$q$ 次询问，每次询问给出一个点集 $S$，问有多少点满足在图上删除该点后，$\exists u,v\in S$，$u,v$ 在图上不连通。<br>$n,m\le 10^5, \sum|S_i|\le 2\times 10^5$</p></div></article><p>“圆方树上圆方果，<br>“圆方树下你和我，<br>“圆方树前建虚树，<br>“欢乐多又多。</p><p>Subtask2 $|S_i|=2$ 两点间割点数量等于圆方树上点对路径上的圆点数量，则直接在圆方树上倍增即可。<br>Subtask3 考虑建出圆方树的虚树来，然后就可以简单树形 DP 了，时间复杂度 $O(n)-O(|S_i|\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar(); <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> s * ne;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> TC, n, m, q, id[CN]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[CN], T[CN], S[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[CN], top = <span class="number">0</span>, dfn[CN], low[CN], idx = <span class="number">0</span>, ext;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u;</span><br><span class="line">    <span class="keyword">int</span> l = G[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123; <span class="comment">// dfn[] 需要清空!!!</span></span><br><span class="line">            tarjan(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[u] == low[v])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>; T[u].push_back(++ext), T[ext].clear(); </span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], T[ext].push_back(pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[CN], fa[CN][<span class="number">21</span>], dis[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = ++idx, fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dis[u] = dis[p] + (u &lt;= n);</span><br><span class="line">    <span class="keyword">int</span> l = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) dfs(T[u][i], u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125; <span class="keyword">int</span> rt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    rt = stk[top = <span class="number">1</span>] = a[<span class="number">1</span>], S[ a[<span class="number">1</span>] ].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = a[i], l = lca(u, stk[top]); <span class="keyword">if</span>(dfn[l] &lt; dfn[rt]) rt = l;</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span> ] ] &gt; dfn[l]) S[ stk[top - <span class="number">1</span>] ].push_back(stk[top]), top--;</span><br><span class="line">            <span class="keyword">if</span>(stk[top - <span class="number">1</span>] ^ l) S[l].clear(), S[l].push_back(stk[top]), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> S[l].push_back(stk[top--]);</span><br><span class="line">        &#125;</span><br><span class="line">        S[u].clear(), stk[++top] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) S[ stk[i] ].push_back(stk[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = S[u].size(); f[u] = u &lt;= n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = S[u][i]; </span><br><span class="line">        dp(v), f[u] += f[v] + dis[ fa[v][<span class="number">0</span>] ] - dis[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    TC = read(); <span class="keyword">while</span>(TC--)&#123;</span><br><span class="line">        ext = n = read(), m = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear(), T[i].clear();</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = read(), v = read(); G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn)), idx = top = <span class="number">0</span>, tarjan(<span class="number">1</span>, <span class="number">0</span>), idx = <span class="number">0</span>, dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ext; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        q = read();</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            id[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id[<span class="number">0</span>]; i++) id[i] = read();</span><br><span class="line">            build(id, id[<span class="number">0</span>]), dp(rt), <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[rt] - id[<span class="number">0</span>]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://www.luogu.com.cn/problem/P4320">「LG-P4320」道路相遇</a></li><li><a href="https://loj.ac/problem/2587">「APIO2018」Duathlon</a></li><li><a href="https://codeforces.com/problemset/problem/487/E">「CF487E」Tourists</a></li><li><a href="https://www.luogu.com.cn/problem/P4606">「SDOI2018」战略游戏</a></li></ol><p>习题<br><a href="https://www.luogu.com.cn/problem/P5236">「LG-P5236」静态仙人掌</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，圆方树是用以解决一类仙人掌图问题的重构树，但是类似的方法也可以用来解决某些普通无向图问题。依赖于其优美的树形结构，我们可以在 $\log |V|$ 的时间复杂度内回答一类图上的点对路径并集的询问问题……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="树" scheme="https://big-news.cn/tags/%E6%A0%91/"/>
    
      <category term="圆方树" scheme="https://big-news.cn/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"/>
    
      <category term="仙人掌图" scheme="https://big-news.cn/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」洛谷九月月赛</title>
    <link href="https://big-news.cn/2020/09/19/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E4%B9%9D%E6%9C%88%E6%9C%88%E8%B5%9B/"/>
    <id>https://big-news.cn/2020/09/19/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E4%B9%9D%E6%9C%88%E6%9C%88%E8%B5%9B/</id>
    <published>2020-09-19T08:48:00.000Z</published>
    <updated>2020-09-24T14:45:25.074Z</updated>
    
    <content type="html"><![CDATA[<p>今天怎么有一页阿克爷啊…..<br>怎么我还是啥都不会啊……</p><a id="more"></a><h3 id="A-子弦"><a href="#A-子弦" class="headerlink" title="A 子弦"></a>A 子弦</h3><p>容易发现答案是出现次数最多的字母的出现次数。证明很简单：再扩展一位字符出去限制性也不会变弱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e7</span> + <span class="number">7</span>; <span class="keyword">char</span> ch[CN]; <span class="keyword">int</span> tot[<span class="number">300</span>], mx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ch[i]; i++) tot[ ch[i] ]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; i++) mx = max(mx, tot[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, mx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-雷雨"><a href="#B-雷雨" class="headerlink" title="B 雷雨"></a>B 雷雨</h3><p>跑三遍 Dijkstra，枚举一个中间点拼起来就好了，复杂度 $O(nm(\log n + \log m))$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e3</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> x, y; LL v; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ &amp; a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;&#125;;</span><br><span class="line"><span class="function">DJ <span class="title">mk</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, LL c)</span> </span>&#123;DJ d; d.x = a, d.y = b, d.v = c; <span class="keyword">return</span> d;&#125;</span><br><span class="line">priority_queue&lt;DJ&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[CN][CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SP</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m,<span class="keyword">int</span> sx, <span class="keyword">int</span> sy, LL d[][CN], LL dis[][CN])</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    Q.push( mk(sx, sy, dis[sx][sy] = d[sx][sy]) );</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.top().x, y = Q.top().y; Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[x][y]) <span class="keyword">continue</span>; vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> vx = x + dx[k], vy = y + dy[k];</span><br><span class="line">            <span class="keyword">if</span>(!vx || !vy || vx &gt; n || vy &gt; m || vis[vx][vy]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[vx][vy] &gt; dis[x][y] + d[vx][vy])&#123;</span><br><span class="line">                dis[vx][vy] = dis[x][y] + d[vx][vy];</span><br><span class="line">                Q.push( mk(vx, vy, dis[vx][vy]) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a, b, c; LL d[CN][CN], da[CN][CN], db[CN][CN], dc[CN][CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), a = read(), b = read(), c = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) d[i][j] = read();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(da, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(da)), SP(n, m, <span class="number">1</span>, a, d, da);</span><br><span class="line">    <span class="built_in">memset</span>(db, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(db)), SP(n, m, n, b, d, db);</span><br><span class="line">    <span class="built_in">memset</span>(dc, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dc)), SP(n, m, n, c, d, dc);</span><br><span class="line"></span><br><span class="line">    LL ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            ans = min(ans, da[i][j] + db[i][j] + dc[i][j] - <span class="number">2l</span>l * d[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-梦原"><a href="#C-梦原" class="headerlink" title="C 梦原"></a>C 梦原</h3><p>考虑如果给出一颗形态固定的树，我们应该怎样算答案？我们只需要把 $w[u]$ 变成 $w[ fa[u] ]-w[u]$（就是树上差分），然后把所有 $w[u]&gt;0$ 的 $w[u]$ 加起来就可以了。也就是我们只考虑把多出来的那部分算到费用里面，容易发现这样一定是最优的。</p><p>然后考虑 $i$ 的父亲大概有 $\min i - 1,k$ 种可能，根据期望的线性性，只需对这些可能求个概率加权和就好了。设 $m=\min i-1, k$，得到答案是：<br>$$\sum\limits_{i=1}^n\sum\limits_{j=i-m}^{i-1}\frac{1}{m}[a_j&lt;a_i](a_i-a_j)$$ 实际上就是个二维数点，由于区间是定长，因此直接拿个树状数组维护即可，复杂度 $O(n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN], cnt[CN], n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(p &lt;= n) d[p] = (d[p] + x) % P, cnt[p]++, p += lb(p);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(p &lt;= n) d[p] = (d[p] - x + P) % P, cnt[p]--, p += lb(p);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(p) r = (r + d[p]) % P, p -= lb(p); <span class="keyword">return</span> r;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quc</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(p) r += cnt[p], p -= lb(p); <span class="keyword">return</span> r;&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D.n = n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), val[ ++val[<span class="number">0</span>] ] = a[i];</span><br><span class="line">    </span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[++tmp] = val[i]; val[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = a[<span class="number">1</span>]; </span><br><span class="line">    D.add(id(a[<span class="number">1</span>]), a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = qp(min(i - <span class="number">1</span>, m), P - <span class="number">2</span>), si = D.qu( id(a[i]) ), cnt = D.quc( id(a[i]) );</span><br><span class="line">        si = (<span class="number">1l</span>l * cnt * a[i] % P - si + P) % P;</span><br><span class="line">        ans = (<span class="number">1l</span>l * k * si % P + ans) % P;</span><br><span class="line">        D.add( id(a[i]) , a[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m + <span class="number">1</span>) D.minus( id(a[i - m]), a[i - m] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-线形生物"><a href="#D-线形生物" class="headerlink" title="D 线形生物"></a>D 线形生物</h3><p>看上去今天只有我一个人不会这题的样子……<br>Subtask1, 10pts 交个<code>cout&lt;&lt;(n&lt;&lt;1)</code>上去就好了，因为对每一位都有 $E_i=\frac{1}{2}E_i+1$，解得 $E_i=2$，因此答案是 $2n$。<br>Subtask4, 40pts 看上去用高斯消元解方程就好了，考场上遇到了些哲学问题没调出来…<br>Subtask5…这就不会了啊。<br>事实上赛后<code>红太阳</code> <a href="https://shuyumo2003.github.io/">SSX</a> 告诉我合并方程就完事了…<br>太草了就不写了…感性理解下吧…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天怎么有一页阿克爷啊…..&lt;br&gt;怎么我还是啥都不会啊……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」AtCoder Beginner Contest 178</title>
    <link href="https://big-news.cn/2020/09/13/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DAtCoder%20Beginner%20Contest%20178/"/>
    <id>https://big-news.cn/2020/09/13/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DAtCoder%20Beginner%20Contest%20178/</id>
    <published>2020-09-13T13:23:00.000Z</published>
    <updated>2020-09-13T13:48:36.061Z</updated>
    
    <content type="html"><![CDATA[<p>人生 AK 第一场，不过我还是这么的菜……</p><a id="more"></a><p><a href="https://atcoder.jp/contests/abc178">比赛链接</a></p><h3 id="A-Not"><a href="#A-Not" class="headerlink" title="A. Not"></a>A. Not</h3><p>考察输入输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x; x ^= <span class="number">1</span>; <span class="built_in">cout</span> &lt;&lt; x;&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Product-Max"><a href="#B-Product-Max" class="headerlink" title="B. Product Max"></a>B. Product Max</h3><p>对四个值取个 $\max$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL a, b, c, d, x, y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    x = max(a * c, a * d), y = max(b * c, b * d);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Ubiquity"><a href="#C-Ubiquity" class="headerlink" title="C. Ubiquity"></a>C. Ubiquity</h3><p>简单容斥一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = qp(<span class="number">10</span>, n), k = <span class="number">2l</span>l * qp(<span class="number">9</span>, n) % P;</span><br><span class="line">    ans = (ans - k + P) % P, k = qp(<span class="number">8</span>, n), ans = (ans + k) % P;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Redistribution"><a href="#D-Redistribution" class="headerlink" title="D. Redistribution"></a>D. Redistribution</h3><p>枚举数列的长度，然后简单插板即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e3</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> C[CN][CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = ( C[i - <span class="number">1</span>][j] +<span class="number">0l</span>l+ C[i - <span class="number">1</span>][j - <span class="number">1</span>] ) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n, pcal(n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l * <span class="number">3</span> &lt;= n; l++) ans = (ans + C[n - l * <span class="number">2</span> - <span class="number">1</span>][l - <span class="number">1</span>]) % P;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Dist-Max"><a href="#E-Dist-Max" class="headerlink" title="E. Dist Max"></a>E. Dist Max</h3><p>求平面曼哈顿距离的最大值，有一个经典的技巧是把曼哈顿距离的绝对值拆成四个值的 $\max$，即有：<br>$$|x-x’|+|y-y’|=\max x-x’+y-y’, x-x’+y’-y, x’-x+y-y’, x’-x+y’-y$$ 于是维护一下 $x+y$ 和 $x-y$ 的最大最小值更新答案即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, x[CN], y[CN], mx = -INF, mn = INF, ans = -INF;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = max(mx, x[i] + y[i]), mn = min(mn, x[i] + y[i]);</span><br><span class="line">    ans = max(ans, mx - mn);</span><br><span class="line">    mx = -INF, mn = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = max(mx, x[i] - y[i]), mn = min(mn, x[i] - y[i]);</span><br><span class="line">    ans = max(ans, mx - mn);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Contrast"><a href="#F-Contrast" class="headerlink" title="F. Contrast"></a>F. Contrast</h3><p>大概拿<code>set</code>维护一下就好，但是我的做法好像假了，不过考场上瞎搞过去了……<br>做法先咕着吧。</p><p>先贴一份假代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, a[CN], b[CN]; <span class="keyword">int</span> cnt[CN]; <span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt; S;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = read(), S.insert(b[i]), cnt[ b[i] ]++;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> has = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; :: iterator it = S.begin(); it != S.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = *it;</span><br><span class="line">            <span class="keyword">if</span>(val ^ a[i])&#123;</span><br><span class="line">                b[i] = val, has = <span class="literal">true</span>, cnt[val]--; </span><br><span class="line">                <span class="keyword">if</span>(!cnt[val]) S.erase(it); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag &amp;= has;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生 AK 第一场，不过我还是这么的菜……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>概率期望学习笔记</title>
    <link href="https://big-news.cn/2020/09/13/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/09/13/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-13T09:04:00.000Z</published>
    <updated>2020-09-21T13:04:47.348Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，一个随机变量 $x$ 的数学期望定义为 $E(x)$，即是 $E(x)traodinary$ 的缩写形式，代表 $x$ 是一个非凡的数字……</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>随机变量 $x$ 的数学期望 $E(x)$ 定义为 $x$ 的每种取值的概率加权和，可以理解为 $x$ 在平均情况下的取值，我们一般称其为「期望取值」。<br>举个例子，若 $x$ 有 $1/3$ 的概率为 $1$，有 $2/3$ 的概率为 $2$，则 $E(x)=1/3+2\times (2/3)=5/3$。</p><h3 id="线性性"><a href="#线性性" class="headerlink" title="线性性"></a>线性性</h3><p>根据乘法结合律以及分配律，可以发现期望具有线性性，可以将其理解为「元素和的期望等于元素期望的和」，亦即：<br>$$ E(\Sigma x_i)=\sum E(x_i) $$ 设 $c$ 为常量，也容易验证：<br>$$E(x+c)=E(x)+c$$</p><h3 id="一道简单题"><a href="#一道简单题" class="headerlink" title="一道简单题"></a>一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个长度为 $n$ 的数列，一开始所有位置都未被访问。每次随机一个未被访问过的位置，将它和它之前的位置都标记为访问过，问期望操作次数。<br>$n\le 10^{18}$</p></div></article><p>考虑期望的线性性，答案就等于每个位置能被访问到的概率。一个位置 $i$ 能被访问到当且仅当它在所有它后面的数之前被访问，这个概率是 $\frac{1}{n-i+1}$，因此容易发现答案是调和级数 $H_n$，使用近似公式计算即可。</p><h3 id="又一道简单题"><a href="#又一道简单题" class="headerlink" title="又一道简单题"></a>又一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个 $n$ 个节点的有根树，一开始所有节点都未被访问。每次随机一个未被访问过的节点，将它到根的路径上所有点都标记为访问过，问期望操作次数，对 $998244353$ 取模。<br>$n\le 10^7$</p></div></article><p>仿照上题，容易发现答案是 $\sum\limits_{i=1}^n\frac{1}{sz[i]}$，其中 $sz[i]$ 表示子树 $i$ 的大小，线性求逆即可。</p><h3 id="双一道简单题"><a href="#双一道简单题" class="headerlink" title="双一道简单题"></a>双一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 堆石子，每堆有 $a_i$ 个，每次随机选一个石子，并取光它所在的那堆石子。问第一堆石子被取到的时间的期望。<br>$n\le 10^5$</p></div></article><p>根据期望的线性性，答案等于每堆石子在 $1$ 之前取到的期望之和，即 $1+\sum\limits_{i=2}^n\frac{a_i}{a_1+a_i}$，线性计算即可。</p><h3 id="叒一道简单题"><a href="#叒一道简单题" class="headerlink" title="叒一道简单题"></a>叒一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个 $n$ 面的骰子，问每一面都被掷到的期望投掷次数。<br>$n\le 10^{18}$</p></div></article><p>此类问题被称作「赠券收集问题」。<br>设 $f[n]$ 为 $n$ 面掷出后还需投掷的次数的期望，易得 $f[i]=\frac{i}{n}f[i]+\frac{n-i}{n}f[i+1]+1$，整理得 $f[i]=f[i+1]+\frac{n}{n-i}$，从而有 $f[0]=nH_n$，利用公式计算即可。</p><h3 id="叕一道简单题"><a href="#叕一道简单题" class="headerlink" title="叕一道简单题"></a>叕一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>求所有 $n!$ 个 $n$ 的全排列中，逆序对数的期望，对 $998244353$ 取模。<br>$n\le 10^{7}$</p></div></article><p>众所周知，$n$ 的全排列一共有 $\dfrac{n!}{2}\dbinom{n}{2}$ 个逆序对，即对每个二元组 $(i,j)$ 讨论一下它们是否会形成逆序对。<br>因此答案为 $\dfrac{\dfrac{n!}{2}\dbinom{n}{2}}{n!}=\dfrac{n(n-1)}{4}$。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。<br>求该 01 串的价值的期望。<br>$n\le 10^5$</p></div></article><p>设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：<br>$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：<br>$$ \begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \end{aligned}$$ 于是可以做到 $O(n)$ 求出答案。<br>注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。</p><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一颗 $n$ 个节点的有根树，$1$ 号节点为根，树上的每个节点 $u$ 都有一个权值 $c_u$。<br>你需要随机一个节点的排列 $P\in [n]$， 并且按这个排列的顺序依次访问所有树上的节点。每当访问到树上的一个节点 $u$ 时，你需要将子树 $u$ 内所有节点的权值加上 $c_u$（包括点 $u$）。<br>问在一切的操作结束之后所有节点权值之和的期望。由于期望可能不是一个整数，请将它乘上 $n!$，并对 $10^9+7$ 取模。<br>$n\le 10^5$, 且<strong>保证树的形态随机</strong></p></div></article><p>根据期望的线性性，我们只需要求出每个节点最后的期望权值即可。设这个东西是 $a_u$ ，容易发现 $a_u$ 的取值只与从根到 $u$ 的这一条祖孙链上的节点有关。<br>因为树的形态随机，所以树高是期望 $O(\sqrt{n})$ 的。设祖孙链长为 $d$，那么只需考虑 $O(d)$ 地求出 $a_u$ 即可。<br>运用贡献法考虑：期望权值 = $Σ$权值$×$期望累加次数，那么考虑预处理一个 $t[]$，使得 $a_u=\sum c_v·t_v$ 即可。</p><p>容易发现 $t_v$ 的取值只与 $u,v$ 的相对距离有关，则可以设 $f_i$ 表示考虑随机访问一个有 $n$ 位的序列 $a_1,a_2,…,a_n$，$a_1$ 在 $i$ 上的期望累加次数。<br>考虑一次累加应当是什么样子： $1\to p_1\to p_2\to …\to i$，且满足 $1&lt;p_1&lt;p_2&lt;…&lt;i$。这显然双射了一个上升子序列（IS）。<br>则 $f_i$ 即代表考虑所有 $P\in [i]$，$P$ 中以 $1$ 起始的 IS 的期望数量。这样我们可以直接拿组合数选出来，即有：<br>$$ f_i=\sum\limits_d \dbinom{i-1}{d-1}\dbinom{i}{d}(i-d)! $$ 于是就可以计算了，时间复杂度 $O(n\sqrt{n})$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[CN], fac[CN], ifac[CN], f[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l * (<span class="number">1l</span>l * fac[n] * ifac[m] % P) * ifac[n - m] % P;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[CN], ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">stk[dep] = a[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = dep, j = <span class="number">1</span>; i; i--, j++) ans = (<span class="number">1l</span>l * stk[i] * f[j] % P + ans) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line"><span class="keyword">int</span> v = E[k].to;</span><br><span class="line"><span class="keyword">if</span>(v ^ p) dfs(v, u, dep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">ifac[n] = qp(fac[n], P - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) ifac[i] = <span class="number">1l</span>l * (i + <span class="number">1</span>) * ifac[i + <span class="number">1</span>] % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5000</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= i; d++)&#123;</span><br><span class="line"><span class="keyword">int</span> prd = <span class="number">1l</span>l * C(i - <span class="number">1</span>, d - <span class="number">1</span>) * C(i, d) % P;</span><br><span class="line">prd = <span class="number">1l</span>l * prd * fac[i - d] % P, f[i] = (f[i] + prd) % P;</span><br><span class="line">&#125;</span><br><span class="line">f[i] = <span class="number">1l</span>l * f[i] * ifac[i] % P; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = (ans + a[i]) % P;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), ans = <span class="number">1l</span>l * ans * fac[n] % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 种方法，每种方法需要 $k_i$ 条途径，第 $j$ 条途径有 $p[i,j]$ 的概率无法使用。每次可以查询任意一条途径可否使用，直到查询到一种能使用的方法，求最小的“最少查询次数的期望”。<br>$n,k_i \le 500$</p></div></article><p>容易发现对于任意一种方法，如果不将其全部查询完，那么这次查询是无意义的。对于任意一种方法，我们应当按照 $p[i,j]$ 降序排序的顺序去查询。<br>假定 $\forall i$，$p[i,j]$ 已经降序排序为 $p_1,p_2,…p_{k_i}$，那么考虑对所有方法进行排列，设 $E_i$ 为考虑 $[1:i]$ 中的方法时的答案，则有：<br>$$\begin{aligned} E_i&amp;=p_1(1+E_{i-1}) + p_2(1-p_1)(2+E_{i-1})+…\newline &amp;=k_iE_{i-1}+b_i \end{aligned} $$ 注意到还有 $\prod\limits_j (1-p_j)$ 的概率本次查询不会停止，把这部分加到常数项即可。<br>于是变成了一次函数嵌套的最小值问题，按 $(k_i-1)/b_i$ 升序排序即可，时间复杂度 $O(\sum k_i + n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">const</span> DB EPS = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, id[CN]; DB k[CN], b[CN], p[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span> </span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> k[i] * b[j] + b[i] &lt; k[j] * b[i] + b[j];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        m = read(); <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;p[j]);</span><br><span class="line">        sort(p + <span class="number">1</span>, p + m + <span class="number">1</span>, cmp); DB prd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">1</span>] &gt; <span class="number">1.0</span> - EPS) &#123;i--, n--; <span class="keyword">continue</span>;&#125; <span class="keyword">while</span>(m &amp;&amp; p[m] &lt;= EPS) m--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) k[i] += p[j] * prd, b[i] += p[j] * prd * j, prd *= (<span class="number">1.0</span> - p[j]);</span><br><span class="line">        b[i] += m * prd, id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, comp); DB ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i, p = n; p; p--) i = id[p], ans = k[i] * ans + b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $m$ 张牌，其中一张是王牌。现在你执行 $n$ 次如下操作：洗牌后查看第一张牌是什么。<br>令 $x$ 为洗牌后第一张牌为王牌的次数，现在假设洗牌时 $m!$ 种牌的排列出现的概率均相等，求 $x^k$ 的期望值，对 $998244353$ 取模。<br>$n,m\le 998244352, k\le 5000$</p></div></article><p>题目等价于：有 $n$ 个相互独立的随机变量 $x_1,x_2,…x_n$，每个变量有 $\frac{1}{m}$ 的概率为 $1$，其余情况为 $0$，求：<br>$$E[\left(\sum\limits_{i=1}^nx_i\right)^k]$$</p><p>根据期望的线性性，可以枚举 $d=\sum\limits_{i=1}^nx_i$，则有：<br>$$\begin{aligned} E[\left(\sum\limits_{i=1}^nx_i\right)^k] &amp;=\sum\limits_{d=0}^n E(d^k)\newline &amp;= \sum\limits_{d=0}^n P(d)·d^k\newline  &amp;= \sum\limits_{d=0}^n\dbinom{n}{d}\left(\frac{1}{m}\right)^d\left(1-\frac{1}{m} \right)^{n-d} ·d^k  \end{aligned}$$ 把后面的 $d^k$ 拿 Stirling 数展开，大力化一下柿子，得到：<br>$$ \sum\limits_{d=0}^n\dbinom{n}{d}\left(\frac{1}{m}\right)^d\left(1-\frac{1}{m} \right)^{n-d} ·d^k=\sum\limits_{i=0}^k \begin{Bmatrix}k\newline i\end{Bmatrix} n^{\underline{i}}\left(\frac{1}{m} \right)^i $$ 就可以做了，时间复杂度 $O(k^2)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, S[CN][CN], ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), k = read(), m = qp(m, P - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) S[i][j] = (<span class="number">1l</span>l * j * S[i - <span class="number">1</span>][j] % P + S[i - <span class="number">1</span>][j - <span class="number">1</span>]) % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fall = <span class="number">1</span>, pw = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> prd = <span class="number">1l</span>l * S[k][i] * fall % P;</span><br><span class="line">        ans = (<span class="number">1l</span>l * prd * pw % P + ans) % P;</span><br><span class="line">        pw = <span class="number">1l</span>l * pw * m % P, fall = <span class="number">1l</span>l * fall * (n - i) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li>暂无来源</li><li>暂无来源</li><li>暂无来源</li><li><a href="https://www.spoj.com/problems/FAVDICE/">「SPOJ1026」FAVDICE - Favorite Dice</a> </li><li>暂无来源</li><li><a href="https://darkbzoj.tk/problem/4318">「BZOJ4318」OSU!</a></li><li>暂无来源</li><li>暂无来源</li><li><a href="https://codeforces.com/problemset/problem/1278/F">「CF1278F」Cards</a></li></ol><p>习题<br><a href="https://www.luogu.com.cn/problem/P6834?contestId=34123">「LG-P6843」梦原</a><br><a href="https://www.luogu.com.cn/problem/P6835?contestId=34123">「LG-P5835」线形生物</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，一个随机变量 $x$ 的数学期望定义为 $E(x)$，即是 $E(x)traodinary$ 的缩写形式，代表 $x$ 是一个非凡的数字……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://big-news.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="期望" scheme="https://big-news.cn/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>虚树</title>
    <link href="https://big-news.cn/2020/09/11/%E8%99%9A%E6%A0%91/"/>
    <id>https://big-news.cn/2020/09/11/%E8%99%9A%E6%A0%91/</id>
    <published>2020-09-11T00:39:00.000Z</published>
    <updated>2020-09-21T13:05:52.096Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，虚树是一类重构树，用于处理点数较多而关键点（有效点）数较少的树上问题。举个栗子，我们所熟知的后缀树就是一种虚树……</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定点集 $V_k$ 代表有效点，我们定义一颗树 $T=(V,E)$ 是建立在 $V_k$ 上的虚树，当且仅当：</p><ol><li>$V_k\subseteq V$</li><li>$\forall x\in V, x\in V_k \text{ or } \exists u,v\in V, \text{s.t. } \text{LCA}(u,v)=x$ </li><li>$\forall (u,v)\in E, \text{LCA}(u,v)=u\text{ or }v$</li></ol><p>一句话来讲：虚数是关键点以及关键点的 LCA 构成的，保证原树的祖孙关系不变的重构树。</p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>模仿笛卡尔树的构建，虚树的构建可以使用单调栈在 $O(|V_k|\log |V|)$ 的时间内完成，其中 $\log V$ 的复杂度是倍增 LCA 的复杂度。如果使用 $O(n)-O(1)$ 的 RMQ-LCA，则可以降至 $O(|V_k|\log |V_k|)$，基本可以视作线性。<br>这种方法一般被称为「单调栈维护右链」。</p><p>顾名思义，这种构建方法的本质就在于使用单调栈去维护虚数最靠右边的树链。容易得出这份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span> :: sort;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span>&#123;</span>&#125;  E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[CN], stk[CN], top = <span class="number">0</span>, dfn[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125; <span class="comment">// 按 dfs 序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>, hd[<span class="number">1</span>] = <span class="number">0</span>, ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = lca(a[i], stk[top]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top], <span class="number">0</span>), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top], <span class="number">0</span>), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top], <span class="number">0</span>), top--;</span><br><span class="line">        &#125;</span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的树，边有边权。$q$ 次询问，每次给出 $k_i$ 个关键点，问切断多少边能使得关键点都不与 $1$ 号节点联通，最小化切断的边的边权。<br>$n,q,\sum k_i\le 10^5$</p></div></article><p>如果只有一次询问，则可以通过树上 DP 简单求出。注意到 DP 的过程中有效的点只有关键点和它们的 LCA，因此直接建出虚树 DP 即可，时间复杂度 $O(\sum k_i\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,w; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> d)</span> </span>&#123;to = t, nxt = n, w = d;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mn[CN], dep[CN], fa[CN][<span class="number">21</span>], dfn[CN], idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123; <span class="comment">// 预处理</span></span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) mn[v] = min(mn[u], E[k].w), dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">// 倍增 LCA</span></span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[x][k] ] &gt;= dep[y]) x = fa[x][k];</span><br><span class="line">    <span class="keyword">if</span>(x ^ y)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[x][k] ^ fa[y][k]) x = fa[x][k], y = fa[y][k];</span><br><span class="line">        x = fa[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[CN], stk[CN], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123; <span class="comment">// 建立虚树</span></span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>, hd[<span class="number">1</span>] = <span class="number">0</span>, ecnt = <span class="number">0</span>; <span class="comment">// 小心翼翼的初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = lca(stk[top], a[i]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top], <span class="number">0</span>), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top], <span class="number">0</span>), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top], <span class="number">0</span>), top--;</span><br><span class="line">        &#125; </span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i]; <span class="comment">// 小心翼翼的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[CN]; <span class="keyword">bool</span> is[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123; <span class="comment">// DP</span></span><br><span class="line">    f[u] = mn[u]; <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 小心翼翼的初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) dp(v, u), sum += f[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!is[u]) f[u] = min(f[u], sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w);&#125;</span><br><span class="line">    mn[<span class="number">1</span>] = INF, dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(hd, <span class="number">0</span>, <span class="keyword">sizeof</span>(hd)), ecnt = <span class="number">0</span>;</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) a[i] = read(), is[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">        bd(), dp(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[<span class="number">1</span>]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) is[ a[i] ] = <span class="literal">false</span>; <span class="comment">// 小心翼翼的清空标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的树，$q$ 次询问，每次给出 $k_i$ 个关键点，问切断多少点能使得关键点互不相连，无解输出 -1。<br>$n,q,\sum k_i\le 10^5$</p></div></article><p>依然沿用上题的思路，只不过在树上 DP 的时候细节较多。可以维护一个 $g[u]$ 表示子树 $u$ 中是否还存在与 $u$ 相连的关键点，在转移时分类讨论即可，时间复杂度 $O(\sum k_i\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[CN], fa[CN][<span class="number">21</span>], dfn[CN], idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[CN], top = <span class="number">0</span>, a[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>, hd[<span class="number">1</span>] = <span class="number">0</span>, ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = lca(stk[top], a[i]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top]), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top]), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top]), top--;</span><br><span class="line">        &#125;</span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[CN], g[CN]; <span class="keyword">bool</span> is[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    f[u] = g[u] = <span class="number">0</span>; <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dp(v, u)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        f[u] += f[v], cnt += g[v];</span><br><span class="line">        <span class="keyword">if</span>(is[u] &amp;&amp; is[v] &amp;&amp; dep[v] - dep[u] &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 无解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is[u]) f[u] += cnt, g[u] = <span class="number">1</span>; <span class="comment">// 讨论 u 的决策</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) f[u]++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>) g[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 有解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) a[i] = read(), is[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">        bd();</span><br><span class="line">        <span class="keyword">if</span>(dp(<span class="number">1</span>, <span class="number">0</span>)) <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[<span class="number">1</span>]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) is[ a[i] ] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的树，$q$ 次询问，每次给出 $k_i$ 个关键点，问关键点之间的两两距离和，距离最小值和距离最大值。<br>$n,q,\sum k_i\le 10^5$</p></div></article><p>距离最大 / 最小都可以简单维护，对于“距离和”这个问题，有一个常用方法是考虑每条边对答案的贡献。这就跟边有关系了，因此在建立虚树时不能再固定以 $1$ 号节点为根，简单维护一下树根即可，时间复杂度 $O(\sum k_i\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,w; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> d)</span> </span>&#123;to = t, nxt = n, w = d;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[CN][<span class="number">21</span>], dep[CN], dis[CN], dfn[CN], idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) dis[v] = dis[u] + E[k].w, dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125;</span><br><span class="line"><span class="keyword">int</span> stk[CN], top = <span class="number">0</span>, a[CN], rt; <span class="comment">// rt 维护树根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = a[<span class="number">1</span>], hd[ a[<span class="number">1</span>] ] = <span class="number">0</span>, ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = lca(stk[top], a[i]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top], <span class="number">0</span>), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top], <span class="number">0</span>), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top], <span class="number">0</span>), top--;</span><br><span class="line">        &#125;</span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rt = stk[<span class="number">1</span>]; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mn[CN], mx[CN], sz[CN], amn, amx, ans, tmp1[<span class="number">4</span>], tmp2[<span class="number">4</span>]; <span class="keyword">bool</span> is[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!hd[u]) <span class="keyword">return</span> (<span class="keyword">void</span>)(mn[u] = mx[u] = <span class="number">0</span>, sz[u] = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    mn[u] = INF, mx[u] = sz[u] = <span class="number">0</span>; <span class="keyword">int</span> Mn = INF, pMn = INF, Mx = <span class="number">0</span>, pMx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to, d = dis[v] - dis[u]; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        dp(v, u);</span><br><span class="line">        </span><br><span class="line">        mn[u] = min(mn[u], mn[v] + d), tmp1[<span class="number">0</span>] = mn[v] + d,</span><br><span class="line">        mx[u] = max(mx[u], mx[v] + d), tmp2[<span class="number">0</span>] = mx[v] + d;</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line"></span><br><span class="line">        ans += d * (a[<span class="number">0</span>] - sz[v]) * sz[v]; <span class="comment">// 计算距离和</span></span><br><span class="line"></span><br><span class="line">        tmp1[<span class="number">1</span>] = Mn, tmp1[<span class="number">2</span>] = pMn, tmp2[<span class="number">1</span>] = Mx, tmp2[<span class="number">2</span>] = pMx;</span><br><span class="line">        sort(tmp1, tmp1 + <span class="number">3</span>), sort(tmp2, tmp2 + <span class="number">3</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        Mn = tmp1[<span class="number">0</span>], pMn = tmp1[<span class="number">1</span>], Mx = tmp2[<span class="number">0</span>], pMx = tmp2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    amn = min(amn, Mn + pMn), amx = max(amx, Mx + pMx); <span class="comment">// 计算距离最大 最小</span></span><br><span class="line">    <span class="keyword">if</span>(is[u]) sz[u]++, amn = min(amn, Mn), mn[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v, <span class="number">1</span>), add(v, u, <span class="number">1</span>);&#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) a[i] = read(), is[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">        bd(), amn = INF, amx = ans = <span class="number">0</span>; <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="number">1</span>) ans = amn = amx = <span class="number">0</span>;</span><br><span class="line">        dp(rt, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%lld %lld %lld"</span>, ans, amn, amx), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) is[ a[i] ] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://www.luogu.com.cn/problem/P2495">「SDOI2011」消耗战</a></li><li><a href="http://codeforces.com/problemset/problem/613/D">「CF613D」Kingdom and its Cities</a></li><li><a href="https://www.luogu.com.cn/problem/P4103">「HEOI2014」大工程</a></li></ol><p>习题<br><a href="https://www.luogu.com.cn/problem/P3233">「HNOI2014」世界树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，虚树是一类重构树，用于处理点数较多而关键点（有效点）数较少的树上问题。举个栗子，我们所熟知的后缀树就是一种虚树……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="树" scheme="https://big-news.cn/tags/%E6%A0%91/"/>
    
      <category term="虚树" scheme="https://big-news.cn/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 669 (Div. 2)</title>
    <link href="https://big-news.cn/2020/09/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20669%20(Div.%202)/"/>
    <id>https://big-news.cn/2020/09/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20669%20(Div.%202)/</id>
    <published>2020-09-09T03:51:00.000Z</published>
    <updated>2020-09-09T06:02:45.420Z</updated>
    
    <content type="html"><![CDATA[<p>蒟蒻下分场……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1407">比赛链接</a></p><h3 id="A-Ahahahahahahahaha"><a href="#A-Ahahahahahahahaha" class="headerlink" title="A. Ahahahahahahahaha"></a>A. Ahahahahahahahaha</h3><p>注意到 01 串一定有 $\ge n/2$ 个 0 或者 1，依此构造即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), c += (a[i] == <span class="number">0</span>);</span><br><span class="line">n /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"0 "</span>);<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!c)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, n &lt;&lt; <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);  <span class="built_in">puts</span>(<span class="string">""</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, n + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);  <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c &gt;= n)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Big-Vova"><a href="#B-Big-Vova" class="headerlink" title="B. Big Vova"></a>B. Big Vova</h3><p>$O(n^2)$ 贪心即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) usd[i] = <span class="number">0</span>;</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(usd[j]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(mx == <span class="number">0</span>) mx = j;</span><br><span class="line">        <span class="keyword">if</span>(gcd(lst, a[mx]) &lt; gcd(lst, a[j])) mx = j;</span><br><span class="line">    &#125;</span><br><span class="line">    usd[mx] = <span class="number">1</span>, b[i] = a[mx];</span><br><span class="line">    lst = gcd(lst, a[mx]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="C-Chocolate-Bunny"><a href="#C-Chocolate-Bunny" class="headerlink" title="C. Chocolate Bunny"></a>C. Chocolate Bunny</h3><p>连续询问 $x,y$ 和 $y, x$，得到 $a,b$，则有 $\max(a,b)=\min(p_x,p_y)$，依此模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = read(); <span class="keyword">int</span> lst = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? %d %d\n"</span>, lst, i); fflush(<span class="built_in">stdout</span>); </span><br><span class="line">    x = read();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? %d %d\n"</span>, i, lst); fflush(<span class="built_in">stdout</span>); </span><br><span class="line">    y = read(), z = max(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y) a[i] = z ;</span><br><span class="line">    <span class="keyword">else</span> a[lst] = z, lst = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vis[ a[i] ]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!vis[i]) &#123;a[lst] = i; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"! "</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]); fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure><h3 id="D-Discrete-Centrifugal-Jumps"><a href="#D-Discrete-Centrifugal-Jumps" class="headerlink" title="D. Discrete Centrifugal Jumps"></a>D. Discrete Centrifugal Jumps</h3><p>理性分析一下，边数看上去不是 $O(n^2)$ 的而是 $O(n)$ 的，那么可以线性地把图建出来，单调栈维护一下即可。<br>但是这个题并不需要最短路算法，注意到这是一个 DAG，因此直接 DP 计算即可，时间复杂度 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">stk1[++top1] = <span class="number">1</span>, stk2[++top2] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(top1 &amp;&amp; a[ stk1[top1] ] &lt; a[i])&#123;</span><br><span class="line">        f[i] = min(f[i], f[ stk1[top1] ]);</span><br><span class="line">        <span class="keyword">while</span>(top1 &amp;&amp; a[ stk1[top1] ] == a[ stk1[top1 - <span class="number">1</span>] ]) top1--;</span><br><span class="line">        <span class="keyword">if</span>(top1) top1--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top1) f[i] = min(f[i], f[ stk1[top1] ]);</span><br><span class="line">    stk1[++top1] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(top2 &amp;&amp; a[ stk2[top2] ] &gt; a[i])&#123;</span><br><span class="line">        f[i] = min(f[i], f[ stk2[top2] ]);</span><br><span class="line">        <span class="keyword">while</span>(top2 &amp;&amp; a[ stk2[top2] ] == a[ stk2[top2 - <span class="number">1</span>] ]) top2--;</span><br><span class="line">        <span class="keyword">if</span>(top2) top2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top2) f[i] = min(f[i], f[ stk2[top2] ]);</span><br><span class="line">    stk2[++top2] = i;</span><br><span class="line"></span><br><span class="line">    f[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]);</span><br></pre></td></tr></table></figure><h3 id="E-Egor-in-the-Republic-of-Dagestan"><a href="#E-Egor-in-the-Republic-of-Dagestan" class="headerlink" title="E. Egor in the Republic of Dagestan"></a>E. Egor in the Republic of Dagestan</h3><p>算是比较裸的一道 E 题了……<br>设 $f[u,0/1]$ 表示在 $u$ 点，选 0 边还是选 1 边的答案，对于一条边 $u\gets v$，应当有 $f[u,c]\gets \max(f[v,0],f[v,1])+1$，其中 $c$ 代表边 $u\gets v$ 的颜色。<br>注意到一个点不会被松弛超过一次，直接跑 Dijkstra 转移即可，时间复杂度 $O((n+m)\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,tp; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span> </span>&#123;to = t, nxt = n, tp = p;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> v, id; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;&#125; ;</span><br><span class="line"><span class="function">DJ <span class="title">mk</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;DJ d; d.v = a, d.id = b; <span class="keyword">return</span> d;&#125;</span><br><span class="line"><span class="keyword">int</span> d[CN][<span class="number">2</span>]; <span class="keyword">bool</span> vis[CN]; priority_queue&lt;DJ&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SP</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d)), Q.push( mk(d[u][<span class="number">0</span>] = d[u][<span class="number">1</span>] = <span class="number">0</span>, u) );</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        u = Q.top().id, Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">int</span> dis = max(d[u][<span class="number">0</span>], d[u][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to, c = E[k].tp, cur; <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(d[v][c] &gt; dis + <span class="number">1</span>)&#123;</span><br><span class="line">                d[v][c] = dis + <span class="number">1</span>, cur = max(d[v][<span class="number">0</span>], d[v][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(cur &lt; INF) Q.push( mk(cur, v) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;<span class="keyword">int</span> u = read(), v = read(), t = read(); add(v, u, t);&#125;</span><br><span class="line">    SP(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(max(d[<span class="number">1</span>][<span class="number">0</span>], d[<span class="number">1</span>][<span class="number">1</span>]) &lt; INF) <span class="built_in">printf</span>(<span class="string">"%d"</span>, max(d[<span class="number">1</span>][<span class="number">0</span>], d[<span class="number">1</span>][<span class="number">1</span>])), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">putchar</span>(d[i][<span class="number">0</span>] &gt; d[i][<span class="number">1</span>] ? <span class="string">'0'</span> : <span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;蒟蒻下分场……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 668 (Div. 2)</title>
    <link href="https://big-news.cn/2020/09/07/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20668%20(Div.%202)/"/>
    <id>https://big-news.cn/2020/09/07/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20668%20(Div.%202)/</id>
    <published>2020-09-07T02:12:00.000Z</published>
    <updated>2020-09-14T03:26:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>两场 Div.2 爆肝上蓝系列……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1405">比赛链接</a></p><h3 id="A-Permutation-Forgery"><a href="#A-Permutation-Forgery" class="headerlink" title="A. Permutation Forgery"></a>A. Permutation Forgery</h3><p>这题是精心构造样例给选手降智啊….卡了我半小时 /kk<br>实际上反过来输出就好了啊…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[CN], n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="B-Array-Cancellation"><a href="#B-Array-Cancellation" class="headerlink" title="B. Array Cancellation"></a>B. Array Cancellation</h3><p>容易发现答案就是后缀和的最大值…证明显然啊，就算了吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[CN];</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">int</span> ans = max(<span class="number">0l</span>l, a[n]); <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) a[i] += a[i + <span class="number">1</span>], ans = max(ans, a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="C-Balanced-Bitstring"><a href="#C-Balanced-Bitstring" class="headerlink" title="C. Balanced Bitstring"></a>C. Balanced Bitstring</h3><p>容易发现模 $k$ 相同的位置， 字符应当是相同的，那么模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, k; <span class="keyword">char</span> a[CN], s[CN];</span><br><span class="line">ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; a;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) s[i] = <span class="string">'?'</span>; <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; flag; i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i] != <span class="string">'?'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i % k] == <span class="string">'?'</span>) s[i % k] = a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i % k] != a[i]) flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    cnt1 += (s[i] == <span class="string">'1'</span>), cnt0 += (s[i] == <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">if</span>(cnt0 &gt; (k / <span class="number">2</span>) || cnt1 &gt; (k / <span class="number">2</span>)) flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">flag ? <span class="built_in">puts</span>(<span class="string">"YES"</span>) : <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br></pre></td></tr></table></figure><h3 id="D-Tree-Tag"><a href="#D-Tree-Tag" class="headerlink" title="D. Tree Tag"></a>D. Tree Tag</h3><p>容易发现初始位置看似是无用的，那么把树的直径找出来判断即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, a, b, da, db;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hinit</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) hd[i] = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[CN], dm;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinit</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) d[i] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) d[v] = d[u] + <span class="number">1</span>, dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[CN][<span class="number">21</span>], dep[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) fa[j][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dep[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) pc(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v) &#123;<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][<span class="number">0</span>];&#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="keyword">return</span> dep[u] + dep[v] - <span class="number">2</span> * dep[lca(u, v)];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; T = read(); <span class="keyword">while</span>(T--)&#123; </span><br><span class="line">    hinit(), ecnt = <span class="number">0</span>;</span><br><span class="line">    n = read(), a = read(), b = read(), da = read(), db = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"></span><br><span class="line">    finit(), pc(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(dis(a, b) &lt;= da) &#123;<span class="built_in">puts</span>(<span class="string">"Alice"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">    dinit(), dfs(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> mx = <span class="number">0</span>, p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = mx &lt; d[i] ? p = i, mx = d[i] : mx;</span><br><span class="line"></span><br><span class="line">    dinit(), dfs(p, <span class="number">0</span>), dm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dm = max(dm, d[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * da &gt;= dm) <span class="built_in">puts</span>(<span class="string">"Alice"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(db &gt;= <span class="number">2</span> * da + <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"Bob"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Alice"</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Fixed-Point-Removal"><a href="#E-Fixed-Point-Removal" class="headerlink" title="E. Fixed Point Removal"></a>E. Fixed Point Removal</h3><p>容易发现一个点能否被消除仅与询问的左边界 $l$ 有关，设 $p_i$ 为可以令 $a_i$ 消除的最大的 $l$，则答案是 $\sum\limits_{i=l}^r[p_i\ge l]$，这是一个愉快的二维数点。<br>考虑 $p_i$ 如何求出，容易观察到如下性质：</p><ol><li>若  $a_i &gt; i$，则可以定义 $p_i = 0$；</li><li>若 $a_i = i$，显然 $p_i=i$； </li><li>若 $a_i &lt; i$，则 $p_i=\max m, \text{s.t.} \left( \sum\limits_{j=m}^{i-1}[p_j\ge m]\right) \ge i - a_i$</li></ol><p>前两条都好处理，最后一条二分即可，套一个静态主席树解决二维数点，时间复杂度 $O(n\log^2 n+q\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], rt[CN], idx; SGT()&#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = ++idx;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] = d[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) rc = ch[v][<span class="number">1</span>], md(lc, ch[v][<span class="number">0</span>], l, m, p);</span><br><span class="line">        <span class="keyword">else</span> lc = ch[v][<span class="number">0</span>], md(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> d[u] - d[v];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) <span class="keyword">return</span> d[rc] - d[ch[v][<span class="number">1</span>]] + qu(lc, ch[v][<span class="number">0</span>], l, m, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qu(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, p[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ai = read();</span><br><span class="line">        <span class="keyword">if</span>(ai &gt; i) p[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ai == i) p[i] = i;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>, m, minus = i - ai;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                m = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> cur = D.qu(D.rt[i - <span class="number">1</span>], D.rt[m - <span class="number">1</span>], <span class="number">0</span>, n, m);</span><br><span class="line">                <span class="keyword">if</span>(cur &gt;= minus) l = m;</span><br><span class="line">                <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[i] = l;</span><br><span class="line">        &#125;</span><br><span class="line">        D.md(D.rt[i], D.rt[i - <span class="number">1</span>], <span class="number">0</span>, n, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(); l++, r = n - r;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.qu(D.rt[r], D.rt[l - <span class="number">1</span>], <span class="number">0</span>, n, l)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两场 Div.2 爆肝上蓝系列……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 667 (Div. 3)</title>
    <link href="https://big-news.cn/2020/09/05/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20667%20(Div.%203)/"/>
    <id>https://big-news.cn/2020/09/05/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20667%20(Div.%203)/</id>
    <published>2020-09-05T06:43:00.000Z</published>
    <updated>2020-09-07T02:14:24.132Z</updated>
    
    <content type="html"><![CDATA[<p>最近 CF 的 Div2.3 有一点点水啊，虽然说蒟蒻还是上不了分……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1409">比赛链接</a></p><h3 id="A-Yet-Another-Two-Integers-Problem"><a href="#A-Yet-Another-Two-Integers-Problem" class="headerlink" title="A. Yet Another Two Integers Problem"></a>A. Yet Another Two Integers Problem</h3><p>签到傻题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t, a, b;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    a = read(), b = read(); <span class="keyword">int</span> k = <span class="built_in">abs</span>(a - b), b = k / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(b * <span class="number">10</span> == k) <span class="built_in">printf</span>(<span class="string">"%d"</span>, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, b + <span class="number">1</span>); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Minimum-Product"><a href="#B-Minimum-Product" class="headerlink" title="B. Minimum Product"></a>B. Minimum Product</h3><p>设 $a$ 变成了 $a-c$，$b$ 变成了 $b-d$，则减少的部分是 $-cb-ad+cd$，代入 $c+d=n$ 可以推出这是一个关于 $c$ 的二次函数，且开口向下，那么容易知道 $c$ 只有两种取值 $\max(0,y-b+n)$ 或 $a-x$，代入检验即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> t, a, b, x, y, n;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    a = read(), b = read(), x = read(), y = read(), n = read();</span><br><span class="line">    <span class="keyword">int</span> ans = INF, c, d;</span><br><span class="line">    <span class="keyword">if</span>(a + b - x - y &lt;= n) ans = x * y;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        c = min(n, a - x), d = min(b - y, n - c);</span><br><span class="line">        ans = min(ans, (a - c) * (b - d));</span><br><span class="line">        c = min(n, max(<span class="number">0l</span>l, y - b + n)), d = min(b - y, n - c);</span><br><span class="line">        ans = min(ans, (a - c) * (b - d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d"</span>, ans);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Yet-Another-Array-Restoration"><a href="#C-Yet-Another-Array-Restoration" class="headerlink" title="C. Yet Another Array Restoration"></a>C. Yet Another Array Restoration</h3><p>傻题，模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">202</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, x, y, d, a[CN], ans[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mx</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = max(mx, a[i]);</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    n = read(), x = read(), y = read(); <span class="keyword">int</span> mn = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(d = <span class="number">1</span>; d &lt;= y; d++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((y - x) % d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = (y - x) / d + <span class="number">1</span>, u = x; <span class="keyword">if</span>(l &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) a[i] = u, u += d;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = n - l; u = x - d;</span><br><span class="line">            <span class="keyword">while</span>(u &gt; <span class="number">0</span> &amp;&amp; sum) sum--, a[++l] = u, u -= d;</span><br><span class="line">            u = y + d;</span><br><span class="line">            <span class="keyword">while</span>(sum) sum--, a[++l] = u, u += d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = mx(a); <span class="keyword">if</span>(cur &lt; y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur &lt; mn) mn = cur, <span class="built_in">memcpy</span>(ans, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Decrease-the-Sum-of-Digits"><a href="#D-Decrease-the-Sum-of-Digits" class="headerlink" title="D. Decrease the Sum of Digits"></a>D. Decrease the Sum of Digits</h3><p>容易发现代价是固定的，那么模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> t, n, s, bit[<span class="number">101</span>], p10[<span class="number">101</span>], cur;</span><br><span class="line">p10[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">70</span>; i++) p10[i] = p10[i - <span class="number">1</span>] * <span class="number">10</span>;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    cur = <span class="number">0</span>, n = read(), s = read();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) bit[++lg] = n % <span class="number">10</span>, n /= <span class="number">10</span>, cur += bit[lg];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg &amp;&amp; cur &gt; s; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bit[i]) <span class="keyword">continue</span>;</span><br><span class="line">        ans += (<span class="number">10</span> - bit[i]) * p10[i - <span class="number">1</span>];</span><br><span class="line">        bit[i + <span class="number">1</span>]++, cur -= bit[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Two-Platforms"><a href="#E-Two-Platforms" class="headerlink" title="E. Two Platforms"></a>E. Two Platforms</h3><p>离散化坐标，考虑对于每个坐标 $i$ ，求出 $[1,i]$ 和 $(i,n]$ 的答案，加起来更新答案即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, d, X[CN], val[CN], pre[CN], suf[CN], sum[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    </span><br><span class="line">    n = read(), d = read(), val[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) X[i] = read(), val[ ++val[<span class="number">0</span>] ] = X[i], val[ ++val[<span class="number">0</span>] ] = X[i] + d, val[ ++val[<span class="number">0</span>] ] = X[i] - d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read();</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[++cnt] = val[i];</span><br><span class="line">    val[<span class="number">0</span>] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= val[<span class="number">0</span>] + <span class="number">100</span>; i++) pre[i] = suf[i] = sum[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[ id(X[i]) ]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = id(X[i]), l = id(X[i] - d), r = id(X[i] + d);</span><br><span class="line">        pre[p] = sum[p] - sum[l - <span class="number">1</span>], suf[p] = sum[r] - sum[p - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) pre[i] = max(pre[i], pre[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = val[<span class="number">0</span>]; i; i--) suf[i] = max(suf[i], suf[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) ans = max(ans, pre[i] + suf[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Subsequences-of-Length-Two"><a href="#F-Subsequences-of-Length-Two" class="headerlink" title="F. Subsequences of Length Two"></a>F. Subsequences of Length Two</h3><p>显然要 DP，设 $f[i,j,k]$ 表示考虑 $s[1:i]$ 中，$t[1]$ 出现了 $j$ 次，当前改动了 $k$ 次的方案数，就可以转移了。</p><p>具体来讲，考虑 $i\to i+1$，我们有两种选择：</p><ol><li>什么都不做，转移到 $f[i+1,c+0/1,k]$；</li><li>把这一位改成 $t_1$，转移到 $f[i+1,c+1,k+1]$</li><li>把这一位改成 $t_2$，转移到 $f[i+1,c,k+1]+c$</li></ol><p>最后特殊考虑一下 $t[1]=t[2]$ 的情况即可，时间复杂度 $O(n^3)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, d, f[CN][CN][CN], ans; <span class="keyword">char</span> s[CN], c1, c2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i][c + (s[i] == c1)][<span class="number">0</span>] = f[i - <span class="number">1</span>][c][<span class="number">0</span>];</span><br><span class="line">        c += (s[i] == c1); <span class="keyword">if</span>(s[i] == c2) f[i][c][<span class="number">0</span>] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= n; c++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c2) f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k] + c);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">else</span> f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c2) f[i + <span class="number">1</span>][c][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c][k + <span class="number">1</span>], f[i][c][k] + c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i][c + (s[i] == c1)][<span class="number">0</span>] = f[i - <span class="number">1</span>][c][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == c1) c++, f[i][c][<span class="number">0</span>] += c - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= n; c++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k], f[i][c][k] + c);</span><br><span class="line">          <span class="keyword">else</span> f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>], f[i][c][k] + c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), d = read(), <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(c1 != c2) DP1(); <span class="keyword">else</span> DP2();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= n; x++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">            ans = max(ans, f[n][x][k]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 CF 的 Div2.3 有一点点水啊，虽然说蒟蒻还是上不了分……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>2-SAT问题</title>
    <link href="https://big-news.cn/2020/09/03/2-SAT%E9%97%AE%E9%A2%98/"/>
    <id>https://big-news.cn/2020/09/03/2-SAT%E9%97%AE%E9%A2%98/</id>
    <published>2020-09-03T00:28:00.000Z</published>
    <updated>2020-09-03T08:18:20.002Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，2-SAT即二元适配性问题，用于解决一类布尔方程的求值问题……</p><a id="more"></a><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个布尔变量 $x_1, x_2, …,x_n$，给定 $m$ 对冲突关系，形如 $x_i\And x_j=0$，问一组可行解。<br>$n\le 10^5, m\le 10^6$</p></div></article><p>拆点建图，对每个变量 $x_i$ 拆成两个点 $i$ 和 $i’$，前者表示“$x_i$ 为真”，后者表示“$x_i$ 为假”。则可以将冲突关系 $(x_i,x_j)$ 转化为偏序关系 $(i,j’)$ 和 $(j,i’)$，依此得到一张有向图，然后就可以按照处理偏序关系的思路去做了。</p><p>容易发现，对于一个偏序环上的点，如果取一个值为真，那么剩下的点取值也必然为真；于是可以得到解的存在性定理：该布尔方程有解当且仅当 $\forall i$，$i$ 和 $i’$ 不在同一个偏序环上。</p><p>如何求出一组可行解呢？贪心地想，对于 $i$ 和 $i’$，我们应该选择在新图中拓扑序大的那个将其设为真，因为这样可以最小化影响。注意到 tarjan 求出的 SCC 的编号即为新图拓扑序的反序，因此直接判断即可。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个布尔变量 $x_1\sim x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 true / false 或 $x_j$ 为 true / false」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。<br>试给每个变量赋值使得所有条件得到满足，无解输出 IMPOSSIBLE。<br>$n, m\le 10^6$</p></div></article><p>容易发现一共有三种本质不同的条件形式：</p><ol><li>$x_i=0|x_j=1$，等价于 $x_i\And \neg x_j=0$，连边 $(i,j),(j’,i’)$；</li><li>$x_i=0|x_j=0$，等价于 $x_i\And x_j=0$，连边 $(i,j’),(j,i’)$；</li><li>$x_i=1|x_j=1$，等价于 $\neg x_i\And \neg x_j=0$，连边 $(i’,j),(j’,i)$。</li></ol><p>然后套用上面的做法就好了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]),hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, du[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, bel[CN], bcnt = <span class="number">0</span>; <span class="keyword">bool</span> ins[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u, ins[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) dfs(v), low[u] = min(low[u], low[v]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[v]) low[u] = min(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">        bcnt++; <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos ^ u) pos = stk[top--], ins[pos] = <span class="literal">false</span>, bel[pos] = bcnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = read(), a = read(), j = read(), b = read();</span><br><span class="line">        <span class="keyword">if</span>(a ^ b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt; b) swap(i, j), swap(a, b);</span><br><span class="line">            add(i, j), add(j + n, i + n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a) add(i, j + n), add(j, i + n);</span><br><span class="line">            <span class="keyword">else</span> add(i + n, j), add(j + n, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); i++) <span class="keyword">if</span>(!dfn[i]) dfs(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; i++) flag &amp;= (bel[i] != bel[i + n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"POSSIBLE"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(bel[i] &lt; bel[i + n]) <span class="built_in">printf</span>(<span class="string">"1 "</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，2-SAT即二元适配性问题，用于解决一类布尔方程的求值问题……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论" scheme="https://big-news.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="2-SAT" scheme="https://big-news.cn/tags/2-SAT/"/>
    
  </entry>
  
  <entry>
    <title>博弈论学习笔记</title>
    <link href="https://big-news.cn/2020/09/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/09/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-02T01:25:00.000Z</published>
    <updated>2020-09-21T13:05:05.651Z</updated>
    
    <content type="html"><![CDATA[<p>Alice 和 Bob 又开始玩游戏了……</p><a id="more"></a><h3 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h3><p>对于博弈论中的局面 $S$，定义它的 SG 函数为 $SG(S)=\text{mex} SG(T)$，其中 $T$ 是 $S$ 的后继局面。<br>对于无法做出任何移动的局面（先手必败态），我们称之为 P 态，否则称之为 N 态（先手必胜态）。</p><ul><li>SG 定理：一个局面 $S$ 是 P 态当且仅当 $SG(S)=0$</li></ul><p>这个定理也可以这样理解：可以到达 P 态的局面是 N 态，所有移动都导致 N 态的局面是 P 态。<br>另一个非常有用的结论：对于由多个局面 $S_1, S_2,…S_n$ 组成的博弈游戏，该局面的 SG 函数是所有 $SG(S_i)$ 的异或和。</p><h3 id="经典-Nim"><a href="#经典-Nim" class="headerlink" title="经典 Nim"></a>经典 Nim</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取，最后没石子可取的人就输了。问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>根据 SG 定理，容易发现 $SG(S_i)=a_i$，故先手必胜当且仅当 $a_i$ 的异或和不为0。</p><h3 id="阶梯-Nim"><a href="#阶梯-Nim" class="headerlink" title="阶梯 Nim"></a>阶梯 Nim</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出任意多枚石子<strong>移动到前面一堆石子</strong>，可以取完，不能不取，最后无法移动的人就输了（此时所有石子都在位置0）。问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>若先手移动偶数堆的石子到奇数堆去，那么后手可以立刻将其移入下一个偶数堆，这样看起来对奇数堆毫无影响。但是如果先手移动奇数堆的石子去偶数堆，则可能会将其移入第 0 堆。因此，只有在奇数堆移动石子是本质的。</p><p>“从奇数堆移动一些石子去偶数堆”等价于从奇数堆拿走一些石子扔掉，因子对奇数堆做 Nim 即可。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个箱子，每个箱子有 $a_i$ 个石头，一开始所有箱子都是关着的。<br>Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。<br>不能操作的输，求先手必胜还是后手必胜。<br>$1\le n\le 10^5, 0\le a_i\le 10^9$</p></div></article><p>考虑如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。<br>如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。</p><p>因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。<br>大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。</p><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出一枚石子扔掉，但任意两次不能取同堆的石子。最后无法移动的人输，问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>若存在一堆石子，满足其中石子的个数比其它堆石子个数总和还多，则先手是必胜的，即一直取这一堆就好了。<br>如果不存在呢？那么任意时刻，不能存在一堆石子，使得其中石子的个数多于其它堆石子个数总和。这意味着所有石子都要被取走，因此直接判断奇偶性即可，复杂度 $O(n)$。</p><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给你 $n$ 张卡片，每张卡片的两个面各有数字 $a_i$ 和 $b_i$，每个面都有 $1/2$ 的概率出现为卡片的正面，卡牌正反面的概率相互独立，求把所有卡牌正面数字拿来玩 Nim 游戏，先手必胜的概率。<br>$n\le 5\times 10^5, a_i,b_i\le 10^{18}$</p></div></article><p>设 $S=\bigoplus\limits_{i=1}^na_i$，定义序列 $c_i=a_i\oplus b_i$，则问题等价于求序列 $c$ 有多少个子集使得异或和为 $S$，线性基维护即可，复杂度 $O(n\log a_i)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LB</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: LL a[<span class="number">101</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i + <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(x &amp; (<span class="number">1l</span>l &lt;&lt; i))) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span>(a[i]) x ^= a[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j + <span class="number">1</span>; j--) <span class="keyword">if</span>(x &amp; (<span class="number">1l</span>l &lt;&lt; j)) x ^= a[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= <span class="number">63</span>; j++) <span class="keyword">if</span>(a[j] &amp; (<span class="number">1l</span>l &lt;&lt; i)) a[j] ^= x;</span><br><span class="line">                a[i] = x; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sz</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">63</span>; i++) <span class="keyword">if</span>(a[i]) cnt++; <span class="keyword">return</span> cnt;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ext</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i + <span class="number">1</span>; i--) <span class="keyword">if</span>(x &amp; (<span class="number">1l</span>l &lt;&lt; i)) x ^= a[i]; <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line">LL n, sum, a[CN], b[CN];</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), b[i] = read(), D.ins(a[i] ^ b[i]), sum ^= a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!D.ext(sum)) <span class="built_in">puts</span>(<span class="string">"1/1"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = D.sz();</span><br><span class="line">    LL ans = <span class="number">1</span>; <span class="keyword">while</span>(k--) ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld/%lld"</span>, ans - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子（$n$ 是偶数），每堆石子有 $a_i$ 个，每人每次可从任意 $n/2$ 堆石子里取出至少一枚石子扔掉。最后无法移动（有石子的堆的数量 $\le n/2$）的人输，问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>考虑若存在石子个数为 1 的堆，设堆数为 $x(x&gt;0)$，则有情况如下：</p><ol><li>$x &gt; n/2$，则先手必败，因为无法避免在操作中形成空堆；</li><li>$x\le n/2$，则先手必胜，因为先手只要令操作后 $x&gt;n/2$ 即可</li></ol><p>剩下的唯一问题是不存在石子个数为 1 的堆的情况。<br>可以考虑放宽限制，即考虑石子个数为 2 的堆的情况。容易发现石子个数为 2 的情况依然可以归结到上述的两种讨论，因此直接猜出结论：先手必胜当且仅当石子个数最小的堆的数量 $\le n / 2$。</p><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://www.luogu.com.cn/problem/P2197">「LG-P2197」NIM游戏</a></li><li>暂无来源</li><li>暂无来源</li><li><a href="https://codeforces.com/contest/1396/problem/B">「CF1396B」Stoned Game</a></li><li><a href="https://codeforces.com/problemset/problem/662/A">「CF662A」Gambling Nim</a></li><li><a href="https://codeforces.com/problemset/problem/1147/C">「CF1147C」Thanos Nim</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Alice 和 Bob 又开始玩游戏了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="博弈论" scheme="https://big-news.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="线性基" scheme="https://big-news.cn/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>KMP学习笔记</title>
    <link href="https://big-news.cn/2020/08/31/KMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/08/31/KMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-31T11:12:00.000Z</published>
    <updated>2020-09-21T13:05:15.659Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，对于一般的字符串题，存在如下规律：字符串算法 &lt; hash &lt; 暴力，其中 “&lt;” 代表“劣于”。</p><a id="more"></a><p>kmp 被用来解决下面的这样一个问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定两个字符串 $S,T$ ，求 $S$ 在 $T$ 中匹配的数量和位置。<br>$|T|,|S|\le 10^6$</p></div></article><p>直接 hash 和 kmp 都是 $O(|S|+|T|)$ 的复杂度，但是 kmp 的思想还是要理解的。<br>kmp 的思想基于下面这两个东西。</p><h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>一个 border 定义为字符串的一段前缀，使其等于本串的一段后缀。<br>用符号表示的话就是找到一个 $k$，使得 $s[1:k]=s[n-k+1:n]$。容易发现我们可以用这个 $k$ 去双射一个 border。<br>众所周知，border 具有一个非常优美的性质，即你的 border 的 border 还是你的 border。</p><h3 id="next-数组"><a href="#next-数组" class="headerlink" title="next[] 数组"></a>next[] 数组</h3><p>定义 $nxt[i]=md(s[1:i])$ 是串 $s$ 的 $nxt[]$ 数组，其中 $md(x)$ 代表串 $x$ 的最长 border 长度（不能是自身）。<br>容易发现 $nxt[i], nxt[nxt[i]],…$ 构成了串 $s[1:i]$ 的所有 border。</p><p>kmp 每次确定一个最大的 $k$，使得 $S[1:k] = T[i - k + 1:i]$，然后尝试扩展 $k\to k+1$，如果 $k=|S|$ 则发现了匹配位置。<br>容易发现，这个尝试扩展的过程可以通过 border 来加速，即若 $S[k+1]\neq T[i+1]$，则令 $k=nxt[k]$ 即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, nxt[CN]; <span class="keyword">char</span> s[CN], t[CN];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; (t + <span class="number">1</span>) &gt;&gt; (s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(t + <span class="number">1</span>), m = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; nxt[<span class="number">1</span>] = <span class="number">0</span>, nxt[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// k : 当前的最长 border</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != s[i]) k = nxt[k]; <span class="comment">// 去找次长 border</span></span><br><span class="line">    nxt[i] = (k += <span class="number">1</span>); <span class="comment">// 往下匹配一位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != t[i]) k = nxt[k]; <span class="comment">// 同理</span></span><br><span class="line">    <span class="keyword">if</span>((k += <span class="number">1</span>) == m) <span class="built_in">printf</span>(<span class="string">"%d"</span>, i - m + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>); <span class="comment">// 已经匹配上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定字符串 $S$，求 $S$ 的所有前缀的<strong>不重叠</strong>的 border 数量。<br>$|S|\le 5\times 10^7$</p></div></article><p>直接在 kmp 上维护即可，注意一下 kmp 想要保证复杂度则必须避免反复横跳。<br>时间复杂度 $O(n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e7</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, nxt[CN], num[CN]; <span class="keyword">char</span> s[CN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; nxt[<span class="number">0</span>] = <span class="number">-1</span>, nxt[<span class="number">1</span>] = <span class="number">0</span>, num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != s[i]) k = nxt[k];</span><br><span class="line">    k += <span class="number">1</span>, nxt[i] = k, num[i] = num[k] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != s[i]) k = nxt[k];</span><br><span class="line">    <span class="keyword">while</span>(k &gt; i / <span class="number">2</span>) k = nxt[k]; <span class="comment">// 跑过了就挪回去</span></span><br><span class="line">    ans = <span class="number">1l</span>l * ans * (num[k] + <span class="number">1</span>) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="在字典树上的扩展"><a href="#在字典树上的扩展" class="headerlink" title="在字典树上的扩展"></a>在字典树上的扩展</h3><p>考虑这样一个问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个字符串 $T$，和<strong>一些</strong>字符串 $S_1,S_2,…S_n$，对每个 $S_i$ 求其在 $T$ 中匹配的数量。<br>$|T|,\sum|S_i|\le 10^6$</p></div></article><p>解决方法是对 $S_i$ 建立字典树，然后再在字典树上建立类似于 $nxt[]$ 指针的结构。注意到这种方法具有可扩展性，即广义后缀自动机也通过类似的思想构建。</p><p>于是这棵字典树变成了一个<strong>确定有限状态自动机（DFA）</strong>，我们称其为 <strong>AC自动机（Aho-Corasick Automaton, ACAM）</strong>。</p><p>则可以得到这样一份构建代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAM</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> son[CN][<span class="number">26</span>], fail[CN], e[CN], idx; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!son[u][ s[i] - <span class="string">'a'</span> ]) son[u][ s[i] - <span class="string">'a'</span> ] = ++idx;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">        &#125;</span><br><span class="line">        e[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) Q.push( son[<span class="number">0</span>][i] );</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]);</span><br><span class="line">                <span class="keyword">else</span> son[u][i] = son[ fail[u] ][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = u; j &amp;&amp; e[j] ^ <span class="number">-1</span>; j = fail[j])</span><br><span class="line">                r += e[j], e[j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个字符串 $T$ 和一些字符串 $S_1,S_2,…S_n$，定义一个字符串是可爱的当且仅当它不包含任何 $S_i$ 作为子串。试删除最少的字符使得 $T$ 变得可爱。<br>$|T|,\sum|S_i|\le 5000$</p></div></article><p>考虑 DP，设 $f[l,u]$ 为考虑 $S[1:l]$，在AC自动机上走到了节点 $u$ 的最小代价。考虑 $S[l+1]$ 是否删除，则有转移：<br>$$\begin{aligned} &amp;f[l,u]+1\to f[l + 1, u]\newline &amp;f[l,u]\to f[l+1,v] \text{ }|\text{ }son[u, S[l + 1]] = v\end{aligned}$$ $v$ 点应当满足怎样的限制呢？首先它不应该是接受状态，并且 fail 树上它到根的路径上也不能存在接受状态，因为这些状态是后缀等价的。那么按照 bfs 序更新一下即可，时间复杂度 $O(|T|\sum |S_i|)$。 </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2020</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAM</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> son[CN][<span class="number">26</span>], fail[CN], w[CN], idx; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!son[u][ s[i] - <span class="string">'a'</span> ]) son[u][ s[i] - <span class="string">'a'</span> ] = ++idx;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">        &#125;</span><br><span class="line">        w[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) Q.push(son[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]);</span><br><span class="line">                <span class="keyword">else</span> son[u][i] = son[ fail[u] ][i];</span><br><span class="line">            w[u] += w[ fail[u] ]; <span class="comment">// mark</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f[CN][CN];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= idx; i++)&#123;</span><br><span class="line">                f[l + <span class="number">1</span>][i] = min(f[l + <span class="number">1</span>][i], f[l][i] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> v = son[i][ s[l] - <span class="string">'a'</span> ];</span><br><span class="line">                <span class="keyword">if</span>(!w[v]) f[l + <span class="number">1</span>][v] = min(f[l + <span class="number">1</span>][v], f[l][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= idx; i++) ans = min(ans, f[n][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一些字符串 $S_1,S_2,…S_n$ 和字符集 $\Sigma$，每个字符串 $S_i$ 有一个价值 $w_i$。<br>定义一个字符串的价值为其所有子串的价值和（未定义则为 $0$），求一个长度为 $l$ 的串使得其价值最大。<br>$|\Sigma|\le 26 ,\sum|S_i|,l\le 1000$</p></div></article><p>考虑 DP，假设当前的字符串为 $s$，新增了一个字符 $c$ 得到 $sc$，则新增的子串应当是 $sc$ 的所有后缀，新增字符的价值为这些后缀的价值和。<br>对 $S_i$ 建立AC自动机，则“这些后缀的价值和”体现为 fail 树上从根到 $sc$ 所在的节点的权值和，我们记其为 $w[u]$。</p><p>于是就可以 DP 了，设 $f[l,u]$ 表示当前拼出的串长度为 $l$，现在在AC自动机上的节点 $u$ 的最大价值，有转移：<br>$$ f[l,u]+w[v]\to f[l+1,v]\text{ }|\text{ }\exists c, \text{s.t.} son[u, c]=v$$ 时间复杂度 $O(l\sum|S_i||\Sigma|)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2020</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">queue</span> &#123;</span> <span class="comment">// 惨痛经历</span></span><br><span class="line">  <span class="keyword">public</span>: T a[CN], hd, tl; <span class="built_in">queue</span>() &#123;hd = tl = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> hd ^ tl ? <span class="number">0</span> : <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a[hd];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;hd++;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;a[tl++] = x;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAM</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> w[CN], son[CN][<span class="number">26</span>], fail[CN], idx; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!son[u][ s[i] - <span class="string">'a'</span> ]) son[u][ s[i] - <span class="string">'a'</span> ] = ++idx;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">        &#125;</span><br><span class="line">        w[u] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) Q.push(son[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]);</span><br><span class="line">                <span class="keyword">else</span> son[u][i] = son[ fail[u] ][i];</span><br><span class="line">            w[u] += w[ fail[u] ]; <span class="comment">// mark</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f[CN][CN];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt;= idx; u++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">26</span>; c++)</span><br><span class="line">                    f[i + <span class="number">1</span>][ son[u][c] ] = max(f[i + <span class="number">1</span>][ son[u][c] ], f[i][u] + w[ son[u][c] ]);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt;= idx; u++) ans = max(ans, f[l][u]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://loj.ac/problem/2246">「NOI2014」动物园</a></li><li>暂无来源</li><li>暂无来源</li><li>暂无来源</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，对于一般的字符串题，存在如下规律：字符串算法 &amp;lt; hash &amp;lt; 暴力，其中 “&amp;lt;” 代表“劣于”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="KMP" scheme="https://big-news.cn/tags/KMP/"/>
    
      <category term="AC自动机" scheme="https://big-news.cn/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」牛客练习赛68</title>
    <link href="https://big-news.cn/2020/08/28/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B68/"/>
    <id>https://big-news.cn/2020/08/28/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B68/</id>
    <published>2020-08-28T12:03:00.000Z</published>
    <updated>2020-08-29T12:22:16.464Z</updated>
    
    <content type="html"><![CDATA[<p>牛客的题还是比较板啊，像我这样的菜鸡都能打到 rk30？？？/jk</p><a id="more"></a><h3 id="A-牛牛的mex"><a href="#A-牛牛的mex" class="headerlink" title="A 牛牛的mex"></a>A 牛牛的mex</h3><p>主席树模板题。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx;</span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] = d[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) rc = ch[v][<span class="number">1</span>], ins(lc, ch[v][<span class="number">0</span>], l, m, p);</span><br><span class="line">        <span class="keyword">else</span> lc = ch[v][<span class="number">0</span>], ins(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = d[lc] - d[ ch[v][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &lt; m - l + <span class="number">1</span>) <span class="keyword">return</span> qu(lc, ch[v][<span class="number">0</span>], l, m);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qu(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, ai;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ai = read(), D.ins(D.rt[i], D.rt[i - <span class="number">1</span>], <span class="number">1</span>, n, ai + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span>(q--) x = read(), y = read(), <span class="built_in">printf</span>(<span class="string">"%d"</span>, y - x + <span class="number">1</span> &lt; n ? D.qu(D.rt[y], D.rt[x - <span class="number">1</span>], <span class="number">1</span>, n) - <span class="number">1</span> : n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-牛牛的算术"><a href="#B-牛牛的算术" class="headerlink" title="B 牛牛的算术"></a>B 牛牛的算术</h3><p>傻题，随便推一推柿子，特判下就好了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">199999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> i2 qp(2, P - 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, f[CN], p[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> squ = <span class="number">1l</span>l * x * x % P; squ = <span class="number">1l</span>l * squ * (x + <span class="number">1</span>) % P;</span><br><span class="line">    <span class="keyword">return</span> squ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; P; i++) f[i] = (f[i - <span class="number">1</span>] + cal(i)) % P;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; P; i++) p[i] = <span class="number">1l</span>l * p[i - <span class="number">1</span>] * i % P, p[i] = <span class="number">1l</span>l * p[i] * f[i] % P, p[i] = <span class="number">1l</span>l * p[i] * i2 % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch; <span class="keyword">int</span> l = <span class="built_in">strlen</span>(ch); <span class="keyword">if</span>(l &gt;= <span class="number">6</span>) &#123;<span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) n = n * <span class="number">10</span> + (ch[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= P) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, p[n]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-牛牛的无向图"><a href="#C-牛牛的无向图" class="headerlink" title="C 牛牛的无向图"></a>C 牛牛的无向图</h3><p>容易想到把边和询问都按权值排序，然后依次加边，能加就加，然后对于每个连通块就可以 $O(1)$ 算答案了。维护一个并查集就解决了，时间复杂度 $O(m\log m + (m + q)\alpha(n))$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fa[CN];</span><br><span class="line">    DSU() &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) fa[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] ^ x ? fa[x] = fd(fa[x]) : x;&#125;</span><br><span class="line">&#125; C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, LIM, X[CN], Y[CN], W[CN], id[CN], pos = <span class="number">1</span>, L[CN], sz[CN]; </span><br><span class="line">LL ans[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> W[i] &lt; W[j];&#125;</span><br><span class="line"><span class="function">LL <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l * x * (x - <span class="number">1</span>) / <span class="number">2l</span>l;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SA, SB, SC; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">rng61</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SA ^= SA &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    SA ^= SA &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    SA ^= SA &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> t = SA;</span><br><span class="line">    SA = SB;</span><br><span class="line">    SB = SC;</span><br><span class="line">    SC ^= t ^ SA;</span><br><span class="line">    <span class="keyword">return</span> SC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%u%u%u%d"</span>, &amp;n, &amp;m, &amp;q, &amp;SA, &amp;SB, &amp;SC, &amp;LIM);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        X[i] = rng61() % n + <span class="number">1</span>;</span><br><span class="line">        Y[i] = rng61() % n + <span class="number">1</span>;</span><br><span class="line">        W[i] = rng61() % LIM; id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        L[i] = rng61() % LIM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    gen();</span><br><span class="line"></span><br><span class="line">    sort(L + <span class="number">1</span>, L + q + <span class="number">1</span>), sort(id + <span class="number">1</span>, id + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sz[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        LL cur = ans[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(W[ id[pos] ] &lt;= L[i] &amp;&amp; pos &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = X[ id[pos] ], v = Y[ id[pos] ], fu = C.fd(u), fv = C.fd(v);</span><br><span class="line">            <span class="keyword">if</span>(fu ^ fv) </span><br><span class="line">                cur += <span class="number">1l</span>l * sz[fu] * sz[fv], </span><br><span class="line">                C.fa[fv] = fu, sz[fu] += sz[fv];</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) ans[<span class="number">0</span>] ^= ans[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-牛牛的粉丝"><a href="#D-牛牛的粉丝" class="headerlink" title="D 牛牛的粉丝"></a>D 牛牛的粉丝</h3><p>显然是个矩乘优化 DP 转移，设 $f[k,i]$ 表示 $k$ 轮后点 $i$ 的答案这样，直接做复杂度 $O(n^3\log k)$，好像不太行。<br>然后就没有想法了……</p><p>upd：转移矩阵是循环的啊……既然是循环的就没必要 $O(n^3)$ 算了……存下第一行来矩乘就变卷积了……于是做到 $O(n^2\log k)$……甚至还可以 $O(n\log n\log k)$ /jk……</p><h3 id="E-牛牛的字符串"><a href="#E-牛牛的字符串" class="headerlink" title="E 牛牛的字符串"></a>E 牛牛的字符串</h3><p>回文不会处理啊……看上去我只会 $O(n^3)$ 的辣鸡 DP，也许可以通过一些字符串算法优化到 $O(n^2)$？不可做不可做。</p><p>upd：并没有什么神仙算法……所以说还是要观察性质……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;牛客的题还是比较板啊，像我这样的菜鸡都能打到 rk30？？？/jk&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>利用vector重现set</title>
    <link href="https://big-news.cn/2020/08/28/%E5%88%A9%E7%94%A8vector%E9%87%8D%E7%8E%B0set/"/>
    <id>https://big-news.cn/2020/08/28/%E5%88%A9%E7%94%A8vector%E9%87%8D%E7%8E%B0set/</id>
    <published>2020-08-28T01:45:00.000Z</published>
    <updated>2020-08-28T03:12:31.120Z</updated>
    
    <content type="html"><![CDATA[<p>提供一种小数据下运行效率极高的<code>std::set</code>替代方法。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-asia mr-2"></i>此页面存在相关页面。关于普通平衡树，请参见<a href="/2020/06/26/Splay/">「Splay」</a>。</div></article><a id="more"></a><p>众所周知，平衡树有两类：一类维护集合，一类维护序列。维护序列的平衡树通常作为线段树的替代，用于解决线段树并不支持的区间翻转操作；而维护集合的平衡树则可以被看作是在重现<code>std::set</code>。</p><p>但是这并不是最简便的方案，实际上，我们可以利用<code>std::vector</code>去吊锤维护集合的平衡树。此种方法在 $10^5$ 量级下速度极快，运行时间甚至优于普通 Splay。</p><p>维护集合的平衡树被用来解决这样一类问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>您需要写一种数据结构，来维护一些数，其中需要提供以下操作：</p><ol><li>插入 $x$ 数</li><li>删除 $x$ 数（若有多个相同的数，因只删除一个）</li><li>查询 $x$ 数的排名（排名定义为比当前数小的数的个数 $+1$）</li><li>查询排名为 $x$ 的数</li><li>求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）</li><li>求 $x$ 的后继（后继定义为大于 $x$，且最小的数）</li></ol><p>设 $n$ 为集合的最大大小，对所有数据，满足 $n\le 10^5$。</p></div></article><p>利用<code>std::lower_bound</code>和<code>std::upper_bound</code>，可以得到下面的这样两条语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lower_bound(v.begin(), v.end(), x) - v.begin() <span class="comment">// &lt; x 的元素个数</span></span><br><span class="line">upper_bound(v.begin(), v.end(), x) - v.begin() <span class="comment">// &lt;= x 的元素个数</span></span><br></pre></td></tr></table></figure><p>于是可以得到下面<a href="https://www.luogu.com.cn/record/37763229">这份</a>代码实现。显然，它吊锤了 <a href="https://www.luogu.com.cn/record/34668994">Splay</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v; <span class="keyword">int</span> n = read();</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    <span class="keyword">int</span> tp = read(), x = read();</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">1</span>) v.insert(lower_bound(v.begin(), v.end(), x), x);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">2</span>) v.erase(lower_bound(v.begin(), v.end(), x));</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, lower_bound(v.begin(), v.end(), x) - v.begin() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, v[x - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, v[lower_bound(v.begin(), v.end(), x) - v.begin() - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, v[upper_bound(v.begin(), v.end(), x) - v.begin()]);</span><br><span class="line">    <span class="keyword">if</span>(tp &gt; <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理性分析一下，这份代码的时间复杂度为 $O(n^2\log n)$，瓶颈在于<code>erase()</code>和<code>insert()</code>。</p><p>但是我们可以对其进行测试，Generator 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">int</span> t1 = <span class="number">1</span>, t2 = <span class="number">1000000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"1 %d"</span>, t1++), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1 %d"</span>, t2--), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4 %d"</span>, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本机测试结果如下：</p><table><thead><tr><th>数据范围</th><th>$n=5\times10^4$</th><th>$n=10^5$</th><th>$n=5\times 10^5$</th><th>$n=10^6$</th></tr></thead><tbody><tr><td>运行时间（平均，向下近似）</td><td>100ms</td><td>280ms</td><td>7.7s</td><td>30s</td></tr><tr><td>运行时间（平均，向下近似，O2）</td><td>70ms</td><td>280ms</td><td>7s</td><td>28s</td></tr><tr><td>对比（普通 Splay）</td><td>30ms</td><td>30ms</td><td>260ms</td><td>380ms</td></tr></tbody></table><p>容易发现当 $n$ 超过 $10^5$ 的量级后，其运行效率略大于 $O(n\sqrt{n})$，而在之前效率及其优秀。但是实际上题目中插入操作的数量并没有达到测试中的量级，因此出现了吊锤 Splay 的现象。</p><p>于是我们可以初步地得出结论：在 $10^5$ 的数据量级下，利用<code>vector</code>代替 Splay 有着优秀的运行效率。</p><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的图，给出 $m$ 对点和 $q$ 条边。顺序尝试加入每条边，如果不会使得 $m$ 对点中的任意一对点联通，则加入，否则不加入。判断每条边是否会被加入。<br>$n,m,q\le 10^5$</p></div></article><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>条件反射：看到不可逆性修改操作，就应该想到结构合并。</div></article><p>容易想到对每个点维护一个<code>set</code>，表示该点不能到达的点集，然后连一条边相当于合并两个<code>set</code>，在合并前判断一下，然后启发式合并就好了。<br>然后把<code>set</code>换成<code>vector</code>，运行时间得以缩小一半。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fa[CN]; DSU() &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) fa[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] ^ x ? fa[x] = fd( fa[x] ) : x;&#125;</span><br><span class="line">&#125; C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("_in.in", "r", stdin);</span></span><br><span class="line"></span><br><span class="line">    n = read(), m = read(), q = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        v[x].push_back(y), v[y].push_back(x);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(), fx = C.fd(x), fy = C.fd(y);</span><br><span class="line">        <span class="keyword">if</span>(fx == fy) &#123;<span class="built_in">putchar</span>(<span class="string">'1'</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> szx = v[fx].size(), szy = v[fy].size();</span><br><span class="line">        <span class="keyword">if</span>(szx &gt; szy) swap(fx, fy), swap(szx, szy);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; szx &amp;&amp; flag; i++) <span class="keyword">if</span>(C.fd( v[fx][i] ) == fy) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;<span class="built_in">putchar</span>(<span class="string">'0'</span>); <span class="keyword">continue</span>;&#125; <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        <span class="comment">/* fx -&gt; fy */</span></span><br><span class="line">        C.fa[fx] = fy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; szx; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = v[fx][i], p = lower_bound(v[fy].begin(), v[fy].end(), u) - v[fy].begin() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(v[fy][p] == u) <span class="keyword">continue</span>;</span><br><span class="line">            v[fy].insert(lower_bound(v[fy].begin(), v[fy].end(), u), u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提供一种小数据下运行效率极高的&lt;code&gt;std::set&lt;/code&gt;替代方法。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-primary&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;
此页面存在相关页面。关于普通平衡树，请参见&lt;a href=&quot;/2020/06/26/Splay/&quot;&gt;「Splay」&lt;/a&gt;。
&lt;/div&gt;
&lt;/article&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="平衡树" scheme="https://big-news.cn/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>「题解」Fancy Fence</title>
    <link href="https://big-news.cn/2020/08/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DFancy%20Fence/"/>
    <id>https://big-news.cn/2020/08/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DFancy%20Fence/</id>
    <published>2020-08-27T02:15:00.000Z</published>
    <updated>2020-08-30T01:34:52.225Z</updated>
    
    <content type="html"><![CDATA[<p>打了一场 CEOI2020 Day1 的线上镜像，发现这个 A 题好像有点水啊，于是切掉，来水个题解……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1402/problem/A">原题链接</a></p><p>容易发现，一个长为 $N$ 宽为 $M$ 的矩形的合法子矩形的数量可以 $O(1)$ 算。具体来讲，设：<br>$$A=\dbinom{NM}{2}, B = M·\dbinom{N}{2},C=N·\dbinom{M}{2}$$ 有该矩形的子矩形数量为：<br>$$(A-B-C)/2+B+C$$ 之所以要算的这么麻烦是为了去重…这个重复的问题考场上卡了我半小时/kk…</p><p>那么考虑对于每个 $h_i$ 拆开来算贡献。对于当前的高度 $h_i$ ，我们确定两个端点 $l_i$ 和 $r_i$，使得 $[l_i,r_i]$ 是极长的一段区间满足 $\min\limits_{l_i\le k\le r_i} h_k=h_i$，于是我们可以找到一个极大的矩形，然后就可以在这个矩形里面算答案了。</p><p>剩下的问题是考虑重复，即这个矩形下方存在一个 $h$ 更小的矩形（它应该是矮矮长长的这个样子），而它的贡献我们已经在前面算过了。我们强制令矩形的一个端点在这个矩形上方就好了。</p><p>于是就只剩下单调栈的复杂度了，总复杂度 $O(n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long <span class="comment">// 惨痛经历</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i2 = <span class="number">500000004</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, h[CN], w[CN], sum[CN], pr[CN], nt[CN], stk[CN], top = <span class="number">0</span>, ans = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; cal[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> (<span class="number">1l</span>l * x * (x - <span class="number">1</span>) / <span class="number">2l</span>l) % P;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ab = ((a - b) % P + P) % P;</span><br><span class="line">    <span class="keyword">int</span> rec = C(<span class="number">1l</span>l * l * ab % P), t1 = C(ab), t2 = C(l);</span><br><span class="line">    t1 = <span class="number">1l</span>l * t1 * l % P, t2 = <span class="number">1l</span>l * t2 * ab % P;</span><br><span class="line">    rec = ((rec - t1 - t2) % P + P) % P, rec = <span class="number">1l</span>l * rec * i2 % P;</span><br><span class="line">    rec = (rec + t1 + t2) % P;</span><br><span class="line">    <span class="keyword">int</span> t = C(l + <span class="number">1</span>); t = <span class="number">1l</span>l * t * b % P, t = <span class="number">1l</span>l * t * ab % P, t = (t + P) % P;</span><br><span class="line">    <span class="keyword">return</span> (rec + t) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) h[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) w[i] = read(), sum[i] = (sum[i - <span class="number">1</span>] + w[i]) % P, ans = (<span class="number">1l</span>l * w[i] * h[i] % P + ans) % P;</span><br><span class="line"></span><br><span class="line">    stk[++top] = <span class="number">1</span>, pr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h[ stk[top] ] &gt;= h[i]) top--;</span><br><span class="line">        pr[i] = stk[top], stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[top = <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h[ stk[top] ] &gt;= h[i]) top--;</span><br><span class="line">        nt[i] = stk[top], stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cal[ pr[i] ][ h[i] ]) <span class="keyword">continue</span>; cal[ pr[i] ][ h[i] ] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l = (sum[ nt[i] - <span class="number">1</span> ] - sum[ pr[i] ] + P) % P, a = h[i], b = max(h[ pr[i] ], h[ nt[i] ]);</span><br><span class="line">        ans = (ans + calc(l, a, b)) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打了一场 CEOI2020 Day1 的线上镜像，发现这个 A 题好像有点水啊，于是切掉，来水个题解……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="单调栈" scheme="https://big-news.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>「杂题选做」八月口胡合集</title>
    <link href="https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/"/>
    <id>https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/</id>
    <published>2020-08-24T10:06:00.000Z</published>
    <updated>2020-09-03T03:16:33.672Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，做题的关键在于口胡出解法，而我还是什么都不会……</p><a id="more"></a><p>本篇 Blog 多以口胡为主，杂题居多。</p><h3 id="1-Hunger-Game"><a href="#1-Hunger-Game" class="headerlink" title="1 Hunger Game"></a>1 Hunger Game</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $N$ 个箱子，每个箱子有 $a[i]$ 个石头，一开始所有箱子都是关着的。<br>Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。<br>不能操作的输，求先手必胜还是后手必胜。<br>$1\le N\le 1e5, 0\le a[i]&lt;10^9$</p></div></article><p>Nim 博弈的经典结论：对于每个状态有 $SG_i=a_i$ ，则终态是 P 态的充要条件是 $a_1\oplus a_2\oplus … \oplus a_n = 0$。</p><p>回到本题，如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。<br>如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。</p><p>因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。<br>大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。</p><h3 id="2-Minimum-Value-of-Equation"><a href="#2-Minimum-Value-of-Equation" class="headerlink" title="2 Minimum Value of Equation"></a>2 Minimum Value of Equation</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定 $k[i],b[i]$，有 $n$ 个函数，第 $j$ 个函数为 $f_j(x)=\sum |k[i]x+b[i]|$，其中$1\le i\le j$。<br>对于每个 $j=1…n$，求出 $f_j(x)$ 的最小值。<br>$1\le n\le 10^5 , |k[i]|\le 1000$</p></div></article><p>提一下公因式变成 $\sum k_i|x+(b_i/k_i)|$ ，即 $x$ 到数轴上的一堆点 $b_i/k_i$ 的距离和，那么 $x$ 取这些点的中位数就好了。</p><h3 id="3-DFS-Count"><a href="#3-DFS-Count" class="headerlink" title="3 DFS Count"></a>3 DFS Count</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个 $n$ 个点的有向图，求合法的 DFS 序的个数。<br>$n \le 13$</p></div></article><p>直接搜？？？（雾<br>设 $f[u,S]$ 表示当前在 $u$ ，没走过的点集为 $S$ 的方案数。$|S|$ 是递减的，可通过其来划分子问题，得到转移：<br>$$ f[v,T_v \And S]·f[u,S-(T_v \And S)] \to f[u, S] | (u,v)\in E$$<br>其中 $T_v$ 是 $v$ 能到达的点集。容易发现这次从小集合往大集合转移，则其是可操作的。</p><h3 id="4-XOR-Product"><a href="#4-XOR-Product" class="headerlink" title="4 XOR Product"></a>4 XOR Product</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定序列 $a_1,…,a_n$ ，求：<br>$$ \sum\limits_{i&lt;j&lt;k}(a_i\oplus a_j)·(a_j \oplus a_k) $$</p></div></article><p>把 $j$ 提出来，拆一下柿子：<br>$$ \sum\limits_j(\sum\limits_{i&lt;j}a_i\oplus a_j)(\sum\limits_{j&lt;k}a_j \oplus a_k) $$<br>考虑求 $\sum\limits_{i&lt;j}a_i\oplus a_j$ ，把每一位拆开算贡献，则应当统计 $a_1,…,a_{j-1}$ 中这一位上有多少个 1 ，预处理即可。<br>预处理是 $O(n\log)$ 的，枚举 $j$ 处理前后两个 sigma 是 $O(n\log)$ 的，最后统计答案也是 $O(n)$ 的。</p><h3 id="5-SUMXOR"><a href="#5-SUMXOR" class="headerlink" title="5 SUMXOR"></a>5 SUMXOR</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定序列 $a[1…n]$ 和 $b[1…n]$ ，求：<br>$$ \bigoplus\limits_{i,j}a_i+b_j $$</p></div></article><p>依然拆开每一位算，考虑第 $w$ 位的贡献应当是 $2^w\sum[(a_i+b_j)\text{ mod } 2^{w+1} \ge 2^w] \text{ mod }2$。<br>令 $a_i\gets a_i\text{ mod }2^{w+1},b_i\gets b_i\text{ mod }2^{w+1} $，有两种情况：</p><ol><li>$a_i + b_j \ge 2^{w+1}$，则应当有 $a_i+b_j-2^{w+1}\ge 2^w$，移项得 $a_i+b_j\ge 2^w+2^{w+1}$</li><li>$a_i+b_j&lt; 2^{w+1}$，则应当有 $2^w\le a_i+b_j&lt; 2^{w+1}$</li></ol><p>于是转化成序列上的查询问题，Two-Pointers 扫即可。</p><h3 id="6-The-Hanged-Man"><a href="#6-The-Hanged-Man" class="headerlink" title="6 The Hanged Man"></a>6 The Hanged Man</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个 $n$ 个点的树，每个点有一个体积 $v[i]$ 和收益 $w[i]$，现在你能选一个独立集，对于每个 $i$ 输出体积和为 $i$ 的收益和最大的独立集的值。<br>$n\le 50, m\le 5000$</p></div></article><p>$O(nm^2)$ 的 DP 显然啊，但是重链剖分 DP 看不懂啊，这个先咕着。</p><p>资料：<a href="https://www.cnblogs.com/dqsssss/p/11534336.html">乱搞</a>，<a href="https://blog.aor.sd.cn/archives/1122/">重链剖分</a></p><p>附一个 $O(nm^2)$ 的 DP：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, vi[CN], wi[CN], f[CN][<span class="number">5005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][ vi[u] ][<span class="number">1</span>] = wi[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> V = m; V; V--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> Vp = <span class="number">0</span>; Vp &lt;= V; Vp++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(V - Vp &gt;= vi[u]) f[u][V][<span class="number">1</span>] = max(f[u][V][<span class="number">1</span>], f[v][Vp][<span class="number">0</span>] + f[u][V - Vp][<span class="number">1</span>]);</span><br><span class="line">                f[u][V][<span class="number">0</span>] = max(f[u][V][<span class="number">0</span>], max(f[v][Vp][<span class="number">0</span>], f[v][Vp][<span class="number">1</span>]) + f[u][V - Vp][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Anton-and-Ira"><a href="#7-Anton-and-Ira" class="headerlink" title="7 Anton and Ira"></a>7 Anton and Ira</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定两个排列 $s$ 和 $p$ ，每次可以交换 $p$ 中的两个数，代价为它们间的距离，问最小代价使 $p$ 变为 $s$ ，输出方案。<br>$n\le 1000$</p></div></article><p>设 $to[u]$ 是 $u$ 想要去到的位置，可以将其看作一条有向边。根据抽屉原理，某一时刻必然存在一个点使 $to[u]$ 与 $to[to[u]]$ 反向，于是贪心就好了。<br>设这样得到的答案为 $s$，容易发现对于一种操作方案，必然存在另一种与之互为补集的操作方案，其答案也为 $s$。两者可以组成全集，即有 $2s=\sum|i-to[i]|$，从而 $s=\sum|i-to[i]|/2$。</p><h3 id="8-Increasing-Shortest-Path"><a href="#8-Increasing-Shortest-Path" class="headerlink" title="8 Increasing Shortest Path"></a>8 Increasing Shortest Path</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有个 $n$ 个点 $m$ 条边的有向图，有 $q$ 个询问：从 $ai$ 到 $bi$，边权递增，经过不超过 $ci$ 条边，权值和最小是多少？<br>$T$组数据（$T\le 100$）。<br>$n ≤ 150, m, q ≤ 5000.$</p></div></article><p>$n$ 比较小，那么考虑 DP。<br>边权看上去没办法放进状态里面，有一个技巧是把边升序排序，然后按照边来转移状态，即可满足要求。</p><p>设 $f[u,v,m]$ 表示 $u\to v$ 经过不超过 $m$ 条边的答案，$O(n)$ 固定起点 $s$，$O(m)$ 枚举一条边 $(u,v,w)$，则有转移：<br>$$ f[s,u,k]+w\to f[s,v,k+1] $$<br>这样看上去是 $O(nm^2)$ 的，但是考虑到限制是“至多经过”，而要求最小路径，则一个环不应在路径中出现，即一个点不会被访问超过一次。考虑到一个点之多有一条出边被选中，因此状态第三维的数量实际上是 $O(n)$ 的。对于 $ci&gt; n$ 的询问，其答案一定等于 $ci=n$ 的询问。</p><p>复杂度 $O(T(m\log m+n^2m+q))$，瓶颈在于 $O(Tn^2m)$；考虑到时限是 60s， 因此可以通过。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sort(G + <span class="number">1</span>, G + m + <span class="number">1</span>), <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) f[i][i][k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= n; s++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = G[i].u, v = G[i].v, w = G[i].w;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) </span><br><span class="line">                f[s][v][k + <span class="number">1</span>] = min(f[s][u][k] + w, f[s][v][k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="9-Increasing-Number"><a href="#9-Increasing-Number" class="headerlink" title="9 Increasing Number"></a>9 Increasing Number</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个数是Increasing当且仅当它的十进制表示是不降的，求 $n$ 位不降十进制数中被 $m$ 整除的有多少个。<br>$n ≤ 10^{18}, m ≤ 500.$</p></div></article><p>显然有状态 $f[n,p,k]$ 表示考虑第 $n$ 位数字，当前位填 $p$，模 $m$ 等于 $k$ 的方案数，转移可以枚举当前位数字和上一位数字，有关系 $f[n,p,(p\times 10^n+k)\text{ mod }m]\gets f[n-1,p’,k]$，复杂度 $O(100nm)$，不太可行。<br>对于这种转移关系比较固定的 DP，可以考虑矩乘加速，但是这是 $O((10m)^3\log n)$ 的，看上去也不太行。</p><p>一个重要的性质：一个合法数字必然是至多 9 个仅由 1 组成的数的和。<br>则可以按 $111…111$ 模 $m$ 的值将其分类，这样有 $m$ 类，然后对类做 DP 即可。<br>这也令我们可以得出一个结论：位数小于 $n$ 的不降数的总个数是 $\sum\limits_{i=1}^9\dbinom{i+n-1}{n-1}=\dbinom{n+9}{n}-1$。</p><h3 id="10-Little-Elephant-and-Colored-Coins"><a href="#10-Little-Elephant-and-Colored-Coins" class="headerlink" title="10 Little Elephant and Colored Coins"></a>10 Little Elephant and Colored Coins</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定 $n$ 个物品，每个物品可以取无限次，每个物品有两种属性：价值 $v$ 和颜色 $c$。<br>现在有 $q$ 个询问，询问最多能用多少种颜色组成 $S$。<br>$n ≤ 30, v_i ≤ 2\times 10^5,s\le 10^{18}$</p></div></article><p>对于这种题目，一般来说技巧是取 $w=\min v_i$ ，把问题转化到模 $w$ 的剩余系下做。这样做的正确性在于：$\mathbb{F}_P$ 中的所有数与 $P$ 的倍数组合能够填满整个整数域。<br>然后可以设状态 $f[u,k]$ 或 $f[k]$ 表示模 $w$ 为 $k$ 的答案，对于物品的价值 $v$ 可以抽象成一条边的边权，然后套用最短路模型，于是做到 $O(w\log w)$ 转移状态。</p><p>对于本题，考虑到硬币种类可能在统计过程中重复，因此设 $f[i,k]$ 表示选至少 $i$ 种，模 $w$ 为 $k$ 的路径的最小长度；用最短路模型来转移看上去也不太行，考虑换成背包模型，即有 $f[i,k]\gets f[i+1,(k+v_i)\text{ mod }w]$，然后按 $i$ 分组 DP 更新即可，复杂度 $O(n^2w)$。</p><p>给出大致的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = read(), w = w ? min(w, v[i]) : v[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j + <span class="number">1</span>; j--) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">            f[j + <span class="number">1</span>][(k + v[i]) % w] = min(f[j][k] + v[i], f[j + <span class="number">1</span>][(k + v[i]) % w]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">            f[i][(k + v[j]) % w] = min(f[i][k] + v[j], f[i][(k + v[j]) % w]);</span><br><span class="line">    </span><br><span class="line">q = read();</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> s = read(), sw = s % w;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &amp;&amp; !flag; i--)</span><br><span class="line">        <span class="keyword">if</span>(f[i][sw] &lt; INF &amp;&amp; f[i][sw] &lt;= s) <span class="built_in">printf</span>(<span class="string">"%d"</span>, i), <span class="built_in">puts</span>(<span class="string">""</span>), flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Balance"><a href="#11-Balance" class="headerlink" title="11 Balance"></a>11 Balance</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个杠杆，半长为 $n$，$2n+1$ 个整数坐标各有一个质量相同的砝码，取走 $k$ 个，问最终杠杆仍然平衡的方案数。<br>$n\le 10^4, k\le 10$</p></div></article><p>整数划分问题。<br>容易发现两边是完全对称的，那么只需要考虑一边。考虑枚举取的数字和是多少，设 $f[i,k]$ 表示把数字 $i$ 拆分成 $k$ 个小于 $n$ 的不同数字的方案数，有转移：<br>$$ \begin{aligned}f[i,k]&amp;=f[i-k,k]+f[i-k,k-1]\newline f[i,k]&amp;=f[i,k]-f[i-n-1,k-1] \text{ }\text{ }| \text{ }\text{ }i\ge n + 1 \end{aligned}$$<br>复杂度 $O(nk^2)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - K + <span class="number">1</span>; i &lt;= n; i++) N += i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        f[i][k] = i &gt;= k ? (f[i - k][k] + f[i - k][k - <span class="number">1</span>]) % p : <span class="number">0</span>,</span><br><span class="line">        f[i][k] = i &gt; n ? (f[i][k] - f[i - n - <span class="number">1</span>][k - <span class="number">1</span>] + p) % p : f[i][k];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= N; w++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K; j++) ans = (<span class="number">1l</span>l * f[w][j] * f[w][K - j] % p + ans) % p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= N; w++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K - <span class="number">1</span>; j++) ans = (<span class="number">1l</span>l * f[w][j] * f[w][K - j - <span class="number">1</span>] % p + ans) % p;</span><br></pre></td></tr></table></figure><h3 id="12-Arrangement-Count"><a href="#12-Arrangement-Count" class="headerlink" title="12 Arrangement Count"></a>12 Arrangement Count</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>求有多少个排列 $A\subseteq [n]$，使得 $A$ 中每个位置与相邻位置的数的差不为 1。<br>$n\le 1000$</p></div></article><p>设 $f[i,j,0/1]$ 表示考虑 $A\subseteq [i]$，有 $j$ 对相邻位置相差为 1 ，$i$ 是否与 $i+1$ 相邻的方案数，有转移：</p><ol><li>$f[i,j,0]·j\to f[i+1,j-1,0]$</li><li>$f[i,j,0]·2\to f[i+1, j + 1, 1], f[i,j,1]·2\to f[i+1, j, 1]$</li><li>$f[i,j,0/1]·(i-j-1)\to f[i+1,j,0]$</li></ol><p>复杂度 $O(n^2)$。</p><h3 id="13-Cut-Tree"><a href="#13-Cut-Tree" class="headerlink" title="13 Cut Tree"></a>13 Cut Tree</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个节点的树，点有点权，要切两条边和加一个点使得形成的三个子树点权和相等，最小化新加节点点权的绝对值。<br>$n \le 10^5$</p></div></article><p>考虑固定一整棵树的根，对所有 $n$ 棵子树的大小统计其出现次数 $cnt[]$。不妨设当前的根处需要割断一条边，那么枚举其的枚举一个子树 $v$，设其大小为 $sz[v]$ ，则当 $cnt[sz[v]]&gt;1$ 时，可将整棵树切成三个部分：两个 $sz[v]$ 和一个 $n-sz[v]$ ，于是可以更新答案。</p><p>但是当前根处不一定会割断边，那么考虑换根。容易发现当根向某个儿子移动时，至多有两个节点的 $sz[]$ 值会发生变化，则简单维护即可。</p><p>于是可以做到不漏算答案，时间复杂度 $O(n)$。</p><h3 id="14-Number-Game"><a href="#14-Number-Game" class="headerlink" title="14 Number Game"></a>14 Number Game</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>Alice 和 Bob 又双叒叕在玩游戏。<br>Bob 每次会想一个 $0\text{~}n$ 的数，Alice 每次猜 $k$，Bob 告诉 Alice 大了还是小了。Alice 猜 $k$ 会付出 $a_k$ 的代价，Alice 要最小化代价，Bob 要最大化代价（并在不违反前面询问的情况下改数）。假设二人都绝顶聪明，求 Alice 最后付出多少代价。<br>$n \le 10^5, a_i\le 9$</p></div></article><p>本人只会 $O(n^3)$ 的辣鸡 DP……</p><p>设 $f[l,r]$ 为考虑区间 $[l,r]$ 的答案，应当有转移：<br>$$ f[l,r]=\min\limits_k a_k+ \max(f[l,k-1],f[k+1,r]) $$ 边界是 $f[i,i]=a_i$，直接大力 DP 即可做到 $O(n^3)$。</p><h3 id="15-Distributs"><a href="#15-Distributs" class="headerlink" title="15 Distributs"></a>15 Distributs</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>小 A 带来了 $m$ 种特产，第 $i$ 种特产的数量为 $a_i$。小 A 要把它们全部分给 $n$ 个同学，要求每个同学至少拿到一个特产，问有多少种分法，对 $10^9+7$ 取模。<br>$n,m \le 1000$</p></div></article><p>容斥简单题，钦点 $k$ 个人一定分不到，剩下的随便分，在总方案数中减去就好了，则答案是：<br>$$ \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k}\sum\limits_j \dbinom{a_j+n-k-1}{n-k-1}$$ 复杂度 $O(n^2)$。</p><h3 id="16-Solutions-of-the-Equation"><a href="#16-Solutions-of-the-Equation" class="headerlink" title="16 Solutions of the Equation"></a>16 Solutions of the Equation</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个变量 $x_1…x_n$，每个变量 $0&lt;x\le R$，给定 $S$，求方程 $x_1+x_2+…+x_n=S$有多少组正整数解。<br>$n \le 1000$</p></div></article><p>容斥简单题，如果不考虑限制答案是 $\dbinom{S-1}{n-1}$，然后钦点有 $k$ 个变量不合法然后去加加减减，答案是：<br>$$ \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k}\dbinom{S-kR-1}{n-1} $$ 复杂度 $O(n^2)$。</p><h3 id="17-Bohater"><a href="#17-Bohater" class="headerlink" title="17 Bohater"></a>17 Bohater</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>在一款电脑游戏中，你需要打败$n$只怪物（从 $1$ 到 $n$ 编号），初始生命值为 $z$。<br>为了打败第 $i$ 只怪物，你需要消耗 $d_i$ 点生命值，但怪物死后会掉落血药，使你恢复 $a_i$ 点生命值。<br>任何时候你的生命值都不能降到 0（或 0 以下）。请问是否存在一种打怪顺序，使得你可以打完这 $n$ 只怪物而不死掉。如果存在请输出方案，不存在输出NO。<br>$1≤n,z≤10^5，0≤d_i,a_i≤10^5$</p></div></article><p>考虑把怪分成两类，先打加血怪，再打减血怪；考虑打加血怪的过程：应当按 $d_i$ 升序去打。<br>减血怪呢？考虑打怪的反过程：不打一个怪，血量增加 $d_i$ 而减少 $a_i$。<br>则反过程应当按 $a_i$ 升序排，正过来就是按 $a_i$ 降序排。</p><p>复杂度 $O(n\log n)$。</p><h3 id="18-Swap-Space"><a href="#18-Swap-Space" class="headerlink" title="18 Swap Space"></a>18 Swap Space</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>你有许多电脑，它们的硬盘用不同的文件系统储存数据。你想要通过格式化来统一文件系统。格式化硬盘可能使它的容量从 $a_i$ 变成 $b_i$。<br>为了格式化，你需要买额外的硬盘。当然，你想要买容量最小的额外储存设备以便省钱。<br>你可以按任意顺序格式化硬盘。格式化之前，你要把该硬盘上所有数据移到一个或更多的其他硬盘上，数据可以分割。<br>格式化后，该硬盘可以立刻开始使用。你没有必要把数据放到它原来所在的硬盘上。数据也可以被放到你额外买的硬盘上。<br>求最小的额外储存设备容量。<br>$1≤n≤10^6,1≤a_i,b_i≤10^9$</p></div></article><p>考虑二分最终的答案 $M$ ，表示一开始购买的硬盘大小，则模型变为：</p><ul><li>给定一些元素 $(a,b)$ ，选择某个元素会付出代价 $a$ 得到收益 $b$ ，求能否选择所有元素。</li></ul><p>这就是上题模型，复杂度 $O(n\log^2n)$，看上去有点卡。</p><p>实际上二分大可不必，依然按照上题的思路去做，当代价和多于当前的承受限度时，把多出来的那一部分加到答案里即可，复杂度 $O(n\log n)$。</p><h3 id="19-Maximum-Value-of-Linear-Function"><a href="#19-Maximum-Value-of-Linear-Function" class="headerlink" title="19 Maximum Value of Linear Function"></a>19 Maximum Value of Linear Function</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>现在有 $n$ 个一次函数，$f_i(x)=a_ix+b_i$。给定 $x$，并且对于所有的 $f_i(x)$ 可以任意改变顺序嵌套函数，求 $f(f(f(…f(x))…)$ 的最大值。<br>$n\le 10^6$</p></div></article><p>容易发现 $x$ 的系数一定，那么只需要考虑常数项最大。<br>考虑交换，对二元组 $(a_1,b_1)$ 和 $(a_2,b_2)$ ，前者放在外层当且仅当 $a_1(a_2x+b_2)+b_1&gt;a_2(a_1x+b_1)+b_2$，移项得 $(a_1-1)/b_1&gt;(a_2-1)/b_2$，则按照 $(a_i-1)/b_i$ 降序排序，把靠前的放在外层即可。</p><p>这个题也可以类比一下<a href="https://www.luogu.com.cn/problem/P1080">「国王游戏」</a>那道题。考虑何时应该交换相邻的两个元素 $i,j$：当且仅当 $\Pi/b_i+(a_i·\Pi)/b_j &gt; \Pi/b_j+(a_j·\Pi)/b_i$，化简得 $(a_j-1)·b_j&lt;(a_i-1)·b_i$，因此按 $(a_i-1)·b_i$ 为关键字排序即可。</p><h3 id="20-Kuglarz"><a href="#20-Kuglarz" class="headerlink" title="20 Kuglarz"></a>20 Kuglarz</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个杯子排成一排，每个杯子中可能放有也可能没有一个小球。你每次可以花费 $C(i,j)$ 的代价得知区间 $[i,j]$ 的杯子中球的总数的奇偶性。<br>问最少花费多少代价才能求出每个杯子中是否有小球。<br>$n\le 1000$</p></div></article><p>看上去很像 DP，但我的做法假掉了……<br>建一张图，边 $(u,v)$ 的边权为 $C(u,v)$，则问题等价于求出图上的最小生成树。<br>时间复杂度 $O(n^2)$。</p><h3 id="21-OSU"><a href="#21-OSU" class="headerlink" title="21 OSU!"></a>21 OSU!</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。<br>求该 01 串的价值的期望。<br>$n\le 10^5$</p></div></article><p>考察期望的定义，和应用用贡献法计算每一位的价值期望。<br>设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：<br>$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：<br>$$ \begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \end{aligned}$$ 于是可以做到 $O(n)$。<br>注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l[i] = a[i] * (l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l2[i] = a[i] * (l2[i - <span class="number">1</span>] + <span class="number">2</span> * l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] + a[i] * (<span class="number">3</span> * l2[i - <span class="number">1</span>] + <span class="number">3</span> * l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，做题的关键在于口胡出解法，而我还是什么都不会……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
</feed>
