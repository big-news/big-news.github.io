<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://big-news.cn/"/>
  <updated>2020-09-21T13:06:18.456Z</updated>
  <id>https://big-news.cn/</id>
  
  <author>
    <name>big-news</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>圆方树</title>
    <link href="https://big-news.cn/2020/09/21/%E5%9C%86%E6%96%B9%E6%A0%91/"/>
    <id>https://big-news.cn/2020/09/21/%E5%9C%86%E6%96%B9%E6%A0%91/</id>
    <published>2020-09-21T06:15:00.000Z</published>
    <updated>2020-09-21T13:06:18.456Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，圆方树是用以解决一类仙人掌图问题的重构树，但是类似的方法也可以用来解决某些普通无向图问题。依赖于其优美的树形结构，我们可以在 $\log |V|$ 的时间复杂度内回答一类图上的点对路径并集的询问问题……</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>我们对一张联通无向图的每个 BCC（点双连通分量）建一个方点，原图上每个点作为一个圆点。对于不在环上的点，保留它们之间的边；对于环上的点，把它们和对应的方点相连边，就得到了一棵圆方树，如下图。</p><p><img src="/pictures/1126418-20190711015718548-2063534813.png" alt="圆方树的构建"></p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>这里使用的是 <code>PinkRabbit</code> 兔队的<a href="https://www.cnblogs.com/PinkRabbit/p/10446473.html#codeforces-487etourists">构建方法</a>，用于一般无向图的圆方树构建。注意，对于仙人掌图的圆方树构建，可以在 dfs 中枚举返祖边来完成，它的好处在于能求出环上的点的顺序，以便于维护环上路径信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, ext = n; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ext++; <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], T[ext].push_back(v), T[v].push_back(ext);</span><br><span class="line">                T[ext].push_back(u), T[u].push_back(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，$q$ 次询问 $u,v$ 之间的割点的数量。<br>$n,m,q\le 5\times 10^5$</p></div></article><p>容易发现答案就是圆方树上 $u\to v$ 的路径上圆点的数量，倍增维护即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, ext, fa[CN][<span class="number">21</span>]; <span class="keyword">bool</span> w[CN]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u, w[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ext++, fa[ext][<span class="number">0</span>] = u, T[u].push_back(ext);</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], fa[pos][<span class="number">0</span>] = ext, T[ext].push_back(pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[CN], dep[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dep[u] = dep[p] + <span class="number">1</span>, dis[u] = dis[p] + w[u];</span><br><span class="line">    <span class="keyword">int</span> sz = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) dfs(T[u][i], u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ext = n = read(), m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bd(<span class="number">1</span>, <span class="number">0</span>), dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(), l = lca(x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, dis[x] + dis[y] - dis[l] - dis[ fa[l][<span class="number">0</span>] ]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，问有多少三元组 $(s,c,f)$ 满足存在一条 $s\to f$ 的路径经过 $c$。<br>$n,m\le 2\times 10^5$</p></div></article><p>题目本质上就是在求 $s\to f$ 的简单路径的并集大小。</p><p>有一个经典结论：</p><ol><li>一张无向图上相同 BCC 中两个点 $(u,v)$ 之间的简单路径并集恰好是这个 BCC</li><li>一张无向图上不同 BCC 中两个点 $(u,v)$ 之间的简单路径并集是这两个 BCC 并上把它们连接的点</li></ol><p>于是可以圆方树上的点恰当赋值：方点点权为该 BCC 的大小，圆点点权为 $-1$。那么 $s\to f$ 在树上的路径权就是合法的 $c$ 的数量。</p><p>考虑计算所有圆点对 $(s,f)$ 的路径长度和。运用贡献法去想，答案是每个 $w[u]$（即点权）乘上经过这个点的路径数量。经过 $u$ 的路径可以分为两种：从 $u$ 子树内到 $u$ 子树外；$u$ 子树内兄弟节点之间的路径。前者的数量是 $sz[u]\times (n-sz[u])$，后者的数量大概是 $\dbinom{sz[u]}{2}$ 再减去若干部分，直接在 dfs 的过程中计算即可，时间复杂度 $O(n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar(); <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> s * ne;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, ext, w[CN], num; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u, w[u] = <span class="number">-1</span>, num++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ext++, T[u].push_back(ext);</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>; w[ext] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], T[ext].push_back(pos), w[ext]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>; <span class="keyword">int</span> sz[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[u].size(); sz[u] = u &lt;= n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) dfs(T[u][i]), ans += <span class="number">1l</span>l * sz[u] * sz[ T[u][i] ] * w[u], sz[u] += sz[ T[u][i] ];</span><br><span class="line">    ans += <span class="number">1l</span>l * sz[u] * (num - sz[u]) * w[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    ext = n = read(), m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!dfn[i]) num = <span class="number">0</span>, bd(i, <span class="number">0</span>), dfs(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，点有点权，$q$ 次询问 $u\to v$ 的可行简单路径上权值最小值，支持修改点权。<br>$n,m,q\le 10^5$</p></div></article><p>注意到如果不带修改，直接圆方树上倍增即可。带修的话，显然的想法是重链剖分之后套个线段树。</p><p>但是这样有个问题，就是修改一个圆点需要修改所有与其相连的方点，这样实际上是 $O(n)$ 的。<br>我们考虑利用圆方树的性质，把方点的点权设为它的儿子的权值最小值，那么因为一个圆点至多有一个方点作为父亲，这样修改就变成了 $O(1)$ 的。<br>但是这样查询的时候如果方点的父亲没被访问到，即方点作为 lca 的情况，还需要对这个方点的父亲的权值取 $\min$。</p><p>时间复杂度 $O(n\log^2 n)$，常数不小，因为实际上我们需要一个 <code>multiset</code> 去维护方点的点权……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar(); <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> s * ne;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; </span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; val[CN]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], dfc = <span class="number">0</span>, w[CN], ext = <span class="number">0</span>, stk[CN], tp = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++dfc, stk[++tp] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>; ext++;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) </span><br><span class="line">                    pos = stk[tp--], T[ext].push_back(pos), val[ext].insert(w[pos]);</span><br><span class="line">                w[ext] = *val[ext].begin(), T[u].push_back(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[k] = x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(l, m, lc, p, x); <span class="keyword">else</span> md(m + <span class="number">1</span>, r, rc, p, x);</span><br><span class="line">        d[k] = min(d[lc], d[rc]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> d[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = INF;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = qu(l, m, lc, s, t);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = min(ans, qu(m + <span class="number">1</span>, r, rc, s, t));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[CN], id[CN], idx = <span class="number">0</span>, top[CN], imp[CN], sz[CN], fa[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u] = p, dep[u] = dep[p] + <span class="number">1</span>, sz[u] = <span class="number">1</span>; <span class="keyword">int</span> mx = <span class="number">0</span>, l = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = T[u][i]; </span><br><span class="line">        dfs1(v, u), sz[u] += sz[v], imp[u] = mx &lt; sz[v] ? mx = sz[v], v : imp[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    id[u] = ++idx, D.md(<span class="number">1</span>, ext, <span class="number">1</span>, id[u], w[u]), top[u] = t;</span><br><span class="line">    <span class="keyword">if</span>(imp[u]) dfs2(imp[u], t); <span class="keyword">int</span> l = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = T[u][i]; </span><br><span class="line">        <span class="keyword">if</span>(v ^ imp[u]) dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">while</span>(top[x] ^ top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[ top[x] ] &lt; dep[ top[y] ]) swap(x, y);</span><br><span class="line">        ans = min(ans, D.qu(<span class="number">1</span>, ext, <span class="number">1</span>, id[ top[x] ], id[x]));</span><br><span class="line">        x = fa[ top[x] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    ans = min(ans, D.qu(<span class="number">1</span>, ext, <span class="number">1</span>, id[y], id[x]));</span><br><span class="line">    <span class="keyword">if</span>(y &gt; n) ans = min(ans, w[ fa[y] ]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    ext = n = read(), m = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) w[i] = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bd(<span class="number">1</span>, <span class="number">0</span>), dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">char</span> c;  <span class="built_in">cin</span> &gt;&gt; c; <span class="keyword">int</span> a = read(), b = read();</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'C'</span>)&#123;</span><br><span class="line">            D.md(<span class="number">1</span>, ext, <span class="number">1</span>, id[a], b); <span class="keyword">int</span> f = fa[a];</span><br><span class="line">            <span class="keyword">if</span>(f &gt; n)&#123;</span><br><span class="line">                val[f].erase(w[a]), val[f].insert(b);</span><br><span class="line">                <span class="keyword">if</span>(*val[f].begin() ^ w[f]) w[f] = *val[f].begin(), D.md(<span class="number">1</span>, ext, <span class="number">1</span>, id[f], w[f]);</span><br><span class="line">            &#125;</span><br><span class="line">            w[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, qu(a, b)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，$q$ 次询问，每次询问给出一个点集 $S$，问有多少点满足在图上删除该点后，$\exists u,v\in S$，$u,v$ 在图上不连通。<br>$n,m\le 10^5, \sum|S_i|\le 2\times 10^5$</p></div></article><p>“圆方树上圆方果，<br>“圆方树下你和我，<br>“圆方树前建虚树，<br>“欢乐多又多。</p><p>Subtask2 $|S_i|=2$ 两点间割点数量等于圆方树上点对路径上的圆点数量，则直接在圆方树上倍增即可。<br>Subtask3 考虑建出圆方树的虚树来，然后就可以简单树形 DP 了，时间复杂度 $O(n)-O(q\sum|S_i|\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar(); <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> s * ne;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> TC, n, m, q, id[CN]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[CN], T[CN], S[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[CN], top = <span class="number">0</span>, dfn[CN], low[CN], idx = <span class="number">0</span>, ext;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u;</span><br><span class="line">    <span class="keyword">int</span> l = G[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123; <span class="comment">// dfn[] 需要清空!!!</span></span><br><span class="line">            tarjan(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[u] == low[v])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>; T[u].push_back(++ext), T[ext].clear(); </span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], T[ext].push_back(pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[CN], fa[CN][<span class="number">21</span>], dis[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = ++idx, fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dis[u] = dis[p] + (u &lt;= n);</span><br><span class="line">    <span class="keyword">int</span> l = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) dfs(T[u][i], u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125; <span class="keyword">int</span> rt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    rt = stk[top = <span class="number">1</span>] = a[<span class="number">1</span>], S[ a[<span class="number">1</span>] ].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = a[i], l = lca(u, stk[top]); <span class="keyword">if</span>(dfn[l] &lt; dfn[rt]) rt = l;</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span> ] ] &gt; dfn[l]) S[ stk[top - <span class="number">1</span>] ].push_back(stk[top]), top--;</span><br><span class="line">            <span class="keyword">if</span>(stk[top - <span class="number">1</span>] ^ l) S[l].clear(), S[l].push_back(stk[top]), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> S[l].push_back(stk[top--]);</span><br><span class="line">        &#125;</span><br><span class="line">        S[u].clear(), stk[++top] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) S[ stk[i] ].push_back(stk[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = S[u].size(); f[u] = u &lt;= n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = S[u][i]; </span><br><span class="line">        dp(v), f[u] += f[v] + dis[ fa[v][<span class="number">0</span>] ] - dis[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    TC = read(); <span class="keyword">while</span>(TC--)&#123;</span><br><span class="line">        ext = n = read(), m = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear(), T[i].clear();</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = read(), v = read(); G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn)), idx = top = <span class="number">0</span>, tarjan(<span class="number">1</span>, <span class="number">0</span>), idx = <span class="number">0</span>, dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ext; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        q = read();</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            id[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id[<span class="number">0</span>]; i++) id[i] = read();</span><br><span class="line">            build(id, id[<span class="number">0</span>]), dp(rt), <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[rt] - id[<span class="number">0</span>]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://www.luogu.com.cn/problem/P4320">「LG-P4320」道路相遇</a></li><li><a href="https://loj.ac/problem/2587">「APIO2018」Duathlon</a></li><li><a href="https://codeforces.com/problemset/problem/487/E">「CF487E」Tourists</a></li><li><a href="https://www.luogu.com.cn/problem/P4606">「SDOI2018」战略游戏</a></li></ol><p>习题<br><a href="https://www.luogu.com.cn/problem/P5236">「LG-P5236」静态仙人掌</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，圆方树是用以解决一类仙人掌图问题的重构树，但是类似的方法也可以用来解决某些普通无向图问题。依赖于其优美的树形结构，我们可以在 $\log |V|$ 的时间复杂度内回答一类图上的点对路径并集的询问问题……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="树" scheme="https://big-news.cn/tags/%E6%A0%91/"/>
    
      <category term="圆方树" scheme="https://big-news.cn/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"/>
    
      <category term="仙人掌图" scheme="https://big-news.cn/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」洛谷九月月赛</title>
    <link href="https://big-news.cn/2020/09/19/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E4%B9%9D%E6%9C%88%E6%9C%88%E8%B5%9B/"/>
    <id>https://big-news.cn/2020/09/19/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E4%B9%9D%E6%9C%88%E6%9C%88%E8%B5%9B/</id>
    <published>2020-09-19T08:48:00.000Z</published>
    <updated>2020-09-24T14:45:25.074Z</updated>
    
    <content type="html"><![CDATA[<p>今天怎么有一页阿克爷啊…..<br>怎么我还是啥都不会啊……</p><a id="more"></a><h3 id="A-子弦"><a href="#A-子弦" class="headerlink" title="A 子弦"></a>A 子弦</h3><p>容易发现答案是出现次数最多的字母的出现次数。证明很简单：再扩展一位字符出去限制性也不会变弱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e7</span> + <span class="number">7</span>; <span class="keyword">char</span> ch[CN]; <span class="keyword">int</span> tot[<span class="number">300</span>], mx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ch[i]; i++) tot[ ch[i] ]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; i++) mx = max(mx, tot[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, mx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-雷雨"><a href="#B-雷雨" class="headerlink" title="B 雷雨"></a>B 雷雨</h3><p>跑三遍 Dijkstra，枚举一个中间点拼起来就好了，复杂度 $O(nm(\log n + \log m))$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e3</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> x, y; LL v; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ &amp; a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;&#125;;</span><br><span class="line"><span class="function">DJ <span class="title">mk</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, LL c)</span> </span>&#123;DJ d; d.x = a, d.y = b, d.v = c; <span class="keyword">return</span> d;&#125;</span><br><span class="line">priority_queue&lt;DJ&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[CN][CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SP</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m,<span class="keyword">int</span> sx, <span class="keyword">int</span> sy, LL d[][CN], LL dis[][CN])</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    Q.push( mk(sx, sy, dis[sx][sy] = d[sx][sy]) );</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.top().x, y = Q.top().y; Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[x][y]) <span class="keyword">continue</span>; vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> vx = x + dx[k], vy = y + dy[k];</span><br><span class="line">            <span class="keyword">if</span>(!vx || !vy || vx &gt; n || vy &gt; m || vis[vx][vy]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[vx][vy] &gt; dis[x][y] + d[vx][vy])&#123;</span><br><span class="line">                dis[vx][vy] = dis[x][y] + d[vx][vy];</span><br><span class="line">                Q.push( mk(vx, vy, dis[vx][vy]) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a, b, c; LL d[CN][CN], da[CN][CN], db[CN][CN], dc[CN][CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), a = read(), b = read(), c = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) d[i][j] = read();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(da, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(da)), SP(n, m, <span class="number">1</span>, a, d, da);</span><br><span class="line">    <span class="built_in">memset</span>(db, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(db)), SP(n, m, n, b, d, db);</span><br><span class="line">    <span class="built_in">memset</span>(dc, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dc)), SP(n, m, n, c, d, dc);</span><br><span class="line"></span><br><span class="line">    LL ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            ans = min(ans, da[i][j] + db[i][j] + dc[i][j] - <span class="number">2l</span>l * d[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-梦原"><a href="#C-梦原" class="headerlink" title="C 梦原"></a>C 梦原</h3><p>考虑如果给出一颗形态固定的树，我们应该怎样算答案？我们只需要把 $w[u]$ 变成 $w[ fa[u] ]-w[u]$（就是树上差分），然后把所有 $w[u]&gt;0$ 的 $w[u]$ 加起来就可以了。也就是我们只考虑把多出来的那部分算到费用里面，容易发现这样一定是最优的。</p><p>然后考虑 $i$ 的父亲大概有 $\min i - 1,k$ 种可能，根据期望的线性性，只需对这些可能求个概率加权和就好了。设 $m=\min i-1, k$，得到答案是：<br>$$\sum\limits_{i=1}^n\sum\limits_{j=i-m}^{i-1}\frac{1}{m}[a_j&lt;a_i](a_i-a_j)$$ 实际上就是个二维数点，由于区间是定长，因此直接拿个树状数组维护即可，复杂度 $O(n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN], cnt[CN], n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(p &lt;= n) d[p] = (d[p] + x) % P, cnt[p]++, p += lb(p);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(p &lt;= n) d[p] = (d[p] - x + P) % P, cnt[p]--, p += lb(p);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(p) r = (r + d[p]) % P, p -= lb(p); <span class="keyword">return</span> r;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quc</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(p) r += cnt[p], p -= lb(p); <span class="keyword">return</span> r;&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D.n = n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), val[ ++val[<span class="number">0</span>] ] = a[i];</span><br><span class="line">    </span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[++tmp] = val[i]; val[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = a[<span class="number">1</span>]; </span><br><span class="line">    D.add(id(a[<span class="number">1</span>]), a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = qp(min(i - <span class="number">1</span>, m), P - <span class="number">2</span>), si = D.qu( id(a[i]) ), cnt = D.quc( id(a[i]) );</span><br><span class="line">        si = (<span class="number">1l</span>l * cnt * a[i] % P - si + P) % P;</span><br><span class="line">        ans = (<span class="number">1l</span>l * k * si % P + ans) % P;</span><br><span class="line">        D.add( id(a[i]) , a[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m + <span class="number">1</span>) D.minus( id(a[i - m]), a[i - m] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-线形生物"><a href="#D-线形生物" class="headerlink" title="D 线形生物"></a>D 线形生物</h3><p>看上去今天只有我一个人不会这题的样子……<br>Subtask1, 10pts 交个<code>cout&lt;&lt;(n&lt;&lt;1)</code>上去就好了，因为对每一位都有 $E_i=\frac{1}{2}E_i+1$，解得 $E_i=2$，因此答案是 $2n$。<br>Subtask4, 40pts 看上去用高斯消元解方程就好了，考场上遇到了些哲学问题没调出来…<br>Subtask5…这就不会了啊。<br>事实上赛后<code>红太阳</code> <a href="https://shuyumo2003.github.io/">SSX</a> 告诉我合并方程就完事了…<br>太草了就不写了…感性理解下吧…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天怎么有一页阿克爷啊…..&lt;br&gt;怎么我还是啥都不会啊……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」AtCoder Beginner Contest 178</title>
    <link href="https://big-news.cn/2020/09/13/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DAtCoder%20Beginner%20Contest%20178/"/>
    <id>https://big-news.cn/2020/09/13/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DAtCoder%20Beginner%20Contest%20178/</id>
    <published>2020-09-13T13:23:00.000Z</published>
    <updated>2020-09-13T13:48:36.061Z</updated>
    
    <content type="html"><![CDATA[<p>人生 AK 第一场，不过我还是这么的菜……</p><a id="more"></a><p><a href="https://atcoder.jp/contests/abc178">比赛链接</a></p><h3 id="A-Not"><a href="#A-Not" class="headerlink" title="A. Not"></a>A. Not</h3><p>考察输入输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x; x ^= <span class="number">1</span>; <span class="built_in">cout</span> &lt;&lt; x;&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Product-Max"><a href="#B-Product-Max" class="headerlink" title="B. Product Max"></a>B. Product Max</h3><p>对四个值取个 $\max$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL a, b, c, d, x, y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    x = max(a * c, a * d), y = max(b * c, b * d);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Ubiquity"><a href="#C-Ubiquity" class="headerlink" title="C. Ubiquity"></a>C. Ubiquity</h3><p>简单容斥一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = qp(<span class="number">10</span>, n), k = <span class="number">2l</span>l * qp(<span class="number">9</span>, n) % P;</span><br><span class="line">    ans = (ans - k + P) % P, k = qp(<span class="number">8</span>, n), ans = (ans + k) % P;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Redistribution"><a href="#D-Redistribution" class="headerlink" title="D. Redistribution"></a>D. Redistribution</h3><p>枚举数列的长度，然后简单插板即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e3</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> C[CN][CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = ( C[i - <span class="number">1</span>][j] +<span class="number">0l</span>l+ C[i - <span class="number">1</span>][j - <span class="number">1</span>] ) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n, pcal(n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l * <span class="number">3</span> &lt;= n; l++) ans = (ans + C[n - l * <span class="number">2</span> - <span class="number">1</span>][l - <span class="number">1</span>]) % P;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Dist-Max"><a href="#E-Dist-Max" class="headerlink" title="E. Dist Max"></a>E. Dist Max</h3><p>求平面曼哈顿距离的最大值，有一个经典的技巧是把曼哈顿距离的绝对值拆成四个值的 $\max$，即有：<br>$$|x-x’|+|y-y’|=\max x-x’+y-y’, x-x’+y’-y, x’-x+y-y’, x’-x+y’-y$$ 于是维护一下 $x+y$ 和 $x-y$ 的最大最小值更新答案即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, x[CN], y[CN], mx = -INF, mn = INF, ans = -INF;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = max(mx, x[i] + y[i]), mn = min(mn, x[i] + y[i]);</span><br><span class="line">    ans = max(ans, mx - mn);</span><br><span class="line">    mx = -INF, mn = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = max(mx, x[i] - y[i]), mn = min(mn, x[i] - y[i]);</span><br><span class="line">    ans = max(ans, mx - mn);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Contrast"><a href="#F-Contrast" class="headerlink" title="F. Contrast"></a>F. Contrast</h3><p>大概拿<code>set</code>维护一下就好，但是我的做法好像假了，不过考场上瞎搞过去了……<br>做法先咕着吧。</p><p>先贴一份假代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, a[CN], b[CN]; <span class="keyword">int</span> cnt[CN]; <span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt; S;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = read(), S.insert(b[i]), cnt[ b[i] ]++;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> has = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; :: iterator it = S.begin(); it != S.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = *it;</span><br><span class="line">            <span class="keyword">if</span>(val ^ a[i])&#123;</span><br><span class="line">                b[i] = val, has = <span class="literal">true</span>, cnt[val]--; </span><br><span class="line">                <span class="keyword">if</span>(!cnt[val]) S.erase(it); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag &amp;= has;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生 AK 第一场，不过我还是这么的菜……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>概率期望学习笔记</title>
    <link href="https://big-news.cn/2020/09/13/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/09/13/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-13T09:04:00.000Z</published>
    <updated>2020-09-21T13:04:47.348Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，一个随机变量 $x$ 的数学期望定义为 $E(x)$，即是 $E(x)traodinary$ 的缩写形式，代表 $x$ 是一个非凡的数字……</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>随机变量 $x$ 的数学期望 $E(x)$ 定义为 $x$ 的每种取值的概率加权和，可以理解为 $x$ 在平均情况下的取值，我们一般称其为「期望取值」。<br>举个例子，若 $x$ 有 $1/3$ 的概率为 $1$，有 $2/3$ 的概率为 $2$，则 $E(x)=1/3+2\times (2/3)=5/3$。</p><h3 id="线性性"><a href="#线性性" class="headerlink" title="线性性"></a>线性性</h3><p>根据乘法结合律以及分配律，可以发现期望具有线性性，可以将其理解为「元素和的期望等于元素期望的和」，亦即：<br>$$ E(\Sigma x_i)=\sum E(x_i) $$ 设 $c$ 为常量，也容易验证：<br>$$E(x+c)=E(x)+c$$</p><h3 id="一道简单题"><a href="#一道简单题" class="headerlink" title="一道简单题"></a>一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个长度为 $n$ 的数列，一开始所有位置都未被访问。每次随机一个未被访问过的位置，将它和它之前的位置都标记为访问过，问期望操作次数。<br>$n\le 10^{18}$</p></div></article><p>考虑期望的线性性，答案就等于每个位置能被访问到的概率。一个位置 $i$ 能被访问到当且仅当它在所有它后面的数之前被访问，这个概率是 $\frac{1}{n-i+1}$，因此容易发现答案是调和级数 $H_n$，使用近似公式计算即可。</p><h3 id="又一道简单题"><a href="#又一道简单题" class="headerlink" title="又一道简单题"></a>又一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个 $n$ 个节点的有根树，一开始所有节点都未被访问。每次随机一个未被访问过的节点，将它到根的路径上所有点都标记为访问过，问期望操作次数，对 $998244353$ 取模。<br>$n\le 10^7$</p></div></article><p>仿照上题，容易发现答案是 $\sum\limits_{i=1}^n\frac{1}{sz[i]}$，其中 $sz[i]$ 表示子树 $i$ 的大小，线性求逆即可。</p><h3 id="双一道简单题"><a href="#双一道简单题" class="headerlink" title="双一道简单题"></a>双一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 堆石子，每堆有 $a_i$ 个，每次随机选一个石子，并取光它所在的那堆石子。问第一堆石子被取到的时间的期望。<br>$n\le 10^5$</p></div></article><p>根据期望的线性性，答案等于每堆石子在 $1$ 之前取到的期望之和，即 $1+\sum\limits_{i=2}^n\frac{a_i}{a_1+a_i}$，线性计算即可。</p><h3 id="叒一道简单题"><a href="#叒一道简单题" class="headerlink" title="叒一道简单题"></a>叒一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个 $n$ 面的骰子，问每一面都被掷到的期望投掷次数。<br>$n\le 10^{18}$</p></div></article><p>此类问题被称作「赠券收集问题」。<br>设 $f[n]$ 为 $n$ 面掷出后还需投掷的次数的期望，易得 $f[i]=\frac{i}{n}f[i]+\frac{n-i}{n}f[i+1]+1$，整理得 $f[i]=f[i+1]+\frac{n}{n-i}$，从而有 $f[0]=nH_n$，利用公式计算即可。</p><h3 id="叕一道简单题"><a href="#叕一道简单题" class="headerlink" title="叕一道简单题"></a>叕一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>求所有 $n!$ 个 $n$ 的全排列中，逆序对数的期望，对 $998244353$ 取模。<br>$n\le 10^{7}$</p></div></article><p>众所周知，$n$ 的全排列一共有 $\dfrac{n!}{2}\dbinom{n}{2}$ 个逆序对，即对每个二元组 $(i,j)$ 讨论一下它们是否会形成逆序对。<br>因此答案为 $\dfrac{\dfrac{n!}{2}\dbinom{n}{2}}{n!}=\dfrac{n(n-1)}{4}$。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。<br>求该 01 串的价值的期望。<br>$n\le 10^5$</p></div></article><p>设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：<br>$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：<br>$$ \begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \end{aligned}$$ 于是可以做到 $O(n)$ 求出答案。<br>注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。</p><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一颗 $n$ 个节点的有根树，$1$ 号节点为根，树上的每个节点 $u$ 都有一个权值 $c_u$。<br>你需要随机一个节点的排列 $P\in [n]$， 并且按这个排列的顺序依次访问所有树上的节点。每当访问到树上的一个节点 $u$ 时，你需要将子树 $u$ 内所有节点的权值加上 $c_u$（包括点 $u$）。<br>问在一切的操作结束之后所有节点权值之和的期望。由于期望可能不是一个整数，请将它乘上 $n!$，并对 $10^9+7$ 取模。<br>$n\le 10^5$, 且<strong>保证树的形态随机</strong></p></div></article><p>根据期望的线性性，我们只需要求出每个节点最后的期望权值即可。设这个东西是 $a_u$ ，容易发现 $a_u$ 的取值只与从根到 $u$ 的这一条祖孙链上的节点有关。<br>因为树的形态随机，所以树高是期望 $O(\sqrt{n})$ 的。设祖孙链长为 $d$，那么只需考虑 $O(d)$ 地求出 $a_u$ 即可。<br>运用贡献法考虑：期望权值 = $Σ$权值$×$期望累加次数，那么考虑预处理一个 $t[]$，使得 $a_u=\sum c_v·t_v$ 即可。</p><p>容易发现 $t_v$ 的取值只与 $u,v$ 的相对距离有关，则可以设 $f_i$ 表示考虑随机访问一个有 $n$ 位的序列 $a_1,a_2,…,a_n$，$a_1$ 在 $i$ 上的期望累加次数。<br>考虑一次累加应当是什么样子： $1\to p_1\to p_2\to …\to i$，且满足 $1&lt;p_1&lt;p_2&lt;…&lt;i$。这显然双射了一个上升子序列（IS）。<br>则 $f_i$ 即代表考虑所有 $P\in [i]$，$P$ 中以 $1$ 起始的 IS 的期望数量。这样我们可以直接拿组合数选出来，即有：<br>$$ f_i=\sum\limits_d \dbinom{i-1}{d-1}\dbinom{i}{d}(i-d)! $$ 于是就可以计算了，时间复杂度 $O(n\sqrt{n})$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[CN], fac[CN], ifac[CN], f[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l * (<span class="number">1l</span>l * fac[n] * ifac[m] % P) * ifac[n - m] % P;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[CN], ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">stk[dep] = a[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = dep, j = <span class="number">1</span>; i; i--, j++) ans = (<span class="number">1l</span>l * stk[i] * f[j] % P + ans) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line"><span class="keyword">int</span> v = E[k].to;</span><br><span class="line"><span class="keyword">if</span>(v ^ p) dfs(v, u, dep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">ifac[n] = qp(fac[n], P - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) ifac[i] = <span class="number">1l</span>l * (i + <span class="number">1</span>) * ifac[i + <span class="number">1</span>] % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5000</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= i; d++)&#123;</span><br><span class="line"><span class="keyword">int</span> prd = <span class="number">1l</span>l * C(i - <span class="number">1</span>, d - <span class="number">1</span>) * C(i, d) % P;</span><br><span class="line">prd = <span class="number">1l</span>l * prd * fac[i - d] % P, f[i] = (f[i] + prd) % P;</span><br><span class="line">&#125;</span><br><span class="line">f[i] = <span class="number">1l</span>l * f[i] * ifac[i] % P; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = (ans + a[i]) % P;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), ans = <span class="number">1l</span>l * ans * fac[n] % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 种方法，每种方法需要 $k_i$ 条途径，第 $j$ 条途径有 $p[i,j]$ 的概率无法使用。每次可以查询任意一条途径可否使用，直到查询到一种能使用的方法，求最小的“最少查询次数的期望”。<br>$n,k_i \le 500$</p></div></article><p>容易发现对于任意一种方法，如果不将其全部查询完，那么这次查询是无意义的。对于任意一种方法，我们应当按照 $p[i,j]$ 降序排序的顺序去查询。<br>假定 $\forall i$，$p[i,j]$ 已经降序排序为 $p_1,p_2,…p_{k_i}$，那么考虑对所有方法进行排列，设 $E_i$ 为考虑 $[1:i]$ 中的方法时的答案，则有：<br>$$\begin{aligned} E_i&amp;=p_1(1+E_{i-1}) + p_2(1-p_1)(2+E_{i-1})+…\newline &amp;=k_iE_{i-1}+b_i \end{aligned} $$ 注意到还有 $\prod\limits_j (1-p_j)$ 的概率本次查询不会停止，把这部分加到常数项即可。<br>于是变成了一次函数嵌套的最小值问题，按 $(k_i-1)/b_i$ 升序排序即可，时间复杂度 $O(\sum k_i + n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">const</span> DB EPS = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, id[CN]; DB k[CN], b[CN], p[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span> </span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> k[i] * b[j] + b[i] &lt; k[j] * b[i] + b[j];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        m = read(); <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;p[j]);</span><br><span class="line">        sort(p + <span class="number">1</span>, p + m + <span class="number">1</span>, cmp); DB prd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">1</span>] &gt; <span class="number">1.0</span> - EPS) &#123;i--, n--; <span class="keyword">continue</span>;&#125; <span class="keyword">while</span>(m &amp;&amp; p[m] &lt;= EPS) m--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) k[i] += p[j] * prd, b[i] += p[j] * prd * j, prd *= (<span class="number">1.0</span> - p[j]);</span><br><span class="line">        b[i] += m * prd, id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, comp); DB ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i, p = n; p; p--) i = id[p], ans = k[i] * ans + b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $m$ 张牌，其中一张是王牌。现在你执行 $n$ 次如下操作：洗牌后查看第一张牌是什么。<br>令 $x$ 为洗牌后第一张牌为王牌的次数，现在假设洗牌时 $m!$ 种牌的排列出现的概率均相等，求 $x^k$ 的期望值，对 $998244353$ 取模。<br>$n,m\le 998244352, k\le 5000$</p></div></article><p>题目等价于：有 $n$ 个相互独立的随机变量 $x_1,x_2,…x_n$，每个变量有 $\frac{1}{m}$ 的概率为 $1$，其余情况为 $0$，求：<br>$$E[\left(\sum\limits_{i=1}^nx_i\right)^k]$$</p><p>根据期望的线性性，可以枚举 $d=\sum\limits_{i=1}^nx_i$，则有：<br>$$\begin{aligned} E[\left(\sum\limits_{i=1}^nx_i\right)^k] &amp;=\sum\limits_{d=0}^n E(d^k)\newline &amp;= \sum\limits_{d=0}^n P(d)·d^k\newline  &amp;= \sum\limits_{d=0}^n\dbinom{n}{d}\left(\frac{1}{m}\right)^d\left(1-\frac{1}{m} \right)^{n-d} ·d^k  \end{aligned}$$ 把后面的 $d^k$ 拿 Stirling 数展开，大力化一下柿子，得到：<br>$$ \sum\limits_{d=0}^n\dbinom{n}{d}\left(\frac{1}{m}\right)^d\left(1-\frac{1}{m} \right)^{n-d} ·d^k=\sum\limits_{i=0}^k \begin{Bmatrix}k\newline i\end{Bmatrix} n^{\underline{i}}\left(\frac{1}{m} \right)^i $$ 就可以做了，时间复杂度 $O(k^2)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, S[CN][CN], ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), k = read(), m = qp(m, P - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) S[i][j] = (<span class="number">1l</span>l * j * S[i - <span class="number">1</span>][j] % P + S[i - <span class="number">1</span>][j - <span class="number">1</span>]) % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fall = <span class="number">1</span>, pw = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> prd = <span class="number">1l</span>l * S[k][i] * fall % P;</span><br><span class="line">        ans = (<span class="number">1l</span>l * prd * pw % P + ans) % P;</span><br><span class="line">        pw = <span class="number">1l</span>l * pw * m % P, fall = <span class="number">1l</span>l * fall * (n - i) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li>暂无来源</li><li>暂无来源</li><li>暂无来源</li><li><a href="https://www.spoj.com/problems/FAVDICE/">「SPOJ1026」FAVDICE - Favorite Dice</a> </li><li>暂无来源</li><li><a href="https://darkbzoj.tk/problem/4318">「BZOJ4318」OSU!</a></li><li>暂无来源</li><li>暂无来源</li><li><a href="https://codeforces.com/problemset/problem/1278/F">「CF1278F」Cards</a></li></ol><p>习题<br><a href="https://www.luogu.com.cn/problem/P6834?contestId=34123">「LG-P6843」梦原</a><br><a href="https://www.luogu.com.cn/problem/P6835?contestId=34123">「LG-P5835」线形生物</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，一个随机变量 $x$ 的数学期望定义为 $E(x)$，即是 $E(x)traodinary$ 的缩写形式，代表 $x$ 是一个非凡的数字……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://big-news.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="期望" scheme="https://big-news.cn/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>虚树</title>
    <link href="https://big-news.cn/2020/09/11/%E8%99%9A%E6%A0%91/"/>
    <id>https://big-news.cn/2020/09/11/%E8%99%9A%E6%A0%91/</id>
    <published>2020-09-11T00:39:00.000Z</published>
    <updated>2020-09-21T13:05:52.096Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，虚树是一类重构树，用于处理点数较多而关键点（有效点）数较少的树上问题。举个栗子，我们所熟知的后缀树就是一种虚树……</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定点集 $V_k$ 代表有效点，我们定义一颗树 $T=(V,E)$ 是建立在 $V_k$ 上的虚树，当且仅当：</p><ol><li>$V_k\subseteq V$</li><li>$\forall x\in V, x\in V_k \text{ or } \exists u,v\in V, \text{s.t. } \text{LCA}(u,v)=x$ </li><li>$\forall (u,v)\in E, \text{LCA}(u,v)=u\text{ or }v$</li></ol><p>一句话来讲：虚数是关键点以及关键点的 LCA 构成的，保证原树的祖孙关系不变的重构树。</p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>模仿笛卡尔树的构建，虚树的构建可以使用单调栈在 $O(|V_k|\log |V|)$ 的时间内完成，其中 $\log V$ 的复杂度是倍增 LCA 的复杂度。如果使用 $O(n)-O(1)$ 的 RMQ-LCA，则可以降至 $O(|V_k|\log |V_k|)$，基本可以视作线性。<br>这种方法一般被称为「单调栈维护右链」。</p><p>顾名思义，这种构建方法的本质就在于使用单调栈去维护虚数最靠右边的树链。容易得出这份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span> :: sort;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span>&#123;</span>&#125;  E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[CN], stk[CN], top = <span class="number">0</span>, dfn[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125; <span class="comment">// 按 dfs 序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>, hd[<span class="number">1</span>] = <span class="number">0</span>, ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = lca(a[i], stk[top]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top], <span class="number">0</span>), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top], <span class="number">0</span>), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top], <span class="number">0</span>), top--;</span><br><span class="line">        &#125;</span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的树，边有边权。$q$ 次询问，每次给出 $k_i$ 个关键点，问切断多少边能使得关键点都不与 $1$ 号节点联通，最小化切断的边的边权。<br>$n,q,\sum k_i\le 10^5$</p></div></article><p>如果只有一次询问，则可以通过树上 DP 简单求出。注意到 DP 的过程中有效的点只有关键点和它们的 LCA，因此直接建出虚树 DP 即可，时间复杂度 $O(\sum k_i\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,w; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> d)</span> </span>&#123;to = t, nxt = n, w = d;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mn[CN], dep[CN], fa[CN][<span class="number">21</span>], dfn[CN], idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123; <span class="comment">// 预处理</span></span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) mn[v] = min(mn[u], E[k].w), dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">// 倍增 LCA</span></span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[x][k] ] &gt;= dep[y]) x = fa[x][k];</span><br><span class="line">    <span class="keyword">if</span>(x ^ y)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[x][k] ^ fa[y][k]) x = fa[x][k], y = fa[y][k];</span><br><span class="line">        x = fa[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[CN], stk[CN], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123; <span class="comment">// 建立虚树</span></span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>, hd[<span class="number">1</span>] = <span class="number">0</span>, ecnt = <span class="number">0</span>; <span class="comment">// 小心翼翼的初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = lca(stk[top], a[i]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top], <span class="number">0</span>), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top], <span class="number">0</span>), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top], <span class="number">0</span>), top--;</span><br><span class="line">        &#125; </span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i]; <span class="comment">// 小心翼翼的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[CN]; <span class="keyword">bool</span> is[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123; <span class="comment">// DP</span></span><br><span class="line">    f[u] = mn[u]; <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 小心翼翼的初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) dp(v, u), sum += f[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!is[u]) f[u] = min(f[u], sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w);&#125;</span><br><span class="line">    mn[<span class="number">1</span>] = INF, dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(hd, <span class="number">0</span>, <span class="keyword">sizeof</span>(hd)), ecnt = <span class="number">0</span>;</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) a[i] = read(), is[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">        bd(), dp(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[<span class="number">1</span>]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) is[ a[i] ] = <span class="literal">false</span>; <span class="comment">// 小心翼翼的清空标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的树，$q$ 次询问，每次给出 $k_i$ 个关键点，问切断多少点能使得关键点互不相连，无解输出 -1。<br>$n,q,\sum k_i\le 10^5$</p></div></article><p>依然沿用上题的思路，只不过在树上 DP 的时候细节较多。可以维护一个 $g[u]$ 表示子树 $u$ 中是否还存在与 $u$ 相连的关键点，在转移时分类讨论即可，时间复杂度 $O(\sum k_i\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[CN], fa[CN][<span class="number">21</span>], dfn[CN], idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[CN], top = <span class="number">0</span>, a[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>, hd[<span class="number">1</span>] = <span class="number">0</span>, ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = lca(stk[top], a[i]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top]), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top]), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top]), top--;</span><br><span class="line">        &#125;</span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[CN], g[CN]; <span class="keyword">bool</span> is[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    f[u] = g[u] = <span class="number">0</span>; <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dp(v, u)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        f[u] += f[v], cnt += g[v];</span><br><span class="line">        <span class="keyword">if</span>(is[u] &amp;&amp; is[v] &amp;&amp; dep[v] - dep[u] &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 无解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is[u]) f[u] += cnt, g[u] = <span class="number">1</span>; <span class="comment">// 讨论 u 的决策</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) f[u]++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>) g[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 有解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) a[i] = read(), is[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">        bd();</span><br><span class="line">        <span class="keyword">if</span>(dp(<span class="number">1</span>, <span class="number">0</span>)) <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[<span class="number">1</span>]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) is[ a[i] ] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的树，$q$ 次询问，每次给出 $k_i$ 个关键点，问关键点之间的两两距离和，距离最小值和距离最大值。<br>$n,q,\sum k_i\le 10^5$</p></div></article><p>距离最大 / 最小都可以简单维护，对于“距离和”这个问题，有一个常用方法是考虑每条边对答案的贡献。这就跟边有关系了，因此在建立虚树时不能再固定以 $1$ 号节点为根，简单维护一下树根即可，时间复杂度 $O(\sum k_i\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,w; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> d)</span> </span>&#123;to = t, nxt = n, w = d;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[CN][<span class="number">21</span>], dep[CN], dis[CN], dfn[CN], idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) dis[v] = dis[u] + E[k].w, dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125;</span><br><span class="line"><span class="keyword">int</span> stk[CN], top = <span class="number">0</span>, a[CN], rt; <span class="comment">// rt 维护树根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = a[<span class="number">1</span>], hd[ a[<span class="number">1</span>] ] = <span class="number">0</span>, ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = lca(stk[top], a[i]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top], <span class="number">0</span>), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top], <span class="number">0</span>), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top], <span class="number">0</span>), top--;</span><br><span class="line">        &#125;</span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rt = stk[<span class="number">1</span>]; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mn[CN], mx[CN], sz[CN], amn, amx, ans, tmp1[<span class="number">4</span>], tmp2[<span class="number">4</span>]; <span class="keyword">bool</span> is[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!hd[u]) <span class="keyword">return</span> (<span class="keyword">void</span>)(mn[u] = mx[u] = <span class="number">0</span>, sz[u] = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    mn[u] = INF, mx[u] = sz[u] = <span class="number">0</span>; <span class="keyword">int</span> Mn = INF, pMn = INF, Mx = <span class="number">0</span>, pMx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to, d = dis[v] - dis[u]; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        dp(v, u);</span><br><span class="line">        </span><br><span class="line">        mn[u] = min(mn[u], mn[v] + d), tmp1[<span class="number">0</span>] = mn[v] + d,</span><br><span class="line">        mx[u] = max(mx[u], mx[v] + d), tmp2[<span class="number">0</span>] = mx[v] + d;</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line"></span><br><span class="line">        ans += d * (a[<span class="number">0</span>] - sz[v]) * sz[v]; <span class="comment">// 计算距离和</span></span><br><span class="line"></span><br><span class="line">        tmp1[<span class="number">1</span>] = Mn, tmp1[<span class="number">2</span>] = pMn, tmp2[<span class="number">1</span>] = Mx, tmp2[<span class="number">2</span>] = pMx;</span><br><span class="line">        sort(tmp1, tmp1 + <span class="number">3</span>), sort(tmp2, tmp2 + <span class="number">3</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        Mn = tmp1[<span class="number">0</span>], pMn = tmp1[<span class="number">1</span>], Mx = tmp2[<span class="number">0</span>], pMx = tmp2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    amn = min(amn, Mn + pMn), amx = max(amx, Mx + pMx); <span class="comment">// 计算距离最大 最小</span></span><br><span class="line">    <span class="keyword">if</span>(is[u]) sz[u]++, amn = min(amn, Mn), mn[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v, <span class="number">1</span>), add(v, u, <span class="number">1</span>);&#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) a[i] = read(), is[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">        bd(), amn = INF, amx = ans = <span class="number">0</span>; <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="number">1</span>) ans = amn = amx = <span class="number">0</span>;</span><br><span class="line">        dp(rt, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%lld %lld %lld"</span>, ans, amn, amx), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) is[ a[i] ] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://www.luogu.com.cn/problem/P2495">「SDOI2011」消耗战</a></li><li><a href="http://codeforces.com/problemset/problem/613/D">「CF613D」Kingdom and its Cities</a></li><li><a href="https://www.luogu.com.cn/problem/P4103">「HEOI2014」大工程</a></li></ol><p>习题<br><a href="https://www.luogu.com.cn/problem/P3233">「HNOI2014」世界树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，虚树是一类重构树，用于处理点数较多而关键点（有效点）数较少的树上问题。举个栗子，我们所熟知的后缀树就是一种虚树……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="树" scheme="https://big-news.cn/tags/%E6%A0%91/"/>
    
      <category term="虚树" scheme="https://big-news.cn/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 669 (Div. 2)</title>
    <link href="https://big-news.cn/2020/09/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20669%20(Div.%202)/"/>
    <id>https://big-news.cn/2020/09/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20669%20(Div.%202)/</id>
    <published>2020-09-09T03:51:00.000Z</published>
    <updated>2020-09-09T06:02:45.420Z</updated>
    
    <content type="html"><![CDATA[<p>蒟蒻下分场……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1407">比赛链接</a></p><h3 id="A-Ahahahahahahahaha"><a href="#A-Ahahahahahahahaha" class="headerlink" title="A. Ahahahahahahahaha"></a>A. Ahahahahahahahaha</h3><p>注意到 01 串一定有 $\ge n/2$ 个 0 或者 1，依此构造即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), c += (a[i] == <span class="number">0</span>);</span><br><span class="line">n /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"0 "</span>);<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!c)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, n &lt;&lt; <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);  <span class="built_in">puts</span>(<span class="string">""</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, n + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);  <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c &gt;= n)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Big-Vova"><a href="#B-Big-Vova" class="headerlink" title="B. Big Vova"></a>B. Big Vova</h3><p>$O(n^2)$ 贪心即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) usd[i] = <span class="number">0</span>;</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(usd[j]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(mx == <span class="number">0</span>) mx = j;</span><br><span class="line">        <span class="keyword">if</span>(gcd(lst, a[mx]) &lt; gcd(lst, a[j])) mx = j;</span><br><span class="line">    &#125;</span><br><span class="line">    usd[mx] = <span class="number">1</span>, b[i] = a[mx];</span><br><span class="line">    lst = gcd(lst, a[mx]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="C-Chocolate-Bunny"><a href="#C-Chocolate-Bunny" class="headerlink" title="C. Chocolate Bunny"></a>C. Chocolate Bunny</h3><p>连续询问 $x,y$ 和 $y, x$，得到 $a,b$，则有 $\max(a,b)=\min(p_x,p_y)$，依此模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = read(); <span class="keyword">int</span> lst = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? %d %d\n"</span>, lst, i); fflush(<span class="built_in">stdout</span>); </span><br><span class="line">    x = read();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? %d %d\n"</span>, i, lst); fflush(<span class="built_in">stdout</span>); </span><br><span class="line">    y = read(), z = max(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y) a[i] = z ;</span><br><span class="line">    <span class="keyword">else</span> a[lst] = z, lst = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vis[ a[i] ]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!vis[i]) &#123;a[lst] = i; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"! "</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]); fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure><h3 id="D-Discrete-Centrifugal-Jumps"><a href="#D-Discrete-Centrifugal-Jumps" class="headerlink" title="D. Discrete Centrifugal Jumps"></a>D. Discrete Centrifugal Jumps</h3><p>理性分析一下，边数看上去不是 $O(n^2)$ 的而是 $O(n)$ 的，那么可以线性地把图建出来，单调栈维护一下即可。<br>但是这个题并不需要最短路算法，注意到这是一个 DAG，因此直接 DP 计算即可，时间复杂度 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">stk1[++top1] = <span class="number">1</span>, stk2[++top2] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(top1 &amp;&amp; a[ stk1[top1] ] &lt; a[i])&#123;</span><br><span class="line">        f[i] = min(f[i], f[ stk1[top1] ]);</span><br><span class="line">        <span class="keyword">while</span>(top1 &amp;&amp; a[ stk1[top1] ] == a[ stk1[top1 - <span class="number">1</span>] ]) top1--;</span><br><span class="line">        <span class="keyword">if</span>(top1) top1--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top1) f[i] = min(f[i], f[ stk1[top1] ]);</span><br><span class="line">    stk1[++top1] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(top2 &amp;&amp; a[ stk2[top2] ] &gt; a[i])&#123;</span><br><span class="line">        f[i] = min(f[i], f[ stk2[top2] ]);</span><br><span class="line">        <span class="keyword">while</span>(top2 &amp;&amp; a[ stk2[top2] ] == a[ stk2[top2 - <span class="number">1</span>] ]) top2--;</span><br><span class="line">        <span class="keyword">if</span>(top2) top2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top2) f[i] = min(f[i], f[ stk2[top2] ]);</span><br><span class="line">    stk2[++top2] = i;</span><br><span class="line"></span><br><span class="line">    f[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]);</span><br></pre></td></tr></table></figure><h3 id="E-Egor-in-the-Republic-of-Dagestan"><a href="#E-Egor-in-the-Republic-of-Dagestan" class="headerlink" title="E. Egor in the Republic of Dagestan"></a>E. Egor in the Republic of Dagestan</h3><p>算是比较裸的一道 E 题了……<br>设 $f[u,0/1]$ 表示在 $u$ 点，选 0 边还是选 1 边的答案，对于一条边 $u\gets v$，应当有 $f[u,c]\gets \max(f[v,0],f[v,1])+1$，其中 $c$ 代表边 $u\gets v$ 的颜色。<br>注意到一个点不会被松弛超过一次，直接跑 Dijkstra 转移即可，时间复杂度 $O((n+m)\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,tp; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span> </span>&#123;to = t, nxt = n, tp = p;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> v, id; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;&#125; ;</span><br><span class="line"><span class="function">DJ <span class="title">mk</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;DJ d; d.v = a, d.id = b; <span class="keyword">return</span> d;&#125;</span><br><span class="line"><span class="keyword">int</span> d[CN][<span class="number">2</span>]; <span class="keyword">bool</span> vis[CN]; priority_queue&lt;DJ&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SP</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d)), Q.push( mk(d[u][<span class="number">0</span>] = d[u][<span class="number">1</span>] = <span class="number">0</span>, u) );</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        u = Q.top().id, Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">int</span> dis = max(d[u][<span class="number">0</span>], d[u][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to, c = E[k].tp, cur; <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(d[v][c] &gt; dis + <span class="number">1</span>)&#123;</span><br><span class="line">                d[v][c] = dis + <span class="number">1</span>, cur = max(d[v][<span class="number">0</span>], d[v][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(cur &lt; INF) Q.push( mk(cur, v) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;<span class="keyword">int</span> u = read(), v = read(), t = read(); add(v, u, t);&#125;</span><br><span class="line">    SP(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(max(d[<span class="number">1</span>][<span class="number">0</span>], d[<span class="number">1</span>][<span class="number">1</span>]) &lt; INF) <span class="built_in">printf</span>(<span class="string">"%d"</span>, max(d[<span class="number">1</span>][<span class="number">0</span>], d[<span class="number">1</span>][<span class="number">1</span>])), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">putchar</span>(d[i][<span class="number">0</span>] &gt; d[i][<span class="number">1</span>] ? <span class="string">'0'</span> : <span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;蒟蒻下分场……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 668 (Div. 2)</title>
    <link href="https://big-news.cn/2020/09/07/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20668%20(Div.%202)/"/>
    <id>https://big-news.cn/2020/09/07/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20668%20(Div.%202)/</id>
    <published>2020-09-07T02:12:00.000Z</published>
    <updated>2020-09-14T03:26:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>两场 Div.2 爆肝上蓝系列……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1405">比赛链接</a></p><h3 id="A-Permutation-Forgery"><a href="#A-Permutation-Forgery" class="headerlink" title="A. Permutation Forgery"></a>A. Permutation Forgery</h3><p>这题是精心构造样例给选手降智啊….卡了我半小时 /kk<br>实际上反过来输出就好了啊…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[CN], n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="B-Array-Cancellation"><a href="#B-Array-Cancellation" class="headerlink" title="B. Array Cancellation"></a>B. Array Cancellation</h3><p>容易发现答案就是后缀和的最大值…证明显然啊，就算了吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[CN];</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">int</span> ans = max(<span class="number">0l</span>l, a[n]); <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) a[i] += a[i + <span class="number">1</span>], ans = max(ans, a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="C-Balanced-Bitstring"><a href="#C-Balanced-Bitstring" class="headerlink" title="C. Balanced Bitstring"></a>C. Balanced Bitstring</h3><p>容易发现模 $k$ 相同的位置， 字符应当是相同的，那么模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, k; <span class="keyword">char</span> a[CN], s[CN];</span><br><span class="line">ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; a;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) s[i] = <span class="string">'?'</span>; <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; flag; i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i] != <span class="string">'?'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i % k] == <span class="string">'?'</span>) s[i % k] = a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i % k] != a[i]) flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    cnt1 += (s[i] == <span class="string">'1'</span>), cnt0 += (s[i] == <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">if</span>(cnt0 &gt; (k / <span class="number">2</span>) || cnt1 &gt; (k / <span class="number">2</span>)) flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">flag ? <span class="built_in">puts</span>(<span class="string">"YES"</span>) : <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br></pre></td></tr></table></figure><h3 id="D-Tree-Tag"><a href="#D-Tree-Tag" class="headerlink" title="D. Tree Tag"></a>D. Tree Tag</h3><p>容易发现初始位置看似是无用的，那么把树的直径找出来判断即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, a, b, da, db;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hinit</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) hd[i] = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[CN], dm;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinit</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) d[i] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) d[v] = d[u] + <span class="number">1</span>, dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[CN][<span class="number">21</span>], dep[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) fa[j][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dep[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) pc(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v) &#123;<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][<span class="number">0</span>];&#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="keyword">return</span> dep[u] + dep[v] - <span class="number">2</span> * dep[lca(u, v)];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; T = read(); <span class="keyword">while</span>(T--)&#123; </span><br><span class="line">    hinit(), ecnt = <span class="number">0</span>;</span><br><span class="line">    n = read(), a = read(), b = read(), da = read(), db = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"></span><br><span class="line">    finit(), pc(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(dis(a, b) &lt;= da) &#123;<span class="built_in">puts</span>(<span class="string">"Alice"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">    dinit(), dfs(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> mx = <span class="number">0</span>, p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = mx &lt; d[i] ? p = i, mx = d[i] : mx;</span><br><span class="line"></span><br><span class="line">    dinit(), dfs(p, <span class="number">0</span>), dm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dm = max(dm, d[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * da &gt;= dm) <span class="built_in">puts</span>(<span class="string">"Alice"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(db &gt;= <span class="number">2</span> * da + <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"Bob"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Alice"</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Fixed-Point-Removal"><a href="#E-Fixed-Point-Removal" class="headerlink" title="E. Fixed Point Removal"></a>E. Fixed Point Removal</h3><p>容易发现一个点能否被消除仅与询问的左边界 $l$ 有关，设 $p_i$ 为可以令 $a_i$ 消除的最大的 $l$，则答案是 $\sum\limits_{i=l}^r[p_i\ge l]$，这是一个愉快的二维数点。<br>考虑 $p_i$ 如何求出，容易观察到如下性质：</p><ol><li>若  $a_i &gt; i$，则可以定义 $p_i = 0$；</li><li>若 $a_i = i$，显然 $p_i=i$； </li><li>若 $a_i &lt; i$，则 $p_i=\max m, \text{s.t.} \left( \sum\limits_{j=m}^{i-1}[p_j\ge m]\right) \ge i - a_i$</li></ol><p>前两条都好处理，最后一条二分即可，套一个静态主席树解决二维数点，时间复杂度 $O(n\log^2 n+q\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], rt[CN], idx; SGT()&#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = ++idx;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] = d[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) rc = ch[v][<span class="number">1</span>], md(lc, ch[v][<span class="number">0</span>], l, m, p);</span><br><span class="line">        <span class="keyword">else</span> lc = ch[v][<span class="number">0</span>], md(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> d[u] - d[v];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) <span class="keyword">return</span> d[rc] - d[ch[v][<span class="number">1</span>]] + qu(lc, ch[v][<span class="number">0</span>], l, m, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qu(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, p[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ai = read();</span><br><span class="line">        <span class="keyword">if</span>(ai &gt; i) p[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ai == i) p[i] = i;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>, m, minus = i - ai;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                m = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> cur = D.qu(D.rt[i - <span class="number">1</span>], D.rt[m - <span class="number">1</span>], <span class="number">0</span>, n, m);</span><br><span class="line">                <span class="keyword">if</span>(cur &gt;= minus) l = m;</span><br><span class="line">                <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[i] = l;</span><br><span class="line">        &#125;</span><br><span class="line">        D.md(D.rt[i], D.rt[i - <span class="number">1</span>], <span class="number">0</span>, n, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(); l++, r = n - r;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.qu(D.rt[r], D.rt[l - <span class="number">1</span>], <span class="number">0</span>, n, l)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两场 Div.2 爆肝上蓝系列……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 667 (Div. 3)</title>
    <link href="https://big-news.cn/2020/09/05/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20667%20(Div.%203)/"/>
    <id>https://big-news.cn/2020/09/05/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20667%20(Div.%203)/</id>
    <published>2020-09-05T06:43:00.000Z</published>
    <updated>2020-09-07T02:14:24.132Z</updated>
    
    <content type="html"><![CDATA[<p>最近 CF 的 Div2.3 有一点点水啊，虽然说蒟蒻还是上不了分……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1409">比赛链接</a></p><h3 id="A-Yet-Another-Two-Integers-Problem"><a href="#A-Yet-Another-Two-Integers-Problem" class="headerlink" title="A. Yet Another Two Integers Problem"></a>A. Yet Another Two Integers Problem</h3><p>签到傻题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t, a, b;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    a = read(), b = read(); <span class="keyword">int</span> k = <span class="built_in">abs</span>(a - b), b = k / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(b * <span class="number">10</span> == k) <span class="built_in">printf</span>(<span class="string">"%d"</span>, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, b + <span class="number">1</span>); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Minimum-Product"><a href="#B-Minimum-Product" class="headerlink" title="B. Minimum Product"></a>B. Minimum Product</h3><p>设 $a$ 变成了 $a-c$，$b$ 变成了 $b-d$，则减少的部分是 $-cb-ad+cd$，代入 $c+d=n$ 可以推出这是一个关于 $c$ 的二次函数，且开口向下，那么容易知道 $c$ 只有两种取值 $\max(0,y-b+n)$ 或 $a-x$，代入检验即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> t, a, b, x, y, n;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    a = read(), b = read(), x = read(), y = read(), n = read();</span><br><span class="line">    <span class="keyword">int</span> ans = INF, c, d;</span><br><span class="line">    <span class="keyword">if</span>(a + b - x - y &lt;= n) ans = x * y;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        c = min(n, a - x), d = min(b - y, n - c);</span><br><span class="line">        ans = min(ans, (a - c) * (b - d));</span><br><span class="line">        c = min(n, max(<span class="number">0l</span>l, y - b + n)), d = min(b - y, n - c);</span><br><span class="line">        ans = min(ans, (a - c) * (b - d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d"</span>, ans);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Yet-Another-Array-Restoration"><a href="#C-Yet-Another-Array-Restoration" class="headerlink" title="C. Yet Another Array Restoration"></a>C. Yet Another Array Restoration</h3><p>傻题，模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">202</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, x, y, d, a[CN], ans[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mx</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = max(mx, a[i]);</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    n = read(), x = read(), y = read(); <span class="keyword">int</span> mn = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(d = <span class="number">1</span>; d &lt;= y; d++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((y - x) % d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = (y - x) / d + <span class="number">1</span>, u = x; <span class="keyword">if</span>(l &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) a[i] = u, u += d;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = n - l; u = x - d;</span><br><span class="line">            <span class="keyword">while</span>(u &gt; <span class="number">0</span> &amp;&amp; sum) sum--, a[++l] = u, u -= d;</span><br><span class="line">            u = y + d;</span><br><span class="line">            <span class="keyword">while</span>(sum) sum--, a[++l] = u, u += d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = mx(a); <span class="keyword">if</span>(cur &lt; y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur &lt; mn) mn = cur, <span class="built_in">memcpy</span>(ans, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Decrease-the-Sum-of-Digits"><a href="#D-Decrease-the-Sum-of-Digits" class="headerlink" title="D. Decrease the Sum of Digits"></a>D. Decrease the Sum of Digits</h3><p>容易发现代价是固定的，那么模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> t, n, s, bit[<span class="number">101</span>], p10[<span class="number">101</span>], cur;</span><br><span class="line">p10[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">70</span>; i++) p10[i] = p10[i - <span class="number">1</span>] * <span class="number">10</span>;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    cur = <span class="number">0</span>, n = read(), s = read();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) bit[++lg] = n % <span class="number">10</span>, n /= <span class="number">10</span>, cur += bit[lg];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg &amp;&amp; cur &gt; s; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bit[i]) <span class="keyword">continue</span>;</span><br><span class="line">        ans += (<span class="number">10</span> - bit[i]) * p10[i - <span class="number">1</span>];</span><br><span class="line">        bit[i + <span class="number">1</span>]++, cur -= bit[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Two-Platforms"><a href="#E-Two-Platforms" class="headerlink" title="E. Two Platforms"></a>E. Two Platforms</h3><p>离散化坐标，考虑对于每个坐标 $i$ ，求出 $[1,i]$ 和 $(i,n]$ 的答案，加起来更新答案即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, d, X[CN], val[CN], pre[CN], suf[CN], sum[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    </span><br><span class="line">    n = read(), d = read(), val[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) X[i] = read(), val[ ++val[<span class="number">0</span>] ] = X[i], val[ ++val[<span class="number">0</span>] ] = X[i] + d, val[ ++val[<span class="number">0</span>] ] = X[i] - d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read();</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[++cnt] = val[i];</span><br><span class="line">    val[<span class="number">0</span>] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= val[<span class="number">0</span>] + <span class="number">100</span>; i++) pre[i] = suf[i] = sum[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[ id(X[i]) ]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = id(X[i]), l = id(X[i] - d), r = id(X[i] + d);</span><br><span class="line">        pre[p] = sum[p] - sum[l - <span class="number">1</span>], suf[p] = sum[r] - sum[p - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) pre[i] = max(pre[i], pre[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = val[<span class="number">0</span>]; i; i--) suf[i] = max(suf[i], suf[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) ans = max(ans, pre[i] + suf[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Subsequences-of-Length-Two"><a href="#F-Subsequences-of-Length-Two" class="headerlink" title="F. Subsequences of Length Two"></a>F. Subsequences of Length Two</h3><p>显然要 DP，设 $f[i,j,k]$ 表示考虑 $s[1:i]$ 中，$t[1]$ 出现了 $j$ 次，当前改动了 $k$ 次的方案数，就可以转移了。</p><p>具体来讲，考虑 $i\to i+1$，我们有两种选择：</p><ol><li>什么都不做，转移到 $f[i+1,c+0/1,k]$；</li><li>把这一位改成 $t_1$，转移到 $f[i+1,c+1,k+1]$</li><li>把这一位改成 $t_2$，转移到 $f[i+1,c,k+1]+c$</li></ol><p>最后特殊考虑一下 $t[1]=t[2]$ 的情况即可，时间复杂度 $O(n^3)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, d, f[CN][CN][CN], ans; <span class="keyword">char</span> s[CN], c1, c2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i][c + (s[i] == c1)][<span class="number">0</span>] = f[i - <span class="number">1</span>][c][<span class="number">0</span>];</span><br><span class="line">        c += (s[i] == c1); <span class="keyword">if</span>(s[i] == c2) f[i][c][<span class="number">0</span>] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= n; c++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c2) f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k] + c);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">else</span> f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c2) f[i + <span class="number">1</span>][c][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c][k + <span class="number">1</span>], f[i][c][k] + c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i][c + (s[i] == c1)][<span class="number">0</span>] = f[i - <span class="number">1</span>][c][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == c1) c++, f[i][c][<span class="number">0</span>] += c - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= n; c++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k], f[i][c][k] + c);</span><br><span class="line">          <span class="keyword">else</span> f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>], f[i][c][k] + c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), d = read(), <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(c1 != c2) DP1(); <span class="keyword">else</span> DP2();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= n; x++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">            ans = max(ans, f[n][x][k]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 CF 的 Div2.3 有一点点水啊，虽然说蒟蒻还是上不了分……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>2-SAT问题</title>
    <link href="https://big-news.cn/2020/09/03/2-SAT%E9%97%AE%E9%A2%98/"/>
    <id>https://big-news.cn/2020/09/03/2-SAT%E9%97%AE%E9%A2%98/</id>
    <published>2020-09-03T00:28:00.000Z</published>
    <updated>2020-09-03T08:18:20.002Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，2-SAT即二元适配性问题，用于解决一类布尔方程的求值问题……</p><a id="more"></a><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个布尔变量 $x_1, x_2, …,x_n$，给定 $m$ 对冲突关系，形如 $x_i\And x_j=0$，问一组可行解。<br>$n\le 10^5, m\le 10^6$</p></div></article><p>拆点建图，对每个变量 $x_i$ 拆成两个点 $i$ 和 $i’$，前者表示“$x_i$ 为真”，后者表示“$x_i$ 为假”。则可以将冲突关系 $(x_i,x_j)$ 转化为偏序关系 $(i,j’)$ 和 $(j,i’)$，依此得到一张有向图，然后就可以按照处理偏序关系的思路去做了。</p><p>容易发现，对于一个偏序环上的点，如果取一个值为真，那么剩下的点取值也必然为真；于是可以得到解的存在性定理：该布尔方程有解当且仅当 $\forall i$，$i$ 和 $i’$ 不在同一个偏序环上。</p><p>如何求出一组可行解呢？贪心地想，对于 $i$ 和 $i’$，我们应该选择在新图中拓扑序大的那个将其设为真，因为这样可以最小化影响。注意到 tarjan 求出的 SCC 的编号即为新图拓扑序的反序，因此直接判断即可。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个布尔变量 $x_1\sim x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 true / false 或 $x_j$ 为 true / false」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。<br>试给每个变量赋值使得所有条件得到满足，无解输出 IMPOSSIBLE。<br>$n, m\le 10^6$</p></div></article><p>容易发现一共有三种本质不同的条件形式：</p><ol><li>$x_i=0|x_j=1$，等价于 $x_i\And \neg x_j=0$，连边 $(i,j),(j’,i’)$；</li><li>$x_i=0|x_j=0$，等价于 $x_i\And x_j=0$，连边 $(i,j’),(j,i’)$；</li><li>$x_i=1|x_j=1$，等价于 $\neg x_i\And \neg x_j=0$，连边 $(i’,j),(j’,i)$。</li></ol><p>然后套用上面的做法就好了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]),hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, du[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, bel[CN], bcnt = <span class="number">0</span>; <span class="keyword">bool</span> ins[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u, ins[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) dfs(v), low[u] = min(low[u], low[v]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[v]) low[u] = min(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">        bcnt++; <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos ^ u) pos = stk[top--], ins[pos] = <span class="literal">false</span>, bel[pos] = bcnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = read(), a = read(), j = read(), b = read();</span><br><span class="line">        <span class="keyword">if</span>(a ^ b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt; b) swap(i, j), swap(a, b);</span><br><span class="line">            add(i, j), add(j + n, i + n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a) add(i, j + n), add(j, i + n);</span><br><span class="line">            <span class="keyword">else</span> add(i + n, j), add(j + n, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); i++) <span class="keyword">if</span>(!dfn[i]) dfs(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; i++) flag &amp;= (bel[i] != bel[i + n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"POSSIBLE"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(bel[i] &lt; bel[i + n]) <span class="built_in">printf</span>(<span class="string">"1 "</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，2-SAT即二元适配性问题，用于解决一类布尔方程的求值问题……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论" scheme="https://big-news.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="2-SAT" scheme="https://big-news.cn/tags/2-SAT/"/>
    
  </entry>
  
  <entry>
    <title>博弈论学习笔记</title>
    <link href="https://big-news.cn/2020/09/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/09/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-02T01:25:00.000Z</published>
    <updated>2020-09-21T13:05:05.651Z</updated>
    
    <content type="html"><![CDATA[<p>Alice 和 Bob 又开始玩游戏了……</p><a id="more"></a><h3 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h3><p>对于博弈论中的局面 $S$，定义它的 SG 函数为 $SG(S)=\text{mex} SG(T)$，其中 $T$ 是 $S$ 的后继局面。<br>对于无法做出任何移动的局面（先手必败态），我们称之为 P 态，否则称之为 N 态（先手必胜态）。</p><ul><li>SG 定理：一个局面 $S$ 是 P 态当且仅当 $SG(S)=0$</li></ul><p>这个定理也可以这样理解：可以到达 P 态的局面是 N 态，所有移动都导致 N 态的局面是 P 态。<br>另一个非常有用的结论：对于由多个局面 $S_1, S_2,…S_n$ 组成的博弈游戏，该局面的 SG 函数是所有 $SG(S_i)$ 的异或和。</p><h3 id="经典-Nim"><a href="#经典-Nim" class="headerlink" title="经典 Nim"></a>经典 Nim</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取，最后没石子可取的人就输了。问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>根据 SG 定理，容易发现 $SG(S_i)=a_i$，故先手必胜当且仅当 $a_i$ 的异或和不为0。</p><h3 id="阶梯-Nim"><a href="#阶梯-Nim" class="headerlink" title="阶梯 Nim"></a>阶梯 Nim</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出任意多枚石子<strong>移动到前面一堆石子</strong>，可以取完，不能不取，最后无法移动的人就输了（此时所有石子都在位置0）。问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>若先手移动偶数堆的石子到奇数堆去，那么后手可以立刻将其移入下一个偶数堆，这样看起来对奇数堆毫无影响。但是如果先手移动奇数堆的石子去偶数堆，则可能会将其移入第 0 堆。因此，只有在奇数堆移动石子是本质的。</p><p>“从奇数堆移动一些石子去偶数堆”等价于从奇数堆拿走一些石子扔掉，因子对奇数堆做 Nim 即可。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个箱子，每个箱子有 $a_i$ 个石头，一开始所有箱子都是关着的。<br>Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。<br>不能操作的输，求先手必胜还是后手必胜。<br>$1\le n\le 10^5, 0\le a_i\le 10^9$</p></div></article><p>考虑如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。<br>如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。</p><p>因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。<br>大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。</p><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出一枚石子扔掉，但任意两次不能取同堆的石子。最后无法移动的人输，问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>若存在一堆石子，满足其中石子的个数比其它堆石子个数总和还多，则先手是必胜的，即一直取这一堆就好了。<br>如果不存在呢？那么任意时刻，不能存在一堆石子，使得其中石子的个数多于其它堆石子个数总和。这意味着所有石子都要被取走，因此直接判断奇偶性即可，复杂度 $O(n)$。</p><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给你 $n$ 张卡片，每张卡片的两个面各有数字 $a_i$ 和 $b_i$，每个面都有 $1/2$ 的概率出现为卡片的正面，卡牌正反面的概率相互独立，求把所有卡牌正面数字拿来玩 Nim 游戏，先手必胜的概率。<br>$n\le 5\times 10^5, a_i,b_i\le 10^{18}$</p></div></article><p>设 $S=\bigoplus\limits_{i=1}^na_i$，定义序列 $c_i=a_i\oplus b_i$，则问题等价于求序列 $c$ 有多少个子集使得异或和为 $S$，线性基维护即可，复杂度 $O(n\log a_i)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LB</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: LL a[<span class="number">101</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i + <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(x &amp; (<span class="number">1l</span>l &lt;&lt; i))) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span>(a[i]) x ^= a[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j + <span class="number">1</span>; j--) <span class="keyword">if</span>(x &amp; (<span class="number">1l</span>l &lt;&lt; j)) x ^= a[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= <span class="number">63</span>; j++) <span class="keyword">if</span>(a[j] &amp; (<span class="number">1l</span>l &lt;&lt; i)) a[j] ^= x;</span><br><span class="line">                a[i] = x; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sz</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">63</span>; i++) <span class="keyword">if</span>(a[i]) cnt++; <span class="keyword">return</span> cnt;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ext</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i + <span class="number">1</span>; i--) <span class="keyword">if</span>(x &amp; (<span class="number">1l</span>l &lt;&lt; i)) x ^= a[i]; <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line">LL n, sum, a[CN], b[CN];</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), b[i] = read(), D.ins(a[i] ^ b[i]), sum ^= a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!D.ext(sum)) <span class="built_in">puts</span>(<span class="string">"1/1"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = D.sz();</span><br><span class="line">    LL ans = <span class="number">1</span>; <span class="keyword">while</span>(k--) ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld/%lld"</span>, ans - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子（$n$ 是偶数），每堆石子有 $a_i$ 个，每人每次可从任意 $n/2$ 堆石子里取出至少一枚石子扔掉。最后无法移动（有石子的堆的数量 $\le n/2$）的人输，问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>考虑若存在石子个数为 1 的堆，设堆数为 $x(x&gt;0)$，则有情况如下：</p><ol><li>$x &gt; n/2$，则先手必败，因为无法避免在操作中形成空堆；</li><li>$x\le n/2$，则先手必胜，因为先手只要令操作后 $x&gt;n/2$ 即可</li></ol><p>剩下的唯一问题是不存在石子个数为 1 的堆的情况。<br>可以考虑放宽限制，即考虑石子个数为 2 的堆的情况。容易发现石子个数为 2 的情况依然可以归结到上述的两种讨论，因此直接猜出结论：先手必胜当且仅当石子个数最小的堆的数量 $\le n / 2$。</p><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://www.luogu.com.cn/problem/P2197">「LG-P2197」NIM游戏</a></li><li>暂无来源</li><li>暂无来源</li><li><a href="https://codeforces.com/contest/1396/problem/B">「CF1396B」Stoned Game</a></li><li><a href="https://codeforces.com/problemset/problem/662/A">「CF662A」Gambling Nim</a></li><li><a href="https://codeforces.com/problemset/problem/1147/C">「CF1147C」Thanos Nim</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Alice 和 Bob 又开始玩游戏了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="博弈论" scheme="https://big-news.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="线性基" scheme="https://big-news.cn/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>KMP学习笔记</title>
    <link href="https://big-news.cn/2020/08/31/KMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/08/31/KMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-31T11:12:00.000Z</published>
    <updated>2020-09-21T13:05:15.659Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，对于一般的字符串题，存在如下规律：字符串算法 &lt; hash &lt; 暴力，其中 “&lt;” 代表“劣于”。</p><a id="more"></a><p>kmp 被用来解决下面的这样一个问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定两个字符串 $S,T$ ，求 $S$ 在 $T$ 中匹配的数量和位置。<br>$|T|,|S|\le 10^6$</p></div></article><p>直接 hash 和 kmp 都是 $O(|S|+|T|)$ 的复杂度，但是 kmp 的思想还是要理解的。<br>kmp 的思想基于下面这两个东西。</p><h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>一个 border 定义为字符串的一段前缀，使其等于本串的一段后缀。<br>用符号表示的话就是找到一个 $k$，使得 $s[1:k]=s[n-k+1:n]$。容易发现我们可以用这个 $k$ 去双射一个 border。<br>众所周知，border 具有一个非常优美的性质，即你的 border 的 border 还是你的 border。</p><h3 id="next-数组"><a href="#next-数组" class="headerlink" title="next[] 数组"></a>next[] 数组</h3><p>定义 $nxt[i]=md(s[1:i])$ 是串 $s$ 的 $nxt[]$ 数组，其中 $md(x)$ 代表串 $x$ 的最长 border 长度（不能是自身）。<br>容易发现 $nxt[i], nxt[nxt[i]],…$ 构成了串 $s[1:i]$ 的所有 border。</p><p>kmp 每次确定一个最大的 $k$，使得 $S[1:k] = T[i - k + 1:i]$，然后尝试扩展 $k\to k+1$，如果 $k=|S|$ 则发现了匹配位置。<br>容易发现，这个尝试扩展的过程可以通过 border 来加速，即若 $S[k+1]\neq T[i+1]$，则令 $k=nxt[k]$ 即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, nxt[CN]; <span class="keyword">char</span> s[CN], t[CN];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; (t + <span class="number">1</span>) &gt;&gt; (s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(t + <span class="number">1</span>), m = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; nxt[<span class="number">1</span>] = <span class="number">0</span>, nxt[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// k : 当前的最长 border</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != s[i]) k = nxt[k]; <span class="comment">// 去找次长 border</span></span><br><span class="line">    nxt[i] = (k += <span class="number">1</span>); <span class="comment">// 往下匹配一位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != t[i]) k = nxt[k]; <span class="comment">// 同理</span></span><br><span class="line">    <span class="keyword">if</span>((k += <span class="number">1</span>) == m) <span class="built_in">printf</span>(<span class="string">"%d"</span>, i - m + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>); <span class="comment">// 已经匹配上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定字符串 $S$，求 $S$ 的所有前缀的<strong>不重叠</strong>的 border 数量。<br>$|S|\le 5\times 10^7$</p></div></article><p>直接在 kmp 上维护即可，注意一下 kmp 想要保证复杂度则必须避免反复横跳。<br>时间复杂度 $O(n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e7</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, nxt[CN], num[CN]; <span class="keyword">char</span> s[CN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; nxt[<span class="number">0</span>] = <span class="number">-1</span>, nxt[<span class="number">1</span>] = <span class="number">0</span>, num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != s[i]) k = nxt[k];</span><br><span class="line">    k += <span class="number">1</span>, nxt[i] = k, num[i] = num[k] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != s[i]) k = nxt[k];</span><br><span class="line">    <span class="keyword">while</span>(k &gt; i / <span class="number">2</span>) k = nxt[k]; <span class="comment">// 跑过了就挪回去</span></span><br><span class="line">    ans = <span class="number">1l</span>l * ans * (num[k] + <span class="number">1</span>) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="在字典树上的扩展"><a href="#在字典树上的扩展" class="headerlink" title="在字典树上的扩展"></a>在字典树上的扩展</h3><p>考虑这样一个问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个字符串 $T$，和<strong>一些</strong>字符串 $S_1,S_2,…S_n$，对每个 $S_i$ 求其在 $T$ 中匹配的数量。<br>$|T|,\sum|S_i|\le 10^6$</p></div></article><p>解决方法是对 $S_i$ 建立字典树，然后再在字典树上建立类似于 $nxt[]$ 指针的结构。注意到这种方法具有可扩展性，即广义后缀自动机也通过类似的思想构建。</p><p>于是这棵字典树变成了一个<strong>确定有限状态自动机（DFA）</strong>，我们称其为 <strong>AC自动机（Aho-Corasick Automaton, ACAM）</strong>。</p><p>则可以得到这样一份构建代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAM</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> son[CN][<span class="number">26</span>], fail[CN], e[CN], idx; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!son[u][ s[i] - <span class="string">'a'</span> ]) son[u][ s[i] - <span class="string">'a'</span> ] = ++idx;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">        &#125;</span><br><span class="line">        e[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) Q.push( son[<span class="number">0</span>][i] );</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]);</span><br><span class="line">                <span class="keyword">else</span> son[u][i] = son[ fail[u] ][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = u; j &amp;&amp; e[j] ^ <span class="number">-1</span>; j = fail[j])</span><br><span class="line">                r += e[j], e[j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个字符串 $T$ 和一些字符串 $S_1,S_2,…S_n$，定义一个字符串是可爱的当且仅当它不包含任何 $S_i$ 作为子串。试删除最少的字符使得 $T$ 变得可爱。<br>$|T|,\sum|S_i|\le 5000$</p></div></article><p>考虑 DP，设 $f[l,u]$ 为考虑 $S[1:l]$，在AC自动机上走到了节点 $u$ 的最小代价。考虑 $S[l+1]$ 是否删除，则有转移：<br>$$\begin{aligned} &amp;f[l,u]+1\to f[l + 1, u]\newline &amp;f[l,u]\to f[l+1,v] \text{ }|\text{ }son[u, S[l + 1]] = v\end{aligned}$$ $v$ 点应当满足怎样的限制呢？首先它不应该是接受状态，并且 fail 树上它到根的路径上也不能存在接受状态，因为这些状态是后缀等价的。那么按照 bfs 序更新一下即可，时间复杂度 $O(|T|\sum |S_i|)$。 </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2020</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAM</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> son[CN][<span class="number">26</span>], fail[CN], w[CN], idx; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!son[u][ s[i] - <span class="string">'a'</span> ]) son[u][ s[i] - <span class="string">'a'</span> ] = ++idx;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">        &#125;</span><br><span class="line">        w[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) Q.push(son[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]);</span><br><span class="line">                <span class="keyword">else</span> son[u][i] = son[ fail[u] ][i];</span><br><span class="line">            w[u] += w[ fail[u] ]; <span class="comment">// mark</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f[CN][CN];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= idx; i++)&#123;</span><br><span class="line">                f[l + <span class="number">1</span>][i] = min(f[l + <span class="number">1</span>][i], f[l][i] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> v = son[i][ s[l] - <span class="string">'a'</span> ];</span><br><span class="line">                <span class="keyword">if</span>(!w[v]) f[l + <span class="number">1</span>][v] = min(f[l + <span class="number">1</span>][v], f[l][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= idx; i++) ans = min(ans, f[n][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一些字符串 $S_1,S_2,…S_n$ 和字符集 $\Sigma$，每个字符串 $S_i$ 有一个价值 $w_i$。<br>定义一个字符串的价值为其所有子串的价值和（未定义则为 $0$），求一个长度为 $l$ 的串使得其价值最大。<br>$|\Sigma|\le 26 ,\sum|S_i|,l\le 1000$</p></div></article><p>考虑 DP，假设当前的字符串为 $s$，新增了一个字符 $c$ 得到 $sc$，则新增的子串应当是 $sc$ 的所有后缀，新增字符的价值为这些后缀的价值和。<br>对 $S_i$ 建立AC自动机，则“这些后缀的价值和”体现为 fail 树上从根到 $sc$ 所在的节点的权值和，我们记其为 $w[u]$。</p><p>于是就可以 DP 了，设 $f[l,u]$ 表示当前拼出的串长度为 $l$，现在在AC自动机上的节点 $u$ 的最大价值，有转移：<br>$$ f[l,u]+w[v]\to f[l+1,v]\text{ }|\text{ }\exists c, \text{s.t.} son[u, c]=v$$ 时间复杂度 $O(l\sum|S_i||\Sigma|)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2020</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">queue</span> &#123;</span> <span class="comment">// 惨痛经历</span></span><br><span class="line">  <span class="keyword">public</span>: T a[CN], hd, tl; <span class="built_in">queue</span>() &#123;hd = tl = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> hd ^ tl ? <span class="number">0</span> : <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a[hd];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;hd++;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;a[tl++] = x;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAM</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> w[CN], son[CN][<span class="number">26</span>], fail[CN], idx; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!son[u][ s[i] - <span class="string">'a'</span> ]) son[u][ s[i] - <span class="string">'a'</span> ] = ++idx;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">        &#125;</span><br><span class="line">        w[u] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) Q.push(son[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]);</span><br><span class="line">                <span class="keyword">else</span> son[u][i] = son[ fail[u] ][i];</span><br><span class="line">            w[u] += w[ fail[u] ]; <span class="comment">// mark</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f[CN][CN];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt;= idx; u++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">26</span>; c++)</span><br><span class="line">                    f[i + <span class="number">1</span>][ son[u][c] ] = max(f[i + <span class="number">1</span>][ son[u][c] ], f[i][u] + w[ son[u][c] ]);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt;= idx; u++) ans = max(ans, f[l][u]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://loj.ac/problem/2246">「NOI2014」动物园</a></li><li>暂无来源</li><li>暂无来源</li><li>暂无来源</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，对于一般的字符串题，存在如下规律：字符串算法 &amp;lt; hash &amp;lt; 暴力，其中 “&amp;lt;” 代表“劣于”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="KMP" scheme="https://big-news.cn/tags/KMP/"/>
    
      <category term="AC自动机" scheme="https://big-news.cn/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」牛客练习赛68</title>
    <link href="https://big-news.cn/2020/08/28/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B68/"/>
    <id>https://big-news.cn/2020/08/28/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B68/</id>
    <published>2020-08-28T12:03:00.000Z</published>
    <updated>2020-08-29T12:22:16.464Z</updated>
    
    <content type="html"><![CDATA[<p>牛客的题还是比较板啊，像我这样的菜鸡都能打到 rk30？？？/jk</p><a id="more"></a><h3 id="A-牛牛的mex"><a href="#A-牛牛的mex" class="headerlink" title="A 牛牛的mex"></a>A 牛牛的mex</h3><p>主席树模板题。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx;</span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] = d[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) rc = ch[v][<span class="number">1</span>], ins(lc, ch[v][<span class="number">0</span>], l, m, p);</span><br><span class="line">        <span class="keyword">else</span> lc = ch[v][<span class="number">0</span>], ins(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = d[lc] - d[ ch[v][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &lt; m - l + <span class="number">1</span>) <span class="keyword">return</span> qu(lc, ch[v][<span class="number">0</span>], l, m);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qu(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, ai;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ai = read(), D.ins(D.rt[i], D.rt[i - <span class="number">1</span>], <span class="number">1</span>, n, ai + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span>(q--) x = read(), y = read(), <span class="built_in">printf</span>(<span class="string">"%d"</span>, y - x + <span class="number">1</span> &lt; n ? D.qu(D.rt[y], D.rt[x - <span class="number">1</span>], <span class="number">1</span>, n) - <span class="number">1</span> : n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-牛牛的算术"><a href="#B-牛牛的算术" class="headerlink" title="B 牛牛的算术"></a>B 牛牛的算术</h3><p>傻题，随便推一推柿子，特判下就好了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">199999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> i2 qp(2, P - 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, f[CN], p[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> squ = <span class="number">1l</span>l * x * x % P; squ = <span class="number">1l</span>l * squ * (x + <span class="number">1</span>) % P;</span><br><span class="line">    <span class="keyword">return</span> squ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; P; i++) f[i] = (f[i - <span class="number">1</span>] + cal(i)) % P;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; P; i++) p[i] = <span class="number">1l</span>l * p[i - <span class="number">1</span>] * i % P, p[i] = <span class="number">1l</span>l * p[i] * f[i] % P, p[i] = <span class="number">1l</span>l * p[i] * i2 % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch; <span class="keyword">int</span> l = <span class="built_in">strlen</span>(ch); <span class="keyword">if</span>(l &gt;= <span class="number">6</span>) &#123;<span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) n = n * <span class="number">10</span> + (ch[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= P) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, p[n]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-牛牛的无向图"><a href="#C-牛牛的无向图" class="headerlink" title="C 牛牛的无向图"></a>C 牛牛的无向图</h3><p>容易想到把边和询问都按权值排序，然后依次加边，能加就加，然后对于每个连通块就可以 $O(1)$ 算答案了。维护一个并查集就解决了，时间复杂度 $O(m\log m + (m + q)\alpha(n))$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fa[CN];</span><br><span class="line">    DSU() &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) fa[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] ^ x ? fa[x] = fd(fa[x]) : x;&#125;</span><br><span class="line">&#125; C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, LIM, X[CN], Y[CN], W[CN], id[CN], pos = <span class="number">1</span>, L[CN], sz[CN]; </span><br><span class="line">LL ans[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> W[i] &lt; W[j];&#125;</span><br><span class="line"><span class="function">LL <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l * x * (x - <span class="number">1</span>) / <span class="number">2l</span>l;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SA, SB, SC; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">rng61</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SA ^= SA &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    SA ^= SA &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    SA ^= SA &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> t = SA;</span><br><span class="line">    SA = SB;</span><br><span class="line">    SB = SC;</span><br><span class="line">    SC ^= t ^ SA;</span><br><span class="line">    <span class="keyword">return</span> SC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%u%u%u%d"</span>, &amp;n, &amp;m, &amp;q, &amp;SA, &amp;SB, &amp;SC, &amp;LIM);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        X[i] = rng61() % n + <span class="number">1</span>;</span><br><span class="line">        Y[i] = rng61() % n + <span class="number">1</span>;</span><br><span class="line">        W[i] = rng61() % LIM; id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        L[i] = rng61() % LIM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    gen();</span><br><span class="line"></span><br><span class="line">    sort(L + <span class="number">1</span>, L + q + <span class="number">1</span>), sort(id + <span class="number">1</span>, id + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sz[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        LL cur = ans[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(W[ id[pos] ] &lt;= L[i] &amp;&amp; pos &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = X[ id[pos] ], v = Y[ id[pos] ], fu = C.fd(u), fv = C.fd(v);</span><br><span class="line">            <span class="keyword">if</span>(fu ^ fv) </span><br><span class="line">                cur += <span class="number">1l</span>l * sz[fu] * sz[fv], </span><br><span class="line">                C.fa[fv] = fu, sz[fu] += sz[fv];</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) ans[<span class="number">0</span>] ^= ans[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-牛牛的粉丝"><a href="#D-牛牛的粉丝" class="headerlink" title="D 牛牛的粉丝"></a>D 牛牛的粉丝</h3><p>显然是个矩乘优化 DP 转移，设 $f[k,i]$ 表示 $k$ 轮后点 $i$ 的答案这样，直接做复杂度 $O(n^3\log k)$，好像不太行。<br>然后就没有想法了……</p><p>upd：转移矩阵是循环的啊……既然是循环的就没必要 $O(n^3)$ 算了……存下第一行来矩乘就变卷积了……于是做到 $O(n^2\log k)$……甚至还可以 $O(n\log n\log k)$ /jk……</p><h3 id="E-牛牛的字符串"><a href="#E-牛牛的字符串" class="headerlink" title="E 牛牛的字符串"></a>E 牛牛的字符串</h3><p>回文不会处理啊……看上去我只会 $O(n^3)$ 的辣鸡 DP，也许可以通过一些字符串算法优化到 $O(n^2)$？不可做不可做。</p><p>upd：并没有什么神仙算法……所以说还是要观察性质……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;牛客的题还是比较板啊，像我这样的菜鸡都能打到 rk30？？？/jk&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>利用vector重现set</title>
    <link href="https://big-news.cn/2020/08/28/%E5%88%A9%E7%94%A8vector%E9%87%8D%E7%8E%B0set/"/>
    <id>https://big-news.cn/2020/08/28/%E5%88%A9%E7%94%A8vector%E9%87%8D%E7%8E%B0set/</id>
    <published>2020-08-28T01:45:00.000Z</published>
    <updated>2020-08-28T03:12:31.120Z</updated>
    
    <content type="html"><![CDATA[<p>提供一种小数据下运行效率极高的<code>std::set</code>替代方法。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-asia mr-2"></i>此页面存在相关页面。关于普通平衡树，请参见<a href="/2020/06/26/Splay/">「Splay」</a>。</div></article><a id="more"></a><p>众所周知，平衡树有两类：一类维护集合，一类维护序列。维护序列的平衡树通常作为线段树的替代，用于解决线段树并不支持的区间翻转操作；而维护集合的平衡树则可以被看作是在重现<code>std::set</code>。</p><p>但是这并不是最简便的方案，实际上，我们可以利用<code>std::vector</code>去吊锤维护集合的平衡树。此种方法在 $10^5$ 量级下速度极快，运行时间甚至优于普通 Splay。</p><p>维护集合的平衡树被用来解决这样一类问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>您需要写一种数据结构，来维护一些数，其中需要提供以下操作：</p><ol><li>插入 $x$ 数</li><li>删除 $x$ 数（若有多个相同的数，因只删除一个）</li><li>查询 $x$ 数的排名（排名定义为比当前数小的数的个数 $+1$）</li><li>查询排名为 $x$ 的数</li><li>求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）</li><li>求 $x$ 的后继（后继定义为大于 $x$，且最小的数）</li></ol><p>设 $n$ 为集合的最大大小，对所有数据，满足 $n\le 10^5$。</p></div></article><p>利用<code>std::lower_bound</code>和<code>std::upper_bound</code>，可以得到下面的这样两条语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lower_bound(v.begin(), v.end(), x) - v.begin() <span class="comment">// &lt; x 的元素个数</span></span><br><span class="line">upper_bound(v.begin(), v.end(), x) - v.begin() <span class="comment">// &lt;= x 的元素个数</span></span><br></pre></td></tr></table></figure><p>于是可以得到下面<a href="https://www.luogu.com.cn/record/37763229">这份</a>代码实现。显然，它吊锤了 <a href="https://www.luogu.com.cn/record/34668994">Splay</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v; <span class="keyword">int</span> n = read();</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    <span class="keyword">int</span> tp = read(), x = read();</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">1</span>) v.insert(lower_bound(v.begin(), v.end(), x), x);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">2</span>) v.erase(lower_bound(v.begin(), v.end(), x));</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, lower_bound(v.begin(), v.end(), x) - v.begin() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, v[x - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, v[lower_bound(v.begin(), v.end(), x) - v.begin() - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, v[upper_bound(v.begin(), v.end(), x) - v.begin()]);</span><br><span class="line">    <span class="keyword">if</span>(tp &gt; <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理性分析一下，这份代码的时间复杂度为 $O(n^2\log n)$，瓶颈在于<code>erase()</code>和<code>insert()</code>。</p><p>但是我们可以对其进行测试，Generator 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">int</span> t1 = <span class="number">1</span>, t2 = <span class="number">1000000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"1 %d"</span>, t1++), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1 %d"</span>, t2--), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4 %d"</span>, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本机测试结果如下：</p><table><thead><tr><th>数据范围</th><th>$n=5\times10^4$</th><th>$n=10^5$</th><th>$n=5\times 10^5$</th><th>$n=10^6$</th></tr></thead><tbody><tr><td>运行时间（平均，向下近似）</td><td>100ms</td><td>280ms</td><td>7.7s</td><td>30s</td></tr><tr><td>运行时间（平均，向下近似，O2）</td><td>70ms</td><td>280ms</td><td>7s</td><td>28s</td></tr><tr><td>对比（普通 Splay）</td><td>30ms</td><td>30ms</td><td>260ms</td><td>380ms</td></tr></tbody></table><p>容易发现当 $n$ 超过 $10^5$ 的量级后，其运行效率略大于 $O(n\sqrt{n})$，而在之前效率及其优秀。但是实际上题目中插入操作的数量并没有达到测试中的量级，因此出现了吊锤 Splay 的现象。</p><p>于是我们可以初步地得出结论：在 $10^5$ 的数据量级下，利用<code>vector</code>代替 Splay 有着优秀的运行效率。</p><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的图，给出 $m$ 对点和 $q$ 条边。顺序尝试加入每条边，如果不会使得 $m$ 对点中的任意一对点联通，则加入，否则不加入。判断每条边是否会被加入。<br>$n,m,q\le 10^5$</p></div></article><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>条件反射：看到不可逆性修改操作，就应该想到结构合并。</div></article><p>容易想到对每个点维护一个<code>set</code>，表示该点不能到达的点集，然后连一条边相当于合并两个<code>set</code>，在合并前判断一下，然后启发式合并就好了。<br>然后把<code>set</code>换成<code>vector</code>，运行时间得以缩小一半。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fa[CN]; DSU() &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) fa[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] ^ x ? fa[x] = fd( fa[x] ) : x;&#125;</span><br><span class="line">&#125; C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("_in.in", "r", stdin);</span></span><br><span class="line"></span><br><span class="line">    n = read(), m = read(), q = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        v[x].push_back(y), v[y].push_back(x);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(), fx = C.fd(x), fy = C.fd(y);</span><br><span class="line">        <span class="keyword">if</span>(fx == fy) &#123;<span class="built_in">putchar</span>(<span class="string">'1'</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> szx = v[fx].size(), szy = v[fy].size();</span><br><span class="line">        <span class="keyword">if</span>(szx &gt; szy) swap(fx, fy), swap(szx, szy);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; szx &amp;&amp; flag; i++) <span class="keyword">if</span>(C.fd( v[fx][i] ) == fy) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;<span class="built_in">putchar</span>(<span class="string">'0'</span>); <span class="keyword">continue</span>;&#125; <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        <span class="comment">/* fx -&gt; fy */</span></span><br><span class="line">        C.fa[fx] = fy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; szx; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = v[fx][i], p = lower_bound(v[fy].begin(), v[fy].end(), u) - v[fy].begin() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(v[fy][p] == u) <span class="keyword">continue</span>;</span><br><span class="line">            v[fy].insert(lower_bound(v[fy].begin(), v[fy].end(), u), u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提供一种小数据下运行效率极高的&lt;code&gt;std::set&lt;/code&gt;替代方法。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-primary&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;
此页面存在相关页面。关于普通平衡树，请参见&lt;a href=&quot;/2020/06/26/Splay/&quot;&gt;「Splay」&lt;/a&gt;。
&lt;/div&gt;
&lt;/article&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="平衡树" scheme="https://big-news.cn/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>「题解」Fancy Fence</title>
    <link href="https://big-news.cn/2020/08/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DFancy%20Fence/"/>
    <id>https://big-news.cn/2020/08/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DFancy%20Fence/</id>
    <published>2020-08-27T02:15:00.000Z</published>
    <updated>2020-08-30T01:34:52.225Z</updated>
    
    <content type="html"><![CDATA[<p>打了一场 CEOI2020 Day1 的线上镜像，发现这个 A 题好像有点水啊，于是切掉，来水个题解……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1402/problem/A">原题链接</a></p><p>容易发现，一个长为 $N$ 宽为 $M$ 的矩形的合法子矩形的数量可以 $O(1)$ 算。具体来讲，设：<br>$$A=\dbinom{NM}{2}, B = M·\dbinom{N}{2},C=N·\dbinom{M}{2}$$ 有该矩形的子矩形数量为：<br>$$(A-B-C)/2+B+C$$ 之所以要算的这么麻烦是为了去重…这个重复的问题考场上卡了我半小时/kk…</p><p>那么考虑对于每个 $h_i$ 拆开来算贡献。对于当前的高度 $h_i$ ，我们确定两个端点 $l_i$ 和 $r_i$，使得 $[l_i,r_i]$ 是极长的一段区间满足 $\min\limits_{l_i\le k\le r_i} h_k=h_i$，于是我们可以找到一个极大的矩形，然后就可以在这个矩形里面算答案了。</p><p>剩下的问题是考虑重复，即这个矩形下方存在一个 $h$ 更小的矩形（它应该是矮矮长长的这个样子），而它的贡献我们已经在前面算过了。我们强制令矩形的一个端点在这个矩形上方就好了。</p><p>于是就只剩下单调栈的复杂度了，总复杂度 $O(n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long <span class="comment">// 惨痛经历</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i2 = <span class="number">500000004</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, h[CN], w[CN], sum[CN], pr[CN], nt[CN], stk[CN], top = <span class="number">0</span>, ans = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; cal[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> (<span class="number">1l</span>l * x * (x - <span class="number">1</span>) / <span class="number">2l</span>l) % P;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ab = ((a - b) % P + P) % P;</span><br><span class="line">    <span class="keyword">int</span> rec = C(<span class="number">1l</span>l * l * ab % P), t1 = C(ab), t2 = C(l);</span><br><span class="line">    t1 = <span class="number">1l</span>l * t1 * l % P, t2 = <span class="number">1l</span>l * t2 * ab % P;</span><br><span class="line">    rec = ((rec - t1 - t2) % P + P) % P, rec = <span class="number">1l</span>l * rec * i2 % P;</span><br><span class="line">    rec = (rec + t1 + t2) % P;</span><br><span class="line">    <span class="keyword">int</span> t = C(l + <span class="number">1</span>); t = <span class="number">1l</span>l * t * b % P, t = <span class="number">1l</span>l * t * ab % P, t = (t + P) % P;</span><br><span class="line">    <span class="keyword">return</span> (rec + t) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) h[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) w[i] = read(), sum[i] = (sum[i - <span class="number">1</span>] + w[i]) % P, ans = (<span class="number">1l</span>l * w[i] * h[i] % P + ans) % P;</span><br><span class="line"></span><br><span class="line">    stk[++top] = <span class="number">1</span>, pr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h[ stk[top] ] &gt;= h[i]) top--;</span><br><span class="line">        pr[i] = stk[top], stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[top = <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h[ stk[top] ] &gt;= h[i]) top--;</span><br><span class="line">        nt[i] = stk[top], stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cal[ pr[i] ][ h[i] ]) <span class="keyword">continue</span>; cal[ pr[i] ][ h[i] ] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l = (sum[ nt[i] - <span class="number">1</span> ] - sum[ pr[i] ] + P) % P, a = h[i], b = max(h[ pr[i] ], h[ nt[i] ]);</span><br><span class="line">        ans = (ans + calc(l, a, b)) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打了一场 CEOI2020 Day1 的线上镜像，发现这个 A 题好像有点水啊，于是切掉，来水个题解……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="单调栈" scheme="https://big-news.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>「杂题选做」八月口胡合集</title>
    <link href="https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/"/>
    <id>https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/</id>
    <published>2020-08-24T10:06:00.000Z</published>
    <updated>2020-09-03T03:16:33.672Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，做题的关键在于口胡出解法，而我还是什么都不会……</p><a id="more"></a><p>本篇 Blog 多以口胡为主，杂题居多。</p><h3 id="1-Hunger-Game"><a href="#1-Hunger-Game" class="headerlink" title="1 Hunger Game"></a>1 Hunger Game</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $N$ 个箱子，每个箱子有 $a[i]$ 个石头，一开始所有箱子都是关着的。<br>Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。<br>不能操作的输，求先手必胜还是后手必胜。<br>$1\le N\le 1e5, 0\le a[i]&lt;10^9$</p></div></article><p>Nim 博弈的经典结论：对于每个状态有 $SG_i=a_i$ ，则终态是 P 态的充要条件是 $a_1\oplus a_2\oplus … \oplus a_n = 0$。</p><p>回到本题，如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。<br>如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。</p><p>因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。<br>大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。</p><h3 id="2-Minimum-Value-of-Equation"><a href="#2-Minimum-Value-of-Equation" class="headerlink" title="2 Minimum Value of Equation"></a>2 Minimum Value of Equation</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定 $k[i],b[i]$，有 $n$ 个函数，第 $j$ 个函数为 $f_j(x)=\sum |k[i]x+b[i]|$，其中$1\le i\le j$。<br>对于每个 $j=1…n$，求出 $f_j(x)$ 的最小值。<br>$1\le n\le 10^5 , |k[i]|\le 1000$</p></div></article><p>提一下公因式变成 $\sum k_i|x+(b_i/k_i)|$ ，即 $x$ 到数轴上的一堆点 $b_i/k_i$ 的距离和，那么 $x$ 取这些点的中位数就好了。</p><h3 id="3-DFS-Count"><a href="#3-DFS-Count" class="headerlink" title="3 DFS Count"></a>3 DFS Count</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个 $n$ 个点的有向图，求合法的 DFS 序的个数。<br>$n \le 13$</p></div></article><p>直接搜？？？（雾<br>设 $f[u,S]$ 表示当前在 $u$ ，没走过的点集为 $S$ 的方案数。$|S|$ 是递减的，可通过其来划分子问题，得到转移：<br>$$ f[v,T_v \And S]·f[u,S-(T_v \And S)] \to f[u, S] | (u,v)\in E$$<br>其中 $T_v$ 是 $v$ 能到达的点集。容易发现这次从小集合往大集合转移，则其是可操作的。</p><h3 id="4-XOR-Product"><a href="#4-XOR-Product" class="headerlink" title="4 XOR Product"></a>4 XOR Product</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定序列 $a_1,…,a_n$ ，求：<br>$$ \sum\limits_{i&lt;j&lt;k}(a_i\oplus a_j)·(a_j \oplus a_k) $$</p></div></article><p>把 $j$ 提出来，拆一下柿子：<br>$$ \sum\limits_j(\sum\limits_{i&lt;j}a_i\oplus a_j)(\sum\limits_{j&lt;k}a_j \oplus a_k) $$<br>考虑求 $\sum\limits_{i&lt;j}a_i\oplus a_j$ ，把每一位拆开算贡献，则应当统计 $a_1,…,a_{j-1}$ 中这一位上有多少个 1 ，预处理即可。<br>预处理是 $O(n\log)$ 的，枚举 $j$ 处理前后两个 sigma 是 $O(n\log)$ 的，最后统计答案也是 $O(n)$ 的。</p><h3 id="5-SUMXOR"><a href="#5-SUMXOR" class="headerlink" title="5 SUMXOR"></a>5 SUMXOR</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定序列 $a[1…n]$ 和 $b[1…n]$ ，求：<br>$$ \bigoplus\limits_{i,j}a_i+b_j $$</p></div></article><p>依然拆开每一位算，考虑第 $w$ 位的贡献应当是 $2^w\sum[(a_i+b_j)\text{ mod } 2^{w+1} \ge 2^w] \text{ mod }2$。<br>令 $a_i\gets a_i\text{ mod }2^{w+1},b_i\gets b_i\text{ mod }2^{w+1} $，有两种情况：</p><ol><li>$a_i + b_j \ge 2^{w+1}$，则应当有 $a_i+b_j-2^{w+1}\ge 2^w$，移项得 $a_i+b_j\ge 2^w+2^{w+1}$</li><li>$a_i+b_j&lt; 2^{w+1}$，则应当有 $2^w\le a_i+b_j&lt; 2^{w+1}$</li></ol><p>于是转化成序列上的查询问题，Two-Pointers 扫即可。</p><h3 id="6-The-Hanged-Man"><a href="#6-The-Hanged-Man" class="headerlink" title="6 The Hanged Man"></a>6 The Hanged Man</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个 $n$ 个点的树，每个点有一个体积 $v[i]$ 和收益 $w[i]$，现在你能选一个独立集，对于每个 $i$ 输出体积和为 $i$ 的收益和最大的独立集的值。<br>$n\le 50, m\le 5000$</p></div></article><p>$O(nm^2)$ 的 DP 显然啊，但是重链剖分 DP 看不懂啊，这个先咕着。</p><p>资料：<a href="https://www.cnblogs.com/dqsssss/p/11534336.html">乱搞</a>，<a href="https://blog.aor.sd.cn/archives/1122/">重链剖分</a></p><p>附一个 $O(nm^2)$ 的 DP：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, vi[CN], wi[CN], f[CN][<span class="number">5005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][ vi[u] ][<span class="number">1</span>] = wi[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> V = m; V; V--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> Vp = <span class="number">0</span>; Vp &lt;= V; Vp++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(V - Vp &gt;= vi[u]) f[u][V][<span class="number">1</span>] = max(f[u][V][<span class="number">1</span>], f[v][Vp][<span class="number">0</span>] + f[u][V - Vp][<span class="number">1</span>]);</span><br><span class="line">                f[u][V][<span class="number">0</span>] = max(f[u][V][<span class="number">0</span>], max(f[v][Vp][<span class="number">0</span>], f[v][Vp][<span class="number">1</span>]) + f[u][V - Vp][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Anton-and-Ira"><a href="#7-Anton-and-Ira" class="headerlink" title="7 Anton and Ira"></a>7 Anton and Ira</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定两个排列 $s$ 和 $p$ ，每次可以交换 $p$ 中的两个数，代价为它们间的距离，问最小代价使 $p$ 变为 $s$ ，输出方案。<br>$n\le 1000$</p></div></article><p>设 $to[u]$ 是 $u$ 想要去到的位置，可以将其看作一条有向边。根据抽屉原理，某一时刻必然存在一个点使 $to[u]$ 与 $to[to[u]]$ 反向，于是贪心就好了。<br>设这样得到的答案为 $s$，容易发现对于一种操作方案，必然存在另一种与之互为补集的操作方案，其答案也为 $s$。两者可以组成全集，即有 $2s=\sum|i-to[i]|$，从而 $s=\sum|i-to[i]|/2$。</p><h3 id="8-Increasing-Shortest-Path"><a href="#8-Increasing-Shortest-Path" class="headerlink" title="8 Increasing Shortest Path"></a>8 Increasing Shortest Path</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有个 $n$ 个点 $m$ 条边的有向图，有 $q$ 个询问：从 $ai$ 到 $bi$，边权递增，经过不超过 $ci$ 条边，权值和最小是多少？<br>$T$组数据（$T\le 100$）。<br>$n ≤ 150, m, q ≤ 5000.$</p></div></article><p>$n$ 比较小，那么考虑 DP。<br>边权看上去没办法放进状态里面，有一个技巧是把边升序排序，然后按照边来转移状态，即可满足要求。</p><p>设 $f[u,v,m]$ 表示 $u\to v$ 经过不超过 $m$ 条边的答案，$O(n)$ 固定起点 $s$，$O(m)$ 枚举一条边 $(u,v,w)$，则有转移：<br>$$ f[s,u,k]+w\to f[s,v,k+1] $$<br>这样看上去是 $O(nm^2)$ 的，但是考虑到限制是“至多经过”，而要求最小路径，则一个环不应在路径中出现，即一个点不会被访问超过一次。考虑到一个点之多有一条出边被选中，因此状态第三维的数量实际上是 $O(n)$ 的。对于 $ci&gt; n$ 的询问，其答案一定等于 $ci=n$ 的询问。</p><p>复杂度 $O(T(m\log m+n^2m+q))$，瓶颈在于 $O(Tn^2m)$；考虑到时限是 60s， 因此可以通过。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sort(G + <span class="number">1</span>, G + m + <span class="number">1</span>), <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) f[i][i][k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= n; s++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = G[i].u, v = G[i].v, w = G[i].w;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) </span><br><span class="line">                f[s][v][k + <span class="number">1</span>] = min(f[s][u][k] + w, f[s][v][k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="9-Increasing-Number"><a href="#9-Increasing-Number" class="headerlink" title="9 Increasing Number"></a>9 Increasing Number</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个数是Increasing当且仅当它的十进制表示是不降的，求 $n$ 位不降十进制数中被 $m$ 整除的有多少个。<br>$n ≤ 10^{18}, m ≤ 500.$</p></div></article><p>显然有状态 $f[n,p,k]$ 表示考虑第 $n$ 位数字，当前位填 $p$，模 $m$ 等于 $k$ 的方案数，转移可以枚举当前位数字和上一位数字，有关系 $f[n,p,(p\times 10^n+k)\text{ mod }m]\gets f[n-1,p’,k]$，复杂度 $O(100nm)$，不太可行。<br>对于这种转移关系比较固定的 DP，可以考虑矩乘加速，但是这是 $O((10m)^3\log n)$ 的，看上去也不太行。</p><p>一个重要的性质：一个合法数字必然是至多 9 个仅由 1 组成的数的和。<br>则可以按 $111…111$ 模 $m$ 的值将其分类，这样有 $m$ 类，然后对类做 DP 即可。<br>这也令我们可以得出一个结论：位数小于 $n$ 的不降数的总个数是 $\sum\limits_{i=1}^9\dbinom{i+n-1}{n-1}=\dbinom{n+9}{n}-1$。</p><h3 id="10-Little-Elephant-and-Colored-Coins"><a href="#10-Little-Elephant-and-Colored-Coins" class="headerlink" title="10 Little Elephant and Colored Coins"></a>10 Little Elephant and Colored Coins</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定 $n$ 个物品，每个物品可以取无限次，每个物品有两种属性：价值 $v$ 和颜色 $c$。<br>现在有 $q$ 个询问，询问最多能用多少种颜色组成 $S$。<br>$n ≤ 30, v_i ≤ 2\times 10^5,s\le 10^{18}$</p></div></article><p>对于这种题目，一般来说技巧是取 $w=\min v_i$ ，把问题转化到模 $w$ 的剩余系下做。这样做的正确性在于：$\mathbb{F}_P$ 中的所有数与 $P$ 的倍数组合能够填满整个整数域。<br>然后可以设状态 $f[u,k]$ 或 $f[k]$ 表示模 $w$ 为 $k$ 的答案，对于物品的价值 $v$ 可以抽象成一条边的边权，然后套用最短路模型，于是做到 $O(w\log w)$ 转移状态。</p><p>对于本题，考虑到硬币种类可能在统计过程中重复，因此设 $f[i,k]$ 表示选至少 $i$ 种，模 $w$ 为 $k$ 的路径的最小长度；用最短路模型来转移看上去也不太行，考虑换成背包模型，即有 $f[i,k]\gets f[i+1,(k+v_i)\text{ mod }w]$，然后按 $i$ 分组 DP 更新即可，复杂度 $O(n^2w)$。</p><p>给出大致的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = read(), w = w ? min(w, v[i]) : v[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j + <span class="number">1</span>; j--) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">            f[j + <span class="number">1</span>][(k + v[i]) % w] = min(f[j][k] + v[i], f[j + <span class="number">1</span>][(k + v[i]) % w]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">            f[i][(k + v[j]) % w] = min(f[i][k] + v[j], f[i][(k + v[j]) % w]);</span><br><span class="line">    </span><br><span class="line">q = read();</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> s = read(), sw = s % w;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &amp;&amp; !flag; i--)</span><br><span class="line">        <span class="keyword">if</span>(f[i][sw] &lt; INF &amp;&amp; f[i][sw] &lt;= s) <span class="built_in">printf</span>(<span class="string">"%d"</span>, i), <span class="built_in">puts</span>(<span class="string">""</span>), flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Balance"><a href="#11-Balance" class="headerlink" title="11 Balance"></a>11 Balance</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个杠杆，半长为 $n$，$2n+1$ 个整数坐标各有一个质量相同的砝码，取走 $k$ 个，问最终杠杆仍然平衡的方案数。<br>$n\le 10^4, k\le 10$</p></div></article><p>整数划分问题。<br>容易发现两边是完全对称的，那么只需要考虑一边。考虑枚举取的数字和是多少，设 $f[i,k]$ 表示把数字 $i$ 拆分成 $k$ 个小于 $n$ 的不同数字的方案数，有转移：<br>$$ \begin{aligned}f[i,k]&amp;=f[i-k,k]+f[i-k,k-1]\newline f[i,k]&amp;=f[i,k]-f[i-n-1,k-1] \text{ }\text{ }| \text{ }\text{ }i\ge n + 1 \end{aligned}$$<br>复杂度 $O(nk^2)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - K + <span class="number">1</span>; i &lt;= n; i++) N += i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        f[i][k] = i &gt;= k ? (f[i - k][k] + f[i - k][k - <span class="number">1</span>]) % p : <span class="number">0</span>,</span><br><span class="line">        f[i][k] = i &gt; n ? (f[i][k] - f[i - n - <span class="number">1</span>][k - <span class="number">1</span>] + p) % p : f[i][k];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= N; w++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K; j++) ans = (<span class="number">1l</span>l * f[w][j] * f[w][K - j] % p + ans) % p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= N; w++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K - <span class="number">1</span>; j++) ans = (<span class="number">1l</span>l * f[w][j] * f[w][K - j - <span class="number">1</span>] % p + ans) % p;</span><br></pre></td></tr></table></figure><h3 id="12-Arrangement-Count"><a href="#12-Arrangement-Count" class="headerlink" title="12 Arrangement Count"></a>12 Arrangement Count</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>求有多少个排列 $A\subseteq [n]$，使得 $A$ 中每个位置与相邻位置的数的差不为 1。<br>$n\le 1000$</p></div></article><p>设 $f[i,j,0/1]$ 表示考虑 $A\subseteq [i]$，有 $j$ 对相邻位置相差为 1 ，$i$ 是否与 $i+1$ 相邻的方案数，有转移：</p><ol><li>$f[i,j,0]·j\to f[i+1,j-1,0]$</li><li>$f[i,j,0]·2\to f[i+1, j + 1, 1], f[i,j,1]·2\to f[i+1, j, 1]$</li><li>$f[i,j,0/1]·(i-j-1)\to f[i+1,j,0]$</li></ol><p>复杂度 $O(n^2)$。</p><h3 id="13-Cut-Tree"><a href="#13-Cut-Tree" class="headerlink" title="13 Cut Tree"></a>13 Cut Tree</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个节点的树，点有点权，要切两条边和加一个点使得形成的三个子树点权和相等，最小化新加节点点权的绝对值。<br>$n \le 10^5$</p></div></article><p>考虑固定一整棵树的根，对所有 $n$ 棵子树的大小统计其出现次数 $cnt[]$。不妨设当前的根处需要割断一条边，那么枚举其的枚举一个子树 $v$，设其大小为 $sz[v]$ ，则当 $cnt[sz[v]]&gt;1$ 时，可将整棵树切成三个部分：两个 $sz[v]$ 和一个 $n-sz[v]$ ，于是可以更新答案。</p><p>但是当前根处不一定会割断边，那么考虑换根。容易发现当根向某个儿子移动时，至多有两个节点的 $sz[]$ 值会发生变化，则简单维护即可。</p><p>于是可以做到不漏算答案，时间复杂度 $O(n)$。</p><h3 id="14-Number-Game"><a href="#14-Number-Game" class="headerlink" title="14 Number Game"></a>14 Number Game</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>Alice 和 Bob 又双叒叕在玩游戏。<br>Bob 每次会想一个 $0\text{~}n$ 的数，Alice 每次猜 $k$，Bob 告诉 Alice 大了还是小了。Alice 猜 $k$ 会付出 $a_k$ 的代价，Alice 要最小化代价，Bob 要最大化代价（并在不违反前面询问的情况下改数）。假设二人都绝顶聪明，求 Alice 最后付出多少代价。<br>$n \le 10^5, a_i\le 9$</p></div></article><p>本人只会 $O(n^3)$ 的辣鸡 DP……</p><p>设 $f[l,r]$ 为考虑区间 $[l,r]$ 的答案，应当有转移：<br>$$ f[l,r]=\min\limits_k a_k+ \max(f[l,k-1],f[k+1,r]) $$ 边界是 $f[i,i]=a_i$，直接大力 DP 即可做到 $O(n^3)$。</p><h3 id="15-Distributs"><a href="#15-Distributs" class="headerlink" title="15 Distributs"></a>15 Distributs</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>小 A 带来了 $m$ 种特产，第 $i$ 种特产的数量为 $a_i$。小 A 要把它们全部分给 $n$ 个同学，要求每个同学至少拿到一个特产，问有多少种分法，对 $10^9+7$ 取模。<br>$n,m \le 1000$</p></div></article><p>容斥简单题，钦点 $k$ 个人一定分不到，剩下的随便分，在总方案数中减去就好了，则答案是：<br>$$ \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k}\sum\limits_j \dbinom{a_j+n-k-1}{n-k-1}$$ 复杂度 $O(n^2)$。</p><h3 id="16-Solutions-of-the-Equation"><a href="#16-Solutions-of-the-Equation" class="headerlink" title="16 Solutions of the Equation"></a>16 Solutions of the Equation</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个变量 $x_1…x_n$，每个变量 $0&lt;x\le R$，给定 $S$，求方程 $x_1+x_2+…+x_n=S$有多少组正整数解。<br>$n \le 1000$</p></div></article><p>容斥简单题，如果不考虑限制答案是 $\dbinom{S-1}{n-1}$，然后钦点有 $k$ 个变量不合法然后去加加减减，答案是：<br>$$ \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k}\dbinom{S-kR-1}{n-1} $$ 复杂度 $O(n^2)$。</p><h3 id="17-Bohater"><a href="#17-Bohater" class="headerlink" title="17 Bohater"></a>17 Bohater</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>在一款电脑游戏中，你需要打败$n$只怪物（从 $1$ 到 $n$ 编号），初始生命值为 $z$。<br>为了打败第 $i$ 只怪物，你需要消耗 $d_i$ 点生命值，但怪物死后会掉落血药，使你恢复 $a_i$ 点生命值。<br>任何时候你的生命值都不能降到 0（或 0 以下）。请问是否存在一种打怪顺序，使得你可以打完这 $n$ 只怪物而不死掉。如果存在请输出方案，不存在输出NO。<br>$1≤n,z≤10^5，0≤d_i,a_i≤10^5$</p></div></article><p>考虑把怪分成两类，先打加血怪，再打减血怪；考虑打加血怪的过程：应当按 $d_i$ 升序去打。<br>减血怪呢？考虑打怪的反过程：不打一个怪，血量增加 $d_i$ 而减少 $a_i$。<br>则反过程应当按 $a_i$ 升序排，正过来就是按 $a_i$ 降序排。</p><p>复杂度 $O(n\log n)$。</p><h3 id="18-Swap-Space"><a href="#18-Swap-Space" class="headerlink" title="18 Swap Space"></a>18 Swap Space</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>你有许多电脑，它们的硬盘用不同的文件系统储存数据。你想要通过格式化来统一文件系统。格式化硬盘可能使它的容量从 $a_i$ 变成 $b_i$。<br>为了格式化，你需要买额外的硬盘。当然，你想要买容量最小的额外储存设备以便省钱。<br>你可以按任意顺序格式化硬盘。格式化之前，你要把该硬盘上所有数据移到一个或更多的其他硬盘上，数据可以分割。<br>格式化后，该硬盘可以立刻开始使用。你没有必要把数据放到它原来所在的硬盘上。数据也可以被放到你额外买的硬盘上。<br>求最小的额外储存设备容量。<br>$1≤n≤10^6,1≤a_i,b_i≤10^9$</p></div></article><p>考虑二分最终的答案 $M$ ，表示一开始购买的硬盘大小，则模型变为：</p><ul><li>给定一些元素 $(a,b)$ ，选择某个元素会付出代价 $a$ 得到收益 $b$ ，求能否选择所有元素。</li></ul><p>这就是上题模型，复杂度 $O(n\log^2n)$，看上去有点卡。</p><p>实际上二分大可不必，依然按照上题的思路去做，当代价和多于当前的承受限度时，把多出来的那一部分加到答案里即可，复杂度 $O(n\log n)$。</p><h3 id="19-Maximum-Value-of-Linear-Function"><a href="#19-Maximum-Value-of-Linear-Function" class="headerlink" title="19 Maximum Value of Linear Function"></a>19 Maximum Value of Linear Function</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>现在有 $n$ 个一次函数，$f_i(x)=a_ix+b_i$。给定 $x$，并且对于所有的 $f_i(x)$ 可以任意改变顺序嵌套函数，求 $f(f(f(…f(x))…)$ 的最大值。<br>$n\le 10^6$</p></div></article><p>容易发现 $x$ 的系数一定，那么只需要考虑常数项最大。<br>考虑交换，对二元组 $(a_1,b_1)$ 和 $(a_2,b_2)$ ，前者放在外层当且仅当 $a_1(a_2x+b_2)+b_1&gt;a_2(a_1x+b_1)+b_2$，移项得 $(a_1-1)/b_1&gt;(a_2-1)/b_2$，则按照 $(a_i-1)/b_i$ 降序排序，把靠前的放在外层即可。</p><p>这个题也可以类比一下<a href="https://www.luogu.com.cn/problem/P1080">「国王游戏」</a>那道题。考虑何时应该交换相邻的两个元素 $i,j$：当且仅当 $\Pi/b_i+(a_i·\Pi)/b_j &gt; \Pi/b_j+(a_j·\Pi)/b_i$，化简得 $(a_j-1)·b_j&lt;(a_i-1)·b_i$，因此按 $(a_i-1)·b_i$ 为关键字排序即可。</p><h3 id="20-Kuglarz"><a href="#20-Kuglarz" class="headerlink" title="20 Kuglarz"></a>20 Kuglarz</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个杯子排成一排，每个杯子中可能放有也可能没有一个小球。你每次可以花费 $C(i,j)$ 的代价得知区间 $[i,j]$ 的杯子中球的总数的奇偶性。<br>问最少花费多少代价才能求出每个杯子中是否有小球。<br>$n\le 1000$</p></div></article><p>看上去很像 DP，但我的做法假掉了……<br>建一张图，边 $(u,v)$ 的边权为 $C(u,v)$，则问题等价于求出图上的最小生成树。<br>时间复杂度 $O(n^2)$。</p><h3 id="21-OSU"><a href="#21-OSU" class="headerlink" title="21 OSU!"></a>21 OSU!</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。<br>求该 01 串的价值的期望。<br>$n\le 10^5$</p></div></article><p>考察期望的定义，和应用用贡献法计算每一位的价值期望。<br>设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：<br>$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：<br>$$ \begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \end{aligned}$$ 于是可以做到 $O(n)$。<br>注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l[i] = a[i] * (l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l2[i] = a[i] * (l2[i - <span class="number">1</span>] + <span class="number">2</span> * l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] + a[i] * (<span class="number">3</span> * l2[i - <span class="number">1</span>] + <span class="number">3</span> * l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，做题的关键在于口胡出解法，而我还是什么都不会……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>最小斯坦纳树</title>
    <link href="https://big-news.cn/2020/08/23/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    <id>https://big-news.cn/2020/08/23/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/</id>
    <published>2020-08-23T10:30:00.000Z</published>
    <updated>2020-08-31T11:11:16.837Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，斯坦纳树问题是一类特殊的生成树问题……</p><a id="more"></a><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。<br>再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G=(V,E)$，使得：</p><ol><li>$S\subseteq V$；</li><li>$G$ 为连通图；</li><li>$E$ 中所有边的权值和最小。</li></ol><p>你只需要求出 $E$ 中所有边的权值和。<br>$n\le 100, m\le 500, k\le 10$</p></div></article><p>上述问题被称作「最小斯坦纳树」问题。</p><p>设 $f[i,S]$ 表示当前在 $i$ ，$S$ 中的点已经连通的最小代价，则有转移：</p><p>$$ \begin{aligned} f[i,S] &amp;=\min f[i,S_0]+f[i,S\oplus S_0]\newline f[i,S] &amp;=\min f[j,S]+\text{sp}(i,j)   \end{aligned} $$</p><p>容易发现后一个转移是最短路的形式，考虑到不存在负权边，使用 Dijkstra 转移，复杂度 $O(2^k n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,w; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> d)</span> </span>&#123;to = t, nxt = n, w = d;&#125; &#125; E[CN * CN];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, key[CN], f[CN][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> id, v; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ &amp; a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;&#125;;</span><br><span class="line"><span class="function">DJ <span class="title">make</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;DJ c; c.id = a, c.v = b; <span class="keyword">return</span> c;&#125;</span><br><span class="line">priority_queue&lt;DJ&gt; Q; <span class="keyword">bool</span> vis[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sp</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(f[i][S] &lt; INF) Q.push( make(i, f[i][S]) );</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.top().id; Q.pop();</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[v][S] &gt; f[u][S] + E[k].w)&#123;</span><br><span class="line">                f[v][S] = f[u][S] + E[k].w;</span><br><span class="line">                Q.push( make(v, f[v][S]) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read(), k = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) key[i] = read();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) f[ key[i] ][ <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>) ] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); S++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> V = S; V; V = (V - <span class="number">1</span>) &amp; S)</span><br><span class="line">                f[i][S] = min(f[i][S], f[i][V] + f[i][S ^ V]);</span><br><span class="line">        sp(S);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = min(ans, f[i][(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，斯坦纳树问题是一类特殊的生成树问题……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="斯坦纳树" scheme="https://big-news.cn/tags/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
      <category term="状压DP" scheme="https://big-news.cn/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」牛客小白月赛 27</title>
    <link href="https://big-news.cn/2020/08/22/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B%2027/"/>
    <id>https://big-news.cn/2020/08/22/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B%2027/</id>
    <published>2020-08-22T12:29:00.000Z</published>
    <updated>2020-08-22T14:37:27.394Z</updated>
    
    <content type="html"><![CDATA[<p>又是签到走人的一天……</p><a id="more"></a><p><a href="https://ac.nowcoder.com/acm/contest/6874">比赛链接</a></p><h3 id="A-巨木之森"><a href="#A-巨木之森" class="headerlink" title="A 巨木之森"></a>A 巨木之森</h3><p>签到题，对每个点维护一个到叶子的最长距离，随便怎么搞搞就行了。本人脑子笨，写了个线段树，复杂度 $O(n\log n)$，实际上有严格 $O(n)$ 解法。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,d; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> dd)</span> </span>&#123;to = t, nxt = n, d = dd;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN &lt;&lt; <span class="number">2</span>], tag[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        d[lc] += tag[k], d[rc] += tag[k], tag[lc] += tag[k], tag[rc] += tag[k], tag[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> (<span class="keyword">void</span>)(tag[k] += x, d[k] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(tag[k]) pd(l, r, k);</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) md(l, m, lc, s, t, x); <span class="keyword">if</span>(m &lt; t) md(m + <span class="number">1</span>, r, rc, s, t, x);</span><br><span class="line">        d[k] = max(d[lc], d[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(tag[k]) pd(l, r, k);</span><br><span class="line">        upd(l, m, lc), upd(m + <span class="number">1</span>, r, rc); d[k] = max(d[lc], d[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> d[<span class="number">1</span>];&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sum = <span class="number">0</span>, d[CN], id[CN], sz[CN], idx = <span class="number">0</span>, mxd[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    id[u] = ++idx, sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) d[v] = d[u] + E[k].d, bd(v, u), sz[u] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    mxd[u] = D.qu();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p)&#123;</span><br><span class="line">            D.md(<span class="number">1</span>, n, <span class="number">1</span>, <span class="number">1</span>, n, E[k].d), D.md(<span class="number">1</span>, n, <span class="number">1</span>, id[v], id[v] + sz[v] - <span class="number">1</span>, <span class="number">-2l</span>l * E[k].d);</span><br><span class="line">            dfs(v, u);</span><br><span class="line">            D.md(<span class="number">1</span>, n, <span class="number">1</span>, <span class="number">1</span>, n, -E[k].d), D.md(<span class="number">1</span>, n, <span class="number">1</span>, id[v], id[v] + sz[v] - <span class="number">1</span>, <span class="number">2l</span>l * E[k].d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w), sum += w;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">2l</span>l * sum;</span><br><span class="line"></span><br><span class="line">    bd(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.md(<span class="number">1</span>, n, <span class="number">1</span>, id[i], id[i], d[i]);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mxd[i] = sum - mxd[i];</span><br><span class="line">    sort(mxd + <span class="number">1</span>, mxd + n + <span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n &amp;&amp; sum + mxd[p] &lt;= m) sum += mxd[p++], ans++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-乐团派对"><a href="#B-乐团派对" class="headerlink" title="B 乐团派对"></a>B 乐团派对</h3><p>考察快速排序以及输入输出。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;a[i] = read(); <span class="keyword">if</span>(a[i] &gt; n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;&#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp); </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n) &#123;<span class="keyword">if</span>(p + a[p] &lt;= n + <span class="number">1</span>) ans++, p += a[p]; <span class="keyword">else</span> p++;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-巅峰对决"><a href="#D-巅峰对决" class="headerlink" title="D 巅峰对决"></a>D 巅峰对决</h3><p>线段树板子题。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> !b ? a : gcd(b, a % b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN &lt;&lt; <span class="number">2</span>], mx[CN &lt;&lt; <span class="number">2</span>], mn[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(mx[k] = mn[k] = d[k] = a[l]);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; bd(l, m, lc, a), bd(m + <span class="number">1</span>, r, rc, a);</span><br><span class="line">        d[k] = gcd(d[lc], d[rc]), mx[k] = max(mx[lc], mx[rc]), mn[k] = min(mn[lc], mn[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(mx[k] = mn[k] = d[k] = x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(p &lt;= m) md(l, m, lc, p, x); <span class="keyword">else</span> md(m + <span class="number">1</span>, r, rc, p, x);</span><br><span class="line">        d[k] = gcd(d[lc], d[rc]), mx[k] = max(mx[lc], mx[rc]), mn[k] = min(mn[lc], mn[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> d[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = gcd(qu(l, m, lc, s, t), ans);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = gcd(qu(m + <span class="number">1</span>, r, rc, s, t), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> mx[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = max(qum(l, m, lc, s, t), ans);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = max(qum(m + <span class="number">1</span>, r, rc, s, t), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qun</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> mn[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = INF;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = min(qun(l, m, lc, s, t), ans);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = min(qun(m + <span class="number">1</span>, r, rc, s, t), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> MX = D.qum(<span class="number">1</span>, n, <span class="number">1</span>, s, t), MN = D.qun(<span class="number">1</span>, n, <span class="number">1</span>, s, t);</span><br><span class="line">    <span class="keyword">if</span>((MX - MN) ^ (t - s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> G = D.qu(<span class="number">1</span>, n, <span class="number">1</span>, s, t);</span><br><span class="line">    <span class="keyword">return</span> G ^ <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    D.bd(<span class="number">1</span>, n, <span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op = read(), x = read(), y = read();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) D.md(<span class="number">1</span>, n, <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">else</span> ck(x, y) ? <span class="built_in">puts</span>(<span class="string">"YES"</span>) : <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-核弹剑仙"><a href="#F-核弹剑仙" class="headerlink" title="F 核弹剑仙"></a>F 核弹剑仙</h3><p>傻题。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, f[CN]; <span class="keyword">bool</span> vis[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(!vis[v]) dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dfs(u); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(vis[i]) ans++;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read(); add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt(i)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是签到走人的一天……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://big-news.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>「题解」Emiya家今天的饭</title>
    <link href="https://big-news.cn/2020/08/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DEmiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/"/>
    <id>https://big-news.cn/2020/08/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DEmiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/</id>
    <published>2020-08-21T11:07:00.000Z</published>
    <updated>2020-08-21T13:33:49.332Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，小葱同学擅长计算几何，但是并不擅长 DP。</p><a id="more"></a><ul><li>$m = 2/3$</li></ul><p>设 $f[i,j,k]$ 表示考虑前 $i$ 行，第一列选了 $j$ 个，第二列选了 $k$ 个的方案数之和，有转移：$$f[i,j,k]\gets f[i-1,j-1,k]·a[i,1]+f[i-1,j,k-1]·a[i,2]$$ $m = 3$ 的情况也同理，多开一维状态就好了，复杂度 $O(n^3)$ 或 $O(n^4)$，能拿到 64pts。</p><ul><li>$m\le 500$</li></ul><p>根据 lorem ipsum 原理，不合法方案中至多有一列的选择数超过 $\lfloor k/2 \rfloor$ ，则考虑补集转化，把不合法的方案 DP 出来。<br>钦点第 $u$ 行不合法，设 $f[i,j,k]$ 表示考虑前 $i$ 行，其它行一共选 $j$ 个， $u$ 行选了 $k$ 个的方案数，有转移：<br>$$ f[i,j,k]\gets f[i-1,j,k]+f[i,j,k-1]·a[i,u]+\sum\limits_{v\neq u} f[i,j-1,k]·a[i,v] $$ 预处理前缀和即可 $O(1)$ 转移，复杂度 $O(mn^3)$，能拿到 84pts。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="number">1l</span>l * ans * (a[i][<span class="number">0</span>] + <span class="number">1</span>) % P; ans = (ans + P - <span class="number">1</span>) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= m; u++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(k) f[i][j][k] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][j][k - <span class="number">1</span>] * a[i][u] % P + f[i][j][k]) % P;</span><br><span class="line">                <span class="keyword">if</span>(j) f[i][j][k] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] * (a[i][<span class="number">0</span>] - a[i][u] + P) % P + f[i][j][k]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = (j + k) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(k &lt;= s) <span class="keyword">continue</span>;</span><br><span class="line">            ans = (ans - f[n][j][k] + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$n\le 100, m \le 2000$</li></ul><p>考虑削状态，设 $f[i,l]$ 表示考虑前 $i$ 行，$n+k-j=l$ 时的方案数，有转移：<br>$$ f[i,l]\gets f[i-1,l]+f[i-1,l+1]·a[i,u]+\sum\limits_{u\neq v}f[i-1,l-1]·a[i,v] $$ 预处理前缀和即可 $O(1)$ 转移，复杂度 $O(mn^2)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="number">1l</span>l * ans * (a[i][<span class="number">0</span>] + <span class="number">1</span>) % P; ans = (ans + P - <span class="number">1</span>) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= m; u++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= (n &lt;&lt; <span class="number">1</span>); l++)&#123;</span><br><span class="line">            f[i][l] = f[i - <span class="number">1</span>][l];</span><br><span class="line">            f[i][l] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][l + <span class="number">1</span>] * a[i][u] + f[i][l]) % P;</span><br><span class="line">            <span class="keyword">if</span>(l) f[i][l] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][l - <span class="number">1</span>] * (a[i][<span class="number">0</span>] - a[i][u] + P) % P + f[i][l]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) ans = (ans - f[n][l] + P) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，小葱同学擅长计算几何，但是并不擅长 DP。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>01-Trie</title>
    <link href="https://big-news.cn/2020/08/18/01-Trie/"/>
    <id>https://big-news.cn/2020/08/18/01-Trie/</id>
    <published>2020-08-18T05:32:00.000Z</published>
    <updated>2020-09-01T08:21:53.577Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，01-Trie 是字符集为 $\begin{Bmatrix}0,1\end{Bmatrix}$ 的 Trie ，可用于维护若干数字的二进制位，处理点对异或最值、某种动态异或和问题。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>与线性基不同，01-Trie 无法处理子集异或问题，但是可以通过前缀和转化来处理区间异或问题。</div></article><a id="more"></a><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>01-Trie 支持在 $O(\log a_i)$ 的时间内完成如下操作：</p><ul><li>查询全局异或和</li><li>数列全局加一，维护全局异或和</li><li>查询数列中某个数与指定数字异或的最大值</li><li>合并两棵 01-Trie 维护的信息</li></ul><p>通过将其可持久化，还可以支持如下操作：</p><ul><li>查询区间异或和</li><li>查询区间中某个数与指定数字异或的最大值</li></ul><p>通过观察容易实现上述若干操作，则可以得到这样一份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 非可持久化 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TRIE</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> ch[CN * <span class="number">30</span>][<span class="number">2</span>], d[CN * <span class="number">30</span>], w[CN * <span class="number">30</span>], idx, rt, MAXH;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    TRIE() &#123;rt = idx = <span class="number">0</span>, MAXH = <span class="number">30</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mt</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        d[u] = <span class="number">0</span>, w[u] = w[lc] + w[rc];</span><br><span class="line">        <span class="keyword">if</span>(rc) d[u] ^= (d[rc] &lt;&lt; <span class="number">1</span>) | (w[rc] &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lc) d[u] ^= d[lc] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        w[u] &amp;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span></span>&#123;                      <span class="comment">// 插入一个数</span></span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(dep == MAXH) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[u] ^= <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ins(rc, x &gt;&gt; <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ins(lc, x &gt;&gt; <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">        mt(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">if</span>(rc) add(rc); swap(lc, rc), mt(u);&#125; <span class="comment">// 全局加一</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> d[rt];&#125;                              <span class="comment">// 全局异或和</span></span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><p>注意，01-Trie 的可持久化看上去并不支持版本修改，因为无法使用树状数组维护子树交换信息。</p><h3 id="2-一道栗题"><a href="#2-一道栗题" class="headerlink" title="2 一道栗题"></a>2 一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「TJOI2017」异或和</strong></p><p>给定一段数列，定义数列的“连续和”为数列的某个子串的所有数之和，求序列所有连续和的异或值。</p></div></article><p>考虑固定左端点 $l$ ，$O(n)$ 枚举右端点 $r$ ，则可以求出一些左端点固定的区间 $[l,r]$ 权值和异或和。</p><p>考虑优化这个过程：对于一个左端点 $l$ ，如何快速求出其能对应的所有区间 $[l,r]$ 的异或和。由于数列是静态的，那么我们考虑 $l\to l-1$ 时贡献的变化，它应该是这个样子：</p><p>$$\begin{aligned} &amp; (s[n]-s[l])\oplus (s[n-1]-s[l])\oplus … \oplus (s[l+1]-s[l]) \newline \to &amp;(s[n]-s[l]+a[l-1])\oplus (s[n-1]-s[l]+a[l-1])\oplus …\oplus a[l-1] \end{aligned}$$</p><p>其中 $s[]$ 代表 $a[]$ 的前缀和。容易发现这个变化是对每一项同时加了一个值之后再查询异或和，显然可以通过 01-Tire 来维护，总复杂度 $O((n+\sum a_i)\log a_i)$；由于 $\sum a_i \le 10^6$，所以可以通过。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123; <span class="comment">/* 略 */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TRIE</span> &#123;</span> <span class="comment">/* 同上 */</span> &#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i + <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(s--) D.add( D.rt );</span><br><span class="line">        D.ins(D.rt, a[i + <span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        ans ^= D.sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-又一道栗题"><a href="#3-又一道栗题" class="headerlink" title="3 又一道栗题"></a>3 又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「TJOI2018」异或</strong></p><p>现在有一颗以 $1$ 为根节点的由 $n$ 个节点组成的树，节点从 $1$ 至 $n$ 编号。树上每个节点上都有一个权值 $v_i$。现在有 $q$ 次操作，操作如下：</p><ul><li>1 x z：查询节点 $x$ 的子树中的节点权值与 $z$ 异或结果的最大值。</li><li>2 x y z：查询节点 $x$ 到节点 $y$ 的简单路径上的节点的权值与 $z$ 异或结果最大值。</div></article></li></ul><p>容易想到树剖，则转化为序列上的查询操作。通过版本来区分区间，即将 01-Tire 可持久化，即可解决本题。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>可持久化 01-Trie 一般用于处理静态区间异或最大值问题。</div></article><p>容易得到如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TRIE</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> rt[CN], ch[CN * <span class="number">30</span>][<span class="number">2</span>], w[CN * <span class="number">30</span>], MAXH, idx;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    TRIE() &#123;idx = <span class="number">0</span>, MAXH = <span class="number">31</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(dep &lt; <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[u] = w[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> b = (x &gt;&gt; dep) &amp; <span class="number">1</span>; ch[u][!b] = ch[v][!b];</span><br><span class="line">        ins(ch[u][b], ch[v][b], x, dep - <span class="number">1</span>);</span><br><span class="line">        w[u] = w[lc] + w[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qm</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> k, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = (k &gt;&gt; dep) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(w[ ch[u][!b] ] &gt; w[ ch[v][!b] ]) <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; dep) | qm(ch[u][!b], ch[v][!b], k, dep - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qm(ch[u][b], ch[v][b], k, dep - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, v[CN], oid[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> top[CN], id[CN], sz[CN], imp[CN], dep[CN], fa[CN], idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[p] + <span class="number">1</span>, sz[u] = <span class="number">1</span>, fa[u] = p; <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs1(v, u), sz[u] += sz[v], mx = sz[v] &gt; mx ? imp[u] = v, sz[v] : mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    top[u] = t, id[u] = ++idx;</span><br><span class="line">    <span class="keyword">if</span>(imp[u]) dfs2(imp[u], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ imp[u] &amp;&amp; v ^ fa[u]) dfs2(v, v); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[ top[x] ] &lt; dep[ top[y] ]) swap(x, y);</span><br><span class="line">        ans = max(ans, D.qm(D.rt[ id[x] ], D.rt[ id[ top[x] ] - <span class="number">1</span> ], z, D.MAXH));</span><br><span class="line">        x = fa[ top[x] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    ans = max(ans ,D.qm(D.rt[ id[x] ], D.rt[ id[y] - <span class="number">1</span> ], z, D.MAXH));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> id[x] &lt; id[y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = read(), oid[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"></span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    sort(oid + <span class="number">1</span>, oid + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.ins(D.rt[i], D.rt[i - <span class="number">1</span>], v[ oid[i] ], D.MAXH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> o = read(), x = read(), y = read(), z;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.qm(D.rt[ id[x] + sz[x] - <span class="number">1</span> ], D.rt[ id[x] - <span class="number">1</span> ], y, D.MAXH)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> z = read(), <span class="built_in">printf</span>(<span class="string">"%d"</span>, qu(x, y, z)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-双一道栗题"><a href="#4-双一道栗题" class="headerlink" title="4 双一道栗题"></a>4 双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「联合省选 2020 A」树</strong></p><p>给定一棵 $n$ 个结点的有根树 $T$，结点从 $1$ 开始编号，根结点为 $1$ 号结点，每个结点有一个正整数权值 $v_i$。<br>设 $x$ 号结点的子树内（包含 $x$ 自身）的所有结点编号为 $c_1,c_2,\dots,c_k$，定义 $x$ 的价值为：<br>$$val(x)=(v_{c_1}+d(c_1,x)) \oplus (v_{c_2}+d(c_2,x)) \oplus \cdots \oplus (v_{c_k}+d(c_k, x))$$<br>其中 $d(x,y)$ 表示树上 $x$ 号结点与 $y$ 号结点间唯一简单路径所包含的边数，$d(x,x) = 0$。$\oplus$ 表示异或运算。<br>请你求出 $\sum\limits_{i=1}^n val(i)$ 的结果。</p></div></article><p>对每个叶子建立一棵 01-Trie ，然后每次合起来再全局加一即可得到父亲的 01-Trie ，统计答案即可。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>01-Trie 合并的序列意义是：把两段序列的所有数字插入同一个 01-Trie ，并维护异或和。</div></article><p>容易得到如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125;&#125;E[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN],ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">trie</span>&#123;</span> <span class="comment">// dep = 0,dep &gt; 20</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> ch[CN * <span class="number">30</span>][<span class="number">2</span>], w[CN * <span class="number">30</span>], val[CN * <span class="number">30</span>], rt[CN], tot;</span><br><span class="line">    trie() &#123;<span class="built_in">memset</span>(rt, <span class="number">0</span>, <span class="keyword">sizeof</span>(rt)); tot = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> u = ++tot; lc = rc = w[u] = val[u] = <span class="number">0</span>; <span class="keyword">return</span> tot;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        w[u] = val[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(lc) w[u] += w[lc], val[u] ^= val[lc] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(rc) w[u] += w[rc], val[u] ^= (val[rc] &lt;&lt; <span class="number">1</span>) | w[rc];</span><br><span class="line">        w[u] &amp;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> x,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(dep &gt; <span class="number">20</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[u] ^= <span class="number">1</span>);</span><br><span class="line">        ins(ch[u][x &amp; <span class="number">1</span>], x &gt;&gt; <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">        maintain(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addall</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">if</span>(rc) addall(rc); swap(lc, rc); maintain(u);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k) <span class="keyword">return</span> u; <span class="keyword">if</span>(!u) <span class="keyword">return</span> k;</span><br><span class="line">        w[u] = (w[u] + w[k]) &amp; <span class="number">1</span>; val[u] ^= val[k];</span><br><span class="line">        lc = merge(lc, ch[k][<span class="number">0</span>]); rc = merge(rc, ch[k][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,v[CN],va[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!hd[u])&#123;</span><br><span class="line">        va[u] = v[u];</span><br><span class="line">        D.ins(D.rt[u], v[u], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = hd[u], s1;</span><br><span class="line">    <span class="keyword">for</span>(; k; k = E[k].nxt) dfs(E[k].to);</span><br><span class="line">    </span><br><span class="line">    k = hd[u], s1 = E[k].to, k = E[k].nxt, D.rt[u] = D.rt[s1];</span><br><span class="line">    <span class="keyword">for</span>(; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        D.merge(D.rt[u], D.rt[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    D.addall(D.rt[u]), D.ins(D.rt[u], v[u], <span class="number">0</span>);</span><br><span class="line">    va[u] = D.val[ D.rt[u] ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) v[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) add(read(), i);</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans += <span class="number">1l</span>l * va[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，01-Trie 是字符集为 $\begin{Bmatrix}0,1\end{Bmatrix}$ 的 Trie ，可用于维护若干数字的二进制位，处理点对异或最值、某种动态异或和问题。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-primary&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-lightbulb mr-2&quot;&gt;&lt;/i&gt;
与线性基不同，01-Trie 无法处理子集异或问题，但是可以通过前缀和转化来处理区间异或问题。
&lt;/div&gt;
&lt;/article&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字典树" scheme="https://big-news.cn/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>主席树</title>
    <link href="https://big-news.cn/2020/08/17/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>https://big-news.cn/2020/08/17/%E4%B8%BB%E5%B8%AD%E6%A0%91/</id>
    <published>2020-08-17T00:47:00.000Z</published>
    <updated>2020-08-26T08:42:42.419Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，主席树即可持久化值域线段树， 用于解决区间 $k$ 小值问题以及动态二维数点问题。</p><a id="more"></a><h3 id="1-静态主席树"><a href="#1-静态主席树" class="headerlink" title="1 静态主席树"></a>1 静态主席树</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>静态区间 k 小值</strong></p><p>给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。</p></div></article><p>静态主席树一般指可持久化值域线段树，并不支持修改操作。</p><p>容易发现区间信息是满足可减性的，则只需要在每次插入时建立一个船新版本即可，查询也只需要对两个历史版本作差便能得到区间信息。<br>类似的，01-Trie 与 Treap 之类的无法维护区间信息的数据结构也可以通过可持久化来实现区间信息的维护。</p><p>容易得出下面的这份代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] = d[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, ch[v][<span class="number">0</span>], l, m, p), rc = ch[v][<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">else</span> md(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p), lc = ch[v][<span class="number">0</span>];</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = d[lc] - d[ ch[v][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= k) <span class="keyword">return</span> qu(lc, ch[v][<span class="number">0</span>], l, m, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qu(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, k - s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = a[i] = read();</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + n + <span class="number">1</span>);</span><br><span class="line">    val[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[ ++val[<span class="number">0</span>] ] = val[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.md(D.rt[i], D.rt[i - <span class="number">1</span>], <span class="number">1</span>, val[<span class="number">0</span>], id( a[i] ));</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), k = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, val[ D.qu( D.rt[r], D.rt[l - <span class="number">1</span>], <span class="number">1</span>, val[<span class="number">0</span>], k ) ]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-带修主席树"><a href="#2-带修主席树" class="headerlink" title="2 带修主席树"></a>2 带修主席树</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>动态区间 k 小值</strong></p><p>给定一个含有 $n$ 个数的序列 $a_1, a_2, …, a_n$ ，需要支持两种操作：</p><ul><li>Q l r k 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数</li><li>C x y 表示将 $a_x$ 改为 $y$</div></article></li></ul><p>带修主席树一般指树状数组套可持久化值域线段树。</p><p>容易发现主席树的每个版本是对区间信息做一个前缀和，这样如果在某个版本上修改是 $O(n)$ 的。<br>既然是前缀和，套用树状数组的方式写主席树就好了，复杂度 $O(n\log^2n)$ 。</p><p>于是容易得到下面的这份代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], rt[CN], idx, n;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 修改不新建版本</span></span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, l, m, p, x); <span class="keyword">else</span> md(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 修改 BIT 中所有的树</span></span><br><span class="line">        <span class="keyword">while</span>(u &lt;= rt[<span class="number">0</span>]) md(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t1[<span class="number">101</span>], t2[<span class="number">101</span>]; <span class="comment">// 把 O(log) 棵主席树的根搞下来</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qu_pre</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="comment">// (l, r]</span></span><br><span class="line">        t1[<span class="number">0</span>] = t2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = l; <span class="keyword">while</span>(u) t1[ ++t1[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">        u = r; <span class="keyword">while</span>(u) t2[ ++t2[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) s -= d[ ch[ t1[i] ][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) s += d[ ch[ t2[i] ][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(l, m, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(m + <span class="number">1</span>, r, k - s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QUERY</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> tp, a, b, c;</span><br><span class="line">&#125; Q[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    D.rt[<span class="number">0</span>] = n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[ ++val[<span class="number">0</span>] ] = a[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c; <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'Q'</span>) Q[i].tp = <span class="number">0</span>, Q[i].a = read(), Q[i].b = read(), Q[i].c = read();</span><br><span class="line">        <span class="keyword">else</span> Q[i].tp = <span class="number">1</span>, Q[i].a = read(), val[ ++val[<span class="number">0</span>] ] = Q[i].b = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[ ++cnt ] = val[i];</span><br><span class="line">    D.n = val[<span class="number">0</span>] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.cg(i, id( a[i] ), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Q[i].tp)&#123;</span><br><span class="line">            D.qu_pre(Q[i].a - <span class="number">1</span>, Q[i].b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, val[ D.qu(<span class="number">1</span>, val[<span class="number">0</span>], Q[i].c) ]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            D.cg(Q[i].a, id( a[ Q[i].a ] ), <span class="number">-1</span>), a[ Q[i].a ] = Q[i].b, D.cg(Q[i].a, id( a[ Q[i].a ] ), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，导致其常数巨大，不过它依然能在 1s 左右的时间内通过此题。</p><h3 id="3-一道栗题"><a href="#3-一道栗题" class="headerlink" title="3 一道栗题"></a>3 一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「CQOI2011」动态逆序对</strong></p><p>给出 $1\sim n$ 的一个排列，按照某种顺序依次删除 $m$ 个元素，在每次删除一个元素之前统计整个序列的逆序对数。</p></div></article><p>如果是静态问题，那么只需要用权值树状数组就可以简单维护。</p><p>由于只有删除操作，考虑计算删除一个元素对答案的贡献（实际上是减少量而不是增加量），容易发现这样的查询同时存在下标和权值两个维度；下标即通过版本来区分，因此用主席树。考虑到修改和影响传递的过程，仿照上题套一个树状数组即可。</p><p>于是容易得到如下代码。同样的，由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，其常数巨大，不过它依然能在 1.2s 左右的时间内通过此题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx, n;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, l, m, p, x); <span class="keyword">else</span> md(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(u &lt;= rt[<span class="number">0</span>]) md(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t[CN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pqu</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = r; <span class="keyword">while</span>(u) t[ ++t[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) s += d[ t[i] ];</span><br><span class="line">            <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) t[i] = ch[ t[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(l, m, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) s += d[ ch[ t[i] ][<span class="number">0</span>] ];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) t[i] = ch[ t[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> s + qu(m + <span class="number">1</span>, r, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN], rk[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = a[i] = read(), rk[ a[i] ] = i;</span><br><span class="line">    D.rt[<span class="number">0</span>] = D.n = n;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        D.cg(i, a[i], <span class="number">1</span>), D.pqu(i - <span class="number">1</span>), ans -= D.qu(<span class="number">1</span>, n, a[i]), D.pqu(i - <span class="number">1</span>), ans += D.qu(<span class="number">1</span>, n, n);</span><br><span class="line"></span><br><span class="line">    m -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> x = read(), p = rk[x], s1, s2;</span><br><span class="line">        D.cg(p, x, <span class="number">-1</span>);</span><br><span class="line">        D.pqu(p - <span class="number">1</span>), s2 = D.qu(<span class="number">1</span>, n, x);</span><br><span class="line">        D.pqu(p - <span class="number">1</span>), s1 = D.qu(<span class="number">1</span>, n, n) - s2;</span><br><span class="line">        D.pqu(n), s2 = D.qu(<span class="number">1</span>, n, x) - s2;</span><br><span class="line">        ans -= s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-二维数点"><a href="#4-二维数点" class="headerlink" title="4 二维数点"></a>4 二维数点</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「SHOI2007」园丁的烦恼</strong></p><p>维护二维坐标系上的 $n$ 个点，$q$ 次查询矩形 $(a,b):(c,d)$ 内的点的个数。</p></div></article><p>二维数点是一类宽泛的 RMQ 问题，甚至于许多树上问题都能通过 dfs 序转化成二维数点问题。</p><p>众所周知，带修主席树可以用来解决动态二维数点问题，其本质与上面的题目类似。对于静态的二维数点，带修主席树 $O(n\log^2n)$ 的复杂度要比 $O(n\log n)$ 的树状数组解法要劣，可通过实现一个版本修改函数来避免带修。具体实现也较为简单，因此不再赘述。</p><p>这里给出一份带修主席树解决静态二维数点的代码，使用时需注意常数因子对程序效率带来的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], rt[CN], idx, n, m;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pmd</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(p &lt;= m) pmd(lc, l, m, p, x); <span class="keyword">else</span> pmd(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(u &lt;= m) pmd(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);&#125;</span><br><span class="line">    <span class="keyword">int</span> t1[<span class="number">25</span>], t2[<span class="number">25</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pqu</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = s; t1[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">while</span>(u) t1[ ++t1[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">        u = t; t2[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">while</span>(u) t2[ ++t2[<span class="number">0</span>] ] = rt[u], u -= lb(u); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) ans += d[ t2[i] ];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) ans -= d[ t1[i] ];</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>, tmp1[<span class="number">25</span>], tmp2[<span class="number">25</span>];</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m &lt; t) <span class="built_in">memcpy</span>(tmp1, t1, <span class="keyword">sizeof</span>(t1)), <span class="built_in">memcpy</span>(tmp2, t2, <span class="keyword">sizeof</span>(t2));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">0</span>];</span><br><span class="line">            ans += qu(l, m, s, t);</span><br><span class="line">            <span class="keyword">if</span>(m &lt; t) <span class="built_in">memcpy</span>(t1, tmp1, <span class="keyword">sizeof</span>(tmp1)), <span class="built_in">memcpy</span>(t2, tmp2, <span class="keyword">sizeof</span>(tmp2));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(m &lt; t)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">1</span>];</span><br><span class="line">            ans += qu(m + <span class="number">1</span>, r, s, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, vX[CN], vY[CN], X[CN], Y[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(vX + <span class="number">1</span>, vX + vX[<span class="number">0</span>] + <span class="number">1</span>, x) - vX;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idy</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(vY + <span class="number">1</span>, vY + vY[<span class="number">0</span>] + <span class="number">1</span>, x) - vY;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QU</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> a, b, c, d;&#125; q[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vX[i] = X[i] = read() + <span class="number">1</span>, vY[i] = Y[i] = read() + <span class="number">1</span>; vX[<span class="number">0</span>] = vY[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) vX[ ++vX[<span class="number">0</span>] ] = q[i].a = read() + <span class="number">1</span>, vY[ ++vY[<span class="number">0</span>] ] = q[i].b = read() + <span class="number">1</span>, vX[ ++vX[<span class="number">0</span>] ] = q[i].c = read() + <span class="number">1</span>, vY[ ++vY[<span class="number">0</span>] ] = q[i].d = read() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sort(vX + <span class="number">1</span>, vX + vX[<span class="number">0</span>] + <span class="number">1</span>), sort(vY + <span class="number">1</span>, vY + vY[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= vX[<span class="number">0</span>]; i++) <span class="keyword">if</span>(vX[i] ^ vX[i - <span class="number">1</span>]) vX[++tmp] = vX[i]; vX[<span class="number">0</span>] = tmp;</span><br><span class="line">    tmp = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= vY[<span class="number">0</span>]; i++) <span class="keyword">if</span>(vY[i] ^ vY[i - <span class="number">1</span>]) vY[++tmp] = vY[i]; vY[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    D.n = vY[<span class="number">0</span>], D.m = vX[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.md( idx( X[i] ), idy( Y[i] ), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = q[i].a, b = q[i].b, c = q[i].c, d = q[i].d;</span><br><span class="line">        D.pqu(idx(a) - <span class="number">1</span>, idx(c)), <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.qu(<span class="number">1</span>, D.n, idy(b), idy(d))), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-clock mr-2"></i>最近更新：2020-8-26 添加了二维数点的内容。</div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，主席树即可持久化值域线段树， 用于解决区间 $k$ 小值问题以及动态二维数点问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://big-news.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="https://big-news.cn/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="可持久化" scheme="https://big-news.cn/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
</feed>
