<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://big-news.cn/"/>
  <updated>2020-09-09T06:02:45.420Z</updated>
  <id>https://big-news.cn/</id>
  
  <author>
    <name>big-news</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「解题报告」Codeforces Round 669 (Div. 2)</title>
    <link href="https://big-news.cn/2020/09/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20669%20(Div.%202)/"/>
    <id>https://big-news.cn/2020/09/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20669%20(Div.%202)/</id>
    <published>2020-09-09T03:51:00.000Z</published>
    <updated>2020-09-09T06:02:45.420Z</updated>
    
    <content type="html"><![CDATA[<p>蒟蒻下分场……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1407">比赛链接</a></p><h3 id="A-Ahahahahahahahaha"><a href="#A-Ahahahahahahahaha" class="headerlink" title="A. Ahahahahahahahaha"></a>A. Ahahahahahahahaha</h3><p>注意到 01 串一定有 $\ge n/2$ 个 0 或者 1，依此构造即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), c += (a[i] == <span class="number">0</span>);</span><br><span class="line">n /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"0 "</span>);<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!c)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, n &lt;&lt; <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);  <span class="built_in">puts</span>(<span class="string">""</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, n + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);  <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c &gt;= n)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Big-Vova"><a href="#B-Big-Vova" class="headerlink" title="B. Big Vova"></a>B. Big Vova</h3><p>$O(n^2)$ 贪心即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) usd[i] = <span class="number">0</span>;</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(usd[j]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(mx == <span class="number">0</span>) mx = j;</span><br><span class="line">        <span class="keyword">if</span>(gcd(lst, a[mx]) &lt; gcd(lst, a[j])) mx = j;</span><br><span class="line">    &#125;</span><br><span class="line">    usd[mx] = <span class="number">1</span>, b[i] = a[mx];</span><br><span class="line">    lst = gcd(lst, a[mx]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="C-Chocolate-Bunny"><a href="#C-Chocolate-Bunny" class="headerlink" title="C. Chocolate Bunny"></a>C. Chocolate Bunny</h3><p>连续询问 $x,y$ 和 $y, x$，得到 $a,b$，则有 $\max(a,b)=\min(p_x,p_y)$，依此模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = read(); <span class="keyword">int</span> lst = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? %d %d\n"</span>, lst, i); fflush(<span class="built_in">stdout</span>); </span><br><span class="line">    x = read();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? %d %d\n"</span>, i, lst); fflush(<span class="built_in">stdout</span>); </span><br><span class="line">    y = read(), z = max(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y) a[i] = z ;</span><br><span class="line">    <span class="keyword">else</span> a[lst] = z, lst = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vis[ a[i] ]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!vis[i]) &#123;a[lst] = i; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"! "</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]); fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure><h3 id="D-Discrete-Centrifugal-Jumps"><a href="#D-Discrete-Centrifugal-Jumps" class="headerlink" title="D. Discrete Centrifugal Jumps"></a>D. Discrete Centrifugal Jumps</h3><p>理性分析一下，边数看上去不是 $O(n^2)$ 的而是 $O(n)$ 的，那么可以线性地把图建出来，单调栈维护一下即可。<br>但是这个题并不需要最短路算法，注意到这是一个 DAG，因此直接 DP 计算即可，时间复杂度 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">stk1[++top1] = <span class="number">1</span>, stk2[++top2] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(top1 &amp;&amp; a[ stk1[top1] ] &lt; a[i])&#123;</span><br><span class="line">        f[i] = min(f[i], f[ stk1[top1] ]);</span><br><span class="line">        <span class="keyword">while</span>(top1 &amp;&amp; a[ stk1[top1] ] == a[ stk1[top1 - <span class="number">1</span>] ]) top1--;</span><br><span class="line">        <span class="keyword">if</span>(top1) top1--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top1) f[i] = min(f[i], f[ stk1[top1] ]);</span><br><span class="line">    stk1[++top1] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(top2 &amp;&amp; a[ stk2[top2] ] &gt; a[i])&#123;</span><br><span class="line">        f[i] = min(f[i], f[ stk2[top2] ]);</span><br><span class="line">        <span class="keyword">while</span>(top2 &amp;&amp; a[ stk2[top2] ] == a[ stk2[top2 - <span class="number">1</span>] ]) top2--;</span><br><span class="line">        <span class="keyword">if</span>(top2) top2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top2) f[i] = min(f[i], f[ stk2[top2] ]);</span><br><span class="line">    stk2[++top2] = i;</span><br><span class="line"></span><br><span class="line">    f[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]);</span><br></pre></td></tr></table></figure><h3 id="E-Egor-in-the-Republic-of-Dagestan"><a href="#E-Egor-in-the-Republic-of-Dagestan" class="headerlink" title="E. Egor in the Republic of Dagestan"></a>E. Egor in the Republic of Dagestan</h3><p>算是比较裸的一道 E 题了……<br>设 $f[u,0/1]$ 表示在 $u$ 点，选 0 边还是选 1 边的答案，对于一条边 $u\gets v$，应当有 $f[u,c]\gets \max(f[v,0],f[v,1])+1$，其中 $c$ 代表边 $u\gets v$ 的颜色。<br>注意到一个点不会被松弛超过一次，直接跑 Dijkstra 转移即可，时间复杂度 $O((n+m)\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,tp; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span> </span>&#123;to = t, nxt = n, tp = p;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> v, id; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;&#125; ;</span><br><span class="line"><span class="function">DJ <span class="title">mk</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;DJ d; d.v = a, d.id = b; <span class="keyword">return</span> d;&#125;</span><br><span class="line"><span class="keyword">int</span> d[CN][<span class="number">2</span>]; <span class="keyword">bool</span> vis[CN]; priority_queue&lt;DJ&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SP</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d)), Q.push( mk(d[u][<span class="number">0</span>] = d[u][<span class="number">1</span>] = <span class="number">0</span>, u) );</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        u = Q.top().id, Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">int</span> dis = max(d[u][<span class="number">0</span>], d[u][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to, c = E[k].tp, cur; <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(d[v][c] &gt; dis + <span class="number">1</span>)&#123;</span><br><span class="line">                d[v][c] = dis + <span class="number">1</span>, cur = max(d[v][<span class="number">0</span>], d[v][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(cur &lt; INF) Q.push( mk(cur, v) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;<span class="keyword">int</span> u = read(), v = read(), t = read(); add(v, u, t);&#125;</span><br><span class="line">    SP(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(max(d[<span class="number">1</span>][<span class="number">0</span>], d[<span class="number">1</span>][<span class="number">1</span>]) &lt; INF) <span class="built_in">printf</span>(<span class="string">"%d"</span>, max(d[<span class="number">1</span>][<span class="number">0</span>], d[<span class="number">1</span>][<span class="number">1</span>])), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">putchar</span>(d[i][<span class="number">0</span>] &gt; d[i][<span class="number">1</span>] ? <span class="string">'0'</span> : <span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;蒟蒻下分场……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>概率期望学习笔记</title>
    <link href="https://big-news.cn/2020/09/07/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/09/07/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-07T09:27:00.000Z</published>
    <updated>2020-09-07T12:11:14.763Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，一个随机变量 $x$ 的数学期望定义为 $E(x)$，即是 $E(x)traodinary$ 的缩写形式，代表 $x$ 是一个非凡的数字……</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>随机变量 $x$ 的数学期望 $E(x)$ 定义为 $x$ 的每种取值的概率加权和，可以理解为 $x$ 在平均情况下的取值，我们一般称其为「期望取值」。<br>举个例子，若 $x$ 有 $1/3$ 的概率为 $1$，有 $2/3$ 的概率为 $2$，则 $E(x)=1/3+2\times (2/3)=5/3$。</p><h3 id="线性性"><a href="#线性性" class="headerlink" title="线性性"></a>线性性</h3><p>根据乘法结合律以及分配律，可以发现期望具有线性性，可以将其理解为「元素和的期望等于元素期望的和」，亦即：<br>$$ E(\Sigma x_i)=\sum E(x_i) $$ 设 $c$ 为常量，也容易验证：<br>$$E(x+c)=E(x)+c$$</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。<br>求该 01 串的价值的期望。<br>$n\le 10^5$</p></div></article><p>设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：<br>$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：<br>$$ \begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \end{aligned}$$ 于是可以做到 $O(n)$ 求出答案。<br>注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。</p><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一颗 $n$ 个节点的有根树，$1$ 号节点为根，树上的每个节点 $u$ 都有一个权值 $c_u$。<br>你需要随机一个节点的排列 $P\in [n]$， 并且按这个排列的顺序依次访问所有树上的节点。每当访问到树上的一个节点 $u$ 时，你需要将子树 $u$ 内所有节点的权值加上 $c_u$（包括点 $u$）。<br>问在一切的操作结束之后所有节点权值之和的期望。由于期望可能不是一个整数，请将它乘上 $n!$，并对 $10^9+7$ 取模。<br>$n\le 10^5$, 且<strong>保证树的形态随机</strong></p></div></article><p>根据期望的线性性，我们只需要求出每个节点最后的期望权值即可。设这个东西是 $a_u$ ，容易发现 $a_u$ 的取值只与从根到 $u$ 的这一条祖孙链上的节点有关。<br>因为树的形态随机，所以树高是期望 $O(\sqrt{n})$ 的。设祖孙链长为 $d$，那么只需考虑 $O(d)$ 地求出 $a_u$ 即可。<br>运用贡献法考虑：期望权值 = $Σ$权值$×$期望累加次数，那么考虑预处理一个 $t[]$，使得 $a_u=\sum c_v·t_v$ 即可。</p><p>容易发现 $t_v$ 的取值只与 $u,v$ 的相对距离有关，则可以设 $f_i$ 表示考虑随机访问一个有 $n$ 位的序列 $a_1,a_2,…,a_n$，$a_1$ 在 $i$ 上的期望累加次数。<br>考虑一次累加应当是什么样子： $1\to p_1\to p_2\to …\to i$，且满足 $1&lt;p_1&lt;p_2&lt;…&lt;i$。这显然双射了一个上升子序列（IS）。<br>则 $f_i$ 即代表考虑所有 $P\in [i]$，$P$ 中以 $1$ 起始的 IS 的期望数量。这样我们可以直接拿组合数选出来，即有：<br>$$ f_i=\sum\limits_d \dbinom{i-1}{d-1}\dbinom{i}{d}(i-d)! $$ 于是就可以计算了，时间复杂度 $O(n\sqrt{n})$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[CN], fac[CN], ifac[CN], f[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l * (<span class="number">1l</span>l * fac[n] * ifac[m] % P) * ifac[n - m] % P;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[CN], ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">stk[dep] = a[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = dep, j = <span class="number">1</span>; i; i--, j++) ans = (<span class="number">1l</span>l * stk[i] * f[j] % P + ans) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line"><span class="keyword">int</span> v = E[k].to;</span><br><span class="line"><span class="keyword">if</span>(v ^ p) dfs(v, u, dep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">ifac[n] = qp(fac[n], P - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) ifac[i] = <span class="number">1l</span>l * (i + <span class="number">1</span>) * ifac[i + <span class="number">1</span>] % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5000</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= i; d++)&#123;</span><br><span class="line"><span class="keyword">int</span> prd = <span class="number">1l</span>l * C(i - <span class="number">1</span>, d - <span class="number">1</span>) * C(i, d) % P;</span><br><span class="line">prd = <span class="number">1l</span>l * prd * fac[i - d] % P, f[i] = (f[i] + prd) % P;</span><br><span class="line">&#125;</span><br><span class="line">f[i] = <span class="number">1l</span>l * f[i] * ifac[i] % P; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = (ans + a[i]) % P;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), ans = <span class="number">1l</span>l * ans * fac[n] % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 种方法，每种方法需要 $k_i$ 条途径，第 $j$ 条途径有 $p[i,j]$ 的概率无法使用。每次可以查询任意一条途径可否使用，直到查询到一种能使用的方法，求最小的“最少查询次数的期望”。<br>$n,k_i \le 500$</p></div></article><p>容易发现对于任意一种方法，如果不将其全部查询完，那么这次查询是无意义的。对于任意一种方法，我们应当按照 $p[i,j]$ 降序排序的顺序去查询。<br>假定 $\forall i$，$p[i,j]$ 已经降序排序为 $p_1,p_2,…p_{k_i}$，那么考虑对所有方法进行排列，设 $E_i$ 为考虑 $[1:i]$ 中的方法时的答案，则有：<br>$$\begin{aligned} E_i&amp;=p_1(1+E_{i-1}) + p_2(1-p_1)(2+E_{i-1})+…\newline &amp;=k_iE_{i-1}+b_i \end{aligned} $$ 注意到还有 $\prod\limits_j (1-p_j)$ 的概率本次查询不会停止，把这部分加到常数项即可。<br>于是变成了一次函数嵌套的最小值问题，按 $(k_i-1)/b_i$ 升序排序即可，时间复杂度 $O(\sum k_i + n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">const</span> DB EPS = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, id[CN]; DB k[CN], b[CN], p[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span> </span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> k[i] * b[j] + b[i] &lt; k[j] * b[i] + b[j];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        m = read(); <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;p[j]);</span><br><span class="line">        sort(p + <span class="number">1</span>, p + m + <span class="number">1</span>, cmp); DB prd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">1</span>] &gt; <span class="number">1.0</span> - EPS) &#123;i--, n--; <span class="keyword">continue</span>;&#125; <span class="keyword">while</span>(m &amp;&amp; p[m] &lt;= EPS) m--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) k[i] += p[j] * prd, b[i] += p[j] * prd * j, prd *= (<span class="number">1.0</span> - p[j]);</span><br><span class="line">        b[i] += m * prd, id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, comp); DB ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i, p = n; p; p--) i = id[p], ans = k[i] * ans + b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，一个随机变量 $x$ 的数学期望定义为 $E(x)$，即是 $E(x)traodinary$ 的缩写形式，代表 $x$ 是一个非凡的数字……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://big-news.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="期望" scheme="https://big-news.cn/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 668 (Div. 2)</title>
    <link href="https://big-news.cn/2020/09/07/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20668%20(Div.%202)/"/>
    <id>https://big-news.cn/2020/09/07/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20668%20(Div.%202)/</id>
    <published>2020-09-07T02:12:00.000Z</published>
    <updated>2020-09-07T02:42:16.618Z</updated>
    
    <content type="html"><![CDATA[<p>两场 Div.2 爆肝上蓝系列……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1405">比赛链接</a></p><h3 id="A-Permutation-Forgery"><a href="#A-Permutation-Forgery" class="headerlink" title="A. Permutation Forgery"></a>A. Permutation Forgery</h3><p>这题是精心构造样例给选手降智啊….卡了我半小时 /kk<br>实际上反过来输出就好了啊…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[CN], n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="B-Array-Cancellation"><a href="#B-Array-Cancellation" class="headerlink" title="B. Array Cancellation"></a>B. Array Cancellation</h3><p>容易发现答案就是后缀和的最大值…证明显然啊，就算了吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[CN];</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">int</span> ans = max(<span class="number">0l</span>l, a[n]); <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) a[i] += a[i + <span class="number">1</span>], ans = max(ans, a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="C-Balanced-Bitstring"><a href="#C-Balanced-Bitstring" class="headerlink" title="C. Balanced Bitstring"></a>C. Balanced Bitstring</h3><p>容易发现模 $k$ 相同的位置， 字符应当是相同的，那么模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, k; <span class="keyword">char</span> a[CN], s[CN];</span><br><span class="line">ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; a;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) s[i] = <span class="string">'?'</span>; <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; flag; i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i] != <span class="string">'?'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i % k] == <span class="string">'?'</span>) s[i % k] = a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i % k] != a[i]) flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    cnt1 += (s[i] == <span class="string">'1'</span>), cnt0 += (s[i] == <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">if</span>(cnt0 &gt; (k / <span class="number">2</span>) || cnt1 &gt; (k / <span class="number">2</span>)) flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">flag ? <span class="built_in">puts</span>(<span class="string">"YES"</span>) : <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br></pre></td></tr></table></figure><h3 id="D-Tree-Tag"><a href="#D-Tree-Tag" class="headerlink" title="D. Tree Tag"></a>D. Tree Tag</h3><p>容易发现初始位置看似是无用的，那么把树的直径找出来判断即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, a, b, da, db;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hinit</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) hd[i] = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[CN], dm;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinit</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) d[i] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) d[v] = d[u] + <span class="number">1</span>, dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[CN][<span class="number">21</span>], dep[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) fa[j][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dep[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) pc(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v) &#123;<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][<span class="number">0</span>];&#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="keyword">return</span> dep[u] + dep[v] - <span class="number">2</span> * dep[lca(u, v)];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; T = read(); <span class="keyword">while</span>(T--)&#123; </span><br><span class="line">    hinit(), ecnt = <span class="number">0</span>;</span><br><span class="line">    n = read(), a = read(), b = read(), da = read(), db = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"></span><br><span class="line">    finit(), pc(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(dis(a, b) &lt;= da) &#123;<span class="built_in">puts</span>(<span class="string">"Alice"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">    dinit(), dfs(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> mx = <span class="number">0</span>, p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = mx &lt; d[i] ? p = i, mx = d[i] : mx;</span><br><span class="line"></span><br><span class="line">    dinit(), dfs(p, <span class="number">0</span>), dm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dm = max(dm, d[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * da &gt;= dm) <span class="built_in">puts</span>(<span class="string">"Alice"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(db &gt;= <span class="number">2</span> * da + <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"Bob"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Alice"</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Fixed-Point-Removal"><a href="#E-Fixed-Point-Removal" class="headerlink" title="E. Fixed Point Removal"></a>E. Fixed Point Removal</h3><p>乍一看像是道二维数点，不过我的做法假掉了 /kk<br>英文 tutorial 看不懂啊，咕一咕等个中文题解吧…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两场 Div.2 爆肝上蓝系列……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 667 (Div. 3)</title>
    <link href="https://big-news.cn/2020/09/05/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20667%20(Div.%203)/"/>
    <id>https://big-news.cn/2020/09/05/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20667%20(Div.%203)/</id>
    <published>2020-09-05T06:43:00.000Z</published>
    <updated>2020-09-05T07:12:44.712Z</updated>
    
    <content type="html"><![CDATA[<p>最近 CF 的 Div2.3 有一点点水啊，虽然说蒟蒻还是上不了分……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1409">比赛链接</a></p><h3 id="A-Yet-Another-Two-Integers-Problem"><a href="#A-Yet-Another-Two-Integers-Problem" class="headerlink" title="A Yet Another Two Integers Problem"></a>A Yet Another Two Integers Problem</h3><p>签到傻题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t, a, b;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    a = read(), b = read(); <span class="keyword">int</span> k = <span class="built_in">abs</span>(a - b), b = k / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(b * <span class="number">10</span> == k) <span class="built_in">printf</span>(<span class="string">"%d"</span>, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, b + <span class="number">1</span>); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Minimum-Product"><a href="#B-Minimum-Product" class="headerlink" title="B Minimum Product"></a>B Minimum Product</h3><p>设 $a$ 变成了 $a-c$，$b$ 变成了 $b-d$，则减少的部分是 $-cb-ad+cd$，代入 $c+d=n$ 可以推出这是一个关于 $c$ 的二次函数，且开口向下，那么容易知道 $c$ 只有两种取值 $\max(0,y-b+n)$ 或 $a-x$，代入检验即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> t, a, b, x, y, n;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    a = read(), b = read(), x = read(), y = read(), n = read();</span><br><span class="line">    <span class="keyword">int</span> ans = INF, c, d;</span><br><span class="line">    <span class="keyword">if</span>(a + b - x - y &lt;= n) ans = x * y;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        c = min(n, a - x), d = min(b - y, n - c);</span><br><span class="line">        ans = min(ans, (a - c) * (b - d));</span><br><span class="line">        c = min(n, max(<span class="number">0l</span>l, y - b + n)), d = min(b - y, n - c);</span><br><span class="line">        ans = min(ans, (a - c) * (b - d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d"</span>, ans);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Yet-Another-Array-Restoration"><a href="#C-Yet-Another-Array-Restoration" class="headerlink" title="C Yet Another Array Restoration"></a>C Yet Another Array Restoration</h3><p>傻题，模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">202</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, x, y, d, a[CN], ans[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mx</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = max(mx, a[i]);</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    n = read(), x = read(), y = read(); <span class="keyword">int</span> mn = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(d = <span class="number">1</span>; d &lt;= y; d++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((y - x) % d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = (y - x) / d + <span class="number">1</span>, u = x; <span class="keyword">if</span>(l &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) a[i] = u, u += d;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = n - l; u = x - d;</span><br><span class="line">            <span class="keyword">while</span>(u &gt; <span class="number">0</span> &amp;&amp; sum) sum--, a[++l] = u, u -= d;</span><br><span class="line">            u = y + d;</span><br><span class="line">            <span class="keyword">while</span>(sum) sum--, a[++l] = u, u += d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = mx(a); <span class="keyword">if</span>(cur &lt; y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur &lt; mn) mn = cur, <span class="built_in">memcpy</span>(ans, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Decrease-the-Sum-of-Digits"><a href="#D-Decrease-the-Sum-of-Digits" class="headerlink" title="D Decrease the Sum of Digits"></a>D Decrease the Sum of Digits</h3><p>容易发现代价是固定的，那么模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> t, n, s, bit[<span class="number">101</span>], p10[<span class="number">101</span>], cur;</span><br><span class="line">p10[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">70</span>; i++) p10[i] = p10[i - <span class="number">1</span>] * <span class="number">10</span>;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    cur = <span class="number">0</span>, n = read(), s = read();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) bit[++lg] = n % <span class="number">10</span>, n /= <span class="number">10</span>, cur += bit[lg];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg &amp;&amp; cur &gt; s; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bit[i]) <span class="keyword">continue</span>;</span><br><span class="line">        ans += (<span class="number">10</span> - bit[i]) * p10[i - <span class="number">1</span>];</span><br><span class="line">        bit[i + <span class="number">1</span>]++, cur -= bit[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Two-Platforms"><a href="#E-Two-Platforms" class="headerlink" title="E Two Platforms"></a>E Two Platforms</h3><p>离散化坐标，考虑对于每个坐标 $i$ ，求出 $[1,i]$ 和 $(i,n]$ 的答案，加起来更新答案即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, d, X[CN], val[CN], pre[CN], suf[CN], sum[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    </span><br><span class="line">    n = read(), d = read(), val[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) X[i] = read(), val[ ++val[<span class="number">0</span>] ] = X[i], val[ ++val[<span class="number">0</span>] ] = X[i] + d, val[ ++val[<span class="number">0</span>] ] = X[i] - d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read();</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[++cnt] = val[i];</span><br><span class="line">    val[<span class="number">0</span>] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= val[<span class="number">0</span>] + <span class="number">100</span>; i++) pre[i] = suf[i] = sum[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[ id(X[i]) ]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = id(X[i]), l = id(X[i] - d), r = id(X[i] + d);</span><br><span class="line">        pre[p] = sum[p] - sum[l - <span class="number">1</span>], suf[p] = sum[r] - sum[p - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) pre[i] = max(pre[i], pre[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = val[<span class="number">0</span>]; i; i--) suf[i] = max(suf[i], suf[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) ans = max(ans, pre[i] + suf[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Subsequences-of-Length-Two"><a href="#F-Subsequences-of-Length-Two" class="headerlink" title="F Subsequences of Length Two"></a>F Subsequences of Length Two</h3><p>显然要 DP，设 $f[i,j,k]$ 表示考虑 $s[1:i]$ 中，$t[1]$ 出现了 $j$ 次，当前改动了 $k$ 次的方案数，就可以转移了。</p><p>具体来讲，考虑 $i\to i+1$，我们有两种选择：</p><ol><li>什么都不做，转移到 $f[i+1,c+0/1,k]$；</li><li>把这一位改成 $t_1$，转移到 $f[i+1,c+1,k+1]$</li><li>把这一位改成 $t_2$，转移到 $f[i+1,c,k+1]+c$</li></ol><p>最后特殊考虑一下 $t[1]=t[2]$ 的情况即可，时间复杂度 $O(n^3)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, d, f[CN][CN][CN], ans; <span class="keyword">char</span> s[CN], c1, c2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i][c + (s[i] == c1)][<span class="number">0</span>] = f[i - <span class="number">1</span>][c][<span class="number">0</span>];</span><br><span class="line">        c += (s[i] == c1); <span class="keyword">if</span>(s[i] == c2) f[i][c][<span class="number">0</span>] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= n; c++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c2) f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k] + c);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">else</span> f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c2) f[i + <span class="number">1</span>][c][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c][k + <span class="number">1</span>], f[i][c][k] + c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i][c + (s[i] == c1)][<span class="number">0</span>] = f[i - <span class="number">1</span>][c][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == c1) c++, f[i][c][<span class="number">0</span>] += c - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= n; c++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k], f[i][c][k] + c);</span><br><span class="line">          <span class="keyword">else</span> f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>], f[i][c][k] + c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), d = read(), <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(c1 != c2) DP1(); <span class="keyword">else</span> DP2();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= n; x++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">            ans = max(ans, f[n][x][k]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 CF 的 Div2.3 有一点点水啊，虽然说蒟蒻还是上不了分……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>2-SAT问题</title>
    <link href="https://big-news.cn/2020/09/03/2-SAT%E9%97%AE%E9%A2%98/"/>
    <id>https://big-news.cn/2020/09/03/2-SAT%E9%97%AE%E9%A2%98/</id>
    <published>2020-09-03T00:28:00.000Z</published>
    <updated>2020-09-03T08:18:20.002Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，2-SAT即二元适配性问题，用于解决一类布尔方程的求值问题……</p><a id="more"></a><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个布尔变量 $x_1, x_2, …,x_n$，给定 $m$ 对冲突关系，形如 $x_i\And x_j=0$，问一组可行解。<br>$n\le 10^5, m\le 10^6$</p></div></article><p>拆点建图，对每个变量 $x_i$ 拆成两个点 $i$ 和 $i’$，前者表示“$x_i$ 为真”，后者表示“$x_i$ 为假”。则可以将冲突关系 $(x_i,x_j)$ 转化为偏序关系 $(i,j’)$ 和 $(j,i’)$，依此得到一张有向图，然后就可以按照处理偏序关系的思路去做了。</p><p>容易发现，对于一个偏序环上的点，如果取一个值为真，那么剩下的点取值也必然为真；于是可以得到解的存在性定理：该布尔方程有解当且仅当 $\forall i$，$i$ 和 $i’$ 不在同一个偏序环上。</p><p>如何求出一组可行解呢？贪心地想，对于 $i$ 和 $i’$，我们应该选择在新图中拓扑序大的那个将其设为真，因为这样可以最小化影响。注意到 tarjan 求出的 SCC 的编号即为新图拓扑序的反序，因此直接判断即可。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个布尔变量 $x_1\sim x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 true / false 或 $x_j$ 为 true / false」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。<br>试给每个变量赋值使得所有条件得到满足，无解输出 IMPOSSIBLE。<br>$n, m\le 10^6$</p></div></article><p>容易发现一共有三种本质不同的条件形式：</p><ol><li>$x_i=0|x_j=1$，等价于 $x_i\And \neg x_j=0$，连边 $(i,j),(j’,i’)$；</li><li>$x_i=0|x_j=0$，等价于 $x_i\And x_j=0$，连边 $(i,j’),(j,i’)$；</li><li>$x_i=1|x_j=1$，等价于 $\neg x_i\And \neg x_j=0$，连边 $(i’,j),(j’,i)$。</li></ol><p>然后套用上面的做法就好了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]),hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, du[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, bel[CN], bcnt = <span class="number">0</span>; <span class="keyword">bool</span> ins[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u, ins[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) dfs(v), low[u] = min(low[u], low[v]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[v]) low[u] = min(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">        bcnt++; <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos ^ u) pos = stk[top--], ins[pos] = <span class="literal">false</span>, bel[pos] = bcnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = read(), a = read(), j = read(), b = read();</span><br><span class="line">        <span class="keyword">if</span>(a ^ b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt; b) swap(i, j), swap(a, b);</span><br><span class="line">            add(i, j), add(j + n, i + n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a) add(i, j + n), add(j, i + n);</span><br><span class="line">            <span class="keyword">else</span> add(i + n, j), add(j + n, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); i++) <span class="keyword">if</span>(!dfn[i]) dfs(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; i++) flag &amp;= (bel[i] != bel[i + n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"POSSIBLE"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(bel[i] &lt; bel[i + n]) <span class="built_in">printf</span>(<span class="string">"1 "</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，2-SAT即二元适配性问题，用于解决一类布尔方程的求值问题……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论" scheme="https://big-news.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="2-SAT" scheme="https://big-news.cn/tags/2-SAT/"/>
    
  </entry>
  
  <entry>
    <title>博弈论学习笔记</title>
    <link href="https://big-news.cn/2020/09/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/09/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-02T01:25:00.000Z</published>
    <updated>2020-09-03T08:16:55.463Z</updated>
    
    <content type="html"><![CDATA[<p>Alice 和 Bob 又开始玩游戏了……</p><a id="more"></a><h3 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h3><p>对于博弈论中的局面 $S$，定义它的 SG 函数为 $SG(S)=\text{mex} SG(T)$，其中 $T$ 是 $S$ 的后继局面。<br>对于无法做出任何移动的局面（先手必败态），我们称之为 P 态，否则称之为 N 态（先手必胜态）。</p><ul><li>SG 定理：一个局面 $S$ 是 P 态当且仅当 $SG(S)=0$</li></ul><p>这个定理也可以这样理解：可以到达 P 态的局面是 N 态，所有移动都导致 N 态的局面是 P 态。<br>另一个非常有用的结论：对于由多个局面 $S_1, S_2,…S_n$ 组成的博弈游戏，该局面的 SG 函数是所有 $SG(S_i)$ 的异或和。</p><h3 id="经典-Nim"><a href="#经典-Nim" class="headerlink" title="经典 Nim"></a>经典 Nim</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取，最后没石子可取的人就输了。问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>根据 SG 定理，容易发现 $SG(S_i)=a_i$，故先手必胜当且仅当 $a_i$ 的异或和不为0。</p><h3 id="阶梯-Nim"><a href="#阶梯-Nim" class="headerlink" title="阶梯 Nim"></a>阶梯 Nim</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出任意多枚石子<strong>移动到前面一堆石子</strong>，可以取完，不能不取，最后无法移动的人就输了（此时所有石子都在位置0）。问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>若先手移动偶数堆的石子到奇数堆去，那么后手可以立刻将其移入下一个偶数堆，这样看起来对奇数堆毫无影响。但是如果先手移动奇数堆的石子去偶数堆，则可能会将其移入第 0 堆。因此，只有在奇数堆移动石子是本质的。</p><p>“从奇数堆移动一些石子去偶数堆”等价于从奇数堆拿走一些石子扔掉，因子对奇数堆做 Nim 即可。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个箱子，每个箱子有 $a_i$ 个石头，一开始所有箱子都是关着的。<br>Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。<br>不能操作的输，求先手必胜还是后手必胜。<br>$1\le n\le 10^5, 0\le a_i\le 10^9$</p></div></article><p>考虑如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。<br>如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。</p><p>因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。<br>大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。</p><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出一枚石子扔掉，但任意两次不能取同堆的石子。最后无法移动的人输，问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>若存在一堆石子，满足其中石子的个数比其它堆石子个数总和还多，则先手是必胜的，即一直取这一堆就好了。<br>如果不存在呢？那么任意时刻，不能存在一堆石子，使得其中石子的个数多于其它堆石子个数总和。这意味着所有石子都要被取走，因此直接判断奇偶性即可，复杂度 $O(n)$。</p><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给你 $n$ 张卡片，每张卡片的两个面各有数字 $a_i$ 和 $b_i$，每个面都有 $1/2$ 的概率出现为卡片的正面，卡牌正反面的概率相互独立，求把所有卡牌正面数字拿来玩 Nim 游戏，先手必胜的概率。<br>$n\le 5\times 10^5, a_i,b_i\le 10^{18}$</p></div></article><p>设 $S=\bigoplus\limits_{i=1}^na_i$，定义序列 $c_i=a_i\oplus b_i$，则问题等价于求序列 $c$ 有多少个子集使得异或和为 $S$，线性基维护即可，复杂度 $O(n\log a_i)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LB</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: LL a[<span class="number">101</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i + <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(x &amp; (<span class="number">1l</span>l &lt;&lt; i))) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span>(a[i]) x ^= a[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j + <span class="number">1</span>; j--) <span class="keyword">if</span>(x &amp; (<span class="number">1l</span>l &lt;&lt; j)) x ^= a[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= <span class="number">63</span>; j++) <span class="keyword">if</span>(a[j] &amp; (<span class="number">1l</span>l &lt;&lt; i)) a[j] ^= x;</span><br><span class="line">                a[i] = x; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sz</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">63</span>; i++) <span class="keyword">if</span>(a[i]) cnt++; <span class="keyword">return</span> cnt;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ext</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i + <span class="number">1</span>; i--) <span class="keyword">if</span>(x &amp; (<span class="number">1l</span>l &lt;&lt; i)) x ^= a[i]; <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line">LL n, sum, a[CN], b[CN];</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), b[i] = read(), D.ins(a[i] ^ b[i]), sum ^= a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!D.ext(sum)) <span class="built_in">puts</span>(<span class="string">"1/1"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = D.sz();</span><br><span class="line">    LL ans = <span class="number">1</span>; <span class="keyword">while</span>(k--) ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld/%lld"</span>, ans - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 堆石子（$n$ 是偶数），每堆石子有 $a_i$ 个，每人每次可从任意 $n/2$ 堆石子里取出至少一枚石子扔掉。最后无法移动（有石子的堆的数量 $\le n/2$）的人输，问是否存在先手必胜的策略。<br>$n\le 10^7, a_i\le 10^9$</p></div></article><p>考虑若存在石子个数为 1 的堆，设堆数为 $x(x&gt;0)$，则有情况如下：</p><ol><li>$x &gt; n/2$，则先手必败，因为无法避免在操作中形成空堆；</li><li>$x\le n/2$，则先手必胜，因为先手只要令操作后 $x&gt;n/2$ 即可</li></ol><p>剩下的唯一问题是不存在石子个数为 1 的堆的情况。<br>可以考虑放宽限制，即考虑石子个数为 2 的堆的情况。容易发现石子个数为 2 的情况依然可以归结到上述的两种讨论，因此直接猜出结论：先手必胜当且仅当石子个数最小的堆的数量 $\le n / 2$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Alice 和 Bob 又开始玩游戏了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="博弈论" scheme="https://big-news.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="线性基" scheme="https://big-news.cn/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>KMP学习笔记</title>
    <link href="https://big-news.cn/2020/08/31/KMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/08/31/KMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-31T11:12:00.000Z</published>
    <updated>2020-09-07T12:17:05.907Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，对于一般的字符串题，存在如下规律：字符串算法 &lt; hash &lt; 暴力，其中 “&lt;” 代表“劣于”。</p><a id="more"></a><p>kmp 被用来解决下面的这样一个问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定两个字符串 $S,T$ ，求 $S$ 在 $T$ 中匹配的数量和位置。<br>$|T|,|S|\le 10^6$</p></div></article><p>直接 hash 和 kmp 都是 $O(|S|+|T|)$ 的复杂度，但是 kmp 的思想还是要理解的。<br>kmp 的思想基于下面这两个东西。</p><h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>一个 border 定义为字符串的一段前缀，使其等于本串的一段后缀。<br>用符号表示的话就是找到一个 $k$，使得 $s[1:k]=s[n-k+1:n]$。容易发现我们可以用这个 $k$ 去双射一个 border。<br>众所周知，border 具有一个非常优美的性质，即你的 border 的 border 还是你的 border。</p><h3 id="next-数组"><a href="#next-数组" class="headerlink" title="next[] 数组"></a>next[] 数组</h3><p>定义 $nxt[i]=md(s[1:i])$ 是串 $s$ 的 $nxt[]$ 数组，其中 $md(x)$ 代表串 $x$ 的最长 border 长度（不能是自身）。<br>容易发现 $nxt[i], nxt[nxt[i]],…$ 构成了串 $s[1:i]$ 的所有 border。</p><p>kmp 每次确定一个最大的 $k$，使得 $S[1:k] = T[i - k + 1:i]$，然后尝试扩展 $k\to k+1$，如果 $k=|S|$ 则发现了匹配位置。<br>容易发现，这个尝试扩展的过程可以通过 border 来加速，即若 $S[k+1]\neq T[i+1]$，则令 $k=nxt[k]$ 即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, nxt[CN]; <span class="keyword">char</span> s[CN], t[CN];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; (t + <span class="number">1</span>) &gt;&gt; (s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(t + <span class="number">1</span>), m = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; nxt[<span class="number">1</span>] = <span class="number">0</span>, nxt[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// k : 当前的最长 border</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != s[i]) k = nxt[k]; <span class="comment">// 去找次长 border</span></span><br><span class="line">    nxt[i] = (k += <span class="number">1</span>); <span class="comment">// 往下匹配一位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != t[i]) k = nxt[k]; <span class="comment">// 同理</span></span><br><span class="line">    <span class="keyword">if</span>((k += <span class="number">1</span>) == m) <span class="built_in">printf</span>(<span class="string">"%d"</span>, i - m + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>); <span class="comment">// 已经匹配上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定字符串 $S$，求 $S$ 的所有前缀的<strong>不重叠</strong>的 border 数量。<br>$|S|\le 5\times 10^7$</p></div></article><p>直接在 kmp 上维护即可，注意一下 kmp 想要保证复杂度则必须避免反复横跳。<br>时间复杂度 $O(n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e7</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, nxt[CN], num[CN]; <span class="keyword">char</span> s[CN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; nxt[<span class="number">0</span>] = <span class="number">-1</span>, nxt[<span class="number">1</span>] = <span class="number">0</span>, num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != s[i]) k = nxt[k];</span><br><span class="line">    k += <span class="number">1</span>, nxt[i] = k, num[i] = num[k] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(k ^ <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != s[i]) k = nxt[k];</span><br><span class="line">    <span class="keyword">while</span>(k &gt; i / <span class="number">2</span>) k = nxt[k]; <span class="comment">// 跑过了就挪回去</span></span><br><span class="line">    ans = <span class="number">1l</span>l * ans * (num[k] + <span class="number">1</span>) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="在字典树上的扩展"><a href="#在字典树上的扩展" class="headerlink" title="在字典树上的扩展"></a>在字典树上的扩展</h3><p>考虑这样一个问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个字符串 $T$，和<strong>一些</strong>字符串 $S_1,S_2,…S_n$，对每个 $S_i$ 求其在 $T$ 中匹配的数量。<br>$|T|,\sum|S_i|\le 10^6$</p></div></article><p>解决方法是对 $S_i$ 建立字典树，然后再在字典树上建立类似于 $nxt[]$ 指针的结构。注意到这种方法具有可扩展性，即广义后缀自动机也通过类似的思想构建。</p><p>于是这棵字典树变成了一个<strong>确定有限状态自动机（DFA）</strong>，我们称其为 <strong>AC自动机（Aho-Corasick Automaton, ACAM）</strong>。</p><p>则可以得到这样一份构建代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAM</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> son[CN][<span class="number">26</span>], fail[CN], e[CN], idx; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!son[u][ s[i] - <span class="string">'a'</span> ]) son[u][ s[i] - <span class="string">'a'</span> ] = ++idx;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">        &#125;</span><br><span class="line">        e[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) Q.push( son[<span class="number">0</span>][i] );</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]);</span><br><span class="line">                <span class="keyword">else</span> son[u][i] = son[ fail[u] ][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = u; j &amp;&amp; e[j] ^ <span class="number">-1</span>; j = fail[j])</span><br><span class="line">                r += e[j], e[j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个字符串 $T$ 和一些字符串 $S_1,S_2,…S_n$，定义一个字符串是可爱的当且仅当它不包含任何 $S_i$ 作为子串。试删除最少的字符使得 $T$ 变得可爱。<br>$|T|,\sum|S_i|\le 5000$</p></div></article><p>考虑 DP，设 $f[l,u]$ 为考虑 $S[1:l]$，在AC自动机上走到了节点 $u$ 的最小代价。考虑 $S[l+1]$ 是否删除，则有转移：<br>$$\begin{aligned} &amp;f[l,u]+1\to f[l + 1, u]\newline &amp;f[l,u]\to f[l+1,v] \text{ }|\text{ }son[u, S[l + 1]] = v\end{aligned}$$ $v$ 点应当满足怎样的限制呢？首先它不应该是接受状态，并且 fail 树上它到根的路径上也不能存在接受状态，因为这些状态是后缀等价的。那么按照 bfs 序更新一下即可，时间复杂度 $O(|T|\sum |S_i|)$。 </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2020</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAM</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> son[CN][<span class="number">26</span>], fail[CN], w[CN], idx; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!son[u][ s[i] - <span class="string">'a'</span> ]) son[u][ s[i] - <span class="string">'a'</span> ] = ++idx;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">        &#125;</span><br><span class="line">        w[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) Q.push(son[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]);</span><br><span class="line">                <span class="keyword">else</span> son[u][i] = son[ fail[u] ][i];</span><br><span class="line">            w[u] += w[ fail[u] ]; <span class="comment">// mark</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f[CN][CN];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= idx; i++)&#123;</span><br><span class="line">                f[l + <span class="number">1</span>][i] = min(f[l + <span class="number">1</span>][i], f[l][i] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> v = son[i][ s[l] - <span class="string">'a'</span> ];</span><br><span class="line">                <span class="keyword">if</span>(!w[v]) f[l + <span class="number">1</span>][v] = min(f[l + <span class="number">1</span>][v], f[l][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= idx; i++) ans = min(ans, f[n][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一些字符串 $S_1,S_2,…S_n$ 和字符集 $\Sigma$，每个字符串 $S_i$ 有一个价值 $w_i$。<br>定义一个字符串的价值为其所有子串的价值和（未定义则为 $0$），求一个长度为 $l$ 的串使得其价值最大。<br>$|\Sigma|\le 26 ,\sum|S_i|,l\le 1000$</p></div></article><p>考虑 DP，假设当前的字符串为 $s$，新增了一个字符 $c$ 得到 $sc$，则新增的子串应当是 $sc$ 的所有后缀，新增字符的价值为这些后缀的价值和。<br>对 $S_i$ 建立AC自动机，则“这些后缀的价值和”体现为 fail 树上从根到 $sc$ 所在的节点的权值和，我们记其为 $w[u]$。</p><p>于是就可以 DP 了，设 $f[l,u]$ 表示当前拼出的串长度为 $l$，现在在AC自动机上的节点 $u$ 的最大价值，有转移：<br>$$ f[l,u]+w[v]\to f[l+1,v]\text{ }|\text{ }\exists c, \text{s.t.} son[u, c]=v$$ 时间复杂度 $O(l\sum|S_i||\Sigma|)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2020</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">queue</span> &#123;</span> <span class="comment">// 惨痛经历</span></span><br><span class="line">  <span class="keyword">public</span>: T a[CN], hd, tl; <span class="built_in">queue</span>() &#123;hd = tl = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> hd ^ tl ? <span class="number">0</span> : <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a[hd];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;hd++;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;a[tl++] = x;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAM</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> w[CN], son[CN][<span class="number">26</span>], fail[CN], idx; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!son[u][ s[i] - <span class="string">'a'</span> ]) son[u][ s[i] - <span class="string">'a'</span> ] = ++idx;</span><br><span class="line">            u = son[u][ s[i] - <span class="string">'a'</span> ];</span><br><span class="line">        &#125;</span><br><span class="line">        w[u] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) Q.push(son[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]);</span><br><span class="line">                <span class="keyword">else</span> son[u][i] = son[ fail[u] ][i];</span><br><span class="line">            w[u] += w[ fail[u] ]; <span class="comment">// mark</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f[CN][CN];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt;= idx; u++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">26</span>; c++)</span><br><span class="line">                    f[i + <span class="number">1</span>][ son[u][c] ] = max(f[i + <span class="number">1</span>][ son[u][c] ], f[i][u] + w[ son[u][c] ]);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt;= idx; u++) ans = max(ans, f[l][u]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，对于一般的字符串题，存在如下规律：字符串算法 &amp;lt; hash &amp;lt; 暴力，其中 “&amp;lt;” 代表“劣于”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="KMP" scheme="https://big-news.cn/tags/KMP/"/>
    
      <category term="AC自动机" scheme="https://big-news.cn/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」牛客练习赛68</title>
    <link href="https://big-news.cn/2020/08/28/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B68/"/>
    <id>https://big-news.cn/2020/08/28/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B68/</id>
    <published>2020-08-28T12:03:00.000Z</published>
    <updated>2020-08-29T12:22:16.464Z</updated>
    
    <content type="html"><![CDATA[<p>牛客的题还是比较板啊，像我这样的菜鸡都能打到 rk30？？？/jk</p><a id="more"></a><h3 id="A-牛牛的mex"><a href="#A-牛牛的mex" class="headerlink" title="A 牛牛的mex"></a>A 牛牛的mex</h3><p>主席树模板题。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx;</span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] = d[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) rc = ch[v][<span class="number">1</span>], ins(lc, ch[v][<span class="number">0</span>], l, m, p);</span><br><span class="line">        <span class="keyword">else</span> lc = ch[v][<span class="number">0</span>], ins(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = d[lc] - d[ ch[v][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &lt; m - l + <span class="number">1</span>) <span class="keyword">return</span> qu(lc, ch[v][<span class="number">0</span>], l, m);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qu(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, ai;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ai = read(), D.ins(D.rt[i], D.rt[i - <span class="number">1</span>], <span class="number">1</span>, n, ai + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span>(q--) x = read(), y = read(), <span class="built_in">printf</span>(<span class="string">"%d"</span>, y - x + <span class="number">1</span> &lt; n ? D.qu(D.rt[y], D.rt[x - <span class="number">1</span>], <span class="number">1</span>, n) - <span class="number">1</span> : n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-牛牛的算术"><a href="#B-牛牛的算术" class="headerlink" title="B 牛牛的算术"></a>B 牛牛的算术</h3><p>傻题，随便推一推柿子，特判下就好了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">199999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P; a = <span class="number">1l</span>l * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> i2 qp(2, P - 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, f[CN], p[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> squ = <span class="number">1l</span>l * x * x % P; squ = <span class="number">1l</span>l * squ * (x + <span class="number">1</span>) % P;</span><br><span class="line">    <span class="keyword">return</span> squ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; P; i++) f[i] = (f[i - <span class="number">1</span>] + cal(i)) % P;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; P; i++) p[i] = <span class="number">1l</span>l * p[i - <span class="number">1</span>] * i % P, p[i] = <span class="number">1l</span>l * p[i] * f[i] % P, p[i] = <span class="number">1l</span>l * p[i] * i2 % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch; <span class="keyword">int</span> l = <span class="built_in">strlen</span>(ch); <span class="keyword">if</span>(l &gt;= <span class="number">6</span>) &#123;<span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) n = n * <span class="number">10</span> + (ch[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= P) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, p[n]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-牛牛的无向图"><a href="#C-牛牛的无向图" class="headerlink" title="C 牛牛的无向图"></a>C 牛牛的无向图</h3><p>容易想到把边和询问都按权值排序，然后依次加边，能加就加，然后对于每个连通块就可以 $O(1)$ 算答案了。维护一个并查集就解决了，时间复杂度 $O(m\log m + (m + q)\alpha(n))$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fa[CN];</span><br><span class="line">    DSU() &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) fa[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] ^ x ? fa[x] = fd(fa[x]) : x;&#125;</span><br><span class="line">&#125; C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, LIM, X[CN], Y[CN], W[CN], id[CN], pos = <span class="number">1</span>, L[CN], sz[CN]; </span><br><span class="line">LL ans[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> W[i] &lt; W[j];&#125;</span><br><span class="line"><span class="function">LL <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l * x * (x - <span class="number">1</span>) / <span class="number">2l</span>l;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SA, SB, SC; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">rng61</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SA ^= SA &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    SA ^= SA &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    SA ^= SA &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> t = SA;</span><br><span class="line">    SA = SB;</span><br><span class="line">    SB = SC;</span><br><span class="line">    SC ^= t ^ SA;</span><br><span class="line">    <span class="keyword">return</span> SC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%u%u%u%d"</span>, &amp;n, &amp;m, &amp;q, &amp;SA, &amp;SB, &amp;SC, &amp;LIM);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        X[i] = rng61() % n + <span class="number">1</span>;</span><br><span class="line">        Y[i] = rng61() % n + <span class="number">1</span>;</span><br><span class="line">        W[i] = rng61() % LIM; id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        L[i] = rng61() % LIM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    gen();</span><br><span class="line"></span><br><span class="line">    sort(L + <span class="number">1</span>, L + q + <span class="number">1</span>), sort(id + <span class="number">1</span>, id + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sz[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        LL cur = ans[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(W[ id[pos] ] &lt;= L[i] &amp;&amp; pos &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = X[ id[pos] ], v = Y[ id[pos] ], fu = C.fd(u), fv = C.fd(v);</span><br><span class="line">            <span class="keyword">if</span>(fu ^ fv) </span><br><span class="line">                cur += <span class="number">1l</span>l * sz[fu] * sz[fv], </span><br><span class="line">                C.fa[fv] = fu, sz[fu] += sz[fv];</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) ans[<span class="number">0</span>] ^= ans[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-牛牛的粉丝"><a href="#D-牛牛的粉丝" class="headerlink" title="D 牛牛的粉丝"></a>D 牛牛的粉丝</h3><p>显然是个矩乘优化 DP 转移，设 $f[k,i]$ 表示 $k$ 轮后点 $i$ 的答案这样，直接做复杂度 $O(n^3\log k)$，好像不太行。<br>然后就没有想法了……</p><p>upd：转移矩阵是循环的啊……既然是循环的就没必要 $O(n^3)$ 算了……存下第一行来矩乘就变卷积了……于是做到 $O(n^2\log k)$……甚至还可以 $O(n\log n\log k)$ /jk……</p><h3 id="E-牛牛的字符串"><a href="#E-牛牛的字符串" class="headerlink" title="E 牛牛的字符串"></a>E 牛牛的字符串</h3><p>回文不会处理啊……看上去我只会 $O(n^3)$ 的辣鸡 DP，也许可以通过一些字符串算法优化到 $O(n^2)$？不可做不可做。</p><p>upd：并没有什么神仙算法……所以说还是要观察性质……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;牛客的题还是比较板啊，像我这样的菜鸡都能打到 rk30？？？/jk&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>利用vector重现set</title>
    <link href="https://big-news.cn/2020/08/28/%E5%88%A9%E7%94%A8vector%E9%87%8D%E7%8E%B0set/"/>
    <id>https://big-news.cn/2020/08/28/%E5%88%A9%E7%94%A8vector%E9%87%8D%E7%8E%B0set/</id>
    <published>2020-08-28T01:45:00.000Z</published>
    <updated>2020-08-28T03:12:31.120Z</updated>
    
    <content type="html"><![CDATA[<p>提供一种小数据下运行效率极高的<code>std::set</code>替代方法。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-asia mr-2"></i>此页面存在相关页面。关于普通平衡树，请参见<a href="/2020/06/26/Splay/">「Splay」</a>。</div></article><a id="more"></a><p>众所周知，平衡树有两类：一类维护集合，一类维护序列。维护序列的平衡树通常作为线段树的替代，用于解决线段树并不支持的区间翻转操作；而维护集合的平衡树则可以被看作是在重现<code>std::set</code>。</p><p>但是这并不是最简便的方案，实际上，我们可以利用<code>std::vector</code>去吊锤维护集合的平衡树。此种方法在 $10^5$ 量级下速度极快，运行时间甚至优于普通 Splay。</p><p>维护集合的平衡树被用来解决这样一类问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>您需要写一种数据结构，来维护一些数，其中需要提供以下操作：</p><ol><li>插入 $x$ 数</li><li>删除 $x$ 数（若有多个相同的数，因只删除一个）</li><li>查询 $x$ 数的排名（排名定义为比当前数小的数的个数 $+1$）</li><li>查询排名为 $x$ 的数</li><li>求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）</li><li>求 $x$ 的后继（后继定义为大于 $x$，且最小的数）</li></ol><p>设 $n$ 为集合的最大大小，对所有数据，满足 $n\le 10^5$。</p></div></article><p>利用<code>std::lower_bound</code>和<code>std::upper_bound</code>，可以得到下面的这样两条语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lower_bound(v.begin(), v.end(), x) - v.begin() <span class="comment">// &lt; x 的元素个数</span></span><br><span class="line">upper_bound(v.begin(), v.end(), x) - v.begin() <span class="comment">// &lt;= x 的元素个数</span></span><br></pre></td></tr></table></figure><p>于是可以得到下面<a href="https://www.luogu.com.cn/record/37763229">这份</a>代码实现。显然，它吊锤了 <a href="https://www.luogu.com.cn/record/34668994">Splay</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v; <span class="keyword">int</span> n = read();</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    <span class="keyword">int</span> tp = read(), x = read();</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">1</span>) v.insert(lower_bound(v.begin(), v.end(), x), x);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">2</span>) v.erase(lower_bound(v.begin(), v.end(), x));</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, lower_bound(v.begin(), v.end(), x) - v.begin() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, v[x - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, v[lower_bound(v.begin(), v.end(), x) - v.begin() - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tp == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, v[upper_bound(v.begin(), v.end(), x) - v.begin()]);</span><br><span class="line">    <span class="keyword">if</span>(tp &gt; <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理性分析一下，这份代码的时间复杂度为 $O(n^2\log n)$，瓶颈在于<code>erase()</code>和<code>insert()</code>。</p><p>但是我们可以对其进行测试，Generator 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">int</span> t1 = <span class="number">1</span>, t2 = <span class="number">1000000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"1 %d"</span>, t1++), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1 %d"</span>, t2--), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4 %d"</span>, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本机测试结果如下：</p><table><thead><tr><th>数据范围</th><th>$n=5\times10^4$</th><th>$n=10^5$</th><th>$n=5\times 10^5$</th><th>$n=10^6$</th></tr></thead><tbody><tr><td>运行时间（平均，向下近似）</td><td>100ms</td><td>280ms</td><td>7.7s</td><td>30s</td></tr><tr><td>运行时间（平均，向下近似，O2）</td><td>70ms</td><td>280ms</td><td>7s</td><td>28s</td></tr><tr><td>对比（普通 Splay）</td><td>30ms</td><td>30ms</td><td>260ms</td><td>380ms</td></tr></tbody></table><p>容易发现当 $n$ 超过 $10^5$ 的量级后，其运行效率略大于 $O(n\sqrt{n})$，而在之前效率及其优秀。但是实际上题目中插入操作的数量并没有达到测试中的量级，因此出现了吊锤 Splay 的现象。</p><p>于是我们可以初步地得出结论：在 $10^5$ 的数据量级下，利用<code>vector</code>代替 Splay 有着优秀的运行效率。</p><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的图，给出 $m$ 对点和 $q$ 条边。顺序尝试加入每条边，如果不会使得 $m$ 对点中的任意一对点联通，则加入，否则不加入。判断每条边是否会被加入。<br>$n,m,q\le 10^5$</p></div></article><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>条件反射：看到不可逆性修改操作，就应该想到结构合并。</div></article><p>容易想到对每个点维护一个<code>set</code>，表示该点不能到达的点集，然后连一条边相当于合并两个<code>set</code>，在合并前判断一下，然后启发式合并就好了。<br>然后把<code>set</code>换成<code>vector</code>，运行时间得以缩小一半。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> fa[CN]; DSU() &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) fa[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] ^ x ? fa[x] = fd( fa[x] ) : x;&#125;</span><br><span class="line">&#125; C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("_in.in", "r", stdin);</span></span><br><span class="line"></span><br><span class="line">    n = read(), m = read(), q = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        v[x].push_back(y), v[y].push_back(x);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(), fx = C.fd(x), fy = C.fd(y);</span><br><span class="line">        <span class="keyword">if</span>(fx == fy) &#123;<span class="built_in">putchar</span>(<span class="string">'1'</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> szx = v[fx].size(), szy = v[fy].size();</span><br><span class="line">        <span class="keyword">if</span>(szx &gt; szy) swap(fx, fy), swap(szx, szy);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; szx &amp;&amp; flag; i++) <span class="keyword">if</span>(C.fd( v[fx][i] ) == fy) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;<span class="built_in">putchar</span>(<span class="string">'0'</span>); <span class="keyword">continue</span>;&#125; <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        <span class="comment">/* fx -&gt; fy */</span></span><br><span class="line">        C.fa[fx] = fy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; szx; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = v[fx][i], p = lower_bound(v[fy].begin(), v[fy].end(), u) - v[fy].begin() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(v[fy][p] == u) <span class="keyword">continue</span>;</span><br><span class="line">            v[fy].insert(lower_bound(v[fy].begin(), v[fy].end(), u), u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提供一种小数据下运行效率极高的&lt;code&gt;std::set&lt;/code&gt;替代方法。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-primary&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;
此页面存在相关页面。关于普通平衡树，请参见&lt;a href=&quot;/2020/06/26/Splay/&quot;&gt;「Splay」&lt;/a&gt;。
&lt;/div&gt;
&lt;/article&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="平衡树" scheme="https://big-news.cn/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>「题解」Fancy Fence</title>
    <link href="https://big-news.cn/2020/08/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DFancy%20Fence/"/>
    <id>https://big-news.cn/2020/08/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DFancy%20Fence/</id>
    <published>2020-08-27T02:15:00.000Z</published>
    <updated>2020-08-30T01:34:52.225Z</updated>
    
    <content type="html"><![CDATA[<p>打了一场 CEOI2020 Day1 的线上镜像，发现这个 A 题好像有点水啊，于是切掉，来水个题解……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1402/problem/A">原题链接</a></p><p>容易发现，一个长为 $N$ 宽为 $M$ 的矩形的合法子矩形的数量可以 $O(1)$ 算。具体来讲，设：<br>$$A=\dbinom{NM}{2}, B = M·\dbinom{N}{2},C=N·\dbinom{M}{2}$$ 有该矩形的子矩形数量为：<br>$$(A-B-C)/2+B+C$$ 之所以要算的这么麻烦是为了去重…这个重复的问题考场上卡了我半小时/kk…</p><p>那么考虑对于每个 $h_i$ 拆开来算贡献。对于当前的高度 $h_i$ ，我们确定两个端点 $l_i$ 和 $r_i$，使得 $[l_i,r_i]$ 是极长的一段区间满足 $\min\limits_{l_i\le k\le r_i} h_k=h_i$，于是我们可以找到一个极大的矩形，然后就可以在这个矩形里面算答案了。</p><p>剩下的问题是考虑重复，即这个矩形下方存在一个 $h$ 更小的矩形（它应该是矮矮长长的这个样子），而它的贡献我们已经在前面算过了。我们强制令矩形的一个端点在这个矩形上方就好了。</p><p>于是就只剩下单调栈的复杂度了，总复杂度 $O(n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long <span class="comment">// 惨痛经历</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i2 = <span class="number">500000004</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, h[CN], w[CN], sum[CN], pr[CN], nt[CN], stk[CN], top = <span class="number">0</span>, ans = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; cal[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> (<span class="number">1l</span>l * x * (x - <span class="number">1</span>) / <span class="number">2l</span>l) % P;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ab = ((a - b) % P + P) % P;</span><br><span class="line">    <span class="keyword">int</span> rec = C(<span class="number">1l</span>l * l * ab % P), t1 = C(ab), t2 = C(l);</span><br><span class="line">    t1 = <span class="number">1l</span>l * t1 * l % P, t2 = <span class="number">1l</span>l * t2 * ab % P;</span><br><span class="line">    rec = ((rec - t1 - t2) % P + P) % P, rec = <span class="number">1l</span>l * rec * i2 % P;</span><br><span class="line">    rec = (rec + t1 + t2) % P;</span><br><span class="line">    <span class="keyword">int</span> t = C(l + <span class="number">1</span>); t = <span class="number">1l</span>l * t * b % P, t = <span class="number">1l</span>l * t * ab % P, t = (t + P) % P;</span><br><span class="line">    <span class="keyword">return</span> (rec + t) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) h[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) w[i] = read(), sum[i] = (sum[i - <span class="number">1</span>] + w[i]) % P, ans = (<span class="number">1l</span>l * w[i] * h[i] % P + ans) % P;</span><br><span class="line"></span><br><span class="line">    stk[++top] = <span class="number">1</span>, pr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h[ stk[top] ] &gt;= h[i]) top--;</span><br><span class="line">        pr[i] = stk[top], stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[top = <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h[ stk[top] ] &gt;= h[i]) top--;</span><br><span class="line">        nt[i] = stk[top], stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cal[ pr[i] ][ h[i] ]) <span class="keyword">continue</span>; cal[ pr[i] ][ h[i] ] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l = (sum[ nt[i] - <span class="number">1</span> ] - sum[ pr[i] ] + P) % P, a = h[i], b = max(h[ pr[i] ], h[ nt[i] ]);</span><br><span class="line">        ans = (ans + calc(l, a, b)) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打了一场 CEOI2020 Day1 的线上镜像，发现这个 A 题好像有点水啊，于是切掉，来水个题解……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="单调栈" scheme="https://big-news.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>「杂题选做」八月口胡合集</title>
    <link href="https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/"/>
    <id>https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/</id>
    <published>2020-08-24T10:06:00.000Z</published>
    <updated>2020-09-03T03:16:33.672Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，做题的关键在于口胡出解法，而我还是什么都不会……</p><a id="more"></a><p>本篇 Blog 多以口胡为主，杂题居多。</p><h3 id="1-Hunger-Game"><a href="#1-Hunger-Game" class="headerlink" title="1 Hunger Game"></a>1 Hunger Game</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $N$ 个箱子，每个箱子有 $a[i]$ 个石头，一开始所有箱子都是关着的。<br>Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。<br>不能操作的输，求先手必胜还是后手必胜。<br>$1\le N\le 1e5, 0\le a[i]&lt;10^9$</p></div></article><p>Nim 博弈的经典结论：对于每个状态有 $SG_i=a_i$ ，则终态是 P 态的充要条件是 $a_1\oplus a_2\oplus … \oplus a_n = 0$。</p><p>回到本题，如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。<br>如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。</p><p>因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。<br>大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。</p><h3 id="2-Minimum-Value-of-Equation"><a href="#2-Minimum-Value-of-Equation" class="headerlink" title="2 Minimum Value of Equation"></a>2 Minimum Value of Equation</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定 $k[i],b[i]$，有 $n$ 个函数，第 $j$ 个函数为 $f_j(x)=\sum |k[i]x+b[i]|$，其中$1\le i\le j$。<br>对于每个 $j=1…n$，求出 $f_j(x)$ 的最小值。<br>$1\le n\le 10^5 , |k[i]|\le 1000$</p></div></article><p>提一下公因式变成 $\sum k_i|x+(b_i/k_i)|$ ，即 $x$ 到数轴上的一堆点 $b_i/k_i$ 的距离和，那么 $x$ 取这些点的中位数就好了。</p><h3 id="3-DFS-Count"><a href="#3-DFS-Count" class="headerlink" title="3 DFS Count"></a>3 DFS Count</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个 $n$ 个点的有向图，求合法的 DFS 序的个数。<br>$n \le 13$</p></div></article><p>直接搜？？？（雾<br>设 $f[u,S]$ 表示当前在 $u$ ，没走过的点集为 $S$ 的方案数。$|S|$ 是递减的，可通过其来划分子问题，得到转移：<br>$$ f[v,T_v \And S]·f[u,S-(T_v \And S)] \to f[u, S] | (u,v)\in E$$<br>其中 $T_v$ 是 $v$ 能到达的点集。容易发现这次从小集合往大集合转移，则其是可操作的。</p><h3 id="4-XOR-Product"><a href="#4-XOR-Product" class="headerlink" title="4 XOR Product"></a>4 XOR Product</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定序列 $a_1,…,a_n$ ，求：<br>$$ \sum\limits_{i&lt;j&lt;k}(a_i\oplus a_j)·(a_j \oplus a_k) $$</p></div></article><p>把 $j$ 提出来，拆一下柿子：<br>$$ \sum\limits_j(\sum\limits_{i&lt;j}a_i\oplus a_j)(\sum\limits_{j&lt;k}a_j \oplus a_k) $$<br>考虑求 $\sum\limits_{i&lt;j}a_i\oplus a_j$ ，把每一位拆开算贡献，则应当统计 $a_1,…,a_{j-1}$ 中这一位上有多少个 1 ，预处理即可。<br>预处理是 $O(n\log)$ 的，枚举 $j$ 处理前后两个 sigma 是 $O(n\log)$ 的，最后统计答案也是 $O(n)$ 的。</p><h3 id="5-SUMXOR"><a href="#5-SUMXOR" class="headerlink" title="5 SUMXOR"></a>5 SUMXOR</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定序列 $a[1…n]$ 和 $b[1…n]$ ，求：<br>$$ \bigoplus\limits_{i,j}a_i+b_j $$</p></div></article><p>依然拆开每一位算，考虑第 $w$ 位的贡献应当是 $2^w\sum[(a_i+b_j)\text{ mod } 2^{w+1} \ge 2^w] \text{ mod }2$。<br>令 $a_i\gets a_i\text{ mod }2^{w+1},b_i\gets b_i\text{ mod }2^{w+1} $，有两种情况：</p><ol><li>$a_i + b_j \ge 2^{w+1}$，则应当有 $a_i+b_j-2^{w+1}\ge 2^w$，移项得 $a_i+b_j\ge 2^w+2^{w+1}$</li><li>$a_i+b_j&lt; 2^{w+1}$，则应当有 $2^w\le a_i+b_j&lt; 2^{w+1}$</li></ol><p>于是转化成序列上的查询问题，Two-Pointers 扫即可。</p><h3 id="6-The-Hanged-Man"><a href="#6-The-Hanged-Man" class="headerlink" title="6 The Hanged Man"></a>6 The Hanged Man</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个 $n$ 个点的树，每个点有一个体积 $v[i]$ 和收益 $w[i]$，现在你能选一个独立集，对于每个 $i$ 输出体积和为 $i$ 的收益和最大的独立集的值。<br>$n\le 50, m\le 5000$</p></div></article><p>$O(nm^2)$ 的 DP 显然啊，但是重链剖分 DP 看不懂啊，这个先咕着。</p><p>资料：<a href="https://www.cnblogs.com/dqsssss/p/11534336.html">乱搞</a>，<a href="https://blog.aor.sd.cn/archives/1122/">重链剖分</a></p><p>附一个 $O(nm^2)$ 的 DP：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, vi[CN], wi[CN], f[CN][<span class="number">5005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][ vi[u] ][<span class="number">1</span>] = wi[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> V = m; V; V--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> Vp = <span class="number">0</span>; Vp &lt;= V; Vp++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(V - Vp &gt;= vi[u]) f[u][V][<span class="number">1</span>] = max(f[u][V][<span class="number">1</span>], f[v][Vp][<span class="number">0</span>] + f[u][V - Vp][<span class="number">1</span>]);</span><br><span class="line">                f[u][V][<span class="number">0</span>] = max(f[u][V][<span class="number">0</span>], max(f[v][Vp][<span class="number">0</span>], f[v][Vp][<span class="number">1</span>]) + f[u][V - Vp][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Anton-and-Ira"><a href="#7-Anton-and-Ira" class="headerlink" title="7 Anton and Ira"></a>7 Anton and Ira</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定两个排列 $s$ 和 $p$ ，每次可以交换 $p$ 中的两个数，代价为它们间的距离，问最小代价使 $p$ 变为 $s$ ，输出方案。<br>$n\le 1000$</p></div></article><p>设 $to[u]$ 是 $u$ 想要去到的位置，可以将其看作一条有向边。根据抽屉原理，某一时刻必然存在一个点使 $to[u]$ 与 $to[to[u]]$ 反向，于是贪心就好了。<br>设这样得到的答案为 $s$，容易发现对于一种操作方案，必然存在另一种与之互为补集的操作方案，其答案也为 $s$。两者可以组成全集，即有 $2s=\sum|i-to[i]|$，从而 $s=\sum|i-to[i]|/2$。</p><h3 id="8-Increasing-Shortest-Path"><a href="#8-Increasing-Shortest-Path" class="headerlink" title="8 Increasing Shortest Path"></a>8 Increasing Shortest Path</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有个 $n$ 个点 $m$ 条边的有向图，有 $q$ 个询问：从 $ai$ 到 $bi$，边权递增，经过不超过 $ci$ 条边，权值和最小是多少？<br>$T$组数据（$T\le 100$）。<br>$n ≤ 150, m, q ≤ 5000.$</p></div></article><p>$n$ 比较小，那么考虑 DP。<br>边权看上去没办法放进状态里面，有一个技巧是把边升序排序，然后按照边来转移状态，即可满足要求。</p><p>设 $f[u,v,m]$ 表示 $u\to v$ 经过不超过 $m$ 条边的答案，$O(n)$ 固定起点 $s$，$O(m)$ 枚举一条边 $(u,v,w)$，则有转移：<br>$$ f[s,u,k]+w\to f[s,v,k+1] $$<br>这样看上去是 $O(nm^2)$ 的，但是考虑到限制是“至多经过”，而要求最小路径，则一个环不应在路径中出现，即一个点不会被访问超过一次。考虑到一个点之多有一条出边被选中，因此状态第三维的数量实际上是 $O(n)$ 的。对于 $ci&gt; n$ 的询问，其答案一定等于 $ci=n$ 的询问。</p><p>复杂度 $O(T(m\log m+n^2m+q))$，瓶颈在于 $O(Tn^2m)$；考虑到时限是 60s， 因此可以通过。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sort(G + <span class="number">1</span>, G + m + <span class="number">1</span>), <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) f[i][i][k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= n; s++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = G[i].u, v = G[i].v, w = G[i].w;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) </span><br><span class="line">                f[s][v][k + <span class="number">1</span>] = min(f[s][u][k] + w, f[s][v][k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="9-Increasing-Number"><a href="#9-Increasing-Number" class="headerlink" title="9 Increasing Number"></a>9 Increasing Number</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个数是Increasing当且仅当它的十进制表示是不降的，求 $n$ 位不降十进制数中被 $m$ 整除的有多少个。<br>$n ≤ 10^{18}, m ≤ 500.$</p></div></article><p>显然有状态 $f[n,p,k]$ 表示考虑第 $n$ 位数字，当前位填 $p$，模 $m$ 等于 $k$ 的方案数，转移可以枚举当前位数字和上一位数字，有关系 $f[n,p,(p\times 10^n+k)\text{ mod }m]\gets f[n-1,p’,k]$，复杂度 $O(100nm)$，不太可行。<br>对于这种转移关系比较固定的 DP，可以考虑矩乘加速，但是这是 $O((10m)^3\log n)$ 的，看上去也不太行。</p><p>一个重要的性质：一个合法数字必然是至多 9 个仅由 1 组成的数的和。<br>则可以按 $111…111$ 模 $m$ 的值将其分类，这样有 $m$ 类，然后对类做 DP 即可。<br>这也令我们可以得出一个结论：位数小于 $n$ 的不降数的总个数是 $\sum\limits_{i=1}^9\dbinom{i+n-1}{n-1}=\dbinom{n+9}{n}-1$。</p><h3 id="10-Little-Elephant-and-Colored-Coins"><a href="#10-Little-Elephant-and-Colored-Coins" class="headerlink" title="10 Little Elephant and Colored Coins"></a>10 Little Elephant and Colored Coins</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定 $n$ 个物品，每个物品可以取无限次，每个物品有两种属性：价值 $v$ 和颜色 $c$。<br>现在有 $q$ 个询问，询问最多能用多少种颜色组成 $S$。<br>$n ≤ 30, v_i ≤ 2\times 10^5,s\le 10^{18}$</p></div></article><p>对于这种题目，一般来说技巧是取 $w=\min v_i$ ，把问题转化到模 $w$ 的剩余系下做。这样做的正确性在于：$\mathbb{F}_P$ 中的所有数与 $P$ 的倍数组合能够填满整个整数域。<br>然后可以设状态 $f[u,k]$ 或 $f[k]$ 表示模 $w$ 为 $k$ 的答案，对于物品的价值 $v$ 可以抽象成一条边的边权，然后套用最短路模型，于是做到 $O(w\log w)$ 转移状态。</p><p>对于本题，考虑到硬币种类可能在统计过程中重复，因此设 $f[i,k]$ 表示选至少 $i$ 种，模 $w$ 为 $k$ 的路径的最小长度；用最短路模型来转移看上去也不太行，考虑换成背包模型，即有 $f[i,k]\gets f[i+1,(k+v_i)\text{ mod }w]$，然后按 $i$ 分组 DP 更新即可，复杂度 $O(n^2w)$。</p><p>给出大致的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = read(), w = w ? min(w, v[i]) : v[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j + <span class="number">1</span>; j--) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">            f[j + <span class="number">1</span>][(k + v[i]) % w] = min(f[j][k] + v[i], f[j + <span class="number">1</span>][(k + v[i]) % w]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">            f[i][(k + v[j]) % w] = min(f[i][k] + v[j], f[i][(k + v[j]) % w]);</span><br><span class="line">    </span><br><span class="line">q = read();</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> s = read(), sw = s % w;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &amp;&amp; !flag; i--)</span><br><span class="line">        <span class="keyword">if</span>(f[i][sw] &lt; INF &amp;&amp; f[i][sw] &lt;= s) <span class="built_in">printf</span>(<span class="string">"%d"</span>, i), <span class="built_in">puts</span>(<span class="string">""</span>), flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Balance"><a href="#11-Balance" class="headerlink" title="11 Balance"></a>11 Balance</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个杠杆，半长为 $n$，$2n+1$ 个整数坐标各有一个质量相同的砝码，取走 $k$ 个，问最终杠杆仍然平衡的方案数。<br>$n\le 10^4, k\le 10$</p></div></article><p>整数划分问题。<br>容易发现两边是完全对称的，那么只需要考虑一边。考虑枚举取的数字和是多少，设 $f[i,k]$ 表示把数字 $i$ 拆分成 $k$ 个小于 $n$ 的不同数字的方案数，有转移：<br>$$ \begin{aligned}f[i,k]&amp;=f[i-k,k]+f[i-k,k-1]\newline f[i,k]&amp;=f[i,k]-f[i-n-1,k-1] \text{ }\text{ }| \text{ }\text{ }i\ge n + 1 \end{aligned}$$<br>复杂度 $O(nk^2)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - K + <span class="number">1</span>; i &lt;= n; i++) N += i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        f[i][k] = i &gt;= k ? (f[i - k][k] + f[i - k][k - <span class="number">1</span>]) % p : <span class="number">0</span>,</span><br><span class="line">        f[i][k] = i &gt; n ? (f[i][k] - f[i - n - <span class="number">1</span>][k - <span class="number">1</span>] + p) % p : f[i][k];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= N; w++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K; j++) ans = (<span class="number">1l</span>l * f[w][j] * f[w][K - j] % p + ans) % p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= N; w++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K - <span class="number">1</span>; j++) ans = (<span class="number">1l</span>l * f[w][j] * f[w][K - j - <span class="number">1</span>] % p + ans) % p;</span><br></pre></td></tr></table></figure><h3 id="12-Arrangement-Count"><a href="#12-Arrangement-Count" class="headerlink" title="12 Arrangement Count"></a>12 Arrangement Count</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>求有多少个排列 $A\subseteq [n]$，使得 $A$ 中每个位置与相邻位置的数的差不为 1。<br>$n\le 1000$</p></div></article><p>设 $f[i,j,0/1]$ 表示考虑 $A\subseteq [i]$，有 $j$ 对相邻位置相差为 1 ，$i$ 是否与 $i+1$ 相邻的方案数，有转移：</p><ol><li>$f[i,j,0]·j\to f[i+1,j-1,0]$</li><li>$f[i,j,0]·2\to f[i+1, j + 1, 1], f[i,j,1]·2\to f[i+1, j, 1]$</li><li>$f[i,j,0/1]·(i-j-1)\to f[i+1,j,0]$</li></ol><p>复杂度 $O(n^2)$。</p><h3 id="13-Cut-Tree"><a href="#13-Cut-Tree" class="headerlink" title="13 Cut Tree"></a>13 Cut Tree</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个节点的树，点有点权，要切两条边和加一个点使得形成的三个子树点权和相等，最小化新加节点点权的绝对值。<br>$n \le 10^5$</p></div></article><p>考虑固定一整棵树的根，对所有 $n$ 棵子树的大小统计其出现次数 $cnt[]$。不妨设当前的根处需要割断一条边，那么枚举其的枚举一个子树 $v$，设其大小为 $sz[v]$ ，则当 $cnt[sz[v]]&gt;1$ 时，可将整棵树切成三个部分：两个 $sz[v]$ 和一个 $n-sz[v]$ ，于是可以更新答案。</p><p>但是当前根处不一定会割断边，那么考虑换根。容易发现当根向某个儿子移动时，至多有两个节点的 $sz[]$ 值会发生变化，则简单维护即可。</p><p>于是可以做到不漏算答案，时间复杂度 $O(n)$。</p><h3 id="14-Number-Game"><a href="#14-Number-Game" class="headerlink" title="14 Number Game"></a>14 Number Game</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>Alice 和 Bob 又双叒叕在玩游戏。<br>Bob 每次会想一个 $0\text{~}n$ 的数，Alice 每次猜 $k$，Bob 告诉 Alice 大了还是小了。Alice 猜 $k$ 会付出 $a_k$ 的代价，Alice 要最小化代价，Bob 要最大化代价（并在不违反前面询问的情况下改数）。假设二人都绝顶聪明，求 Alice 最后付出多少代价。<br>$n \le 10^5, a_i\le 9$</p></div></article><p>本人只会 $O(n^3)$ 的辣鸡 DP……</p><p>设 $f[l,r]$ 为考虑区间 $[l,r]$ 的答案，应当有转移：<br>$$ f[l,r]=\min\limits_k a_k+ \max(f[l,k-1],f[k+1,r]) $$ 边界是 $f[i,i]=a_i$，直接大力 DP 即可做到 $O(n^3)$。</p><h3 id="15-Distributs"><a href="#15-Distributs" class="headerlink" title="15 Distributs"></a>15 Distributs</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>小 A 带来了 $m$ 种特产，第 $i$ 种特产的数量为 $a_i$。小 A 要把它们全部分给 $n$ 个同学，要求每个同学至少拿到一个特产，问有多少种分法，对 $10^9+7$ 取模。<br>$n,m \le 1000$</p></div></article><p>容斥简单题，钦点 $k$ 个人一定分不到，剩下的随便分，在总方案数中减去就好了，则答案是：<br>$$ \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k}\sum\limits_j \dbinom{a_j+n-k-1}{n-k-1}$$ 复杂度 $O(n^2)$。</p><h3 id="16-Solutions-of-the-Equation"><a href="#16-Solutions-of-the-Equation" class="headerlink" title="16 Solutions of the Equation"></a>16 Solutions of the Equation</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个变量 $x_1…x_n$，每个变量 $0&lt;x\le R$，给定 $S$，求方程 $x_1+x_2+…+x_n=S$有多少组正整数解。<br>$n \le 1000$</p></div></article><p>容斥简单题，如果不考虑限制答案是 $\dbinom{S-1}{n-1}$，然后钦点有 $k$ 个变量不合法然后去加加减减，答案是：<br>$$ \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k}\dbinom{S-kR-1}{n-1} $$ 复杂度 $O(n^2)$。</p><h3 id="17-Bohater"><a href="#17-Bohater" class="headerlink" title="17 Bohater"></a>17 Bohater</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>在一款电脑游戏中，你需要打败$n$只怪物（从 $1$ 到 $n$ 编号），初始生命值为 $z$。<br>为了打败第 $i$ 只怪物，你需要消耗 $d_i$ 点生命值，但怪物死后会掉落血药，使你恢复 $a_i$ 点生命值。<br>任何时候你的生命值都不能降到 0（或 0 以下）。请问是否存在一种打怪顺序，使得你可以打完这 $n$ 只怪物而不死掉。如果存在请输出方案，不存在输出NO。<br>$1≤n,z≤10^5，0≤d_i,a_i≤10^5$</p></div></article><p>考虑把怪分成两类，先打加血怪，再打减血怪；考虑打加血怪的过程：应当按 $d_i$ 升序去打。<br>减血怪呢？考虑打怪的反过程：不打一个怪，血量增加 $d_i$ 而减少 $a_i$。<br>则反过程应当按 $a_i$ 升序排，正过来就是按 $a_i$ 降序排。</p><p>复杂度 $O(n\log n)$。</p><h3 id="18-Swap-Space"><a href="#18-Swap-Space" class="headerlink" title="18 Swap Space"></a>18 Swap Space</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>你有许多电脑，它们的硬盘用不同的文件系统储存数据。你想要通过格式化来统一文件系统。格式化硬盘可能使它的容量从 $a_i$ 变成 $b_i$。<br>为了格式化，你需要买额外的硬盘。当然，你想要买容量最小的额外储存设备以便省钱。<br>你可以按任意顺序格式化硬盘。格式化之前，你要把该硬盘上所有数据移到一个或更多的其他硬盘上，数据可以分割。<br>格式化后，该硬盘可以立刻开始使用。你没有必要把数据放到它原来所在的硬盘上。数据也可以被放到你额外买的硬盘上。<br>求最小的额外储存设备容量。<br>$1≤n≤10^6,1≤a_i,b_i≤10^9$</p></div></article><p>考虑二分最终的答案 $M$ ，表示一开始购买的硬盘大小，则模型变为：</p><ul><li>给定一些元素 $(a,b)$ ，选择某个元素会付出代价 $a$ 得到收益 $b$ ，求能否选择所有元素。</li></ul><p>这就是上题模型，复杂度 $O(n\log^2n)$，看上去有点卡。</p><p>实际上二分大可不必，依然按照上题的思路去做，当代价和多于当前的承受限度时，把多出来的那一部分加到答案里即可，复杂度 $O(n\log n)$。</p><h3 id="19-Maximum-Value-of-Linear-Function"><a href="#19-Maximum-Value-of-Linear-Function" class="headerlink" title="19 Maximum Value of Linear Function"></a>19 Maximum Value of Linear Function</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>现在有 $n$ 个一次函数，$f_i(x)=a_ix+b_i$。给定 $x$，并且对于所有的 $f_i(x)$ 可以任意改变顺序嵌套函数，求 $f(f(f(…f(x))…)$ 的最大值。<br>$n\le 10^6$</p></div></article><p>容易发现 $x$ 的系数一定，那么只需要考虑常数项最大。<br>考虑交换，对二元组 $(a_1,b_1)$ 和 $(a_2,b_2)$ ，前者放在外层当且仅当 $a_1(a_2x+b_2)+b_1&gt;a_2(a_1x+b_1)+b_2$，移项得 $(a_1-1)/b_1&gt;(a_2-1)/b_2$，则按照 $(a_i-1)/b_i$ 降序排序，把靠前的放在外层即可。</p><p>这个题也可以类比一下<a href="https://www.luogu.com.cn/problem/P1080">「国王游戏」</a>那道题。考虑何时应该交换相邻的两个元素 $i,j$：当且仅当 $\Pi/b_i+(a_i·\Pi)/b_j &gt; \Pi/b_j+(a_j·\Pi)/b_i$，化简得 $(a_j-1)·b_j&lt;(a_i-1)·b_i$，因此按 $(a_i-1)·b_i$ 为关键字排序即可。</p><h3 id="20-Kuglarz"><a href="#20-Kuglarz" class="headerlink" title="20 Kuglarz"></a>20 Kuglarz</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个杯子排成一排，每个杯子中可能放有也可能没有一个小球。你每次可以花费 $C(i,j)$ 的代价得知区间 $[i,j]$ 的杯子中球的总数的奇偶性。<br>问最少花费多少代价才能求出每个杯子中是否有小球。<br>$n\le 1000$</p></div></article><p>看上去很像 DP，但我的做法假掉了……<br>建一张图，边 $(u,v)$ 的边权为 $C(u,v)$，则问题等价于求出图上的最小生成树。<br>时间复杂度 $O(n^2)$。</p><h3 id="21-OSU"><a href="#21-OSU" class="headerlink" title="21 OSU!"></a>21 OSU!</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。<br>求该 01 串的价值的期望。<br>$n\le 10^5$</p></div></article><p>考察期望的定义，和应用用贡献法计算每一位的价值期望。<br>设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：<br>$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：<br>$$ \begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \end{aligned}$$ 于是可以做到 $O(n)$。<br>注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l[i] = a[i] * (l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l2[i] = a[i] * (l2[i - <span class="number">1</span>] + <span class="number">2</span> * l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] + a[i] * (<span class="number">3</span> * l2[i - <span class="number">1</span>] + <span class="number">3</span> * l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，做题的关键在于口胡出解法，而我还是什么都不会……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>最小斯坦纳树</title>
    <link href="https://big-news.cn/2020/08/23/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    <id>https://big-news.cn/2020/08/23/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/</id>
    <published>2020-08-23T10:30:00.000Z</published>
    <updated>2020-08-31T11:11:16.837Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，斯坦纳树问题是一类特殊的生成树问题……</p><a id="more"></a><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。<br>再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G=(V,E)$，使得：</p><ol><li>$S\subseteq V$；</li><li>$G$ 为连通图；</li><li>$E$ 中所有边的权值和最小。</li></ol><p>你只需要求出 $E$ 中所有边的权值和。<br>$n\le 100, m\le 500, k\le 10$</p></div></article><p>上述问题被称作「最小斯坦纳树」问题。</p><p>设 $f[i,S]$ 表示当前在 $i$ ，$S$ 中的点已经连通的最小代价，则有转移：</p><p>$$ \begin{aligned} f[i,S] &amp;=\min f[i,S_0]+f[i,S\oplus S_0]\newline f[i,S] &amp;=\min f[j,S]+\text{sp}(i,j)   \end{aligned} $$</p><p>容易发现后一个转移是最短路的形式，考虑到不存在负权边，使用 Dijkstra 转移，复杂度 $O(2^k n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,w; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> d)</span> </span>&#123;to = t, nxt = n, w = d;&#125; &#125; E[CN * CN];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, key[CN], f[CN][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> id, v; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ &amp; a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;&#125;;</span><br><span class="line"><span class="function">DJ <span class="title">make</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;DJ c; c.id = a, c.v = b; <span class="keyword">return</span> c;&#125;</span><br><span class="line">priority_queue&lt;DJ&gt; Q; <span class="keyword">bool</span> vis[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sp</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(f[i][S] &lt; INF) Q.push( make(i, f[i][S]) );</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.top().id; Q.pop();</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[v][S] &gt; f[u][S] + E[k].w)&#123;</span><br><span class="line">                f[v][S] = f[u][S] + E[k].w;</span><br><span class="line">                Q.push( make(v, f[v][S]) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read(), k = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) key[i] = read();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) f[ key[i] ][ <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>) ] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); S++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> V = S; V; V = (V - <span class="number">1</span>) &amp; S)</span><br><span class="line">                f[i][S] = min(f[i][S], f[i][V] + f[i][S ^ V]);</span><br><span class="line">        sp(S);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = min(ans, f[i][(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，斯坦纳树问题是一类特殊的生成树问题……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="斯坦纳树" scheme="https://big-news.cn/tags/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
      <category term="状压DP" scheme="https://big-news.cn/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」牛客小白月赛 27</title>
    <link href="https://big-news.cn/2020/08/22/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B%2027/"/>
    <id>https://big-news.cn/2020/08/22/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B%2027/</id>
    <published>2020-08-22T12:29:00.000Z</published>
    <updated>2020-08-22T14:37:27.394Z</updated>
    
    <content type="html"><![CDATA[<p>又是签到走人的一天……</p><a id="more"></a><p><a href="https://ac.nowcoder.com/acm/contest/6874">比赛链接</a></p><h3 id="A-巨木之森"><a href="#A-巨木之森" class="headerlink" title="A 巨木之森"></a>A 巨木之森</h3><p>签到题，对每个点维护一个到叶子的最长距离，随便怎么搞搞就行了。本人脑子笨，写了个线段树，复杂度 $O(n\log n)$，实际上有严格 $O(n)$ 解法。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,d; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> dd)</span> </span>&#123;to = t, nxt = n, d = dd;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN &lt;&lt; <span class="number">2</span>], tag[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        d[lc] += tag[k], d[rc] += tag[k], tag[lc] += tag[k], tag[rc] += tag[k], tag[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> (<span class="keyword">void</span>)(tag[k] += x, d[k] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(tag[k]) pd(l, r, k);</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) md(l, m, lc, s, t, x); <span class="keyword">if</span>(m &lt; t) md(m + <span class="number">1</span>, r, rc, s, t, x);</span><br><span class="line">        d[k] = max(d[lc], d[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(tag[k]) pd(l, r, k);</span><br><span class="line">        upd(l, m, lc), upd(m + <span class="number">1</span>, r, rc); d[k] = max(d[lc], d[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> d[<span class="number">1</span>];&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sum = <span class="number">0</span>, d[CN], id[CN], sz[CN], idx = <span class="number">0</span>, mxd[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    id[u] = ++idx, sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) d[v] = d[u] + E[k].d, bd(v, u), sz[u] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    mxd[u] = D.qu();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p)&#123;</span><br><span class="line">            D.md(<span class="number">1</span>, n, <span class="number">1</span>, <span class="number">1</span>, n, E[k].d), D.md(<span class="number">1</span>, n, <span class="number">1</span>, id[v], id[v] + sz[v] - <span class="number">1</span>, <span class="number">-2l</span>l * E[k].d);</span><br><span class="line">            dfs(v, u);</span><br><span class="line">            D.md(<span class="number">1</span>, n, <span class="number">1</span>, <span class="number">1</span>, n, -E[k].d), D.md(<span class="number">1</span>, n, <span class="number">1</span>, id[v], id[v] + sz[v] - <span class="number">1</span>, <span class="number">2l</span>l * E[k].d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w), sum += w;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">2l</span>l * sum;</span><br><span class="line"></span><br><span class="line">    bd(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.md(<span class="number">1</span>, n, <span class="number">1</span>, id[i], id[i], d[i]);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mxd[i] = sum - mxd[i];</span><br><span class="line">    sort(mxd + <span class="number">1</span>, mxd + n + <span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n &amp;&amp; sum + mxd[p] &lt;= m) sum += mxd[p++], ans++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-乐团派对"><a href="#B-乐团派对" class="headerlink" title="B 乐团派对"></a>B 乐团派对</h3><p>考察快速排序以及输入输出。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;a[i] = read(); <span class="keyword">if</span>(a[i] &gt; n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;&#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp); </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n) &#123;<span class="keyword">if</span>(p + a[p] &lt;= n + <span class="number">1</span>) ans++, p += a[p]; <span class="keyword">else</span> p++;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-巅峰对决"><a href="#D-巅峰对决" class="headerlink" title="D 巅峰对决"></a>D 巅峰对决</h3><p>线段树板子题。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> !b ? a : gcd(b, a % b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN &lt;&lt; <span class="number">2</span>], mx[CN &lt;&lt; <span class="number">2</span>], mn[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(mx[k] = mn[k] = d[k] = a[l]);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; bd(l, m, lc, a), bd(m + <span class="number">1</span>, r, rc, a);</span><br><span class="line">        d[k] = gcd(d[lc], d[rc]), mx[k] = max(mx[lc], mx[rc]), mn[k] = min(mn[lc], mn[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(mx[k] = mn[k] = d[k] = x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(p &lt;= m) md(l, m, lc, p, x); <span class="keyword">else</span> md(m + <span class="number">1</span>, r, rc, p, x);</span><br><span class="line">        d[k] = gcd(d[lc], d[rc]), mx[k] = max(mx[lc], mx[rc]), mn[k] = min(mn[lc], mn[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> d[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = gcd(qu(l, m, lc, s, t), ans);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = gcd(qu(m + <span class="number">1</span>, r, rc, s, t), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> mx[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = max(qum(l, m, lc, s, t), ans);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = max(qum(m + <span class="number">1</span>, r, rc, s, t), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qun</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> mn[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = INF;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = min(qun(l, m, lc, s, t), ans);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = min(qun(m + <span class="number">1</span>, r, rc, s, t), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> MX = D.qum(<span class="number">1</span>, n, <span class="number">1</span>, s, t), MN = D.qun(<span class="number">1</span>, n, <span class="number">1</span>, s, t);</span><br><span class="line">    <span class="keyword">if</span>((MX - MN) ^ (t - s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> G = D.qu(<span class="number">1</span>, n, <span class="number">1</span>, s, t);</span><br><span class="line">    <span class="keyword">return</span> G ^ <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    D.bd(<span class="number">1</span>, n, <span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op = read(), x = read(), y = read();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) D.md(<span class="number">1</span>, n, <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">else</span> ck(x, y) ? <span class="built_in">puts</span>(<span class="string">"YES"</span>) : <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-核弹剑仙"><a href="#F-核弹剑仙" class="headerlink" title="F 核弹剑仙"></a>F 核弹剑仙</h3><p>傻题。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, f[CN]; <span class="keyword">bool</span> vis[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(!vis[v]) dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dfs(u); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(vis[i]) ans++;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read(); add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt(i)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是签到走人的一天……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://big-news.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="瞎搞" scheme="https://big-news.cn/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>「题解」Emiya家今天的饭</title>
    <link href="https://big-news.cn/2020/08/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DEmiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/"/>
    <id>https://big-news.cn/2020/08/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DEmiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/</id>
    <published>2020-08-21T11:07:00.000Z</published>
    <updated>2020-08-21T13:33:49.332Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，小葱同学擅长计算几何，但是并不擅长 DP。</p><a id="more"></a><ul><li>$m = 2/3$</li></ul><p>设 $f[i,j,k]$ 表示考虑前 $i$ 行，第一列选了 $j$ 个，第二列选了 $k$ 个的方案数之和，有转移：$$f[i,j,k]\gets f[i-1,j-1,k]·a[i,1]+f[i-1,j,k-1]·a[i,2]$$ $m = 3$ 的情况也同理，多开一维状态就好了，复杂度 $O(n^3)$ 或 $O(n^4)$，能拿到 64pts。</p><ul><li>$m\le 500$</li></ul><p>根据 lorem ipsum 原理，不合法方案中至多有一列的选择数超过 $\lfloor k/2 \rfloor$ ，则考虑补集转化，把不合法的方案 DP 出来。<br>钦点第 $u$ 行不合法，设 $f[i,j,k]$ 表示考虑前 $i$ 行，其它行一共选 $j$ 个， $u$ 行选了 $k$ 个的方案数，有转移：<br>$$ f[i,j,k]\gets f[i-1,j,k]+f[i,j,k-1]·a[i,u]+\sum\limits_{v\neq u} f[i,j-1,k]·a[i,v] $$ 预处理前缀和即可 $O(1)$ 转移，复杂度 $O(mn^3)$，能拿到 84pts。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="number">1l</span>l * ans * (a[i][<span class="number">0</span>] + <span class="number">1</span>) % P; ans = (ans + P - <span class="number">1</span>) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= m; u++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(k) f[i][j][k] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][j][k - <span class="number">1</span>] * a[i][u] % P + f[i][j][k]) % P;</span><br><span class="line">                <span class="keyword">if</span>(j) f[i][j][k] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] * (a[i][<span class="number">0</span>] - a[i][u] + P) % P + f[i][j][k]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = (j + k) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(k &lt;= s) <span class="keyword">continue</span>;</span><br><span class="line">            ans = (ans - f[n][j][k] + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$n\le 100, m \le 2000$</li></ul><p>考虑削状态，设 $f[i,l]$ 表示考虑前 $i$ 行，$n+k-j=l$ 时的方案数，有转移：<br>$$ f[i,l]\gets f[i-1,l]+f[i-1,l+1]·a[i,u]+\sum\limits_{u\neq v}f[i-1,l-1]·a[i,v] $$ 预处理前缀和即可 $O(1)$ 转移，复杂度 $O(mn^2)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="number">1l</span>l * ans * (a[i][<span class="number">0</span>] + <span class="number">1</span>) % P; ans = (ans + P - <span class="number">1</span>) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= m; u++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= (n &lt;&lt; <span class="number">1</span>); l++)&#123;</span><br><span class="line">            f[i][l] = f[i - <span class="number">1</span>][l];</span><br><span class="line">            f[i][l] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][l + <span class="number">1</span>] * a[i][u] + f[i][l]) % P;</span><br><span class="line">            <span class="keyword">if</span>(l) f[i][l] = (<span class="number">1l</span>l * f[i - <span class="number">1</span>][l - <span class="number">1</span>] * (a[i][<span class="number">0</span>] - a[i][u] + P) % P + f[i][l]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) ans = (ans - f[n][l] + P) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，小葱同学擅长计算几何，但是并不擅长 DP。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>01-Trie</title>
    <link href="https://big-news.cn/2020/08/18/01-Trie/"/>
    <id>https://big-news.cn/2020/08/18/01-Trie/</id>
    <published>2020-08-18T05:32:00.000Z</published>
    <updated>2020-09-01T08:21:53.577Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，01-Trie 是字符集为 $\begin{Bmatrix}0,1\end{Bmatrix}$ 的 Trie ，可用于维护若干数字的二进制位，处理点对异或最值、某种动态异或和问题。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>与线性基不同，01-Trie 无法处理子集异或问题，但是可以通过前缀和转化来处理区间异或问题。</div></article><a id="more"></a><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>01-Trie 支持在 $O(\log a_i)$ 的时间内完成如下操作：</p><ul><li>查询全局异或和</li><li>数列全局加一，维护全局异或和</li><li>查询数列中某个数与指定数字异或的最大值</li><li>合并两棵 01-Trie 维护的信息</li></ul><p>通过将其可持久化，还可以支持如下操作：</p><ul><li>查询区间异或和</li><li>查询区间中某个数与指定数字异或的最大值</li></ul><p>通过观察容易实现上述若干操作，则可以得到这样一份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 非可持久化 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TRIE</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> ch[CN * <span class="number">30</span>][<span class="number">2</span>], d[CN * <span class="number">30</span>], w[CN * <span class="number">30</span>], idx, rt, MAXH;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    TRIE() &#123;rt = idx = <span class="number">0</span>, MAXH = <span class="number">30</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mt</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        d[u] = <span class="number">0</span>, w[u] = w[lc] + w[rc];</span><br><span class="line">        <span class="keyword">if</span>(rc) d[u] ^= (d[rc] &lt;&lt; <span class="number">1</span>) | (w[rc] &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lc) d[u] ^= d[lc] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        w[u] &amp;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span></span>&#123;                      <span class="comment">// 插入一个数</span></span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(dep == MAXH) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[u] ^= <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ins(rc, x &gt;&gt; <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ins(lc, x &gt;&gt; <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">        mt(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">if</span>(rc) add(rc); swap(lc, rc), mt(u);&#125; <span class="comment">// 全局加一</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> d[rt];&#125;                              <span class="comment">// 全局异或和</span></span><br><span class="line">&#125; D;</span><br></pre></td></tr></table></figure><p>注意，01-Trie 的可持久化看上去并不支持版本修改，因为无法使用树状数组维护子树交换信息。</p><h3 id="2-一道栗题"><a href="#2-一道栗题" class="headerlink" title="2 一道栗题"></a>2 一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「TJOI2017」异或和</strong></p><p>给定一段数列，定义数列的“连续和”为数列的某个子串的所有数之和，求序列所有连续和的异或值。</p></div></article><p>考虑固定左端点 $l$ ，$O(n)$ 枚举右端点 $r$ ，则可以求出一些左端点固定的区间 $[l,r]$ 权值和异或和。</p><p>考虑优化这个过程：对于一个左端点 $l$ ，如何快速求出其能对应的所有区间 $[l,r]$ 的异或和。由于数列是静态的，那么我们考虑 $l\to l-1$ 时贡献的变化，它应该是这个样子：</p><p>$$\begin{aligned} &amp; (s[n]-s[l])\oplus (s[n-1]-s[l])\oplus … \oplus (s[l+1]-s[l]) \newline \to &amp;(s[n]-s[l]+a[l-1])\oplus (s[n-1]-s[l]+a[l-1])\oplus …\oplus a[l-1] \end{aligned}$$</p><p>其中 $s[]$ 代表 $a[]$ 的前缀和。容易发现这个变化是对每一项同时加了一个值之后再查询异或和，显然可以通过 01-Tire 来维护，总复杂度 $O((n+\sum a_i)\log a_i)$；由于 $\sum a_i \le 10^6$，所以可以通过。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123; <span class="comment">/* 略 */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TRIE</span> &#123;</span> <span class="comment">/* 同上 */</span> &#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i + <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(s--) D.add( D.rt );</span><br><span class="line">        D.ins(D.rt, a[i + <span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        ans ^= D.sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-又一道栗题"><a href="#3-又一道栗题" class="headerlink" title="3 又一道栗题"></a>3 又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「TJOI2018」异或</strong></p><p>现在有一颗以 $1$ 为根节点的由 $n$ 个节点组成的树，节点从 $1$ 至 $n$ 编号。树上每个节点上都有一个权值 $v_i$。现在有 $q$ 次操作，操作如下：</p><ul><li>1 x z：查询节点 $x$ 的子树中的节点权值与 $z$ 异或结果的最大值。</li><li>2 x y z：查询节点 $x$ 到节点 $y$ 的简单路径上的节点的权值与 $z$ 异或结果最大值。</div></article></li></ul><p>容易想到树剖，则转化为序列上的查询操作。通过版本来区分区间，即将 01-Tire 可持久化，即可解决本题。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>可持久化 01-Trie 一般用于处理静态区间异或最大值问题。</div></article><p>容易得到如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TRIE</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> rt[CN], ch[CN * <span class="number">30</span>][<span class="number">2</span>], w[CN * <span class="number">30</span>], MAXH, idx;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    TRIE() &#123;idx = <span class="number">0</span>, MAXH = <span class="number">31</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(dep &lt; <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[u] = w[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> b = (x &gt;&gt; dep) &amp; <span class="number">1</span>; ch[u][!b] = ch[v][!b];</span><br><span class="line">        ins(ch[u][b], ch[v][b], x, dep - <span class="number">1</span>);</span><br><span class="line">        w[u] = w[lc] + w[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qm</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> k, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = (k &gt;&gt; dep) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(w[ ch[u][!b] ] &gt; w[ ch[v][!b] ]) <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; dep) | qm(ch[u][!b], ch[v][!b], k, dep - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qm(ch[u][b], ch[v][b], k, dep - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, v[CN], oid[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> top[CN], id[CN], sz[CN], imp[CN], dep[CN], fa[CN], idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[p] + <span class="number">1</span>, sz[u] = <span class="number">1</span>, fa[u] = p; <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs1(v, u), sz[u] += sz[v], mx = sz[v] &gt; mx ? imp[u] = v, sz[v] : mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    top[u] = t, id[u] = ++idx;</span><br><span class="line">    <span class="keyword">if</span>(imp[u]) dfs2(imp[u], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ imp[u] &amp;&amp; v ^ fa[u]) dfs2(v, v); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[ top[x] ] &lt; dep[ top[y] ]) swap(x, y);</span><br><span class="line">        ans = max(ans, D.qm(D.rt[ id[x] ], D.rt[ id[ top[x] ] - <span class="number">1</span> ], z, D.MAXH));</span><br><span class="line">        x = fa[ top[x] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    ans = max(ans ,D.qm(D.rt[ id[x] ], D.rt[ id[y] - <span class="number">1</span> ], z, D.MAXH));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> id[x] &lt; id[y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = read(), oid[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"></span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    sort(oid + <span class="number">1</span>, oid + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.ins(D.rt[i], D.rt[i - <span class="number">1</span>], v[ oid[i] ], D.MAXH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> o = read(), x = read(), y = read(), z;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.qm(D.rt[ id[x] + sz[x] - <span class="number">1</span> ], D.rt[ id[x] - <span class="number">1</span> ], y, D.MAXH)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> z = read(), <span class="built_in">printf</span>(<span class="string">"%d"</span>, qu(x, y, z)), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-双一道栗题"><a href="#4-双一道栗题" class="headerlink" title="4 双一道栗题"></a>4 双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「联合省选 2020 A」树</strong></p><p>给定一棵 $n$ 个结点的有根树 $T$，结点从 $1$ 开始编号，根结点为 $1$ 号结点，每个结点有一个正整数权值 $v_i$。<br>设 $x$ 号结点的子树内（包含 $x$ 自身）的所有结点编号为 $c_1,c_2,\dots,c_k$，定义 $x$ 的价值为：<br>$$val(x)=(v_{c_1}+d(c_1,x)) \oplus (v_{c_2}+d(c_2,x)) \oplus \cdots \oplus (v_{c_k}+d(c_k, x))$$<br>其中 $d(x,y)$ 表示树上 $x$ 号结点与 $y$ 号结点间唯一简单路径所包含的边数，$d(x,x) = 0$。$\oplus$ 表示异或运算。<br>请你求出 $\sum\limits_{i=1}^n val(i)$ 的结果。</p></div></article><p>对每个叶子建立一棵 01-Trie ，然后每次合起来再全局加一即可得到父亲的 01-Trie ，统计答案即可。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>01-Trie 合并的序列意义是：把两段序列的所有数字插入同一个 01-Trie ，并维护异或和。</div></article><p>容易得到如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125;&#125;E[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN],ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">trie</span>&#123;</span> <span class="comment">// dep = 0,dep &gt; 20</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> ch[CN * <span class="number">30</span>][<span class="number">2</span>], w[CN * <span class="number">30</span>], val[CN * <span class="number">30</span>], rt[CN], tot;</span><br><span class="line">    trie() &#123;<span class="built_in">memset</span>(rt, <span class="number">0</span>, <span class="keyword">sizeof</span>(rt)); tot = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> u = ++tot; lc = rc = w[u] = val[u] = <span class="number">0</span>; <span class="keyword">return</span> tot;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        w[u] = val[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(lc) w[u] += w[lc], val[u] ^= val[lc] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(rc) w[u] += w[rc], val[u] ^= (val[rc] &lt;&lt; <span class="number">1</span>) | w[rc];</span><br><span class="line">        w[u] &amp;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> x,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(dep &gt; <span class="number">20</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(w[u] ^= <span class="number">1</span>);</span><br><span class="line">        ins(ch[u][x &amp; <span class="number">1</span>], x &gt;&gt; <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">        maintain(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addall</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">if</span>(rc) addall(rc); swap(lc, rc); maintain(u);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k) <span class="keyword">return</span> u; <span class="keyword">if</span>(!u) <span class="keyword">return</span> k;</span><br><span class="line">        w[u] = (w[u] + w[k]) &amp; <span class="number">1</span>; val[u] ^= val[k];</span><br><span class="line">        lc = merge(lc, ch[k][<span class="number">0</span>]); rc = merge(rc, ch[k][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,v[CN],va[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!hd[u])&#123;</span><br><span class="line">        va[u] = v[u];</span><br><span class="line">        D.ins(D.rt[u], v[u], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = hd[u], s1;</span><br><span class="line">    <span class="keyword">for</span>(; k; k = E[k].nxt) dfs(E[k].to);</span><br><span class="line">    </span><br><span class="line">    k = hd[u], s1 = E[k].to, k = E[k].nxt, D.rt[u] = D.rt[s1];</span><br><span class="line">    <span class="keyword">for</span>(; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        D.merge(D.rt[u], D.rt[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    D.addall(D.rt[u]), D.ins(D.rt[u], v[u], <span class="number">0</span>);</span><br><span class="line">    va[u] = D.val[ D.rt[u] ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) v[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) add(read(), i);</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans += <span class="number">1l</span>l * va[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，01-Trie 是字符集为 $\begin{Bmatrix}0,1\end{Bmatrix}$ 的 Trie ，可用于维护若干数字的二进制位，处理点对异或最值、某种动态异或和问题。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-primary&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-lightbulb mr-2&quot;&gt;&lt;/i&gt;
与线性基不同，01-Trie 无法处理子集异或问题，但是可以通过前缀和转化来处理区间异或问题。
&lt;/div&gt;
&lt;/article&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字典树" scheme="https://big-news.cn/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>主席树</title>
    <link href="https://big-news.cn/2020/08/17/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>https://big-news.cn/2020/08/17/%E4%B8%BB%E5%B8%AD%E6%A0%91/</id>
    <published>2020-08-17T00:47:00.000Z</published>
    <updated>2020-08-26T08:42:42.419Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，主席树即可持久化值域线段树， 用于解决区间 $k$ 小值问题以及动态二维数点问题。</p><a id="more"></a><h3 id="1-静态主席树"><a href="#1-静态主席树" class="headerlink" title="1 静态主席树"></a>1 静态主席树</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>静态区间 k 小值</strong></p><p>给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。</p></div></article><p>静态主席树一般指可持久化值域线段树，并不支持修改操作。</p><p>容易发现区间信息是满足可减性的，则只需要在每次插入时建立一个船新版本即可，查询也只需要对两个历史版本作差便能得到区间信息。<br>类似的，01-Trie 与 Treap 之类的无法维护区间信息的数据结构也可以通过可持久化来实现区间信息的维护。</p><p>容易得出下面的这份代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] = d[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, ch[v][<span class="number">0</span>], l, m, p), rc = ch[v][<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">else</span> md(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p), lc = ch[v][<span class="number">0</span>];</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = d[lc] - d[ ch[v][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= k) <span class="keyword">return</span> qu(lc, ch[v][<span class="number">0</span>], l, m, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qu(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, k - s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = a[i] = read();</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + n + <span class="number">1</span>);</span><br><span class="line">    val[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[ ++val[<span class="number">0</span>] ] = val[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.md(D.rt[i], D.rt[i - <span class="number">1</span>], <span class="number">1</span>, val[<span class="number">0</span>], id( a[i] ));</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), k = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, val[ D.qu( D.rt[r], D.rt[l - <span class="number">1</span>], <span class="number">1</span>, val[<span class="number">0</span>], k ) ]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-带修主席树"><a href="#2-带修主席树" class="headerlink" title="2 带修主席树"></a>2 带修主席树</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>动态区间 k 小值</strong></p><p>给定一个含有 $n$ 个数的序列 $a_1, a_2, …, a_n$ ，需要支持两种操作：</p><ul><li>Q l r k 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数</li><li>C x y 表示将 $a_x$ 改为 $y$</div></article></li></ul><p>带修主席树一般指树状数组套可持久化值域线段树。</p><p>容易发现主席树的每个版本是对区间信息做一个前缀和，这样如果在某个版本上修改是 $O(n)$ 的。<br>既然是前缀和，套用树状数组的方式写主席树就好了，复杂度 $O(n\log^2n)$ 。</p><p>于是容易得到下面的这份代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], rt[CN], idx, n;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 修改不新建版本</span></span><br><span class="line">        <span class="keyword">if</span>(!u) u = make();</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, l, m, p, x); <span class="keyword">else</span> md(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 修改 BIT 中所有的树</span></span><br><span class="line">        <span class="keyword">while</span>(u &lt;= rt[<span class="number">0</span>]) md(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t1[<span class="number">101</span>], t2[<span class="number">101</span>]; <span class="comment">// 把 O(log) 棵主席树的根搞下来</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qu_pre</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="comment">// (l, r]</span></span><br><span class="line">        t1[<span class="number">0</span>] = t2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = l; <span class="keyword">while</span>(u) t1[ ++t1[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">        u = r; <span class="keyword">while</span>(u) t2[ ++t2[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) s -= d[ ch[ t1[i] ][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) s += d[ ch[ t2[i] ][<span class="number">0</span>] ];</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(l, m, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(m + <span class="number">1</span>, r, k - s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QUERY</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> tp, a, b, c;</span><br><span class="line">&#125; Q[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    D.rt[<span class="number">0</span>] = n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[ ++val[<span class="number">0</span>] ] = a[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c; <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'Q'</span>) Q[i].tp = <span class="number">0</span>, Q[i].a = read(), Q[i].b = read(), Q[i].c = read();</span><br><span class="line">        <span class="keyword">else</span> Q[i].tp = <span class="number">1</span>, Q[i].a = read(), val[ ++val[<span class="number">0</span>] ] = Q[i].b = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[ ++cnt ] = val[i];</span><br><span class="line">    D.n = val[<span class="number">0</span>] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.cg(i, id( a[i] ), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Q[i].tp)&#123;</span><br><span class="line">            D.qu_pre(Q[i].a - <span class="number">1</span>, Q[i].b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, val[ D.qu(<span class="number">1</span>, val[<span class="number">0</span>], Q[i].c) ]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            D.cg(Q[i].a, id( a[ Q[i].a ] ), <span class="number">-1</span>), a[ Q[i].a ] = Q[i].b, D.cg(Q[i].a, id( a[ Q[i].a ] ), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，导致其常数巨大，不过它依然能在 1s 左右的时间内通过此题。</p><h3 id="3-一道栗题"><a href="#3-一道栗题" class="headerlink" title="3 一道栗题"></a>3 一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「CQOI2011」动态逆序对</strong></p><p>给出 $1\sim n$ 的一个排列，按照某种顺序依次删除 $m$ 个元素，在每次删除一个元素之前统计整个序列的逆序对数。</p></div></article><p>如果是静态问题，那么只需要用权值树状数组就可以简单维护。</p><p>由于只有删除操作，考虑计算删除一个元素对答案的贡献（实际上是减少量而不是增加量），容易发现这样的查询同时存在下标和权值两个维度；下标即通过版本来区分，因此用主席树。考虑到修改和影响传递的过程，仿照上题套一个树状数组即可。</p><p>于是容易得到如下代码。同样的，由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，其常数巨大，不过它依然能在 1.2s 左右的时间内通过此题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], rt[CN], ch[CN * <span class="number">50</span>][<span class="number">2</span>], idx, n;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    SGT() &#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(lc, l, m, p, x); <span class="keyword">else</span> md(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(u &lt;= rt[<span class="number">0</span>]) md(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t[CN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pqu</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = r; <span class="keyword">while</span>(u) t[ ++t[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) s += d[ t[i] ];</span><br><span class="line">            <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) t[i] = ch[ t[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> qu(l, m, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) s += d[ ch[ t[i] ][<span class="number">0</span>] ];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t[<span class="number">0</span>]; i++) t[i] = ch[ t[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> s + qu(m + <span class="number">1</span>, r, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN], rk[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = a[i] = read(), rk[ a[i] ] = i;</span><br><span class="line">    D.rt[<span class="number">0</span>] = D.n = n;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        D.cg(i, a[i], <span class="number">1</span>), D.pqu(i - <span class="number">1</span>), ans -= D.qu(<span class="number">1</span>, n, a[i]), D.pqu(i - <span class="number">1</span>), ans += D.qu(<span class="number">1</span>, n, n);</span><br><span class="line"></span><br><span class="line">    m -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> x = read(), p = rk[x], s1, s2;</span><br><span class="line">        D.cg(p, x, <span class="number">-1</span>);</span><br><span class="line">        D.pqu(p - <span class="number">1</span>), s2 = D.qu(<span class="number">1</span>, n, x);</span><br><span class="line">        D.pqu(p - <span class="number">1</span>), s1 = D.qu(<span class="number">1</span>, n, n) - s2;</span><br><span class="line">        D.pqu(n), s2 = D.qu(<span class="number">1</span>, n, x) - s2;</span><br><span class="line">        ans -= s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-二维数点"><a href="#4-二维数点" class="headerlink" title="4 二维数点"></a>4 二维数点</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p><strong>「SHOI2007」园丁的烦恼</strong></p><p>维护二维坐标系上的 $n$ 个点，$q$ 次查询矩形 $(a,b):(c,d)$ 内的点的个数。</p></div></article><p>二维数点是一类宽泛的 RMQ 问题，甚至于许多树上问题都能通过 dfs 序转化成二维数点问题。</p><p>众所周知，带修主席树可以用来解决动态二维数点问题，其本质与上面的题目类似。对于静态的二维数点，带修主席树 $O(n\log^2n)$ 的复杂度要比 $O(n\log n)$ 的树状数组解法要劣，可通过实现一个版本修改函数来避免带修。具体实现也较为简单，因此不再赘述。</p><p>这里给出一份带修主席树解决静态二维数点的代码，使用时需注意常数因子对程序效率带来的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], rt[CN], idx, n, m;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++idx;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pmd</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = make(); <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] += x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span>(p &lt;= m) pmd(lc, l, m, p, x); <span class="keyword">else</span> pmd(rc, m + <span class="number">1</span>, r, p, x);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(u &lt;= m) pmd(rt[u], <span class="number">1</span>, n, p, x), u += lb(u);&#125;</span><br><span class="line">    <span class="keyword">int</span> t1[<span class="number">25</span>], t2[<span class="number">25</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pqu</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = s; t1[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">while</span>(u) t1[ ++t1[<span class="number">0</span>] ] = rt[u], u -= lb(u);</span><br><span class="line">        u = t; t2[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">while</span>(u) t2[ ++t2[<span class="number">0</span>] ] = rt[u], u -= lb(u); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) ans += d[ t2[i] ];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) ans -= d[ t1[i] ];</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>, tmp1[<span class="number">25</span>], tmp2[<span class="number">25</span>];</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m &lt; t) <span class="built_in">memcpy</span>(tmp1, t1, <span class="keyword">sizeof</span>(t1)), <span class="built_in">memcpy</span>(tmp2, t2, <span class="keyword">sizeof</span>(t2));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">0</span>];</span><br><span class="line">            ans += qu(l, m, s, t);</span><br><span class="line">            <span class="keyword">if</span>(m &lt; t) <span class="built_in">memcpy</span>(t1, tmp1, <span class="keyword">sizeof</span>(tmp1)), <span class="built_in">memcpy</span>(t2, tmp2, <span class="keyword">sizeof</span>(tmp2));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(m &lt; t)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t1[<span class="number">0</span>]; i++) t1[i] = ch[ t1[i] ][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t2[<span class="number">0</span>]; i++) t2[i] = ch[ t2[i] ][<span class="number">1</span>];</span><br><span class="line">            ans += qu(m + <span class="number">1</span>, r, s, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, vX[CN], vY[CN], X[CN], Y[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(vX + <span class="number">1</span>, vX + vX[<span class="number">0</span>] + <span class="number">1</span>, x) - vX;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idy</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(vY + <span class="number">1</span>, vY + vY[<span class="number">0</span>] + <span class="number">1</span>, x) - vY;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QU</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> a, b, c, d;&#125; q[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vX[i] = X[i] = read() + <span class="number">1</span>, vY[i] = Y[i] = read() + <span class="number">1</span>; vX[<span class="number">0</span>] = vY[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) vX[ ++vX[<span class="number">0</span>] ] = q[i].a = read() + <span class="number">1</span>, vY[ ++vY[<span class="number">0</span>] ] = q[i].b = read() + <span class="number">1</span>, vX[ ++vX[<span class="number">0</span>] ] = q[i].c = read() + <span class="number">1</span>, vY[ ++vY[<span class="number">0</span>] ] = q[i].d = read() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sort(vX + <span class="number">1</span>, vX + vX[<span class="number">0</span>] + <span class="number">1</span>), sort(vY + <span class="number">1</span>, vY + vY[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= vX[<span class="number">0</span>]; i++) <span class="keyword">if</span>(vX[i] ^ vX[i - <span class="number">1</span>]) vX[++tmp] = vX[i]; vX[<span class="number">0</span>] = tmp;</span><br><span class="line">    tmp = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= vY[<span class="number">0</span>]; i++) <span class="keyword">if</span>(vY[i] ^ vY[i - <span class="number">1</span>]) vY[++tmp] = vY[i]; vY[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    D.n = vY[<span class="number">0</span>], D.m = vX[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D.md( idx( X[i] ), idy( Y[i] ), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = q[i].a, b = q[i].b, c = q[i].c, d = q[i].d;</span><br><span class="line">        D.pqu(idx(a) - <span class="number">1</span>, idx(c)), <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.qu(<span class="number">1</span>, D.n, idy(b), idy(d))), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-clock mr-2"></i>最近更新：2020-8-26 添加了二维数点的内容。</div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，主席树即可持久化值域线段树， 用于解决区间 $k$ 小值问题以及动态二维数点问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://big-news.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="https://big-news.cn/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="可持久化" scheme="https://big-news.cn/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>后缀树</title>
    <link href="https://big-news.cn/2020/08/16/%E5%90%8E%E7%BC%80%E6%A0%91/"/>
    <id>https://big-news.cn/2020/08/16/%E5%90%8E%E7%BC%80%E6%A0%91/</id>
    <published>2020-08-16T08:03:00.000Z</published>
    <updated>2020-08-16T12:08:29.441Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知：后缀树是不对劲的 Tire 树….</p><a id="more"></a><p>后缀树即是路径压缩之后的后缀 Trie ，满足其中的 <strong>一些节点</strong> 可以双射原串的所有后缀。<br>其分为 <strong>显示构造</strong> 与 <strong>隐式构造</strong> 两种，区别在于是否在字符串尾添加一个终止符。其中，显示构造的后缀树满足每个叶子双射原串的一个后缀。</p><p>众所周知，SAM 的 Parent 树是反串的后缀树，从而可以通过将字符串倒着插入 SAM 来得到一个串的后缀树。注意，这样得到的后缀树是隐式构造的。</p><p>后缀树为我们提供了一个新的思路：两个字符串的 LCP 是它们在 Trie 上的 LCA ，则两个后缀的 LCP 也是它们在后缀树上的 LCA。这可以被形式化地表达如下：</p><p>$$ \text{LCP}(s[i:n], s[j:n]) = \text{len}[ \text{LCA}(i, j) ] $$</p><p>其中等号后面的 $i, j$ 应当对应为在树上的编号，$\text{len}[]$ 即为 SAM 中的 <code>len[]</code> 数组。</p><p>给出一份查询两个后缀的 LCP 的代码。显然，该份代码也可以通过 SA 实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) ne = c == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> len[CN &lt;&lt; <span class="number">1</span>], nxt[CN &lt;&lt; <span class="number">1</span>], son[CN &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], lst, idx; </span><br><span class="line">    SAM() &#123;nxt[<span class="number">0</span>] = <span class="number">-1</span>, idx = lst = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">et</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = ++idx, p = lst;</span><br><span class="line">        len[u] = len[p] + <span class="number">1</span>, lst = u;</span><br><span class="line">        <span class="keyword">while</span>(p ^ <span class="number">-1</span> &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">-1</span>) <span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">int</span> d = son[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[d] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> nxt[u] = d, idx;</span><br><span class="line">        <span class="keyword">int</span> v = ++idx;</span><br><span class="line">        nxt[v] = nxt[d], nxt[d] = nxt[u] = v, len[v] = len[p] + <span class="number">1</span>, <span class="built_in">memcpy</span>(son[v], son[d], <span class="keyword">sizeof</span>(son[d]));</span><br><span class="line">        <span class="keyword">while</span>(p ^ <span class="number">-1</span> &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p];</span><br><span class="line">        <span class="keyword">return</span> idx - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, id[CN]; <span class="keyword">char</span> ch[CN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; to[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D.idx; i++) to[ D.nxt[i] ].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[CN][<span class="number">30</span>], dep[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>; <span class="keyword">int</span> sz = to[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v) &#123;<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][<span class="number">0</span>];&#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch; n = <span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i + <span class="number">1</span>; i--) id[i + <span class="number">1</span>] = D.et( ch[i] - <span class="string">'a'</span> );</span><br><span class="line"></span><br><span class="line">    rbd(), dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D.idx; i++)</span><br><span class="line">            fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = read(), j = read(), l = lca( id[i], id[j] );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, D.len[l]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知：后缀树是不对劲的 Tire 树….&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="后缀树" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>组合数学再基础</title>
    <link href="https://big-news.cn/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/"/>
    <id>https://big-news.cn/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-07T06:00:00.000Z</published>
    <updated>2020-09-01T08:20:00.153Z</updated>
    
    <content type="html"><![CDATA[<p>之前好像写过「组合数学基础」，在这里再来堆点柿子。</p><a id="more"></a><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-asia mr-2"></i>此页面存在相关页面。关于组合数学基础，请参见<a href="/2019/07/26/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">「组合数学基础」</a>。</div></article><h3 id="1-Stirling-数"><a href="#1-Stirling-数" class="headerlink" title="1 Stirling 数"></a>1 Stirling 数</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>众所周知，Stirling 数有两类，分别是：</p><p>$$ \begin{align} \begin{bmatrix}n\newline m \end{bmatrix} = \begin{bmatrix}n-1\newline m-1 \end{bmatrix}+(n-1)\begin{bmatrix}n-1\newline m \end{bmatrix}  \newline  \begin{Bmatrix}n\newline m \end{Bmatrix}=\begin{Bmatrix}n-1\newline m-1\end{Bmatrix}+m \begin{Bmatrix}n-1\newline m \end{Bmatrix} \end{align} \tag1 $$</p><p>接下来介绍 Stirling 数的性质。</p><h4 id="1-2-常幂展开"><a href="#1-2-常幂展开" class="headerlink" title="1.2 常幂展开"></a>1.2 常幂展开</h4><p>一个组合意义显然的柿子：</p><p>$$ \begin{align} n^m &amp;= \sum\limits_{k=0}^m  \begin{Bmatrix}m\newline k \end{Bmatrix}k! \dbinom{n}{k} \tag2 \newline &amp;= \sum\limits_{k=0}^m  \begin{Bmatrix}m\newline k\end{Bmatrix} n^{\underline{k}} \tag{3} \end{align} $$</p><p>$(3)$ 式通常被称为 <strong>常幂展开</strong>。</p><h4 id="1-3-Stirling-反演"><a href="#1-3-Stirling-反演" class="headerlink" title="1.3 Stirling 反演"></a>1.3 Stirling 反演</h4><p>$$ f(n) = \sum\limits_{k=0}^n \begin{Bmatrix}n\newline k\end{Bmatrix} g(k) \Leftrightarrow g(n) = \sum\limits_{k=0}^n (-1)^{n - k} \begin{bmatrix}n\newline k\end{bmatrix} f(k)  \tag{4} $$</p><p>$(4)$ 式通常被称为 <strong>Stirling 反演公式</strong>。</p><h4 id="1-4-阶乘幂展开"><a href="#1-4-阶乘幂展开" class="headerlink" title="1.4 阶乘幂展开"></a>1.4 阶乘幂展开</h4><p>对 $(3)$ 应用 $(4)$ 式得：</p><p>$$ n^{\underline{m}}= \sum\limits_{k=0}^m (-1)^{m-k} \begin{bmatrix}m\newline k\end{bmatrix} n^k \tag{5} $$</p><p>可以证明有：</p><p>$$ n^{\overline{m}}= \sum\limits_{k=0}^m \begin{bmatrix}m\newline k\end{bmatrix} n^k \tag{6} $$</p><p>$(5),(6)$ 两式被称作 <strong>阶乘幂展开</strong>。</p><h3 id="2-组合数"><a href="#2-组合数" class="headerlink" title="2 组合数"></a>2 组合数</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>众所周知，小葱同学擅长计算，尤其擅长计算组合数，但是这跟本文的主题并没有什么关系。</div></article><p>小葱同学擅长计算的组合数定义为：</p><p>$$\dbinom{n}{m} = \dbinom{n-1}{m} + \dbinom{n-1}{m-1}$$</p><h4 id="2-2-二项式定理"><a href="#2-2-二项式定理" class="headerlink" title="2.2 二项式定理"></a>2.2 二项式定理</h4><p>$$(x+y)^k = \sum\limits_{i=0}^k \dbinom{k}{i} x^i y^{k-i} \tag{7}$$</p><p>$(7)$ 式被称作 <strong>二项式定理</strong>。</p><h4 id="2-3-组合恒等式"><a href="#2-3-组合恒等式" class="headerlink" title="2.3 组合恒等式"></a>2.3 组合恒等式</h4><ul><li>组合恒等式 I</li></ul><p>在 $(7)$ 式中令 $x=y=1$ ，得：</p><p>$$\sum\limits_{i=0}^k \dbinom{k}{i} = 2^k \tag{8}$$</p><ul><li>组合恒等式 II</li></ul><p>$$\sum\limits_{i=0}^k \dbinom{k}{i}[2|i] =\sum\limits_{i=0}^k \dbinom{k}{i}[2\nmid i] = 2^{k-1} \tag9$$</p><p>证明显然。</p><ul><li>组合恒等式  III</li></ul><p>$$\dbinom{n}{k}\dbinom{k}{j} = \dbinom{n}{j} \dbinom{n-j}{k-j} \tag{10}$$</p><p>证明显然。</p><ul><li>组合恒等式 IV</li></ul><p>$$\begin{align} \sum\limits_{i=m}^n \dbinom{i}{m} &amp;= \dbinom{n+1}{m+1} \tag{11} \newline<br>\sum\limits_{i=0}^n \dbinom{m+i}{m} &amp;= \dbinom{n+m+1}{n} \tag{12} \end{align}$$</p><p>证明显然。</p><ul><li>组合恒等式 V</li></ul><p>$$ \dbinom{n+m}{k}= \sum\limits_{i=0}^k \dbinom{n}{i}\dbinom{m}{k-i} \tag{13}$$</p><p>证明显然。</p><p>$(8),(9),(10),(11),(12),(13)$ 式通常被称作 <strong>组合恒等式</strong>。</p><h4 id="2-4-二项式反演"><a href="#2-4-二项式反演" class="headerlink" title="2.4 二项式反演"></a>2.4 二项式反演</h4><ul><li>形式  I</li></ul><p>$$ f(n) = \sum\limits_{k=0}^n (-1)^k\dbinom{n}{k} g(k) \Leftrightarrow g(n) = \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k} f(k)  \tag{14} $$</p><ul><li>形式  II</li></ul><p>$$ f(n) = \sum\limits_{k=0}^n\dbinom{n}{k} g(k) \Leftrightarrow g(n) = \sum\limits_{k=0}^n (-1)^{n-k} \dbinom{n}{k} f(k)  \tag{15} $$</p><ul><li>形式  III</li></ul><p>$$ f(n) = \sum\limits_{k=n}^m\dbinom{k}{n} g(k) \Leftrightarrow g(n) = \sum\limits_{k=n}^m (-1)^{k-n} \dbinom{k}{n} f(k)  \tag{16} $$</p><p>$(14),(15),(16)$ 式被称作 <strong>二项式反演公式</strong>。</p><h4 id="2-5-第二类-Stirling-数通项"><a href="#2-5-第二类-Stirling-数通项" class="headerlink" title="2.5 第二类 Stirling 数通项"></a>2.5 第二类 Stirling 数通项</h4><p>对 $(2)$ 式应用 $(15)$ 式得：</p><p>$$ \begin{Bmatrix}n\newline m \end{Bmatrix}m! = \sum\limits_{k=0}^m  (-1)^k \dbinom{m}{k} (m-k)^n \tag{17} $$</p><p>其中 $(17)$ 式被称为 <strong>第二类 Stirling 数通项公式</strong>。</p><h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3 应用"></a>3 应用</h3><p><a href="https://darkbzoj.tk/problem/2839">「bzoj2839」集合计数</a><br><a href="https://darkbzoj.tk/problem/3622">「bzoj3622」已经没有什么好害怕的了</a><br><a href="https://codeforces.com/problemset/problem/932/E">「CF932E」 Team Work</a><br><a href="https://vjudge.net/problem/TopCoder-13444">「2018 雅礼集训」方阵</a><br><a href="https://loj.ac/problem/2058">「TJOI / HEOI2016」求和</a><br><a href="https://loj.ac/problem/6716">「LOJ #6716.」 自然数幂之和</a><br><a href="https://loj.ac/problem/3300">「2020联考A卷」组合数问题</a><br>「各种数数题」…</p><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-clock mr-2"></i>最近更新： 2020.8.9</div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前好像写过「组合数学基础」，在这里再来堆点柿子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数论" scheme="https://big-news.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="排列组合" scheme="https://big-news.cn/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>「题解」Typewriter</title>
    <link href="https://big-news.cn/2020/08/06/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DTypewriter/"/>
    <id>https://big-news.cn/2020/08/06/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DTypewriter/</id>
    <published>2020-08-06T14:30:00.000Z</published>
    <updated>2020-08-17T07:56:40.554Z</updated>
    
    <content type="html"><![CDATA[<p>一道很好的SAM+DP综合题，虽然说坑点也很多……</p><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6583">原题链接</a></p><p>考虑DP。设 $f[i]$ 为考虑前 $i$ 个位置的答案，应当有转移 $f[i] = \min f[i - 1] + p, f[l]+q$ ，其中 $l$ 满足 $s[l+1:r]\subseteq s[1:l]$ 。$f[]$ 显然是不降的，那么我们应取最小的 $l$ 。</p><p>考虑 $r\to r + 1$ ，容易发现 $l$ 是不降的；那么对 $s[1:l]$ 建立SAM，每次尝试扩展 $s[r+1]$，如果不行则令 $l\to l + 1$，即可找到最小的 $l$。维护当前的 $s[l+1:r]$ 对应在SAM上的路径，则可 O(1) 做到删除该路径上的第一个字符 $s[l+1]$ ，然后再扩展出$s[r+1]$即可。</p><p>小细节：当SAM在<code>extend()</code>的时候，若该路径的终点 $d$ 被拆成了 $v,d’$ 两个节点，且$\text{nxt}[d’]=v$，则应当将路径的终点变换为 $v$，否则维护的路径就被破坏了。<br>HDU不给数据，然后上面那个坑点卡了我一晚上…</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, prv[CN]; <span class="keyword">long</span> <span class="keyword">long</span> p, q, f[CN]; <span class="keyword">char</span> s[CN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> nxt[CN &lt;&lt; <span class="number">1</span>], son[CN &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], len[CN &lt;&lt; <span class="number">1</span>], sz, lst, cur, l;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (n &lt;&lt; <span class="number">1</span>);i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++) son[i][j] = <span class="number">0</span>; <span class="comment">// 题目卡memset()</span></span><br><span class="line">        sz = <span class="number">1</span>, lst = cur = l = len[<span class="number">0</span>] = <span class="number">0</span>, nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">et</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = sz++, p = lst;</span><br><span class="line">        lst = u, len[u] = len[p] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">-1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(nxt[u] = <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> d = son[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[d] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(nxt[u] = d);</span><br><span class="line">        <span class="keyword">int</span> v = sz++; </span><br><span class="line">        <span class="keyword">if</span>(d == cur) cur = v; <span class="comment">// 坑点</span></span><br><span class="line">        len[v] = len[p] + <span class="number">1</span>, nxt[v] = nxt[d], nxt[d] = nxt[u] = v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) son[v][i] = son[d][i];</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;<span class="keyword">if</span>(nxt[cur] != <span class="number">-1</span> &amp;&amp; --l == len[ nxt[cur] ]) cur = nxt[cur];&#125;   <span class="comment">// delete</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">rd</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;<span class="keyword">return</span> son[cur][c] ? cur = son[cur][c], l++, <span class="literal">true</span> : <span class="literal">false</span>;&#125; <span class="comment">// read</span></span><br><span class="line">&#125;D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    freopen(<span class="string">"_in.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">// freopen("wa.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>))&#123;</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;p, &amp;q), D.init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>; D.et(s[<span class="number">1</span>] - <span class="string">'a'</span>), prv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!D.rd(s[i] - <span class="string">'a'</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(l + <span class="number">1</span> == i) &#123;flag = <span class="literal">false</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">                D.del(), D.et(s[++l] - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            prv[i] = flag ? l : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!flag) D.et(s[++l] - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">1</span>] = p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">if</span>(prv[i]) f[i] = min(f[i - <span class="number">1</span>] + p, f[ prv[i] ] + q);</span><br><span class="line">            <span class="keyword">else</span> f[i] = f[i - <span class="number">1</span>] + p;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道很好的SAM+DP综合题，虽然说坑点也很多……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="后缀自动机" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>「题解」AC自动机（简单版）</title>
    <link href="https://big-news.cn/2020/08/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DAC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/"/>
    <id>https://big-news.cn/2020/08/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DAC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/</id>
    <published>2020-08-04T07:01:00.000Z</published>
    <updated>2020-08-17T07:56:40.555Z</updated>
    
    <content type="html"><![CDATA[<p>虽然说这题是AC自动机吧…但是后缀数组也能解。<br>在这里提供一个清新的后缀数组解法。</p><a id="more"></a><h3 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h3><p>后缀数组是个好东西啊，通过这个工具可以解决许多类型的字符串问题，这里简单介绍一下：</p><p>形式化地，对于一个长度为 $n$ 的字符串 $s$，它的形如 $s[i:n]$ 的子串被称作 $s$ 的后缀。</p><p>容易发现 $s$ 一共有 $n$ 个后缀，不妨记 $s[i:n]$ 为后缀 $i$，将所有的后缀排序后，顺序写下后缀的编号，就得到了后缀数组 (Suffix Array)。</p><p>举个例子，对 $s=ababa$，其后缀有 $a,ba,aba,baba,ababa$，排序后得到 $a,aba,ababa,ba,baba$，依次写下其编号，得到后缀数组为 $5,3,1,2,4$。</p><p>朴素求后缀数组是 $O(n^2 \log n)$ 的，这显然是不太好的。通过倍增法去求，容易发现倍增的过程是某种双关键字排序，那么对其进行基数排序，可做到 $O(n \log n)$。具体的实现超出了本篇题解的范畴，请移步 <a href="https://www.luogu.com.cn/problem/P3809">后缀排序</a>。</p><h3 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h3><p>容易发现，一个串 $s$ 若能与 $t$ 匹配，那么它必然是 $t$ 的 <strong>某个后缀的前缀</strong>。<br>我们可以快速把所有后缀都排序，这样后缀就是有序的了，可以通过二分来找 $s$ 是否与 $t$ 匹配。</p><p>具体实现上，因为后缀的长度和是 $O(n^2)$ 级别的，所以不能把他们全部搞出来（会MLE）。实际上只需要写一个 <code>cmp()</code> 函数来比较字符串大小就好了，实现起来比较清新易懂。</p><p>复杂度因为每次要二分，所以整体多了一个 $\log$，不过均摊下来跑的非常快，常数比AC自动机大了不到一半。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fake-acam.cpp */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> t[CN], s[CN];</span><br><span class="line"><span class="built_in">string</span> mem[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sa[CN], rk[CN &lt;&lt; <span class="number">1</span>], prk[CN &lt;&lt; <span class="number">1</span>], id[CN], px[CN], cnt[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = max(n, <span class="number">300</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) rk[i] = t[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cnt[ rk[i] ] ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[ cnt[ rk[i] ]-- ] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt; n; w &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = sa[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] + w ] ]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = sa[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] ] ]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i];</span><br><span class="line">        <span class="built_in">memcpy</span>(prk, rk, <span class="keyword">sizeof</span>(rk)); m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">if</span>(prk[ sa[i] ] == prk[ sa[i - <span class="number">1</span>] ] &amp;&amp; prk[ sa[i] + w ] == prk[ sa[i - <span class="number">1</span>] + w ])</span><br><span class="line">                rk[ sa[i] ] = m;</span><br><span class="line">            <span class="keyword">else</span> rk[ sa[i] ] = ++m;</span><br><span class="line">        <span class="keyword">if</span>(m == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, lt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 a[] &lt; b[]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">le</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b, <span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[p] == b[p] &amp;&amp; p &lt; min(la, lb)) p++;</span><br><span class="line">    <span class="keyword">if</span>(p == lb) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == la) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> a[p] &lt; b[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("_in.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen("out.txt", "w", stdout);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; mem[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t; lt = <span class="built_in">strlen</span>(t);</span><br><span class="line"></span><br><span class="line">    SA(lt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = mem[i].size();</span><br><span class="line">        s[ls] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; ls;j++) s[j] = mem[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = lt, m; <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> leq = le(t + sa[m] - <span class="number">1</span>, s, lt - sa[m] + <span class="number">1</span>,ls);</span><br><span class="line">            <span class="keyword">if</span>(leq == <span class="number">-1</span>) &#123;found = <span class="literal">true</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(leq) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt += found ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然说这题是AC自动机吧…但是后缀数组也能解。&lt;br&gt;在这里提供一个清新的后缀数组解法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀数组" scheme="https://big-news.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
